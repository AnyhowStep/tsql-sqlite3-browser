{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./dist/driver/constants.js","webpack:///./dist/driver/execution/connection/connection.js","webpack:///./dist/driver/execution/connection/index.js","webpack:///./dist/driver/execution/index.js","webpack:///./dist/driver/execution/pool/bigint-polyfill.js","webpack:///./dist/driver/execution/pool/bigint-util.js","webpack:///./dist/driver/execution/pool/decimal-polyfill.js","webpack:///./dist/driver/execution/pool/fixed-point-util.js","webpack:///./dist/driver/execution/pool/floating-point-util.js","webpack:///./dist/driver/execution/pool/index.js","webpack:///./dist/driver/execution/pool/polyfill.js","webpack:///./dist/driver/execution/pool/pool.js","webpack:///./dist/driver/execution/pool/signed-decimal-str-util.js","webpack:///./dist/driver/execution/pool/unsigned-decimal-str-util.js","webpack:///./dist/driver/expr-library/index.js","webpack:///./dist/driver/expr-library/information/index.js","webpack:///./dist/driver/expr-library/information/last-insert-row-id.js","webpack:///./dist/driver/index.js","webpack:///./dist/driver/schema-introspection/index.js","webpack:///./dist/driver/schema-introspection/sqlite-master.js","webpack:///./dist/driver/schema-introspection/try-fetch-generated-column-expression.js","webpack:///./dist/driver/schema-introspection/try-fetch-schema-meta.js","webpack:///./dist/driver/schema-introspection/try-fetch-table-meta.js","webpack:///./dist/driver/sqlfier/convenience.js","webpack:///./dist/driver/sqlfier/delete-sql-string.js","webpack:///./dist/driver/sqlfier/index.js","webpack:///./dist/driver/sqlfier/insert-many-sql-string.js","webpack:///./dist/driver/sqlfier/insert-one-sql-string.js","webpack:///./dist/driver/sqlfier/insert-select-sql-string.js","webpack:///./dist/driver/sqlfier/sqlfier.js","webpack:///./dist/driver/sqlfier/update-sql-string.js","webpack:///./dist/driver/worker.js","webpack:///./test-browser/src/index.ts"],"names":[],"mappings":";QAAA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA,QAAQ,oBAAoB;QAC5B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA,iBAAiB,4BAA4B;QAC7C;QACA;QACA,kBAAkB,2BAA2B;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;QAEA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;QACA;QACA;QACA,gBAAgB,uBAAuB;QACvC;;;QAGA;QACA;QACA;QACA;;;;;;;;;;;;;;ACvJa;AACb,8CAA8C,cAAc;AAC5D;AACA,qC;;;;;;;;;;;;;ACHa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,qDAAe;AACzC,+BAA+B,mBAAO,CAAC,+EAA4B;AACnE,iBAAiB,mBAAO,CAAC,6CAAc;AACvC,gBAAgB,mBAAO,CAAC,+DAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI,YAAY,QAAQ;AAChE;AACA;AACA;AACA,4CAA4C,QAAQ,YAAY,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,iBAAiB,yEAAyE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,iCAAiC,oBAAoB,sBAAsB;AAC7J;AACA;AACA,0FAA0F,iCAAiC,gBAAgB,WAAW;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,EAAE;AACxB,SAAS;AACT;AACA;AACA;AACA,0FAA0F;AAC1F,SAAS;AACT;AACA;AACA;AACA,yFAAyF,SAAS,EAAE;AACpG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,EAAE;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,SAAS,EAAE;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,SAAS,EAAE;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,EAAE;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,2BAA2B;AAC5C,wBAAwB;AACxB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,yBAAyB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,SAAS,yBAAyB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS,yBAAyB;AAC9G;AACA;AACA,kEAAkE,YAAY,MAAM,iBAAiB,oBAAoB;AACzH;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,SAAS,yBAAyB;AACpH;AACA;AACA,wEAAwE,YAAY,cAAc,YAAY,oBAAoB;AAClI;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS,yBAAyB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS,yBAAyB;AAC3G;AACA;AACA,+DAA+D,YAAY,MAAM,YAAY,oBAAoB;AACjH;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,SAAS,yBAAyB;AAChH;AACA;AACA,qFAAqF,YAAY,oBAAoB;AACrH;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS,yBAAyB;AACtH;AACA;AACA,2FAA2F,YAAY,oBAAoB;AAC3H;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,SAAS,yBAAyB;AAC7G;AACA;AACA,kFAAkF,YAAY,oBAAoB;AAClH;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oEAAoE,SAAS,yBAAyB;AACtG;AACA;AACA,2EAA2E,YAAY,oBAAoB;AAC3G;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,yBAAyB;AACtG;AACA;AACA,2EAA2E,YAAY,oBAAoB;AAC3G;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+CAA+C;AAC9F;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,4BAA4B;AAC/F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,4BAA4B;AAChG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,4BAA4B;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,sDAAsD,iCAAiC;AACvF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,kDAAkD,iCAAiC;AACnF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;ACh6Ba;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,sEAAc;AAC/B,iC;;;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,iEAAc;AAC/B,SAAS,mBAAO,CAAC,qDAAQ;AACzB,iC;;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,8FAA6B;AACpE,6BAA6B,mBAAO,CAAC,0FAA2B;AAChE,mBAAmB,mBAAO,CAAC,kEAAe;AAC1C,OAAO,uOAAuO;AAC9O,OAAO,oMAAoM;AAC3M,OAAO,yHAAyH;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wDAAwD,SAAS,GAAG,SAAS;AAC7E;AACA;AACA,KAAK;AACL;AACA;AACA,2C;;;;;;;;;;;;;ACrGa;AACb,8CAA8C,cAAc;AAC5D,6BAA6B,mBAAO,CAAC,0FAA2B;AAChE,OAAO,wKAAwK;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;ACrFa;AACb,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,4EAAoB;AACnD,0BAA0B,mBAAO,CAAC,kFAAuB;AACzD,OAAO,qBAAqB;AAC5B,OAAO,2DAA2D;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,cAAc,UAAU,IAAI,MAAM;AACtF;AACA;AACA;AACA;AACA,yDAAyD,UAAU,IAAI,MAAM,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU,IAAI,MAAM;AAC3D;AACA;AACA,uCAAuC,UAAU,IAAI,MAAM;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA,4C;;;;;;;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,kFAAuB;AACzD,OAAO,2DAA2D;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kDAAkD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;ACzLa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;ACjFa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,oDAAQ;AACzB,iC;;;;;;;;;;;;;ACNa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,4EAAoB;AACvD,0BAA0B,mBAAO,CAAC,0EAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS,IAAI,SAAS;AACzD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oC;;;;;;;;;;;;;ACvXa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,iBAAiB,mBAAO,CAAC,6CAAc;AACvC,qBAAqB,mBAAO,CAAC,kEAAe;AAC5C,mBAAmB,mBAAO,CAAC,4DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS,cAAc,EAAE;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;;ACzFa;AACb,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,8FAA6B;AACpE,OAAO,2GAA2G;AAClH;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;;AC3Ia;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;;;;;;;;;;ACxLa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,sEAAe;AAChC,iC;;;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,0FAAsB;AACvC,iC;;;;;;;;;;;;;ACNa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC;AACA,8C;;;;;;;;;;;;;ACLa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,qDAAa;AAC9B,SAAS,mBAAO,CAAC,2DAAgB;AACjC,SAAS,mBAAO,CAAC,2EAAwB;AACzC,SAAS,mBAAO,CAAC,iDAAW;AAC5B,SAAS,mBAAO,CAAC,+CAAa;AAC9B,SAAS,mBAAO,CAAC,yCAAU;AAC3B,iC;;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,4EAAiB;AAClC,SAAS,mBAAO,CAAC,4HAAyC;AAC1D,SAAS,mBAAO,CAAC,4FAAyB;AAC1C,SAAS,mBAAO,CAAC,0FAAwB;AACzC,iC;;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,+BAA+B,mBAAO,CAAC,0FAAwB;AAC/D,wBAAwB,mBAAO,CAAC,4EAAiB;AACjD,oBAAoB,mBAAO,CAAC,gDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAA4C,GAAG,uDAAuD;AAC3I;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;AC/Ba;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC,wBAAwB,mBAAO,CAAC,4EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,GAAG,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,mCAAmC,oDAAoD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;AC9Ia;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uC;;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;ACda;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,2DAAe;AAChC,SAAS,mBAAO,CAAC,uEAAqB;AACtC,SAAS,mBAAO,CAAC,iFAA0B;AAC3C,SAAS,mBAAO,CAAC,+EAAyB;AAC1C,SAAS,mBAAO,CAAC,qFAA4B;AAC7C,SAAS,mBAAO,CAAC,mDAAW;AAC5B,SAAS,mBAAO,CAAC,uEAAqB;AACtC,iC;;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC,+BAA+B,mBAAO,CAAC,4EAAyB;AAChE,oBAAoB,mBAAO,CAAC,gDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAA2C,GAAG,4CAA4C;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sDAAsD,YAAY,GAAG,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,GAAG,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;AClGa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC,oBAAoB,mBAAO,CAAC,gDAAc;AAC1C,+BAA+B,mBAAO,CAAC,4EAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAA2C,GAAG,4CAA4C;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kDAAkD,YAAY,GAAG,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,GAAG,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iBAAiB,EAAE,iBAAiB,EAAE,kBAAkB;AAC1H;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;;AChGa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+DAAc;AACjC,eAAe,mBAAO,CAAC,mEAAgB;AACvC,oBAAoB,mBAAO,CAAC,gDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB,EAAE,iBAAiB,EAAE,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB,EAAE,iBAAiB,EAAE,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,oBAAoB,EAAE,iBAAiB,EAAE,qBAAqB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kBAAkB,EAAE,iBAAiB,EAAE,mBAAmB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iCAAiC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,eAAe;AAC3D;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mDAAmD,eAAe;AAClE;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D,6CAA6C,eAAe;AAC5D,4CAA4C,eAAe;AAC3D,0CAA0C,eAAe;AACzD,+CAA+C,eAAe;AAC9D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE,uCAAuC,WAAW;AAClD,iDAAiD,WAAW;AAC5D,qDAAqD,WAAW;AAChE,2CAA2C,WAAW;AACtD,8CAA8C,WAAW;AACzD,oDAAoD,WAAW;AAC/D,uDAAuD,WAAW;AAClE,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,WAAW;AACxD,yCAAyC,WAAW;AACpD,4CAA4C,WAAW;AACvD,gDAAgD,WAAW;AAC3D,yCAAyC,WAAW;AACpD,6CAA6C,WAAW;AACxD,0CAA0C,WAAW;AACrD,8CAA8C,WAAW;AACzD,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iDAAiD,wCAAwC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,WAAW;AACtD,uCAAuC,WAAW;AAClD,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD,oCAAoC,WAAW;AAC/C,qCAAqC,WAAW;AAChD;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD,qCAAqC,WAAW;AAChD,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD,8CAA8C,WAAW;AACzD;AACA;AACA,wCAAwC,WAAW;AACnD,kDAAkD,WAAW;AAC7D,2CAA2C,WAAW;AACtD,6CAA6C,WAAW;AACxD,qCAAqC,WAAW;AAChD,wCAAwC,WAAW;AACnD,sCAAsC,WAAW;AACjD,sCAAsC,WAAW;AACjD,uCAAuC,WAAW;AAClD,uCAAuC,WAAW;AAClD,sCAAsC,WAAW;AACjD,0CAA0C,WAAW;AACrD,wCAAwC,WAAW;AACnD,yCAAyC,WAAW;AACpD,yCAAyC,WAAW;AACpD,2CAA2C,WAAW;AACtD,uCAAuC,WAAW;AAClD,uCAAuC,WAAW;AAClD,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,SAAS;AACjF;AACA,SAAS;AACT;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS;AAClF;AACA,SAAS;AACT,sDAAsD,qBAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF;AACA,SAAS;AACT,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D,4CAA4C,WAAW;AACvD,0CAA0C,WAAW;AACrD,6CAA6C,WAAW;AACxD,+CAA+C,WAAW;AAC1D,2CAA2C,WAAW;AACtD,yCAAyC,WAAW;AACpD,wCAAwC,WAAW;AACnD,2CAA2C,WAAW;AACtD,yCAAyC,WAAW;AACpD,wDAAwD,WAAW;AACnE,uCAAuC,WAAW;AAClD,oCAAoC,WAAW;AAC/C,qCAAqC,WAAW;AAChD,sCAAsC,WAAW;AACjD,uCAAuC,WAAW;AAClD;AACA,uCAAuC,WAAW;AAClD,yCAAyC,WAAW;AACpD,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA,SAAS;AACT,0CAA0C,SAAS;AACnD,sCAAsC,WAAW;AACjD,sCAAsC,WAAW;AACjD,6CAA6C,WAAW;AACxD,yCAAyC,WAAW;AACpD,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB,IAAI,aAAa;AAC7E;AACA;AACA,gDAAgD,WAAW,4CAA4C,gBAAgB;AACvH,uDAAuD,WAAW,4CAA4C,gBAAgB;AAC9H,gDAAgD,WAAW;AAC3D,iDAAiD,WAAW;AAC5D,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD,4CAA4C,WAAW;AACvD,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD,oDAAoD,WAAW;AAC/D,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,SAAS;AACT,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,SAAS;AACT,+CAA+C,WAAW;AAC1D;AACA,SAAS;AACT,+CAA+C,WAAW;AAC1D;AACA,SAAS;AACT,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,SAAS;AACT,gEAAgE,yBAAyB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,SAAS;AACT,0DAA0D,yBAAyB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,SAAS;AACT,iEAAiE,WAAW;AAC5E;AACA;AACA,4DAA4D,WAAW;AACvE,yEAAyE,WAAW;AACpF;AACA,SAAS;AACT,qEAAqE,WAAW;AAChF;AACA,SAAS;AACT,+DAA+D,WAAW;AAC1E;AACA,SAAS;AACT,2DAA2D,WAAW;AACtE;AACA,SAAS;AACT,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;AC96Ca;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mEAAgB;AACvC,kBAAkB,mBAAO,CAAC,mDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;AC3BA,uFAA6C;AAG7C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,mBAAmB,CAAC,CAAC;AAE/C,MAAM,aAAa,GAAG,IAAI,OAAO,CAAC,YAAY,CAAC;IAC3C,WAAW,EAAG,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC;IAC7C,YAAY,EAAG,CAAC,SAAS,EAAE,EAAE;QACzB,MAAM,CAAC,SAAS,GAAG,CAAC,KAAK,EAAE,EAAE;YACzB,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACtB,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,YAAY,CAAC,KAAK,EAAE;gBACjD,MAAM,CAAC,SAAS,EAAE,CAAC;aACtB;QACL,CAAC,CAAC;IACN,CAAC;CACJ,CAAC,CAAC;AAEH,MAAM,IAAI,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AAW7C,MAAM,CAAC,QAAQ,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CACzC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,SAAS,CAAC,CAC/C,CAAC;AAEF,MAAM,CAAC,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CACrC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAC3C,CAAC;AAEF,MAAM,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAChC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,CACpC,CAAC;AAEF,MAAM,CAAC,QAAQ,GAAG,CAAC,MAAmB,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CACnD,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CACxC,CAAC","file":"index.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"index\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([\"./test-browser/src/index.ts\",\"vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_SCHEMA_NAME = \"main\";\n//# sourceMappingURL=constants.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"../../sqlfier\");\nconst schema_introspection_1 = require(\"../../schema-introspection\");\nconst worker_1 = require(\"../../worker\");\nconst ExprLib = require(\"../../expr-library\");\nclass IdAllocator {\n    constructor() {\n        this.nextId = 0;\n    }\n    allocateId() {\n        return ++this.nextId;\n    }\n}\nexports.IdAllocator = IdAllocator;\nfunction onMessage(data, id, action, resolve, reject) {\n    if (data.id != id) {\n        reject(new Error(`Expected id ${id}; received ${data.id}`));\n        return;\n    }\n    if (data.action != action) {\n        reject(new Error(`Expected action ${action}; received ${data.action}`));\n        return;\n    }\n    if (data.error == undefined) {\n        resolve(data);\n    }\n    else {\n        reject(new Error(data.error));\n    }\n}\nfunction postMessage(worker, id, action, data, resolve) {\n    return new Promise((innerResolve, originalInnerReject) => {\n        const innerReject = (error) => {\n            const sql = (\"sql\" in data ?\n                data.sql :\n                undefined);\n            if (error instanceof Error) {\n                if (error.message.startsWith(\"DataOutOfRangeError\") || error.message.includes(\"overflow\")) {\n                    const newErr = new squill.DataOutOfRangeError({\n                        innerError: error,\n                        sql,\n                    });\n                    originalInnerReject(newErr);\n                }\n                else if (error.message.startsWith(\"DivideByZeroError\")) {\n                    const newErr = new squill.DivideByZeroError({\n                        innerError: error,\n                        sql,\n                    });\n                    originalInnerReject(newErr);\n                }\n                else {\n                    const newErr = new squill.SqlError({\n                        innerError: error,\n                        sql,\n                    });\n                    originalInnerReject(newErr);\n                }\n            }\n            else {\n                const newErr = new squill.SqlError({\n                    innerError: error,\n                    sql,\n                });\n                originalInnerReject(newErr);\n            }\n        };\n        worker.onmessage = (e) => {\n            const data = e.data;\n            onMessage(data, id, action, (data) => {\n                innerResolve(resolve(data));\n            }, innerReject);\n        };\n        worker.onmessageerror = innerReject;\n        worker.onerror = innerReject;\n        worker.postMessage({\n            id,\n            action,\n            ...data,\n        });\n    });\n}\nclass Connection {\n    constructor({ pool, eventEmitters, worker, idAllocator, sharedConnectionInformation, }) {\n        this.savepointData = undefined;\n        this.deallocatePromise = undefined;\n        this.pool = pool;\n        this.eventEmitters = eventEmitters;\n        this.idAllocator = idAllocator;\n        this.asyncQueue = worker instanceof squill.AsyncQueue ?\n            worker :\n            new squill.AsyncQueue(() => {\n                return {\n                    item: worker,\n                    deallocate: async () => { }\n                };\n            });\n        this.sharedConnectionInformation = sharedConnectionInformation;\n        this.sharedConnectionInformation;\n    }\n    tryGetFullConnection() {\n        if (this.sharedConnectionInformation.transactionData != undefined &&\n            this.sharedConnectionInformation.transactionData.accessMode == squill.TransactionAccessMode.READ_ONLY) {\n            /**\n             * Can't give a full connection if we are in a readonly transaction.\n             * No `INSERT/UPDATE/DELETE` allowed.\n             */\n            return undefined;\n        }\n        else {\n            return this;\n        }\n    }\n    lock(callback) {\n        return this.asyncQueue.lock((nestedAsyncQueue) => {\n            const nestedConnection = new Connection({\n                pool: this.pool,\n                eventEmitters: this.eventEmitters,\n                idAllocator: this.idAllocator,\n                worker: nestedAsyncQueue,\n                sharedConnectionInformation: this.sharedConnectionInformation\n            });\n            return callback(nestedConnection);\n        });\n    }\n    rollback() {\n        if (!this.isInTransaction()) {\n            return Promise.reject(new Error(\"Not in transaction; cannot rollback\"));\n        }\n        return this.rawQuery(\"ROLLBACK\")\n            .then(() => {\n            this.sharedConnectionInformation.transactionData = undefined;\n            /**\n             * @todo Handle sync errors somehow.\n             * Maybe propagate them to `IPool` and have an `onError` handler or something\n             */\n            this.eventEmitters.rollback();\n        });\n    }\n    commit() {\n        if (!this.isInTransaction()) {\n            return Promise.reject(new Error(\"Not in transaction; cannot commit\"));\n        }\n        return this.rawQuery(\"COMMIT\")\n            .then(() => {\n            this.sharedConnectionInformation.transactionData = undefined;\n            /**\n             * @todo Handle sync errors somehow.\n             * Maybe propagate them to `IPool` and have an `onError` handler or something\n             */\n            this.eventEmitters.commit();\n        });\n    }\n    getMinimumIsolationLevel() {\n        if (this.sharedConnectionInformation.transactionData == undefined) {\n            throw new Error(`Not in transaction`);\n        }\n        return this.sharedConnectionInformation.transactionData.minimumIsolationLevel;\n    }\n    getTransactionAccessMode() {\n        if (this.sharedConnectionInformation.transactionData == undefined) {\n            throw new Error(`Not in transaction`);\n        }\n        return this.sharedConnectionInformation.transactionData.accessMode;\n    }\n    transactionImpl(minimumIsolationLevel, accessMode, callback) {\n        if (this.sharedConnectionInformation.transactionData != undefined) {\n            return Promise.reject(new Error(`Transaction already started or starting`));\n        }\n        /**\n         * SQLite only has `SERIALIZABLE` transactions.\n         * So, no matter what we request, we will always get a\n         * `SERIALIZABLE` transaction.\n         *\n         * However, we will just pretend that we have all\n         * isolation levels supported.\n         */\n        this.sharedConnectionInformation.transactionData = {\n            minimumIsolationLevel,\n            accessMode,\n        };\n        return new Promise((resolve, reject) => {\n            return this.rawQuery(`BEGIN TRANSACTION`)\n                .then(() => {\n                /**\n                 * @todo Handle sync errors somehow.\n                 * Maybe propagate them to `IPool` and have an `onError` handler or something\n                 */\n                this.eventEmitters.commit();\n                if (!this.isInTransaction()) {\n                    /**\n                     * Why did one of the `OnCommit` listeners call `commit()` or `rollback()`?\n                     */\n                    throw new Error(`Expected to be in transaction`);\n                }\n                return callback(this);\n            })\n                .then((result) => {\n                if (!this.isInTransaction()) {\n                    resolve(result);\n                    return;\n                }\n                this.commit()\n                    .then(() => {\n                    resolve(result);\n                })\n                    .catch((commitErr) => {\n                    this.rollback()\n                        .then(() => {\n                        reject(commitErr);\n                    })\n                        .catch((rollbackErr) => {\n                        commitErr.rollbackErr = rollbackErr;\n                        reject(commitErr);\n                    });\n                });\n            })\n                .catch((err) => {\n                if (!this.isInTransaction()) {\n                    reject(err);\n                    return;\n                }\n                this.rollback()\n                    .then(() => {\n                    reject(err);\n                })\n                    .catch((rollbackErr) => {\n                    err.rollbackErr = rollbackErr;\n                    reject(err);\n                });\n            });\n        });\n    }\n    transactionIfNotInOneImpl(minimumIsolationLevel, accessMode, callback) {\n        return this.lock(async (nestedConnection) => {\n            if (nestedConnection.isInTransaction()) {\n                if (squill.IsolationLevelUtil.isWeakerThan(this.getMinimumIsolationLevel(), minimumIsolationLevel)) {\n                    /**\n                     * For example, our current isolation level is\n                     * `READ_UNCOMMITTED` but we want\n                     * `SERIALIZABLE`.\n                     *\n                     * Obviously, `READ_UNCOMMITTED` is weaker than\n                     * `SERIALIZABLE`.\n                     *\n                     * So, we error.\n                     *\n                     * @todo Custom error type\n                     */\n                    return Promise.reject(new Error(`Current isolation level is ${this.getMinimumIsolationLevel()}; cannot guarantee ${minimumIsolationLevel}`));\n                }\n                if (squill.TransactionAccessModeUtil.isLessPermissiveThan(this.getTransactionAccessMode(), accessMode)) {\n                    return Promise.reject(new Error(`Current transaction access mode is ${this.getTransactionAccessMode()}; cannot allow ${accessMode}`));\n                }\n                try {\n                    return callback(nestedConnection);\n                }\n                catch (err) {\n                    return Promise.reject(err);\n                }\n            }\n            else {\n                return nestedConnection.transactionImpl(minimumIsolationLevel, accessMode, callback);\n            }\n        });\n    }\n    transactionIfNotInOne(...args) {\n        return this.transactionIfNotInOneImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_WRITE, args.length == 1 ? args[0] : args[1]);\n    }\n    readOnlyTransactionIfNotInOne(...args) {\n        return this.transactionIfNotInOneImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_ONLY, args.length == 1 ? args[0] : args[1]);\n    }\n    allocateId() {\n        return this.idAllocator.allocateId();\n    }\n    open(dbFile) {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.OPEN, {\n                buffer: dbFile,\n            }, () => { });\n        });\n    }\n    export() {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.EXPORT, {}, data => data.buffer);\n        });\n    }\n    close() {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CLOSE, {}, () => { });\n        });\n    }\n    createGlobalJsFunction(functionName, impl) {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_GLOBAL_JS_FUNCTION, {\n                functionName,\n                impl: impl.toString(),\n            }, () => { });\n        });\n    }\n    /**\n     * The `impl` function will be stringified using `impl.toString()`.\n     *\n     * Then, the function will be \"rebuilt\" using `eval()`.\n     *\n     * This means your `impl` cannot rely on anything outside its scope.\n     * It must be a \"pure\" function.\n     *\n     * Also, you really shouldn't pass user input to this method.\n     */\n    createFunction(functionName, impl) {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_FUNCTION, {\n                functionName,\n                options: {\n                    isVarArg: false,\n                },\n                impl: impl.toString(),\n            }, () => { });\n        });\n    }\n    /**\n     * The `impl` function will be stringified using `impl.toString()`.\n     *\n     * Then, the function will be \"rebuilt\" using `eval()`.\n     *\n     * This means your `impl` cannot rely on anything outside its scope.\n     * It must be a \"pure\" function.\n     *\n     * Also, you really shouldn't pass user input to this method.\n     */\n    createVarArgFunction(functionName, impl) {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_FUNCTION, {\n                functionName,\n                options: {\n                    isVarArg: true,\n                },\n                impl: impl.toString(),\n            }, () => { });\n        });\n    }\n    createAggregate(functionName, init, step, finalize) {\n        return this.asyncQueue.enqueue((worker) => {\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_AGGREGATE, {\n                functionName,\n                init: init.toString(),\n                step: step.toString(),\n                finalize: finalize.toString(),\n            }, () => { });\n        });\n    }\n    exec(sql) {\n        return this.asyncQueue.enqueue((worker) => {\n            //console.log(\"sql\", sql);\n            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.EXEC, {\n                sql,\n            }, ({ execResult, rowsModified }) => {\n                return { execResult, rowsModified };\n            });\n        });\n    }\n    rawQuery(sql) {\n        //console.log(\"sql\", sql);\n        return this\n            .exec(sql)\n            .then((result) => {\n            if (result.execResult.length == 0) {\n                return {\n                    query: { sql },\n                    results: undefined,\n                    columns: undefined,\n                };\n            }\n            return {\n                query: { sql },\n                results: result.execResult[0].values,\n                columns: result.execResult[0].columns,\n            };\n        });\n    }\n    async select(query) {\n        const sql = squill.AstUtil.toSql(query, sqlfier_1.sqlfier);\n        return this.exec(sql)\n            .then((result) => {\n            if (result.execResult.length > 1) {\n                throw new Error(`Expected to run 1 SELECT statement; found ${result.execResult.length}`);\n            }\n            /**\n             * When SQLite fetches zero rows, we get zero execResults...\n             * Which is frustrating.\n             */\n            const resultSet = ((result.execResult.length == 0) ?\n                {\n                    values: [],\n                    columns: [],\n                } :\n                result.execResult[0]);\n            const selectResult = {\n                query: { sql, },\n                rows: resultSet.values.map((row) => {\n                    const obj = {};\n                    for (let i = 0; i < resultSet.columns.length; ++i) {\n                        const k = resultSet.columns[i];\n                        const v = row[i];\n                        obj[k] = v;\n                    }\n                    return obj;\n                }),\n                columns: resultSet.columns,\n            };\n            return selectResult;\n        });\n    }\n    async insertOne(table, row) {\n        const sql = sqlfier_1.insertOneSqlString(\"INSERT\", table, row);\n        return this.lock((rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertOne() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified != 1) {\n                    throw new Error(`insertOne() should modify one row`);\n                }\n                const autoIncrementId = ((table.autoIncrement == undefined) ?\n                    undefined :\n                    (row[table.autoIncrement] === undefined) ?\n                        await squill\n                            .selectValue(() => ExprLib.lastInsertRowId())\n                            .fetchValue(nestedConnection) :\n                        /**\n                         * Emulate MySQL behaviour\n                         */\n                        tm.BigInt(0));\n                const insertOneResult = {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(1),\n                    autoIncrementId: (autoIncrementId == undefined ?\n                        undefined :\n                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?\n                            undefined :\n                            autoIncrementId),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n                return insertOneResult;\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    async insertMany(table, rows) {\n        const sql = await sqlfier_1.insertManySqlString(this, \"INSERT\", table, rows);\n        return this.lock(async (rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertMany() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified != rows.length) {\n                    throw new Error(`insertMany() should modify ${rows.length} rows; only modified ${result.rowsModified} rows`);\n                }\n                return {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(result.rowsModified),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    insertIgnoreOne(table, row) {\n        const sql = sqlfier_1.insertOneSqlString(\"INSERT OR IGNORE\", table, row);\n        return this.lock((rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertIgnoreOne() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified != 0 && result.rowsModified != 1) {\n                    throw new Error(`insertIgnoreOne() should modify zero or one row`);\n                }\n                if (result.rowsModified == 0) {\n                    return {\n                        query: { sql, },\n                        insertedRowCount: tm.BigInt(result.rowsModified),\n                        autoIncrementId: undefined,\n                        warningCount: tm.BigInt(1),\n                        message: \"ok\",\n                    };\n                }\n                const autoIncrementId = ((table.autoIncrement == undefined) ?\n                    undefined :\n                    (row[table.autoIncrement] === undefined) ?\n                        await squill\n                            .selectValue(() => ExprLib.lastInsertRowId())\n                            .fetchValue(nestedConnection) :\n                        /**\n                         * Emulate MySQL behaviour\n                         */\n                        tm.BigInt(0));\n                return {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(result.rowsModified),\n                    autoIncrementId: (autoIncrementId == undefined ?\n                        undefined :\n                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?\n                            undefined :\n                            autoIncrementId),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    async insertIgnoreMany(table, rows) {\n        const sql = await sqlfier_1.insertManySqlString(this, \"INSERT OR IGNORE\", table, rows);\n        return this.lock(async (rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertIgnoreMany() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified > rows.length) {\n                    throw new Error(`insertIgnoreMany() should modify ${rows.length} rows or less; modified ${result.rowsModified} rows`);\n                }\n                return {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(result.rowsModified),\n                    warningCount: tm.BigInt(rows.length - result.rowsModified),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    replaceOne(table, row) {\n        const sql = sqlfier_1.insertOneSqlString(\"REPLACE\", table, row);\n        return this.lock((rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`replaceOne() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified != 1) {\n                    throw new Error(`replaceOne() should modify one row`);\n                }\n                const autoIncrementId = ((table.autoIncrement == undefined) ?\n                    undefined :\n                    (row[table.autoIncrement] === undefined) ?\n                        await squill\n                            .selectValue(() => ExprLib.lastInsertRowId())\n                            .fetchValue(nestedConnection) :\n                        /**\n                         * Emulate MySQL behaviour\n                         */\n                        tm.BigInt(0));\n                return {\n                    query: { sql, },\n                    insertedOrReplacedRowCount: tm.BigInt(1),\n                    autoIncrementId: (autoIncrementId == undefined ?\n                        undefined :\n                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?\n                            undefined :\n                            autoIncrementId),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    async replaceMany(table, rows) {\n        const sql = await sqlfier_1.insertManySqlString(this, \"REPLACE\", table, rows);\n        return this.exec(sql)\n            .then(async (result) => {\n            if (result.execResult.length != 0) {\n                throw new Error(`replaceMany() should have no result set; found ${result.execResult.length}`);\n            }\n            if (result.rowsModified != rows.length) {\n                throw new Error(`replaceMany() should modify ${rows.length} rows; modified ${result.rowsModified} rows`);\n            }\n            return {\n                query: { sql, },\n                insertedOrReplacedRowCount: tm.BigInt(result.rowsModified),\n                warningCount: tm.BigInt(0),\n                message: \"ok\",\n            };\n        })\n            .catch((err) => {\n            //console.error(\"error encountered\", sql);\n            throw err;\n        });\n    }\n    async insertSelect(query, table, insertSelectRow) {\n        const sql = await sqlfier_1.insertSelectSqlString(this, \"INSERT\", query, table, insertSelectRow);\n        return this.lock(async (rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertSelect() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified < 0) {\n                    throw new Error(`insertSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);\n                }\n                return {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(result.rowsModified),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    async insertIgnoreSelect(query, table, insertSelectRow) {\n        const sql = await sqlfier_1.insertSelectSqlString(this, \"INSERT OR IGNORE\", query, table, insertSelectRow);\n        return this.transactionIfNotInOne(async (rawNestedConnection) => {\n            const nestedConnection = rawNestedConnection;\n            const maxInsertCount = await squill.ExecutionUtil.count(query, nestedConnection);\n            return nestedConnection.exec(sql)\n                .then(async (result) => {\n                if (result.execResult.length != 0) {\n                    throw new Error(`insertIgnoreSelect() should have no result set; found ${result.execResult.length}`);\n                }\n                if (result.rowsModified < 0) {\n                    throw new Error(`insertIgnoreSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);\n                }\n                return {\n                    query: { sql, },\n                    insertedRowCount: tm.BigInt(result.rowsModified),\n                    warningCount: tm.BigIntUtil.sub(maxInsertCount, result.rowsModified),\n                    message: \"ok\",\n                };\n            })\n                .catch((err) => {\n                //console.error(\"error encountered\", sql);\n                throw err;\n            });\n        });\n    }\n    async replaceSelect(query, table, insertSelectRow) {\n        const sql = await sqlfier_1.insertSelectSqlString(this, \"REPLACE\", query, table, insertSelectRow);\n        return this.exec(sql)\n            .then(async (result) => {\n            if (result.execResult.length != 0) {\n                throw new Error(`replaceSelect() should have no result set; found ${result.execResult.length}`);\n            }\n            if (result.rowsModified < 0) {\n                throw new Error(`replaceSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);\n            }\n            return {\n                query: { sql, },\n                insertedOrReplacedRowCount: tm.BigInt(result.rowsModified),\n                warningCount: tm.BigInt(0),\n                message: \"ok\",\n            };\n        })\n            .catch((err) => {\n            //console.error(\"error encountered\", sql);\n            throw err;\n        });\n    }\n    update(table, whereClause, assignmentMap) {\n        const sql = sqlfier_1.updateSqlString(table, whereClause, assignmentMap);\n        if (sql == undefined) {\n            return squill.from(table)\n                .where(() => whereClause)\n                .count(this)\n                .then((count) => {\n                return {\n                    query: {\n                        /**\n                         * No `UPDATE` statement executed\n                         */\n                        sql: \"\",\n                    },\n                    foundRowCount: count,\n                    updatedRowCount: tm.BigInt(0),\n                    warningCount: tm.BigInt(0),\n                    message: \"ok\",\n                };\n            });\n        }\n        return this.exec(sql)\n            .then(async (result) => {\n            if (result.execResult.length != 0) {\n                throw new Error(`update() should have no result set; found ${result.execResult.length}`);\n            }\n            if (result.rowsModified < 0) {\n                throw new Error(`update() should modify zero, or more rows; modified ${result.rowsModified} rows`);\n            }\n            return {\n                query: { sql, },\n                foundRowCount: tm.BigInt(result.rowsModified),\n                updatedRowCount: tm.BigInt(result.rowsModified),\n                warningCount: tm.BigInt(0),\n                message: \"ok\",\n            };\n        })\n            .catch((err) => {\n            //console.error(\"error encountered\", sql);\n            throw err;\n        });\n    }\n    delete(table, whereClause) {\n        const sql = sqlfier_1.deleteSqlString(table, whereClause);\n        return this.exec(sql)\n            .then(async (result) => {\n            if (result.execResult.length != 0) {\n                throw new Error(`delete() should have no result set; found ${result.execResult.length}`);\n            }\n            if (result.rowsModified < 0) {\n                throw new Error(`delete() should modify zero, or more rows; modified ${result.rowsModified} rows`);\n            }\n            return {\n                query: { sql, },\n                deletedRowCount: tm.BigInt(result.rowsModified),\n                warningCount: tm.BigInt(0),\n                message: \"ok\",\n            };\n        })\n            .catch((err) => {\n            //console.error(\"error encountered\", sql);\n            throw err;\n        });\n    }\n    tryFetchSchemaMeta(schemaAlias) {\n        return schema_introspection_1.tryFetchSchemaMeta(this, schemaAlias);\n    }\n    tryFetchGeneratedColumnExpression(schemaAlias, tableAlias, columnAlias) {\n        return schema_introspection_1.tryFetchGeneratedColumnExpression(this, schemaAlias, tableAlias, columnAlias);\n    }\n    transaction(...args) {\n        return this.lock(async (nestedConnection) => {\n            return nestedConnection.transactionImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_WRITE, args.length == 1 ? args[0] : args[1]);\n        });\n    }\n    readOnlyTransaction(...args) {\n        return this.lock(async (nestedConnection) => {\n            return nestedConnection.transactionImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_ONLY, args.length == 1 ? args[0] : args[1]);\n        });\n    }\n    isInTransaction() {\n        return this.sharedConnectionInformation.transactionData != undefined;\n    }\n    savepointImpl(callback) {\n        if (this.sharedConnectionInformation.transactionData == undefined) {\n            return Promise.reject(new Error(`Cannot use savepoint outside transaction`));\n        }\n        if (this.savepointData != undefined) {\n            return Promise.reject(new Error(`A savepoint is already in progress`));\n        }\n        const savepointData = {\n            savepointName: `squill_savepoint_${++this.sharedConnectionInformation.savepointId}`,\n        };\n        this.savepointData = savepointData;\n        this.eventEmitters.savepoint();\n        return new Promise((resolve, reject) => {\n            this.rawQuery(`SAVEPOINT ${savepointData.savepointName}`)\n                .then(() => {\n                if (!this.isInTransaction()) {\n                    throw new Error(`Expected to be in transaction`);\n                }\n                if (this.savepointData != savepointData) {\n                    /**\n                     * Why did the savepoint information change?\n                     */\n                    throw new Error(`Expected to be in savepoint ${savepointData.savepointName}`);\n                }\n                return callback(this);\n            })\n                .then((result) => {\n                if (!this.isInTransaction()) {\n                    /**\n                     * `.rollback()` was probably explicitly called\n                     */\n                    resolve(result);\n                    return;\n                }\n                if (this.savepointData == undefined) {\n                    /**\n                     * `.rollbackToSavepoint()` was probably explicitly called\n                     */\n                    resolve(result);\n                    return;\n                }\n                if (this.savepointData != savepointData) {\n                    /**\n                     * Some weird thing is going on here.\n                     * This should never happen.\n                     */\n                    reject(new Error(`Expected to be in savepoint ${savepointData.savepointName} or to not be in a savepoint`));\n                    return;\n                }\n                this.releaseSavepoint()\n                    .then(() => {\n                    resolve(result);\n                })\n                    .catch((_releaseErr) => {\n                    /**\n                     * Being unable to release a savepoint isn't so bad.\n                     * It usually just means the DBMS cannot reclaim resources\n                     * until the transaction ends.\n                     *\n                     * @todo Do something with `_releaseErr`\n                     */\n                    resolve(result);\n                });\n            })\n                .catch((err) => {\n                if (!this.isInTransaction()) {\n                    /**\n                     * `.rollback()` was probably explicitly called\n                     */\n                    reject(err);\n                    return;\n                }\n                if (this.savepointData == undefined) {\n                    /**\n                     * `.rollbackToSavepoint()` was probably explicitly called\n                     */\n                    reject(err);\n                    return;\n                }\n                if (this.savepointData != savepointData) {\n                    /**\n                     * Some weird thing is going on here.\n                     * This should never happen.\n                     */\n                    err.savepointErr = new Error(`Expected to be in savepoint ${savepointData.savepointName} or to not be in a savepoint`);\n                    reject(err);\n                    return;\n                }\n                this.rollbackToSavepoint()\n                    .then(() => {\n                    reject(err);\n                })\n                    .catch((rollbackToSavepointErr) => {\n                    err.rollbackToSavepointErr = rollbackToSavepointErr;\n                    reject(err);\n                });\n            });\n        });\n    }\n    rollbackToSavepoint() {\n        if (this.savepointData == undefined) {\n            return Promise.reject(new Error(\"Not in savepoint; cannot release savepoint\"));\n        }\n        return this.rawQuery(`ROLLBACK TO SAVEPOINT ${this.savepointData.savepointName}`)\n            .then(() => {\n            this.savepointData = undefined;\n            this.eventEmitters.rollbackToSavepoint();\n        });\n    }\n    releaseSavepoint() {\n        if (this.savepointData == undefined) {\n            return Promise.reject(new Error(\"Not in savepoint; cannot release savepoint\"));\n        }\n        return this.rawQuery(`RELEASE SAVEPOINT ${this.savepointData.savepointName}`)\n            .then(() => {\n            this.savepointData = undefined;\n            this.eventEmitters.releaseSavepoint();\n        });\n    }\n    savepoint(callback) {\n        return this.lock(async (nestedConnection) => {\n            return nestedConnection.savepointImpl(callback);\n        });\n    }\n    deallocate() {\n        //console.log(\"deallocating...\");\n        if (this.deallocatePromise == undefined) {\n            this.deallocatePromise = this.asyncQueue.stop()\n                .then(() => {\n                //console.log(\"deallocated\");\n                /**\n                 * @todo Handle sync errors somehow.\n                 * Maybe propagate them to `IPool` and have an `onError` handler or something\n                 */\n                this.eventEmitters.commit();\n            }, (err) => {\n                //console.log(\"deallocated with error\");\n                /**\n                 * @todo Handle sync errors somehow.\n                 * Maybe propagate them to `IPool` and have an `onError` handler or something\n                 */\n                this.eventEmitters.commit();\n                throw err;\n            });\n            return this.deallocatePromise;\n        }\n        return Promise.reject(\"This connection has already been deallocated\");\n    }\n    isDeallocated() {\n        return this.deallocatePromise != undefined;\n    }\n}\nexports.Connection = Connection;\n//# sourceMappingURL=connection.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./connection\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./connection\"));\n__export(require(\"./pool\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst UnsignedDecimalStrUtil = require(\"./unsigned-decimal-str-util\");\nconst SignedDecimalStrUtil = require(\"./signed-decimal-str-util\");\nconst BigIntUtil = require(\"./bigint-util\");\nconst { unsignedDigitArrayAdd, unsignedDigitArraySubtract, unsignedDecimalStrAdd, unsignedDecimalStrSubtract, unsignedDecimalStrMultiply, unsignedDigitArrayGreaterThanOrEqual, unsignedDigitArrayLessThanOrEqual, unsignedDecimalStrDivide, } = UnsignedDecimalStrUtil;\nconst { signedDecimalStrLessThanOrEqual, signedDecimalStrGreaterThanOrEqual, signedDecimalStrUnaryMinus, signedDecimalStrAdd, signedDecimalStrSubtract, signedDecimalStrMultiply, signedDecimalStrDivide, } = SignedDecimalStrUtil;\nconst { isSafeBigIntSigned, assertSafeBigIntSigned, bigIntAdd, bigIntSubtract, bigIntUnaryMinus, bigIntMultiply, bigIntDivide, } = BigIntUtil;\nasync function initBigIntPolyfill(connection) {\n    await connection.createGlobalJsFunction(\"unsignedDigitArrayAdd\", unsignedDigitArrayAdd);\n    await connection.createGlobalJsFunction(\"unsignedDigitArraySubtract\", unsignedDigitArraySubtract);\n    await connection.createGlobalJsFunction(\"unsignedDecimalStrAdd\", unsignedDecimalStrAdd);\n    await connection.createGlobalJsFunction(\"unsignedDecimalStrSubtract\", unsignedDecimalStrSubtract);\n    await connection.createGlobalJsFunction(\"unsignedDecimalStrMultiply\", unsignedDecimalStrMultiply);\n    await connection.createGlobalJsFunction(\"unsignedDigitArrayGreaterThanOrEqual\", unsignedDigitArrayGreaterThanOrEqual);\n    await connection.createGlobalJsFunction(\"unsignedDigitArrayLessThanOrEqual\", unsignedDigitArrayLessThanOrEqual);\n    await connection.createGlobalJsFunction(\"unsignedDecimalStrDivide\", unsignedDecimalStrDivide);\n    await connection.createGlobalJsFunction(\"signedDecimalStrLessThanOrEqual\", signedDecimalStrLessThanOrEqual);\n    await connection.createGlobalJsFunction(\"signedDecimalStrGreaterThanOrEqual\", signedDecimalStrGreaterThanOrEqual);\n    await connection.createGlobalJsFunction(\"signedDecimalStrUnaryMinus\", signedDecimalStrUnaryMinus);\n    await connection.createGlobalJsFunction(\"signedDecimalStrAdd\", signedDecimalStrAdd);\n    await connection.createGlobalJsFunction(\"signedDecimalStrSubtract\", signedDecimalStrSubtract);\n    await connection.createGlobalJsFunction(\"signedDecimalStrMultiply\", signedDecimalStrMultiply);\n    await connection.createGlobalJsFunction(\"signedDecimalStrDivide\", signedDecimalStrDivide);\n    await connection.createGlobalJsFunction(\"isSafeBigIntSigned\", isSafeBigIntSigned);\n    await connection.createGlobalJsFunction(\"assertSafeBigIntSigned\", assertSafeBigIntSigned);\n    await connection.createGlobalJsFunction(\"bigIntAdd\", bigIntAdd);\n    await connection.createGlobalJsFunction(\"bigIntSubtract\", bigIntSubtract);\n    await connection.createGlobalJsFunction(\"bigIntUnaryMinus\", bigIntUnaryMinus);\n    await connection.createGlobalJsFunction(\"bigIntMultiply\", bigIntMultiply);\n    await connection.createGlobalJsFunction(\"bigIntDivide\", bigIntDivide);\n    await connection.createVarArgFunction(\"bigint_add\", (...arr) => {\n        if (arr.length == 0) {\n            return BigInt(0);\n        }\n        if (arr.length == 1) {\n            const a = arr[0];\n            if (isBigInt(a)) {\n                return a;\n            }\n            else {\n                throw new Error(`Cannot add non-bigint`);\n            }\n        }\n        const [a, b, ...rest] = arr;\n        if (!isBigInt(a) || !isBigInt(b)) {\n            throw new Error(`Cannot add non-bigint`);\n        }\n        const sum = bigIntAdd(a, b);\n        return rest.reduce((result, x) => {\n            if (!isBigInt(x)) {\n                throw new Error(`Cannot add non-bigint`);\n            }\n            return bigIntAdd(result, x);\n        }, sum);\n    });\n    await connection.createFunction(\"bigint_sub\", (a, b) => {\n        if (!isBigInt(a) || !isBigInt(b)) {\n            throw new Error(`Cannot subtract non-bigint`);\n        }\n        return bigIntSubtract(a, b);\n    });\n    await connection.createVarArgFunction(\"bigint_mul\", (...arr) => {\n        if (arr.length == 0) {\n            return BigInt(1);\n        }\n        if (arr.length == 1) {\n            const a = arr[0];\n            if (isBigInt(a)) {\n                return a;\n            }\n            else {\n                throw new Error(`Cannot multiply non-bigint`);\n            }\n        }\n        const [a, b, ...rest] = arr;\n        if (!isBigInt(a) || !isBigInt(b)) {\n            throw new Error(`Cannot multiply non-bigint`);\n        }\n        const product = bigIntMultiply(a, b);\n        return rest.reduce((result, x) => {\n            if (!isBigInt(x)) {\n                throw new Error(`Cannot multiply non-bigint`);\n            }\n            return bigIntMultiply(result, x);\n        }, product);\n    });\n    await connection.createFunction(\"bigint_neg\", (a) => {\n        if (!isBigInt(a)) {\n            throw new Error(`Cannot unary minus non-bigint`);\n        }\n        return bigIntUnaryMinus(a);\n    });\n    await connection.createFunction(\"bigint_div\", (a, b) => {\n        if (!isBigInt(a) || !isBigInt(b)) {\n            throw new Error(`Cannot divide non-bigint ${typeof a}/${typeof b}`);\n        }\n        return bigIntDivide(a, b);\n    });\n}\nexports.initBigIntPolyfill = initBigIntPolyfill;\n//# sourceMappingURL=bigint-polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignedDecimalStrUtil = require(\"./signed-decimal-str-util\");\nconst { signedDecimalStrLessThanOrEqual, signedDecimalStrGreaterThanOrEqual, signedDecimalStrAdd, signedDecimalStrSubtract, signedDecimalStrMultiply, signedDecimalStrDivide, } = SignedDecimalStrUtil;\nfunction isSafeBigIntSigned(x) {\n    const MAX_SAFE_BIGINT_SIGNED = \"9223372036854775807\";\n    const MIN_SAFE_BIGINT_SIGNED = \"-9223372036854775808\";\n    if (typeof x == \"bigint\") {\n        return (x <= BigInt(MAX_SAFE_BIGINT_SIGNED) &&\n            x >= BigInt(MIN_SAFE_BIGINT_SIGNED));\n    }\n    return (signedDecimalStrLessThanOrEqual(x, MAX_SAFE_BIGINT_SIGNED) &&\n        signedDecimalStrGreaterThanOrEqual(x, MIN_SAFE_BIGINT_SIGNED));\n}\nexports.isSafeBigIntSigned = isSafeBigIntSigned;\nfunction assertSafeBigIntSigned(x) {\n    if (!isSafeBigIntSigned(x)) {\n        throw new RangeError(`BIGINT SIGNED overflow`);\n    }\n}\nexports.assertSafeBigIntSigned = assertSafeBigIntSigned;\nfunction bigIntAdd(a, b) {\n    if (typeof a == \"bigint\" && typeof b == \"bigint\") {\n        const result = a + b;\n        assertSafeBigIntSigned(result);\n        return result;\n    }\n    const result = signedDecimalStrAdd(a.toString(), b.toString());\n    assertSafeBigIntSigned(result);\n    return BigInt(result);\n}\nexports.bigIntAdd = bigIntAdd;\nfunction bigIntSubtract(a, b) {\n    if (typeof a == \"bigint\" && typeof b == \"bigint\") {\n        const result = a - b;\n        assertSafeBigIntSigned(result);\n        return result;\n    }\n    const result = signedDecimalStrSubtract(a.toString(), b.toString());\n    assertSafeBigIntSigned(result);\n    return BigInt(result);\n}\nexports.bigIntSubtract = bigIntSubtract;\nfunction bigIntUnaryMinus(a) {\n    if (typeof a == \"bigint\") {\n        const result = -a;\n        assertSafeBigIntSigned(result);\n        return result;\n    }\n    const str = String(a);\n    if (str == \"0\") {\n        return BigInt(\"0\");\n    }\n    const result = (str[0] == \"-\" ?\n        str.substr(1) :\n        \"-\" + str);\n    assertSafeBigIntSigned(result);\n    return BigInt(result);\n}\nexports.bigIntUnaryMinus = bigIntUnaryMinus;\nfunction bigIntMultiply(a, b) {\n    if (typeof a == \"bigint\" && typeof b == \"bigint\") {\n        const result = a * b;\n        assertSafeBigIntSigned(result);\n        return result;\n    }\n    const result = signedDecimalStrMultiply(a.toString(), b.toString());\n    assertSafeBigIntSigned(result);\n    return BigInt(result);\n}\nexports.bigIntMultiply = bigIntMultiply;\nfunction bigIntDivide(a, b) {\n    if (typeof a == \"bigint\" && typeof b == \"bigint\") {\n        if (b == BigInt(0)) {\n            throw new Error(`DivideByZeroError: Cannot divide by zero`);\n        }\n        const result = a / b;\n        assertSafeBigIntSigned(result);\n        return result;\n    }\n    const result = signedDecimalStrDivide(a.toString(), b.toString());\n    assertSafeBigIntSigned(result);\n    return BigInt(result);\n}\nexports.bigIntDivide = bigIntDivide;\n//# sourceMappingURL=bigint-util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FixedPointUtil = require(\"./fixed-point-util\");\nconst FloatingPointUtil = require(\"./floating-point-util\");\nconst { tryParseFixedPoint } = FixedPointUtil;\nconst { tryParseFloatingPoint, floatingPointToIntegerAndExponent } = FloatingPointUtil;\nasync function initDecimalPolyfill(connection) {\n    await connection.createGlobalJsFunction(\"tryParseFloatingPoint\", tryParseFloatingPoint);\n    await connection.createGlobalJsFunction(\"floatingPointToIntegerAndExponent\", floatingPointToIntegerAndExponent);\n    await connection.createGlobalJsFunction(\"tryParseFixedPoint\", tryParseFixedPoint);\n    await connection.createFunction(\"decimal_ctor\", (x, precision, scale) => {\n        if (!isBigInt(precision) ||\n            !isBigInt(scale)) {\n            throw new Error(`Precision and scale must be bigint`);\n        }\n        const maxPrecision = Number(precision);\n        const maxScale = Number(scale);\n        if (maxPrecision < 1) {\n            throw new Error(`Precision cannot be less than 1`);\n        }\n        if (maxScale < 0) {\n            throw new Error(`Scale cannot be less than 0`);\n        }\n        if (maxScale > maxPrecision) {\n            throw new Error(`Scale cannot be greater than precision`);\n        }\n        if (!isBigInt(x) &&\n            typeof x != \"number\" &&\n            typeof x != \"string\") {\n            throw new Error(`Cannot cast ${typeof x} to DECIMAL(${precision}, ${scale})`);\n        }\n        const str = String(x);\n        const parsed = tryParseFixedPoint(str);\n        if (parsed == undefined) {\n            throw new Error(`Could not cast to DECIMAL(${precision}, ${scale}); invalid fixed point format`);\n        }\n        const curScale = (parsed.getFixedPointFractionalPartString() == \"0\" ?\n            0 :\n            parsed.getFixedPointFractionalPartString().length);\n        const curPrecision = (curScale +\n            (parsed.getFixedPointIntegerPartString() == \"0\" ?\n                0 :\n                parsed.getFixedPointIntegerPartString().length));\n        if (curPrecision > maxPrecision) {\n            throw new Error(`DECIMAL(${precision}, ${scale}) precision pverflow`);\n        }\n        if (curScale > maxScale) {\n            throw new Error(`DECIMAL(${precision}, ${scale}) scale pverflow`);\n        }\n        return parsed.getFixedPointString();\n    });\n}\nexports.initDecimalPolyfill = initDecimalPolyfill;\n//# sourceMappingURL=decimal-polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FloatingPointUtil = require(\"./floating-point-util\");\nconst { tryParseFloatingPoint, floatingPointToIntegerAndExponent } = FloatingPointUtil;\n/**\n * @todo Make `getXxx()` functions cache results\n */\nfunction tryParseFixedPoint(str) {\n    const parsed = tryParseFloatingPoint(str);\n    if (parsed == undefined) {\n        return undefined;\n    }\n    const { isNegative, integerPart, isZero, exponentValue, } = floatingPointToIntegerAndExponent(parsed);\n    function lazyInit(initDelegate) {\n        let initialized = false;\n        let value = undefined;\n        return () => {\n            if (!initialized) {\n                value = initDelegate();\n                initialized = true;\n            }\n            return value;\n        };\n    }\n    if (isZero) {\n        const fixedPointIntegerPartLength = 1;\n        const fixedPointFractionalPartLength = 1;\n        const fixedPointLength = ((isNegative ? 1 : 0) +\n            fixedPointIntegerPartLength +\n            1 +\n            fixedPointFractionalPartLength);\n        const getFixedPointIntegerPartString = () => \"0\";\n        const getFixedPointFractionalPartString = () => \"0\";\n        const getFixedPointString = lazyInit(() => {\n            const sign = isNegative ? \"-\" : \"\";\n            return (sign +\n                getFixedPointIntegerPartString() +\n                \".\" +\n                getFixedPointFractionalPartString());\n        });\n        return {\n            isInteger: true,\n            isNegative,\n            isZero,\n            fixedPointIntegerPartLength,\n            fixedPointFractionalPartLength,\n            fixedPointLength,\n            getFixedPointIntegerPartString,\n            getFixedPointFractionalPartString,\n            getFixedPointString,\n        };\n    }\n    if (exponentValue >= 0) {\n        const fixedPointIntegerPartLength = integerPart.length + exponentValue;\n        const fixedPointFractionalPartLength = 1;\n        const fixedPointLength = ((isNegative ? 1 : 0) +\n            fixedPointIntegerPartLength +\n            1 +\n            fixedPointFractionalPartLength);\n        const getFixedPointIntegerPartString = lazyInit(() => (integerPart + \"0\".repeat(exponentValue)));\n        const getFixedPointFractionalPartString = () => \"0\";\n        const getFixedPointString = lazyInit(() => {\n            const sign = isNegative ? \"-\" : \"\";\n            return (sign +\n                getFixedPointIntegerPartString() +\n                \".\" +\n                getFixedPointFractionalPartString());\n        });\n        return {\n            isInteger: true,\n            isNegative,\n            isZero,\n            fixedPointIntegerPartLength,\n            fixedPointFractionalPartLength,\n            fixedPointLength,\n            getFixedPointIntegerPartString,\n            getFixedPointFractionalPartString,\n            getFixedPointString,\n        };\n    }\n    else {\n        const fractionalOffset = -exponentValue;\n        if (fractionalOffset < integerPart.length) {\n            const newIntegerPart = integerPart.substring(0, integerPart.length - fractionalOffset);\n            let newFractionalPart = integerPart.substring(integerPart.length - fractionalOffset, integerPart.length).replace(/(0+)$/, \"\");\n            if (newFractionalPart == \"\") {\n                newFractionalPart = \"0\";\n            }\n            const fixedPointIntegerPartLength = newIntegerPart.length;\n            const fixedPointFractionalPartLength = newFractionalPart.length;\n            const fixedPointLength = ((isNegative ? 1 : 0) +\n                fixedPointIntegerPartLength +\n                1 +\n                fixedPointFractionalPartLength);\n            const getFixedPointIntegerPartString = () => newIntegerPart;\n            const getFixedPointFractionalPartString = () => newFractionalPart;\n            const getFixedPointString = lazyInit(() => {\n                const sign = isNegative ? \"-\" : \"\";\n                return (sign +\n                    getFixedPointIntegerPartString() +\n                    \".\" +\n                    getFixedPointFractionalPartString());\n            });\n            return {\n                isInteger: (newFractionalPart == \"0\"),\n                isNegative,\n                isZero,\n                fixedPointIntegerPartLength,\n                fixedPointFractionalPartLength,\n                fixedPointLength,\n                getFixedPointIntegerPartString,\n                getFixedPointFractionalPartString,\n                getFixedPointString,\n            };\n        }\n        else if (fractionalOffset == integerPart.length) {\n            let newFractionalPart = integerPart.replace(/(0+)$/, \"\");\n            if (newFractionalPart == \"\") {\n                newFractionalPart = \"0\";\n            }\n            const fixedPointIntegerPartLength = 1;\n            const fixedPointFractionalPartLength = newFractionalPart.length;\n            const fixedPointLength = ((isNegative ? 1 : 0) +\n                fixedPointIntegerPartLength +\n                1 +\n                fixedPointFractionalPartLength);\n            const getFixedPointIntegerPartString = () => (\"0\");\n            const getFixedPointFractionalPartString = () => newFractionalPart;\n            const getFixedPointString = lazyInit(() => {\n                const sign = isNegative ? \"-\" : \"\";\n                return (sign +\n                    getFixedPointIntegerPartString() +\n                    \".\" +\n                    getFixedPointFractionalPartString());\n            });\n            return {\n                isInteger: (newFractionalPart == \"0\"),\n                isNegative,\n                isZero,\n                fixedPointIntegerPartLength,\n                fixedPointFractionalPartLength,\n                fixedPointLength,\n                getFixedPointIntegerPartString,\n                getFixedPointFractionalPartString,\n                getFixedPointString,\n            };\n        }\n        else {\n            let leadingZeroCount = fractionalOffset - integerPart.length;\n            let newFractionalPart = integerPart.replace(/(0+)$/, \"\");\n            if (newFractionalPart == \"\") {\n                leadingZeroCount = 0;\n                newFractionalPart = \"0\";\n            }\n            const fixedPointIntegerPartLength = 1;\n            const fixedPointFractionalPartLength = leadingZeroCount + newFractionalPart.length;\n            const fixedPointLength = ((isNegative ? 1 : 0) +\n                fixedPointIntegerPartLength +\n                1 +\n                fixedPointFractionalPartLength);\n            const getFixedPointIntegerPartString = () => (\"0\");\n            const getFixedPointFractionalPartString = lazyInit(() => (\"0\".repeat(leadingZeroCount) +\n                newFractionalPart));\n            const getFixedPointString = lazyInit(() => {\n                const sign = isNegative ? \"-\" : \"\";\n                return (sign +\n                    getFixedPointIntegerPartString() +\n                    \".\" +\n                    getFixedPointFractionalPartString());\n            });\n            return {\n                isInteger: (newFractionalPart == \"0\"),\n                isNegative,\n                isZero,\n                fixedPointIntegerPartLength,\n                fixedPointFractionalPartLength,\n                fixedPointLength,\n                getFixedPointIntegerPartString,\n                getFixedPointFractionalPartString,\n                getFixedPointString,\n            };\n        }\n    }\n}\nexports.tryParseFixedPoint = tryParseFixedPoint;\n//# sourceMappingURL=fixed-point-util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tryParseFloatingPoint(str) {\n    const floatingPointRegex = /^([-+])?([0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)([eE]([-+])?([0-9]+))?$/;\n    const m = floatingPointRegex.exec(str);\n    if (m == undefined) {\n        return undefined;\n    }\n    //-123.456e+789\n    //~\n    const rawCoefficientSign = m[1];\n    //-123.456e+789\n    // ~~~~~~~\n    const rawCoefficientValue = m[2];\n    //-123.456e+789\n    //         ~\n    const rawExponentSign = m[4];\n    //-123.456e+789\n    //          ~~~\n    const rawExponentValue = m[5];\n    const rawDecimalPlaceIndex = rawCoefficientValue.indexOf(\".\");\n    const rawIntegerPart = (rawDecimalPlaceIndex < 0 ?\n        rawCoefficientValue :\n        rawCoefficientValue.substring(0, rawDecimalPlaceIndex));\n    const rawFractionalPart = (rawDecimalPlaceIndex < 0 ?\n        \"\" :\n        rawCoefficientValue.substring(rawDecimalPlaceIndex + 1, rawCoefficientValue.length));\n    const trimmedIntegerPart = rawIntegerPart.replace(/^(0+)/, \"\");\n    const integerPart = (trimmedIntegerPart == \"\" ?\n        \"0\" :\n        trimmedIntegerPart);\n    const trimmedFractionalPart = rawFractionalPart.replace(/(0+)$/, \"\");\n    const fractionalPart = (trimmedFractionalPart == \"\" ?\n        \"0\" :\n        trimmedFractionalPart);\n    const isZero = (integerPart == \"0\" && fractionalPart == \"0\");\n    function safeCastToNumber(str) {\n        const result = Number(str);\n        if (result.toString() != str) {\n            throw new Error(`Cannot cast exponent to number`);\n        }\n        return result;\n    }\n    const exponentValue = (isZero ?\n        0 :\n        rawExponentValue == undefined ?\n            0 :\n            rawExponentSign === \"-\" ?\n                -safeCastToNumber(rawExponentValue) :\n                safeCastToNumber(rawExponentValue));\n    return {\n        isNegative: (rawCoefficientSign === \"-\"),\n        integerPart,\n        fractionalPart,\n        isZero,\n        exponentValue,\n    };\n}\nexports.tryParseFloatingPoint = tryParseFloatingPoint;\n/**\n * Converts the fractional part to an integer part,\n * by lowering the exponent\n */\nfunction floatingPointToIntegerAndExponent(arg) {\n    if (arg.fractionalPart == \"0\") {\n        return arg;\n    }\n    const exponentValue = (arg.exponentValue -\n        arg.fractionalPart.length);\n    const integerPart = (arg.integerPart == \"0\" ?\n        arg.fractionalPart.replace(/^(0+)/, \"\") :\n        arg.integerPart + arg.fractionalPart);\n    return {\n        isNegative: arg.isNegative,\n        integerPart,\n        fractionalPart: \"0\",\n        isZero: arg.isZero,\n        exponentValue,\n    };\n}\nexports.floatingPointToIntegerAndExponent = floatingPointToIntegerAndExponent;\n//# sourceMappingURL=floating-point-util.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./pool\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst decimal_polyfill_1 = require(\"./decimal-polyfill\");\nconst bigint_polyfill_1 = require(\"./bigint-polyfill\");\nasync function initPolyfill(connection) {\n    await decimal_polyfill_1.initDecimalPolyfill(connection);\n    await bigint_polyfill_1.initBigIntPolyfill(connection);\n    await connection.createFunction(\"ASCII\", (x) => {\n        if (typeof x == \"string\") {\n            if (x == \"\") {\n                return 0;\n            }\n            return x.charCodeAt(0);\n        }\n        else {\n            throw new Error(`ASCII only implemented for string`);\n        }\n    });\n    await connection.createFunction(\"BIN\", (x) => {\n        if (isBigInt(x)) {\n            const str = x.toString();\n            if (str[0] == \"-\") {\n                return binaryStrSetWidth(signedDecimalStrToBinaryStr(str), 64);\n            }\n            else {\n                //substr to remove leading 0\n                return signedDecimalStrToBinaryStr(str).substr(1);\n            }\n            /*\n            if (tm.BigIntUtil.greaterThanOrEqual(x, 0)) {\n                return tm.BigIntUtil.toString(\n                    x,\n                    2\n                );\n            } else {\n                return tm.BigIntUtil.toString(\n                    tm.BigIntUtil.add(\n                        tm.BigIntUtil.leftShift(tm.BigInt(1), 64),\n                        x\n                    ),\n                    2\n                );\n            }\n            */\n        }\n        else {\n            throw new Error(`BIN only implemented for bigint`);\n        }\n    });\n    await connection.createVarArgFunction(\"CONCAT_WS\", (separator, ...args) => {\n        if (typeof separator == \"string\") {\n            return args.filter(arg => arg !== null).join(separator);\n        }\n        else {\n            throw new Error(`CONCAT_WS only implemented for string`);\n        }\n    });\n    await connection.createFunction(\"FROM_BASE64\", (x) => {\n        if (typeof x == \"string\") {\n            const result = new Uint8Array(atob(x).split(\"\").filter(s => s != \"\").map(s => s.charCodeAt(0)));\n            return result;\n        }\n        else {\n            throw new Error(`FROM_BASE64 only implemented for string`);\n        }\n    });\n    await connection.createFunction(\"LPAD\", (str, len, pad) => {\n        if (typeof str == \"string\" &&\n            isBigInt(len) &&\n            typeof pad == \"string\") {\n            if (str.length > Number(len)) {\n                return str.substr(0, Number(len));\n            }\n            else if (str.length == Number(len)) {\n                return str;\n            }\n            else {\n                return str.padStart(Number(len), pad);\n            }\n        }\n        else {\n            throw new Error(`LPAD only implemented for (string, bigint, string)`);\n        }\n    });\n    await connection.createFunction(\"RPAD\", (str, len, pad) => {\n        if (typeof str == \"string\" &&\n            isBigInt(len) &&\n            typeof pad == \"string\") {\n            if (str.length > Number(len)) {\n                return str.substr(0, Number(len));\n            }\n            else if (str.length == Number(len)) {\n                return str;\n            }\n            else {\n                return str.padEnd(Number(len), pad);\n            }\n        }\n        else {\n            throw new Error(`RPAD only implemented for (string, bigint, string)`);\n        }\n    });\n    await connection.createFunction(\"REPEAT\", (str, count) => {\n        if (typeof str == \"string\" &&\n            isBigInt(count)) {\n            if (Number(count) < 0) {\n                return \"\";\n            }\n            return str.repeat(Number(count));\n        }\n        else {\n            throw new Error(`REPEAT only implemented for (string, bigint)`);\n        }\n    });\n    await connection.createFunction(\"REVERSE\", (str) => {\n        if (typeof str == \"string\") {\n            return [...str].reverse().join(\"\");\n        }\n        else {\n            throw new Error(`REVERSE only implemented for (string)`);\n        }\n    });\n    await connection.createFunction(\"TO_BASE64\", (blob) => {\n        if (blob instanceof Uint8Array) {\n            return btoa([...blob].map(n => String.fromCharCode(n)).join(\"\"));\n        }\n        else {\n            throw new Error(`TO_BASE64 only implemented for (Uint8Array)`);\n        }\n    });\n    await connection.createFunction(\"UNHEX\", (x) => {\n        if (typeof x == \"string\") {\n            const matches = x.match(/.{2}/g);\n            if (matches == undefined) {\n                throw new Error(`Invalid Hex string`);\n            }\n            const result = new Uint8Array(matches.map(str => parseInt(str, 16)));\n            const hexResult = [...result].map((n) => (\"00\" + n.toString(16)).slice(-2)).join(\"\");\n            if (x.toUpperCase() == hexResult.toUpperCase()) {\n                return result;\n            }\n            else {\n                throw new Error(`Invalid Hex string`);\n            }\n        }\n        else {\n            throw new Error(`UNHEX only implemented for string`);\n        }\n    });\n    await connection.createFunction(\"FLOOR\", (x) => {\n        if (isBigInt(x)) {\n            return x;\n        }\n        else if (typeof x == \"number\") {\n            return Math.floor(x);\n        }\n        else {\n            throw new Error(`Can only FLOOR bigint or double`);\n        }\n    });\n    await connection.createFunction(\"CEILING\", (x) => {\n        if (isBigInt(x)) {\n            return x;\n        }\n        else if (typeof x == \"number\") {\n            return Math.ceil(x);\n        }\n        else {\n            throw new Error(`Can only CEILING bigint or double`);\n        }\n    });\n    await connection.createFunction(\"CBRT\", (x) => {\n        if (typeof x == \"number\") {\n            return Math.cbrt(x);\n        }\n        else {\n            throw new Error(`CBRT(${typeof x}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"COT\", (x) => {\n        if (typeof x == \"number\") {\n            const divisor = Math.cos(x);\n            const dividend = Math.sin(x);\n            if (dividend == 0) {\n                return null;\n            }\n            else {\n                return divisor / dividend;\n            }\n        }\n        else {\n            throw new Error(`COT(${typeof x}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"LN\", (x) => {\n        if (typeof x == \"number\") {\n            if (x == 0) {\n                return null;\n            }\n            const result = Math.log(x);\n            return result;\n        }\n        else {\n            throw new Error(`LN(${typeof x}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"LOG\", (x, y) => {\n        if (typeof x == \"number\" && typeof y == \"number\") {\n            if (x <= 0 || x == 1) {\n                return null;\n            }\n            if (y == 0) {\n                return null;\n            }\n            return Math.log(y) / Math.log(x);\n        }\n        else {\n            throw new Error(`LOG(${typeof x}, ${typeof y}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"LOG2\", (x) => {\n        if (typeof x == \"number\") {\n            if (x == 0) {\n                return null;\n            }\n            const result = Math.log2(x);\n            return result;\n        }\n        else {\n            throw new Error(`LOG2(${typeof x}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"LOG10\", (x) => {\n        if (typeof x == \"number\") {\n            if (x == 0) {\n                return null;\n            }\n            const result = Math.log10(x);\n            return result;\n        }\n        else {\n            throw new Error(`LOG10(${typeof x}) not implmented`);\n        }\n    });\n    await connection.createFunction(\"FRANDOM\", () => {\n        return Math.random();\n    });\n    await connection.createAggregate(\"STDDEV_POP\", () => {\n        return {\n            values: [],\n        };\n    }, (state, x) => {\n        if (x === null) {\n            return;\n        }\n        if (typeof x == \"number\") {\n            state.values.push(x);\n        }\n        else {\n            throw new Error(`STDDEV_POP(${typeof x}) not implmented`);\n        }\n    }, (state) => {\n        if (state == undefined) {\n            return null;\n        }\n        if (state.values.length == 0) {\n            return null;\n        }\n        const sum = state.values.reduce((sum, value) => sum + value, 0);\n        const count = state.values.length;\n        const avg = sum / count;\n        const squaredErrors = state.values.map(value => {\n            return Math.pow(value - avg, 2);\n        });\n        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);\n        return Math.sqrt(sumSquaredErrors / count);\n    });\n    await connection.createAggregate(\"STDDEV_SAMP\", () => {\n        return {\n            values: [],\n        };\n    }, (state, x) => {\n        if (x === null) {\n            return;\n        }\n        if (typeof x == \"number\") {\n            state.values.push(x);\n        }\n        else {\n            throw new Error(`STDDEV_SAMP(${typeof x}) not implmented`);\n        }\n    }, (state) => {\n        if (state == undefined) {\n            return null;\n        }\n        if (state.values.length == 0) {\n            return null;\n        }\n        if (state.values.length == 1) {\n            return null;\n        }\n        const sum = state.values.reduce((sum, value) => sum + value, 0);\n        const count = state.values.length;\n        const avg = sum / count;\n        const squaredErrors = state.values.map(value => {\n            return Math.pow(value - avg, 2);\n        });\n        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);\n        return Math.sqrt(sumSquaredErrors / (count - 1));\n    });\n    await connection.createAggregate(\"VAR_POP\", () => {\n        return {\n            values: [],\n        };\n    }, (state, x) => {\n        if (x === null) {\n            return;\n        }\n        if (typeof x == \"number\") {\n            state.values.push(x);\n        }\n        else {\n            throw new Error(`VAR_POP(${typeof x}) not implmented`);\n        }\n    }, (state) => {\n        if (state == undefined) {\n            return null;\n        }\n        if (state.values.length == 0) {\n            return null;\n        }\n        const sum = state.values.reduce((sum, value) => sum + value, 0);\n        const count = state.values.length;\n        const avg = sum / count;\n        const squaredErrors = state.values.map(value => {\n            return Math.pow(value - avg, 2);\n        });\n        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);\n        return sumSquaredErrors / count;\n    });\n    await connection.createAggregate(\"VAR_SAMP\", () => {\n        return {\n            values: [],\n        };\n    }, (state, x) => {\n        if (x === null) {\n            return;\n        }\n        if (typeof x == \"number\") {\n            state.values.push(x);\n        }\n        else {\n            throw new Error(`VAR_SAMP(${typeof x}) not implmented`);\n        }\n    }, (state) => {\n        if (state == undefined) {\n            return null;\n        }\n        if (state.values.length == 0) {\n            return null;\n        }\n        if (state.values.length == 1) {\n            return null;\n        }\n        const sum = state.values.reduce((sum, value) => sum + value, 0);\n        const count = state.values.length;\n        const avg = sum / count;\n        const squaredErrors = state.values.map(value => {\n            return Math.pow(value - avg, 2);\n        });\n        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);\n        return sumSquaredErrors / (count - 1);\n    });\n}\nexports.initPolyfill = initPolyfill;\n//# sourceMappingURL=polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst worker_1 = require(\"../../worker\");\nconst connection_1 = require(\"../connection\");\nconst polyfill_1 = require(\"./polyfill\");\nclass Pool {\n    constructor(worker) {\n        this.sharedConnectionInfo = {\n            transactionData: undefined,\n            savepointId: 0,\n        };\n        this.onInsert = new squill.PoolEventEmitter();\n        this.onInsertOne = new squill.PoolEventEmitter();\n        this.onInsertAndFetch = new squill.PoolEventEmitter();\n        this.onInsertSelect = new squill.PoolEventEmitter();\n        this.onReplace = new squill.PoolEventEmitter();\n        this.onReplaceOne = new squill.PoolEventEmitter();\n        this.onReplaceSelect = new squill.PoolEventEmitter();\n        this.onUpdate = new squill.PoolEventEmitter();\n        this.onUpdateAndFetch = new squill.PoolEventEmitter();\n        this.onDelete = new squill.PoolEventEmitter();\n        this.worker = worker;\n        this.idAllocator = new connection_1.IdAllocator();\n        this.asyncQueue = new squill.AsyncQueue(() => {\n            const connection = new connection_1.Connection({\n                pool: this,\n                eventEmitters: new squill.ConnectionEventEmitterCollection(this),\n                worker: this.worker,\n                idAllocator: this.idAllocator,\n                sharedConnectionInformation: this.sharedConnectionInfo,\n            });\n            return {\n                item: connection,\n                deallocate: () => {\n                    return connection.deallocate();\n                },\n            };\n        });\n        this.acquire = this.asyncQueue.enqueue;\n        this.acquire(async (connection) => {\n            await polyfill_1.initPolyfill(connection);\n        }).then(() => { }, (err) => {\n            //console.error(\"Error creating functions\", err);\n            //process.exit(1);\n            throw err;\n        });\n    }\n    acquireTransaction(...args) {\n        return this.acquire((connection) => {\n            /**\n             * TS has weird narrowing behaviours\n             */\n            if (args.length == 1) {\n                return connection.transaction(...args);\n            }\n            else {\n                return connection.transaction(...args);\n            }\n        });\n    }\n    acquireReadOnlyTransaction(...args) {\n        return this.acquire((connection) => {\n            /**\n             * TS has weird narrowing behaviours\n             */\n            if (args.length == 1) {\n                return connection.readOnlyTransaction(...args);\n            }\n            else {\n                return connection.readOnlyTransaction(...args);\n            }\n        });\n    }\n    disconnect() {\n        return this.asyncQueue.stop()\n            .then(() => this.worker.postMessage({\n            id: this.idAllocator.allocateId(),\n            action: worker_1.SqliteAction.CLOSE,\n        }), () => this.worker.postMessage({\n            id: this.idAllocator.allocateId(),\n            action: worker_1.SqliteAction.CLOSE,\n        }));\n    }\n    isDeallocated() {\n        return this.asyncQueue.getShouldStop();\n    }\n}\nexports.Pool = Pool;\n//# sourceMappingURL=pool.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst UnsignedDecimalStrUtil = require(\"./unsigned-decimal-str-util\");\nconst { unsignedDecimalStrAdd, unsignedDecimalStrSubtract, unsignedDecimalStrMultiply, unsignedDecimalStrDivide, } = UnsignedDecimalStrUtil;\n/**\n *\n * @param {string} decimalStr\n */\nfunction signedDecimalStrIsPositive(decimalStr) {\n    return decimalStr[0] != \"-\";\n}\nexports.signedDecimalStrIsPositive = signedDecimalStrIsPositive;\n/**\n *\n * @param {string} a\n * @param {string} b\n */\nfunction signedDecimalStrGreaterThanOrEqual(a, b) {\n    if (signedDecimalStrIsPositive(a)) {\n        if (signedDecimalStrIsPositive(b)) {\n            if (a.length > b.length) {\n                return true;\n            }\n            if (a.length < b.length) {\n                return false;\n            }\n            for (let i = 0; i < a.length; ++i) {\n                if (Number(a[i]) > Number(b[i])) {\n                    return true;\n                }\n                if (Number(a[i]) < Number(b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            //a > b\n            return true;\n        }\n    }\n    else {\n        if (signedDecimalStrIsPositive(b)) {\n            //a < b\n            return false;\n        }\n        else {\n            return signedDecimalStrGreaterThanOrEqual(b.substr(1), a.substr(1));\n        }\n    }\n}\nexports.signedDecimalStrGreaterThanOrEqual = signedDecimalStrGreaterThanOrEqual;\n/**\n *\n * @param {string} a\n * @param {string} b\n */\nfunction signedDecimalStrLessThanOrEqual(a, b) {\n    return signedDecimalStrGreaterThanOrEqual(b, a);\n}\nexports.signedDecimalStrLessThanOrEqual = signedDecimalStrLessThanOrEqual;\nfunction signedDecimalStrUnaryMinus(a) {\n    if (a == \"0\") {\n        return a;\n    }\n    const aNegative = a[0] == \"-\";\n    return aNegative ? a.substr(1) : (\"-\" + a);\n}\nexports.signedDecimalStrUnaryMinus = signedDecimalStrUnaryMinus;\nfunction signedDecimalStrSubtract(a, b) {\n    if (a == b) {\n        return \"0\";\n    }\n    if (b[0] == \"-\") {\n        //a - negative = a + (-negative)\n        return signedDecimalStrAdd(a, b.substr(1));\n    }\n    if (a[0] == \"-\") {\n        //negative - b = -((-negative) + b)\n        return signedDecimalStrUnaryMinus(signedDecimalStrAdd(a.substr(1), b));\n    }\n    if (signedDecimalStrGreaterThanOrEqual(a, b)) {\n        //a > b\n        return unsignedDecimalStrSubtract(a, b);\n    }\n    else {\n        //a < b\n        return signedDecimalStrUnaryMinus(signedDecimalStrSubtract(b, a));\n    }\n}\nexports.signedDecimalStrSubtract = signedDecimalStrSubtract;\nfunction signedDecimalStrAdd(a, b) {\n    if (b[0] == \"-\") {\n        //a + negative = a - (-negative)\n        return signedDecimalStrSubtract(a, b.substr(1));\n    }\n    if (a[0] == \"-\") {\n        //negative + b = b - (-negative)\n        const absA = a.substr(1);\n        if (absA == b) {\n            //-x + x = 0\n            return \"0\";\n        }\n        else if (signedDecimalStrGreaterThanOrEqual(absA, b)) {\n            //x > b\n            return signedDecimalStrUnaryMinus(signedDecimalStrSubtract(absA, b));\n        }\n        else {\n            //x < b\n            return signedDecimalStrSubtract(b, absA);\n        }\n    }\n    return unsignedDecimalStrAdd(a, b);\n}\nexports.signedDecimalStrAdd = signedDecimalStrAdd;\nfunction signedDecimalStrMultiply(a, b) {\n    const aNegative = a[0] == \"-\";\n    const bNegative = b[0] == \"-\";\n    const absMul = unsignedDecimalStrMultiply(aNegative ? a.substr(1) : a, bNegative ? b.substr(1) : b);\n    if (aNegative == bNegative) {\n        return absMul;\n    }\n    else {\n        return signedDecimalStrUnaryMinus(absMul);\n    }\n}\nexports.signedDecimalStrMultiply = signedDecimalStrMultiply;\nfunction signedDecimalStrDivide(a, b) {\n    const aNegative = a[0] == \"-\";\n    const bNegative = b[0] == \"-\";\n    const absDiv = unsignedDecimalStrDivide(aNegative ? a.substr(1) : a, bNegative ? b.substr(1) : b);\n    if (aNegative == bNegative) {\n        return absDiv;\n    }\n    else {\n        return signedDecimalStrUnaryMinus(absDiv);\n    }\n}\nexports.signedDecimalStrDivide = signedDecimalStrDivide;\n//# sourceMappingURL=signed-decimal-str-util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction unsignedDigitArrayAdd(numA, numB) {\n    const result = [];\n    let carry = 0;\n    for (let i = 0; i < Math.max(numA.length, numB.length); ++i) {\n        carry += (i < numA.length ?\n            numA[numA.length - i - 1] :\n            0);\n        carry += (i < numB.length ?\n            numB[numB.length - i - 1] :\n            0);\n        const digit = carry % 10;\n        carry = Math.floor(carry / 10);\n        result.unshift(digit);\n    }\n    if (carry != 0) {\n        result.unshift(carry);\n    }\n    return result;\n}\nexports.unsignedDigitArrayAdd = unsignedDigitArrayAdd;\nfunction unsignedDigitArraySubtract(numA, numB) {\n    const result = [];\n    let carry = 0;\n    for (let i = 0; i < numA.length; ++i) {\n        carry += numA[numA.length - i - 1];\n        carry -= (i < numB.length ?\n            numB[numB.length - i - 1] :\n            0);\n        if (carry >= 0) {\n            result.unshift(carry);\n            carry = 0;\n        }\n        else {\n            carry += 10;\n            result.unshift(carry);\n            carry = -1;\n        }\n    }\n    if (carry < 0) {\n        throw new Error(`Result of unsigned subtraction is negative`);\n    }\n    while (result[0] == 0 && result.length >= 2) {\n        result.shift();\n    }\n    return result;\n}\nexports.unsignedDigitArraySubtract = unsignedDigitArraySubtract;\nfunction unsignedDecimalStrAdd(a, b) {\n    const numA = a.toString().split(\"\").map(Number);\n    const numB = b.toString().split(\"\").map(Number);\n    return unsignedDigitArrayAdd(numA, numB).join(\"\");\n}\nexports.unsignedDecimalStrAdd = unsignedDecimalStrAdd;\nfunction unsignedDecimalStrSubtract(a, b) {\n    if (a == b) {\n        return \"0\";\n    }\n    if (a.length < b.length) {\n        throw new Error(`Result of unsigned subtraction is negative`);\n    }\n    const numA = a.toString().split(\"\").map(Number);\n    const numB = b.toString().split(\"\").map(Number);\n    return unsignedDigitArraySubtract(numA, numB).join(\"\");\n}\nexports.unsignedDecimalStrSubtract = unsignedDecimalStrSubtract;\nfunction unsignedDecimalStrMultiply(a, b) {\n    if (a == \"0\" || b == \"0\") {\n        return \"0\";\n    }\n    if (a == \"1\") {\n        return b;\n    }\n    if (b == \"1\") {\n        return a;\n    }\n    const numA = a.toString().split(\"\").map(Number);\n    const numB = b.toString().split(\"\").map(Number);\n    const arr = numB.map((digitB, indexB) => {\n        const result = [];\n        let carry = 0;\n        for (let i = numA.length - 1; i >= 0; --i) {\n            const digitA = numA[i];\n            carry += digitA * digitB;\n            const digit = carry % 10;\n            carry = Math.floor(carry / 10);\n            result.unshift(digit);\n        }\n        if (carry != 0) {\n            result.unshift(carry);\n        }\n        const powerOf10 = numB.length - indexB - 1;\n        for (let i = 0; i < powerOf10; ++i) {\n            result.push(0);\n        }\n        return result;\n    });\n    if (arr.length == 0) {\n        return \"0\";\n    }\n    if (arr.length == 1) {\n        return arr[0].join(\"\");\n    }\n    const [x, y, ...rest] = arr;\n    let result = unsignedDigitArrayAdd(x, y);\n    for (const r of rest) {\n        result = unsignedDigitArrayAdd(result, r);\n    }\n    return result.join(\"\");\n}\nexports.unsignedDecimalStrMultiply = unsignedDecimalStrMultiply;\nfunction unsignedDigitArrayGreaterThanOrEqual(numA, numB) {\n    if (numA.length > numB.length) {\n        return true;\n    }\n    if (numA.length < numB.length) {\n        return false;\n    }\n    for (let i = 0; i < numA.length; ++i) {\n        const digitA = numA[i];\n        const digitB = numB[i];\n        if (digitA > digitB) {\n            return true;\n        }\n        if (digitA < digitB) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.unsignedDigitArrayGreaterThanOrEqual = unsignedDigitArrayGreaterThanOrEqual;\nfunction unsignedDigitArrayLessThanOrEqual(numA, numB) {\n    return unsignedDigitArrayGreaterThanOrEqual(numB, numA);\n}\nexports.unsignedDigitArrayLessThanOrEqual = unsignedDigitArrayLessThanOrEqual;\nfunction unsignedDecimalStrDivide(a, b) {\n    if (b == \"0\") {\n        throw new Error(`DivideByZeroError: Cannot divide by zero`);\n    }\n    if (b == \"1\") {\n        return a;\n    }\n    if (a == \"0\") {\n        return \"0\";\n    }\n    const numA = a.toString().split(\"\").map(Number);\n    const numB = b.toString().split(\"\").map(Number);\n    const quotient = [];\n    let remainder = [];\n    for (let i = 0; i < numA.length; ++i) {\n        remainder.push(numA[i]);\n        while (remainder[0] == 0 && remainder.length >= 2) {\n            remainder.shift();\n        }\n        if (remainder.length < numB.length) {\n            quotient.push(0);\n            continue;\n        }\n        let tmp = [0];\n        let q = 0;\n        while (q <= 9) {\n            const tmp2 = unsignedDigitArrayAdd(tmp, numB);\n            if (unsignedDigitArrayLessThanOrEqual(tmp2, remainder)) {\n                tmp = tmp2;\n                ++q;\n            }\n            else {\n                break;\n            }\n        }\n        if (q == 0) {\n            quotient.push(0);\n            continue;\n        }\n        quotient.push(q);\n        remainder = unsignedDigitArraySubtract(remainder, tmp);\n    }\n    while (quotient[0] == 0 && quotient.length >= 2) {\n        quotient.shift();\n    }\n    return quotient.join(\"\");\n}\nexports.unsignedDecimalStrDivide = unsignedDecimalStrDivide;\n//# sourceMappingURL=unsigned-decimal-str-util.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./information\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./last-insert-row-id\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nexports.lastInsertRowId = squill.makeCustomOperator0(\"LAST_INSERT_ROWID()\", tm.mysql.bigIntSigned());\n//# sourceMappingURL=last-insert-row-id.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./execution\"));\n__export(require(\"./expr-library\"));\n__export(require(\"./schema-introspection\"));\n__export(require(\"./sqlfier\"));\n__export(require(\"./constants\"));\n__export(require(\"./worker\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./sqlite-master\"));\n__export(require(\"./try-fetch-generated-column-expression\"));\n__export(require(\"./try-fetch-schema-meta\"));\n__export(require(\"./try-fetch-table-meta\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nexports.sqlite_master = squill.table(\"sqlite_master\")\n    .addColumns({\n    type: squill.dtVarChar(),\n    name: squill.dtVarChar(),\n    tbl_name: squill.dtVarChar(),\n    rootpage: squill.dtBigIntSigned(),\n    sql: squill.dtVarChar().orNull(),\n})\n    .setPrimaryKey(columns => [columns.name]);\n//# sourceMappingURL=sqlite-master.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tryFetchGeneratedColumnExpression(_connection, _schemaAlias, _tableAlias, _columnAlias) {\n    /**\n     * @todo\n     */\n    return Promise.resolve(undefined);\n}\nexports.tryFetchGeneratedColumnExpression = tryFetchGeneratedColumnExpression;\n//# sourceMappingURL=try-fetch-generated-column-expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst try_fetch_table_meta_1 = require(\"./try-fetch-table-meta\");\nconst sqlite_master_1 = require(\"./sqlite-master\");\nconst constants_1 = require(\"../constants\");\nasync function tryFetchSchemaMeta(connection, rawSchemaAlias) {\n    const schemaAlias = (rawSchemaAlias == undefined ?\n        constants_1.DEFAULT_SCHEMA_NAME :\n        rawSchemaAlias);\n    const tables = await squill\n        .from(sqlite_master_1.sqlite_master\n        .setSchemaName(schemaAlias))\n        .whereEq(columns => columns.type, \"table\")\n        .selectValue(columns => columns.name)\n        .map(async (row) => {\n        const tableMeta = await try_fetch_table_meta_1.tryFetchTableMeta(connection, schemaAlias, row.sqlite_master.name);\n        if (tableMeta == undefined) {\n            throw new Error(`Table ${squill.pascalStyleEscapeString(schemaAlias)}.${squill.pascalStyleEscapeString(row.sqlite_master.name)} does not exist`);\n        }\n        else {\n            return tableMeta;\n        }\n    })\n        .fetchAll(connection);\n    return {\n        schemaAlias,\n        tables,\n    };\n}\nexports.tryFetchSchemaMeta = tryFetchSchemaMeta;\n//# sourceMappingURL=try-fetch-schema-meta.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nconst sqlite_master_1 = require(\"./sqlite-master\");\nasync function tryFetchTableMeta(connection, schemaAlias, tableAlias) {\n    const sql = await sqlite_master_1.sqlite_master\n        .setSchemaName(schemaAlias)\n        .whereEqPrimaryKey({\n        name: tableAlias,\n    })\n        .fetchValue(connection, columns => columns.sql)\n        .orUndefined();\n    if (sql === undefined) {\n        return undefined;\n    }\n    if (sql === null) {\n        throw new Error(`Table ${tableAlias} should have SQL string`);\n    }\n    //Modified version of\n    //http://afoucal.free.fr/index.php/2009/01/26/get-default-value-and-unique-attribute-field-sqlite-database-using-air/\n    const allColumnDefSql = sql.replace(/^CREATE\\s+\\w+\\s+((\"\\w+\"|\\w+)|\\[(.+)\\])\\s+(\\(|AS|)/im, \"\");\n    function getColumnDefSqlImpl(columnAlias) {\n        const columnRegex = new RegExp(columnAlias + \"(.*?)(,|\\r|$)\", \"m\");\n        const columnDefSqlMatch = allColumnDefSql.match(columnRegex);\n        if (columnDefSqlMatch == undefined) {\n            return undefined;\n        }\n        return columnDefSqlMatch[1];\n    }\n    function getColumnDefSql(columnAlias) {\n        const resultQuoted = getColumnDefSqlImpl(squill.escapeIdentifierWithDoubleQuotes(columnAlias));\n        if (resultQuoted != undefined) {\n            return resultQuoted;\n        }\n        const resultUnquoted = getColumnDefSqlImpl(columnAlias);\n        if (resultUnquoted != undefined) {\n            return resultUnquoted;\n        }\n        throw new Error(`Cannot find column definition for ${tableAlias}.${columnAlias}`);\n    }\n    function isAutoIncrement(columnAlias) {\n        return /AUTOINCREMENT/i.test(getColumnDefSql(columnAlias));\n    }\n    function isUnique(columnAlias) {\n        return /UNIQUE/i.test(getColumnDefSql(columnAlias));\n    }\n    function isPrimaryKey(columnAlias) {\n        return /PRIMARY\\s+KEY/i.test(getColumnDefSql(columnAlias));\n    }\n    let constraintSql = allColumnDefSql;\n    const { execResult } = await connection\n        .exec(`pragma table_info(${squill.escapeIdentifierWithDoubleQuotes(tableAlias)})`);\n    if (execResult.length != 1) {\n        throw new Error(`Expected to fetch table info`);\n    }\n    const candidateKeys = [];\n    let primaryKey = undefined;\n    const resultSet = execResult[0];\n    const objArr = resultSet.values.map((row) => {\n        const obj = resultSet.columns.reduce((obj, columnAlias, index) => {\n            obj[columnAlias] = row[index];\n            return obj;\n        }, {});\n        obj.isAutoIncrement = isAutoIncrement(obj.name);\n        obj.isUnique = isUnique(obj.name);\n        obj.isPrimaryKey = isPrimaryKey(obj.name);\n        obj.columnAlias = obj.name;\n        obj.isNullable = tm.BigIntUtil.equal(obj.notnull, tm.BigInt(0));\n        obj.explicitDefaultValue = typeof obj.dflt_value == \"string\" ?\n            obj.dflt_value :\n            undefined;\n        /**\n         * @todo\n         */\n        obj.generationExpression = undefined;\n        const columnDef = getColumnDefSql(obj.name);\n        constraintSql = constraintSql.replace(columnDef, \"\");\n        if (isPrimaryKey(obj.name)) {\n            if (primaryKey != undefined) {\n                throw new Error(`Multiple primary keys found`);\n            }\n            primaryKey = {\n                candidateKeyName: obj.name,\n                columnAliases: [obj.name],\n            };\n        }\n        else if (isUnique(obj.name)) {\n            const constraintRegex = /CONSTRAINT\\s+(.+)\\s+UNIQUE/gi;\n            const constraintMatch = constraintRegex.exec(columnDef);\n            if (constraintMatch == undefined) {\n                throw new Error(`Cannot get UNIQUE constraint of ${obj.name}`);\n            }\n            candidateKeys.push({\n                candidateKeyName: squill.tryUnescapeIdentifierWithDoubleQuotes(constraintMatch[1]),\n                columnAliases: [obj.name],\n            });\n        }\n        return obj;\n    });\n    const constraintRegex = /CONSTRAINT\\s+(.+)\\s+(UNIQUE|PRIMARY\\s+KEY)\\s*\\((.+)\\)/gi;\n    while (true) {\n        const constraintMatch = constraintRegex.exec(constraintSql);\n        if (constraintMatch == undefined) {\n            break;\n        }\n        const constraintName = squill.tryUnescapeIdentifierWithDoubleQuotes(constraintMatch[1]);\n        const constraintType = constraintMatch[2];\n        const constraintColumns = constraintMatch[3];\n        const columnRegex = /\\s*(.+?)\\s*(,|$)/gi;\n        const columnAliases = [];\n        while (true) {\n            const columnMatch = columnRegex.exec(constraintColumns);\n            if (columnMatch == undefined) {\n                break;\n            }\n            columnAliases.push(squill.tryUnescapeIdentifierWithDoubleQuotes(columnMatch[1]));\n        }\n        if (constraintType.toUpperCase() == \"UNIQUE\") {\n            candidateKeys.push({\n                candidateKeyName: constraintName,\n                columnAliases,\n            });\n        }\n        else {\n            if (primaryKey != undefined) {\n                throw new Error(`Multiple primary keys found`);\n            }\n            primaryKey = {\n                candidateKeyName: constraintName,\n                columnAliases,\n            };\n        }\n    }\n    return {\n        tableAlias,\n        columns: objArr,\n        candidateKeys,\n        primaryKey: candidateKeys.find(candidateKey => candidateKey.candidateKeyName == \"PRIMARY\"),\n    };\n}\nexports.tryFetchTableMeta = tryFetchTableMeta;\n//# sourceMappingURL=try-fetch-table-meta.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\n/**\n * Returns an unprettified SQL string.\n * Is fast-ish.\n *\n * @param ast - The AST to convert to a SQL string\n * @see {toSqlPretty} for pretty output but slower performance.\n */\nfunction toSql(ast) {\n    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n}\nexports.toSql = toSql;\n/**\n * Returns a prettified SQL string.\n * Is slow-ish.\n *\n * @param ast - The AST to convert to a SQL string\n * @see {toSql} for ugly output but faster performance.\n */\nfunction toSqlPretty(ast) {\n    return squill.AstUtil.toSqlPretty(ast, sqlfier_1.sqlfier, {\n        stringTypes: [/*`\"\"`,*/ \"N''\", /*\"''\",*/ \"``\", \"[]\", \"X''\", \"pascal-single\", \"pascal-double\"],\n        /**\n         * These `undefined` values should be ignored,\n         * and should not overwrite.\n         */\n        openParens: undefined,\n        closeParens: undefined,\n    });\n}\nexports.toSqlPretty = toSqlPretty;\n//# sourceMappingURL=convenience.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\nfunction deleteSqlString(table, whereClause) {\n    const ast = [\n        \"DELETE FROM\",\n        table.unaliasedAst,\n        \"WHERE\",\n        whereClause.ast\n    ];\n    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n}\nexports.deleteSqlString = deleteSqlString;\n//# sourceMappingURL=delete-sql-string.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./convenience\"));\n__export(require(\"./delete-sql-string\"));\n__export(require(\"./insert-many-sql-string\"));\n__export(require(\"./insert-one-sql-string\"));\n__export(require(\"./insert-select-sql-string\"));\n__export(require(\"./sqlfier\"));\n__export(require(\"./update-sql-string\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\nconst schema_introspection_1 = require(\"../schema-introspection\");\nconst constants_1 = require(\"../constants\");\nasync function insertManySqlString(connection, insertType, table, insertRows) {\n    const rawSchemaName = squill.TableUtil.tryGetSchemaName(table);\n    const schemaName = (rawSchemaName == undefined ?\n        constants_1.DEFAULT_SCHEMA_NAME :\n        rawSchemaName);\n    /**\n     * We need to fetch the `tableMeta` because SQLite does not support the\n     * `DEFAULT` keyword.\n     */\n    const tableMeta = await schema_introspection_1.tryFetchTableMeta(connection, schemaName, table.alias);\n    if (tableMeta == undefined) {\n        throw new Error(`Table ${squill.pascalStyleEscapeString(schemaName)}.${squill.pascalStyleEscapeString(table.alias)} does not exist`);\n    }\n    const structure = tableMeta.columns;\n    //console.log(structure);\n    const columnAliases = squill.TableUtil.columnAlias(table)\n        .sort()\n        .filter(columnAlias => {\n        /**\n         * @todo handle GENERATED columns\n         */\n        //Might possibly be a GENERATED column, actually.\n        //For some reason, these don't show up in pragma table_info\n        const columnDef = structure.find(columnDef => {\n            return columnDef.name == columnAlias;\n        });\n        return columnDef != undefined;\n    });\n    const values = insertRows.map(insertRow => {\n        const ast = columnAliases\n            .map(columnAlias => {\n            const value = insertRow[columnAlias];\n            if (value === undefined) {\n                const columnDef = structure.find(columnDef => {\n                    return columnDef.name == columnAlias;\n                });\n                if (columnDef == undefined) {\n                    //Might possibly be a GENERATED column, actually.\n                    //For some reason, these don't show up in pragma table_info\n                    throw new Error(`Unknown column ${table.alias}.${columnAlias}`);\n                }\n                if (columnDef.dflt_value != undefined) {\n                    return columnDef.dflt_value;\n                }\n                if (tm.BigIntUtil.equal(columnDef.notnull, tm.BigInt(1))) {\n                    if (columnDef.isAutoIncrement) {\n                        return \"NULL\";\n                    }\n                    throw new Error(`${table.alias}.${columnAlias} is not nullable`);\n                }\n                else {\n                    return \"NULL\";\n                }\n            }\n            else {\n                return squill.BuiltInExprUtil.buildAst(value);\n            }\n        })\n            .reduce((values, ast) => {\n            if (values.length > 0) {\n                values.push(\", \");\n            }\n            values.push(ast);\n            return values;\n        }, []);\n        ast.unshift(\"(\");\n        ast.push(\")\");\n        return ast;\n    })\n        .reduce((values, ast) => {\n        if (values.length > 0) {\n            values.push(\", \");\n        }\n        values.push(ast);\n        return values;\n    }, []);\n    const ast = [\n        `${insertType} INTO`,\n        /**\n         * We use the `unaliasedAst` because the user may have called `setSchemaName()`\n         */\n        table.unaliasedAst,\n        \"(\",\n        columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(\", \"),\n        \") VALUES\",\n        ...values,\n    ];\n    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n    return sql;\n}\nexports.insertManySqlString = insertManySqlString;\n//# sourceMappingURL=insert-many-sql-string.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\nfunction insertOneSqlString(insertType, table, insertRow) {\n    const columnAliases = squill.TableUtil.columnAlias(table)\n        .filter(columnAlias => {\n        return insertRow[columnAlias] !== undefined;\n    })\n        .sort();\n    const values = columnAliases\n        .map(columnAlias => squill.BuiltInExprUtil.buildAst(insertRow[columnAlias]))\n        .reduce((values, ast) => {\n        if (values.length > 0) {\n            values.push(\", \");\n        }\n        values.push(ast);\n        return values;\n    }, []);\n    const ast = values.length == 0 ?\n        [\n            `${insertType} INTO`,\n            /**\n             * We use the `unaliasedAst` because the user may have called `setSchemaName()`\n             */\n            table.unaliasedAst,\n            \"DEFAULT VALUES\",\n        ] :\n        [\n            `${insertType} INTO`,\n            /**\n             * We use the `unaliasedAst` because the user may have called `setSchemaName()`\n             */\n            table.unaliasedAst,\n            \"(\",\n            columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(\", \"),\n            \") VALUES (\",\n            ...values,\n            \")\",\n        ];\n    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n}\nexports.insertOneSqlString = insertOneSqlString;\n//# sourceMappingURL=insert-one-sql-string.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\nconst constants_1 = require(\"../constants\");\nconst schema_introspection_1 = require(\"../schema-introspection\");\nasync function insertSelectSqlString(connection, insertType, query, table, insertSelectRow) {\n    const rawSchemaName = squill.TableUtil.tryGetSchemaName(table);\n    const schemaName = (rawSchemaName == undefined ?\n        constants_1.DEFAULT_SCHEMA_NAME :\n        rawSchemaName);\n    /**\n     * We need to fetch the `tableMeta` because SQLite does not support the\n     * `DEFAULT` keyword.\n     */\n    const tableMeta = await schema_introspection_1.tryFetchTableMeta(connection, schemaName, table.alias);\n    if (tableMeta == undefined) {\n        throw new Error(`Table ${squill.pascalStyleEscapeString(schemaName)}.${squill.pascalStyleEscapeString(table.alias)} does not exist`);\n    }\n    const structure = tableMeta.columns;\n    //console.log(structure);\n    const columnAliases = squill.TableUtil.columnAlias(table)\n        .sort()\n        .filter(columnAlias => {\n        /**\n         * @todo handle GENERATED columns\n         */\n        //Might possibly be a GENERATED column, actually.\n        //For some reason, these don't show up in pragma table_info\n        const columnDef = structure.find(columnDef => {\n            return columnDef.name == columnAlias;\n        });\n        return columnDef != undefined;\n    });\n    const values = columnAliases\n        .map(columnAlias => {\n        const value = insertSelectRow[columnAlias];\n        if (value === undefined) {\n            const columnDef = structure.find(columnDef => {\n                return columnDef.name == columnAlias;\n            });\n            if (columnDef == undefined) {\n                //Might possibly be a GENERATED column, actually.\n                //For some reason, these don't show up in pragma table_info\n                throw new Error(`Unknown column ${table.alias}.${columnAlias}`);\n            }\n            if (columnDef.dflt_value != undefined) {\n                return columnDef.dflt_value;\n            }\n            if (tm.BigIntUtil.equal(columnDef.notnull, tm.BigInt(1))) {\n                if (columnDef.isAutoIncrement) {\n                    return \"NULL\";\n                }\n                throw new Error(`${table.alias}.${columnAlias} is not nullable`);\n            }\n            else {\n                return \"NULL\";\n            }\n        }\n        else {\n            if (squill.ColumnUtil.isColumn(value)) {\n                return squill.escapeIdentifierWithDoubleQuotes(`${value.tableAlias}${squill.SEPARATOR}${value.columnAlias}`);\n            }\n            else {\n                return squill.BuiltInExprUtil.buildAst(value);\n            }\n        }\n    })\n        .reduce((values, ast) => {\n        if (values.length > 0) {\n            values.push(\", \");\n        }\n        values.push(ast);\n        return values;\n    }, []);\n    const ast = [\n        `${insertType} INTO`,\n        /**\n         * We use the `unaliasedAst` because the user may have called `setSchemaName()`\n         */\n        table.unaliasedAst,\n        \"(\",\n        columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(\", \"),\n        \")\",\n        \"SELECT\",\n        ...values,\n        \"FROM\",\n        \"(\",\n        query,\n        \") AS tmp\"\n    ];\n    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n    return sql;\n}\nexports.insertSelectSqlString = insertSelectSqlString;\n//# sourceMappingURL=insert-select-sql-string.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tm = require(\"type-mapping\");\nconst squill = require(\"@squill/squill\");\nconst constants_1 = require(\"../constants\");\n/**\n* We do not use `ABS(-9223372036854775808)` because of,\n* https://github.com/AnyhowStep/tsql/issues/233\n*/\nexports.THROW_AST = \"(SELECT SUM(9223372036854775807) FROM (SELECT NULL UNION ALL SELECT NULL))\";\nconst insertBetween = squill.AstUtil.insertBetween;\nfunction normalizeOrderByAndLimitClauses(query) {\n    /**\n     * MySQL behaviour,\n     * No `UNION` clause.\n     *\n     * | `ORDER BY` | `LIMIT` | `UNION ORDER BY` | `UNION LIMIT` | Result\n     * |------------|---------|------------------|---------------|-------------------------------------------------\n     * | Y          | Y       | Y                | Y             | `ORDER BY ... LIMIT ...) ORDER BY ... LIMIT ...`\n     * | Y          | Y       | Y                | N             | `ORDER BY ... LIMIT ...) ORDER BY ...`\n     * | Y          | Y       | N                | Y             | `ORDER BY ...) LIMIT ...`\n     * | Y          | Y       | N                | N             | `ORDER BY ... LIMIT ...)`\n     * | Y          | N       | Y                | Y             | `) ORDER BY ... LIMIT ...`\n     * | Y          | N       | Y                | N             | `) ORDER BY ...`\n     * | Y          | N       | N                | Y             | `ORDER BY ...) LIMIT ...`\n     * | Y          | N       | N                | N             | `ORDER BY ...)`\n     * |------------|---------|------------------|---------------|-------------------------------------------------\n     * | N          | Y       | Y                | Y             | `LIMIT ...) ORDER BY ... LIMIT ...`\n     * | N          | Y       | Y                | N             | `LIMIT ...) ORDER BY ...`\n     * | N          | Y       | N                | Y             | `) LIMIT ...`\n     * | N          | Y       | N                | N             | `LIMIT ...)`\n     * | N          | N       | Y                | Y             | `) ORDER BY ... LIMIT ...`\n     * | N          | N       | Y                | N             | `) ORDER BY ...`\n     * | N          | N       | N                | Y             | `) LIMIT ...`\n     * | N          | N       | N                | N             | `)`\n     *\n     * Observations:\n     * + With no `LIMIT` clause, the `UNION ORDER BY` and `UNION LIMIT` take over, regardless of `ORDER BY`\n     * + With the `LIMIT` clause, the `UNION ORDER BY` never takes over\n     * + With the `LIMIT` clause, the `UNION LIMIT` takes over when there is no `UNION ORDER BY`\n     *\n     * + `UNION LIMIT` takes over when, !`LIMIT` || !`UNION ORDER BY`\n     * + `UNION ORDER BY` takes over when, !`LIMIT`\n     */\n    /**\n     *\n     * MySQL behaviour,\n     * With `UNION` clause.\n     *\n     * Nothing is taken over.\n     */\n    const orderByClause = ((query.compoundQueryOrderByClause != undefined &&\n        query.compoundQueryClause == undefined &&\n        query.limitClause == undefined) ?\n        query.compoundQueryOrderByClause :\n        query.orderByClause);\n    const limitClause = ((query.compoundQueryLimitClause != undefined &&\n        query.compoundQueryClause == undefined &&\n        (query.limitClause == undefined ||\n            query.compoundQueryOrderByClause == undefined)) ?\n        query.compoundQueryLimitClause :\n        query.limitClause);\n    const compoundQueryOrderByClause = (orderByClause == query.compoundQueryOrderByClause ?\n        undefined :\n        query.compoundQueryOrderByClause);\n    const compoundQueryLimitClause = (limitClause == query.compoundQueryLimitClause ?\n        undefined :\n        query.compoundQueryLimitClause);\n    return {\n        ...query,\n        orderByClause,\n        limitClause,\n        compoundQueryOrderByClause,\n        compoundQueryLimitClause,\n    };\n}\nfunction selectClauseColumnToSql(column, isDerivedTable) {\n    return [\n        [\n            squill.escapeIdentifierWithDoubleQuotes(column.tableAlias),\n            \".\",\n            squill.escapeIdentifierWithDoubleQuotes(column.columnAlias)\n        ].join(\"\"),\n        \"AS\",\n        squill.escapeIdentifierWithDoubleQuotes(isDerivedTable ?\n            column.columnAlias :\n            `${column.tableAlias}${squill.SEPARATOR}${column.columnAlias}`)\n    ];\n}\nfunction selectClauseColumnArrayToSql(columns, isDerivedTable) {\n    columns.sort((a, b) => {\n        const tableAliasCmp = a.tableAlias.localeCompare(b.tableAlias);\n        if (tableAliasCmp != 0) {\n            return tableAliasCmp;\n        }\n        return a.columnAlias.localeCompare(b.columnAlias);\n    });\n    const result = [];\n    for (const column of columns) {\n        if (result.length > 0) {\n            result.push(\",\");\n        }\n        result.push(...selectClauseColumnToSql(column, isDerivedTable));\n    }\n    return result;\n}\nfunction selectClauseColumnMapToSql(map, isDerivedTable) {\n    const columns = squill.ColumnUtil.fromColumnMap(map);\n    return selectClauseColumnArrayToSql(columns, isDerivedTable);\n}\nfunction selectClauseColumnRefToSql(ref, isDerivedTable) {\n    const columns = squill.ColumnUtil.fromColumnRef(ref);\n    return selectClauseColumnArrayToSql(columns, isDerivedTable);\n}\nfunction selectClauseToSql(selectClause, toSql, isDerivedTable, isDistinct) {\n    const result = [];\n    for (const selectItem of selectClause) {\n        if (result.length > 0) {\n            result.push(\",\");\n        }\n        if (squill.ColumnUtil.isColumn(selectItem)) {\n            result.push(...selectClauseColumnToSql(selectItem, isDerivedTable));\n        }\n        else if (squill.ExprSelectItemUtil.isExprSelectItem(selectItem)) {\n            result.push(toSql(selectItem.unaliasedAst), \"AS\", squill.escapeIdentifierWithDoubleQuotes(isDerivedTable ?\n                selectItem.alias :\n                `${selectItem.tableAlias}${squill.SEPARATOR}${selectItem.alias}`));\n        }\n        else if (squill.ColumnMapUtil.isColumnMap(selectItem)) {\n            result.push(...selectClauseColumnMapToSql(selectItem, isDerivedTable));\n        }\n        else if (squill.ColumnRefUtil.isColumnRef(selectItem)) {\n            result.push(...selectClauseColumnRefToSql(selectItem, isDerivedTable));\n        }\n        else {\n            throw new Error(`Not implemented`);\n        }\n    }\n    return isDistinct ?\n        [\"SELECT DISTINCT\", ...result] :\n        [\"SELECT\", ...result];\n}\nfunction fromClauseToSql(currentJoins, toSql) {\n    const result = [];\n    for (const join of currentJoins) {\n        if (join.joinType == squill.JoinType.FROM) {\n            result.push(\"FROM\");\n        }\n        else {\n            result.push(join.joinType, \"JOIN\");\n        }\n        if (squill.isIdentifierNode(join.tableAst)) {\n            const lastIdentifier = join.tableAst.identifiers[join.tableAst.identifiers.length - 1];\n            if (lastIdentifier == join.tableAlias) {\n                result.push(toSql(join.tableAst));\n            }\n            else {\n                result.push(toSql(join.tableAst), \"AS\", squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));\n            }\n        }\n        else if (squill.QueryBaseUtil.isQuery(join.tableAst)) {\n            result.push(\"(\", queryToSql(join.tableAst, toSql, true), \")\");\n            result.push(\"AS\");\n            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));\n        }\n        else if (squill.Parentheses.IsParentheses(join.tableAst) && squill.QueryBaseUtil.isQuery(join.tableAst.ast)) {\n            const subQuery = join.tableAst.ast;\n            result.push(\"(\", queryToSql(subQuery, toSql, true), \")\");\n            result.push(\"AS\");\n            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));\n        }\n        else {\n            result.push(\"(\", toSql(join.tableAst), \")\");\n            result.push(\"AS\");\n            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));\n        }\n        if (join.onClause != undefined) {\n            result.push(\"ON\");\n            result.push(toSql(squill.AstUtil.tryUnwrapParentheses(join.onClause.ast)));\n        }\n    }\n    return result;\n}\nfunction whereClauseToSql(whereClause, toSql) {\n    return [\n        \"WHERE\",\n        toSql(squill.AstUtil.tryUnwrapParentheses(whereClause.ast))\n    ];\n}\nfunction orderByClauseToSql(orderByClause, toSql) {\n    if (orderByClause.length == 0) {\n        return [];\n    }\n    const result = [];\n    for (const [sortExpr, sortDirection] of orderByClause) {\n        if (result.length > 0) {\n            result.push(\",\");\n        }\n        if (squill.ColumnUtil.isColumn(sortExpr)) {\n            if (sortExpr.unaliasedAst == undefined) {\n                result.push([\n                    squill.escapeIdentifierWithDoubleQuotes(sortExpr.tableAlias),\n                    \".\",\n                    squill.escapeIdentifierWithDoubleQuotes(sortExpr.columnAlias)\n                ].join(\"\"));\n            }\n            else {\n                result.push(squill.escapeIdentifierWithDoubleQuotes(`${sortExpr.tableAlias}${squill.SEPARATOR}${sortExpr.columnAlias}`));\n            }\n        }\n        else if (squill.ExprUtil.isExpr(sortExpr)) {\n            if (squill.LiteralValueNodeUtil.isLiteralValueNode(sortExpr.ast)) {\n                if (sortExpr.ast.literalValueType == squill.LiteralValueType.BIGINT_SIGNED) {\n                    result.push(toSql([sortExpr.ast, \"+ 0\"]));\n                }\n                else {\n                    result.push(toSql(sortExpr.ast));\n                }\n            }\n            else {\n                result.push(toSql(sortExpr.ast));\n            }\n        }\n        else {\n            result.push(toSql(sortExpr.unaliasedAst));\n        }\n        result.push(sortDirection);\n    }\n    return [\n        \"ORDER BY\",\n        ...result\n    ];\n}\nfunction groupByClauseToSql(groupByClause, _toSql) {\n    if (groupByClause.length == 0) {\n        return [];\n    }\n    const result = [];\n    for (const column of groupByClause) {\n        if (result.length > 0) {\n            result.push(\",\");\n        }\n        if (column.tableAlias == squill.ALIASED) {\n            result.push(squill.escapeIdentifierWithDoubleQuotes(`${column.tableAlias}${squill.SEPARATOR}${column.columnAlias}`));\n        }\n        else {\n            result.push([\n                squill.escapeIdentifierWithDoubleQuotes(column.tableAlias),\n                \".\",\n                squill.escapeIdentifierWithDoubleQuotes(column.columnAlias)\n            ].join(\"\"));\n        }\n    }\n    return [\n        \"GROUP BY\",\n        ...result\n    ];\n}\nfunction havingClauseToSql(havingClause, toSql) {\n    return [\n        \"HAVING\",\n        toSql(squill.AstUtil.tryUnwrapParentheses(havingClause.ast))\n    ];\n}\nfunction limitClauseToSql(limitClause, _toSql) {\n    return [\n        \"LIMIT\",\n        squill.escapeValue(limitClause.maxRowCount),\n        \"OFFSET\",\n        squill.escapeValue(limitClause.offset),\n    ];\n}\nfunction compoundQueryClauseToSql(compoundQueryClause, toSql) {\n    const result = [];\n    for (const rawCompoundQuery of compoundQueryClause) {\n        result.push(rawCompoundQuery.compoundQueryType);\n        if (!rawCompoundQuery.isDistinct) {\n            result.push(\"ALL\");\n        }\n        const query = rawCompoundQuery.query;\n        if (query.orderByClause != undefined ||\n            query.limitClause != undefined ||\n            query.compoundQueryClause != undefined ||\n            query.compoundQueryOrderByClause != undefined ||\n            query.compoundQueryLimitClause != undefined) {\n            result.push(\"SELECT * FROM (\", toSql(query), \")\");\n        }\n        else {\n            result.push(toSql(query));\n        }\n    }\n    return result;\n}\nfunction queryToSql(rawQuery, toSql, isDerivedTable) {\n    const query = normalizeOrderByAndLimitClauses(rawQuery);\n    if ((\n    /**\n     * If we have both a compound `ORDER BY/LIMIT` clause\n     * and regular `ORDER BY/LIMIT` clause,\n     * we will need a derived table because\n     * SQLite only supports on `ORDER BY` and `LIMIT` clause for the entire query.\n     */\n    (query.compoundQueryOrderByClause != undefined ||\n        query.compoundQueryLimitClause != undefined) &&\n        (query.orderByClause != undefined ||\n            query.limitClause != undefined)) ||\n        /**\n         * If we have a compound query and an `ORDER BY` or `LIMIT` clause,\n         * we will need to make the query a derived table because\n         * SQLite only supports on `ORDER BY` and `LIMIT` clause for the entire query.\n         */\n        (query.compoundQueryClause != undefined &&\n            (query.orderByClause != undefined ||\n                query.limitClause != undefined))) {\n        /**\n         * We have to apply some hackery to get the same behaviour as MySQL.\n         */\n        const innerQuery = {\n            ...query,\n            compoundQueryClause: undefined,\n            compoundQueryOrderByClause: undefined,\n            compoundQueryLimitClause: undefined,\n        };\n        const result = [\n            \"SELECT * FROM (\",\n            toSql(innerQuery),\n            \")\"\n        ];\n        if (query.compoundQueryClause != undefined) {\n            result.push(compoundQueryClauseToSql(query.compoundQueryClause, toSql).join(\" \"));\n        }\n        if (query.compoundQueryOrderByClause != undefined) {\n            result.push(orderByClauseToSql(query.compoundQueryOrderByClause, toSql).join(\" \"));\n        }\n        if (query.compoundQueryLimitClause != undefined) {\n            result.push(limitClauseToSql(query.compoundQueryLimitClause, toSql).join(\" \"));\n        }\n        return result.join(\" \");\n    }\n    const result = [];\n    if (query.selectClause != undefined) {\n        result.push(selectClauseToSql(query.selectClause, toSql, isDerivedTable, query.isDistinct).join(\" \"));\n    }\n    if (query.fromClause != undefined && query.fromClause.currentJoins != undefined) {\n        result.push(fromClauseToSql(query.fromClause.currentJoins, toSql).join(\" \"));\n    }\n    if (query.limitClause != undefined && tm.BigIntUtil.equal(query.limitClause.maxRowCount, 0)) {\n        /**\n         * ```sql\n         *  CREATE TABLE \"myTable\" (\"myColumn\" INT PRIMARY KEY);\n         *  INSERT INTO \"myTable\"(\"myColumn\") VALUES (4);\n         *  SELECT\n         *      COALESCE(\n         *          (\n         *              SELECT\n         *                  \"myTable\".\"myColumn\" AS \"myTable--myColumn\"\n         *              FROM\n         *                  \"myTable\"\n         *              LIMIT\n         *                  0\n         *              OFFSET\n         *                  0\n         *          ),\n         *          3\n         *      );\n         * ```\n         * The above gives `4` on SQLite.\n         * Gives `3` on MySQL and PostgreSQL.\n         * SQLite is bugged.\n         *\n         * The fix is to use `WHERE FALSE` when `LIMIT 0` is detected.\n         *\n         * ```sql\n         *  CREATE TABLE \"myTable\" (\"myColumn\" INT PRIMARY KEY);\n         *  INSERT INTO \"myTable\"(\"myColumn\") VALUES (4);\n         *  SELECT\n         *      COALESCE(\n         *          (\n         *              SELECT\n         *                  \"myTable\".\"myColumn\" AS \"myTable--myColumn\"\n         *              FROM\n         *                  \"myTable\"\n         *              WHERE\n         *                  FALSE\n         *              LIMIT\n         *                  0\n         *              OFFSET\n         *                  0\n         *          ),\n         *          3\n         *      );\n         * ```\n         */\n        result.push(\"WHERE FALSE\");\n    }\n    else {\n        if (query.whereClause != undefined) {\n            result.push(whereClauseToSql(query.whereClause, toSql).join(\" \"));\n        }\n    }\n    if (query.groupByClause == undefined || query.groupByClause.length == 0) {\n        if (query.havingClause != undefined) {\n            /**\n             * Workaround for `<empty grouping set>` not supported by SQLite\n             */\n            throw new Error(`SQLite does not support ... GROUP BY () HAVING ...`);\n            //result.push(havingClauseToSql(query.havingClause, toSql).join(\" \"));\n        }\n    }\n    else {\n        result.push(groupByClauseToSql(query.groupByClause, toSql).join(\" \"));\n        if (query.havingClause != undefined) {\n            result.push(havingClauseToSql(query.havingClause, toSql).join(\" \"));\n        }\n    }\n    if (query.orderByClause != undefined) {\n        result.push(orderByClauseToSql(query.orderByClause, toSql).join(\" \"));\n    }\n    if (query.limitClause != undefined) {\n        result.push(limitClauseToSql(query.limitClause, toSql).join(\" \"));\n    }\n    if (query.compoundQueryClause != undefined) {\n        result.push(compoundQueryClauseToSql(query.compoundQueryClause, toSql).join(\" \"));\n    }\n    if (query.compoundQueryOrderByClause != undefined) {\n        result.push(orderByClauseToSql(query.compoundQueryOrderByClause, toSql).join(\" \"));\n    }\n    if (query.compoundQueryLimitClause != undefined) {\n        result.push(limitClauseToSql(query.compoundQueryLimitClause, toSql).join(\" \"));\n    }\n    return result.join(\" \");\n}\nexports.sqlfier = {\n    identifierSqlfier: (identifierNode) => identifierNode.identifiers\n        .map(squill.escapeIdentifierWithDoubleQuotes)\n        .join(\".\"),\n    literalValueSqlfier: {\n        [squill.LiteralValueType.DECIMAL]: ({ literalValue, precision, scale }) => squill.functionCall(\"decimal_ctor\", [\n            squill.pascalStyleEscapeString(literalValue),\n            squill.escapeValue(precision),\n            squill.escapeValue(scale)\n        ]) /*toSql(\n            castAsDecimal(\n                literalValue,\n                precision,\n                scale\n            ).ast\n        )*/,\n        [squill.LiteralValueType.STRING]: ({ literalValue }) => {\n            if (literalValue.includes('\\0')) {\n                throw new Error(`String literal may not contain null characters`);\n            }\n            return squill.pascalStyleEscapeString(literalValue);\n        },\n        [squill.LiteralValueType.DOUBLE]: ({ literalValue }) => {\n            if (isNaN(literalValue)) {\n                throw new squill.DataOutOfRangeError({\n                    message: `Literal ${literalValue} not allowed`,\n                    /**\n                     * @todo Figure out how to get the entire SQL, then throw?\n                     */\n                    sql: undefined,\n                });\n            }\n            if (literalValue == Infinity) {\n                return \"(1e999)\";\n            }\n            if (literalValue == -Infinity) {\n                return \"(-1e999)\";\n            }\n            return squill.escapeValue(literalValue);\n        },\n        [squill.LiteralValueType.BIGINT_SIGNED]: ({ literalValue }) => squill.escapeValue(literalValue),\n        /**\n         * @deprecated\n         */\n        //[LiteralValueType.BIGINT_UNSIGNED] : ({literalValue}) => escapeValue(literalValue),\n        [squill.LiteralValueType.BOOLEAN]: ({ literalValue }) => squill.escapeValue(literalValue),\n        [squill.LiteralValueType.BUFFER]: ({ literalValue }) => squill.escapeValue(literalValue),\n        [squill.LiteralValueType.NULL]: ({ literalValue }) => squill.escapeValue(literalValue),\n        [squill.LiteralValueType.DATE_TIME]: ({ literalValue }, toSql) => toSql(squill.utcStringToTimestamp(squill.DateTimeUtil.toSqlUtc(literalValue, 3)).ast),\n    },\n    operatorSqlfier: {\n        /*\n            Comparison Functions and Operators\n            https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html\n        */\n        [squill.OperatorType.BETWEEN_AND]: ({ operands }) => [\n            operands[0],\n            \"BETWEEN\",\n            operands[1],\n            \"AND\",\n            operands[2]\n        ],\n        [squill.OperatorType.NOT_BETWEEN_AND]: ({ operands }) => [\n            operands[0],\n            \"NOT BETWEEN\",\n            operands[1],\n            \"AND\",\n            operands[2]\n        ],\n        [squill.OperatorType.COALESCE]: ({ operatorType, operands }) => squill.functionCall(operatorType, operands),\n        [squill.OperatorType.EQUAL]: ({ operands }) => insertBetween(operands, \"=\"),\n        [squill.OperatorType.NULL_SAFE_EQUAL]: ({ operands }) => insertBetween(operands, \"IS\"),\n        [squill.OperatorType.NOT_NULL_SAFE_EQUAL]: ({ operands }) => insertBetween(operands, \"IS NOT\"),\n        [squill.OperatorType.LESS_THAN]: ({ operands }) => insertBetween(operands, \"<\"),\n        [squill.OperatorType.GREATER_THAN]: ({ operands }) => insertBetween(operands, \">\"),\n        [squill.OperatorType.LESS_THAN_OR_EQUAL]: ({ operands }) => insertBetween(operands, \"<=\"),\n        [squill.OperatorType.GREATER_THAN_OR_EQUAL]: ({ operands }) => insertBetween(operands, \">=\"),\n        [squill.OperatorType.IN_ARRAY]: ({ operands: [x, ...rest] }) => {\n            return [\n                x,\n                squill.functionCall(\"IN\", [...rest])\n            ];\n        },\n        [squill.OperatorType.IN_QUERY]: ({ operands: [x, y] }) => {\n            /**\n             * https://github.com/AnyhowStep/tsql/issues/198\n             */\n            return [\n                x,\n                squill.functionCall(\"IN\", [\n                    squill.Parentheses.IsParentheses(y) ?\n                        y.ast :\n                        y\n                ])\n            ];\n        },\n        [squill.OperatorType.NOT_IN_ARRAY]: ({ operands: [x, ...rest] }) => {\n            return [\n                x,\n                squill.functionCall(\"NOT IN\", [...rest])\n            ];\n        },\n        [squill.OperatorType.NOT_IN_QUERY]: ({ operands: [x, y] }) => {\n            /**\n             * https://github.com/AnyhowStep/tsql/issues/198\n             */\n            return [\n                x,\n                squill.functionCall(\"NOT IN\", [\n                    squill.Parentheses.IsParentheses(y) ?\n                        y.ast :\n                        y\n                ])\n            ];\n        },\n        [squill.OperatorType.IS_NOT_NULL]: ({ operands }) => [operands[0], \"IS NOT NULL\"],\n        [squill.OperatorType.IS_NULL]: ({ operands }) => [operands[0], \"IS NULL\"],\n        [squill.OperatorType.IS_UNKNOWN]: ({ operands }) => [operands[0], \"IS NULL\"],\n        [squill.OperatorType.IS_NOT_UNKNOWN]: ({ operands }) => [operands[0], \"IS NOT NULL\"],\n        [squill.OperatorType.IS_TRUE]: ({ operands }) => [operands[0], \"IS TRUE\"],\n        [squill.OperatorType.IS_NOT_TRUE]: ({ operands }) => [operands[0], \"IS NOT TRUE\"],\n        [squill.OperatorType.IS_FALSE]: ({ operands }) => [operands[0], \"IS FALSE\"],\n        [squill.OperatorType.IS_NOT_FALSE]: ({ operands }) => [operands[0], \"IS NOT FALSE\"],\n        [squill.OperatorType.LIKE_ESCAPE]: ({ operands: [expr, pattern, escapeChar] }) => {\n            if (squill.LiteralValueNodeUtil.isLiteralValueNode(escapeChar) && escapeChar.literalValue === \"\") {\n                return [\n                    expr, \"LIKE\", pattern\n                ];\n            }\n            else {\n                return [\n                    expr, \"LIKE\", pattern, \"ESCAPE\", escapeChar\n                ];\n            }\n        },\n        [squill.OperatorType.NOT_LIKE_ESCAPE]: ({ operands: [expr, pattern, escapeChar] }) => {\n            if (squill.LiteralValueNodeUtil.isLiteralValueNode(escapeChar) && escapeChar.literalValue === \"\") {\n                return [\n                    expr, \"NOT LIKE\", pattern\n                ];\n            }\n            else {\n                return [\n                    expr, \"NOT LIKE\", pattern, \"ESCAPE\", escapeChar\n                ];\n            }\n        },\n        [squill.OperatorType.NOT_EQUAL]: ({ operands }) => insertBetween(operands, \"<>\"),\n        [squill.OperatorType.LEAST]: ({ operands }) => squill.functionCall(\"MIN\", operands),\n        [squill.OperatorType.GREATEST]: ({ operands }) => squill.functionCall(\"MAX\", operands),\n        /*\n            Logical Operators\n            https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html\n        */\n        [squill.OperatorType.AND]: ({ operands }) => insertBetween(operands, \"AND\"),\n        [squill.OperatorType.OR]: ({ operands }) => insertBetween(operands, \"OR\"),\n        [squill.OperatorType.NOT]: ({ operands }) => [\n            \"NOT\",\n            operands[0]\n        ],\n        [squill.OperatorType.XOR]: ({ operands }) => insertBetween(operands, \"<>\"),\n        /*\n            Control Flow Functions\n            https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html\n        */\n        [squill.OperatorType.IF]: ({ operands: [a, b, c] }) => [\n            \"CASE WHEN\",\n            a,\n            \"THEN\",\n            b,\n            \"ELSE\",\n            c,\n            \"END\"\n        ],\n        [squill.OperatorType.IF_NULL]: ({ operands }) => squill.functionCall(\"IFNULL\", operands),\n        [squill.OperatorType.NULL_IF_EQUAL]: ({ operands }) => squill.functionCall(\"NULLIF\", operands),\n        /*\n            String Functions and Operators\n            https://dev.mysql.com/doc/refman/8.0/en/string-functions.html\n        */\n        [squill.OperatorType.ASCII]: ({ operands }) => squill.functionCall(\"ASCII\", operands),\n        [squill.OperatorType.BIN]: ({ operands }) => squill.functionCall(\"BIN\", operands),\n        [squill.OperatorType.BIT_LENGTH]: ({ operands }) => ([\n            squill.functionCall(\"LENGTH\", [\n                squill.functionCall(\"CAST\", [[operands, \"AS BLOB\"]])\n            ]),\n            \"* 8\"\n        ]),\n        [squill.OperatorType.CHAR_LENGTH]: ({ operands }) => squill.functionCall(\"LENGTH\", operands),\n        [squill.OperatorType.OCTET_LENGTH]: ({ operands }) => squill.functionCall(\"LENGTH\", [\n            squill.functionCall(\"CAST\", [[operands, \"AS BLOB\"]])\n        ]),\n        [squill.OperatorType.CONCAT]: ({ operands }) => insertBetween(operands, \"||\"),\n        [squill.OperatorType.NULL_SAFE_CONCAT]: ({ operands }) => (insertBetween(operands.map(operand => squill.functionCall(\"COALESCE\", [operand, \"''\"])), \"||\")),\n        [squill.OperatorType.CONCAT_WS]: ({ operands }) => squill.functionCall(\"CONCAT_WS\", operands),\n        [squill.OperatorType.FROM_BASE64]: ({ operands }) => squill.functionCall(\"FROM_BASE64\", operands),\n        [squill.OperatorType.HEX]: ({ operands }) => squill.functionCall(\"HEX\", operands),\n        [squill.OperatorType.IN_STR]: ({ operands }) => squill.functionCall(\"INSTR\", operands),\n        [squill.OperatorType.LPAD]: ({ operands }) => squill.functionCall(\"LPAD\", operands),\n        [squill.OperatorType.RPAD]: ({ operands }) => squill.functionCall(\"RPAD\", operands),\n        [squill.OperatorType.LTRIM]: ({ operands }) => squill.functionCall(\"LTRIM\", operands),\n        [squill.OperatorType.RTRIM]: ({ operands }) => squill.functionCall(\"RTRIM\", operands),\n        [squill.OperatorType.TRIM]: ({ operands }) => squill.functionCall(\"TRIM\", operands),\n        [squill.OperatorType.POSITION]: ({ operands }) => squill.functionCall(\"INSTR\", [operands[1], operands[0]]),\n        [squill.OperatorType.REPEAT]: ({ operands }) => squill.functionCall(\"REPEAT\", operands),\n        [squill.OperatorType.REPLACE]: ({ operands }) => squill.functionCall(\"REPLACE\", operands),\n        [squill.OperatorType.REVERSE]: ({ operands }) => squill.functionCall(\"REVERSE\", operands),\n        [squill.OperatorType.TO_BASE64]: ({ operands }) => squill.functionCall(\"TO_BASE64\", operands),\n        [squill.OperatorType.UNHEX]: ({ operands }) => squill.functionCall(\"UNHEX\", operands),\n        [squill.OperatorType.UPPER]: ({ operands }) => squill.functionCall(\"UPPER\", operands),\n        [squill.OperatorType.LOWER]: ({ operands }) => squill.functionCall(\"LOWER\", operands),\n        /*\n            Arithmetic Operators\n            https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html\n        */\n        [squill.OperatorType.FRACTIONAL_DIVISION]: ({ operands }) => insertBetween(operands, \"/\"),\n        [squill.OperatorType.INTEGER_DIVISION]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.DOUBLE) {\n                return squill.functionCall(\"CAST\", [\n                    [\n                        insertBetween(operands, \"/\"),\n                        \"AS BIGINT\"\n                    ]\n                ]);\n            }\n            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"bigint_div\", operands);\n            }\n            else {\n                throw new Error(`INTEGER_DIVISION not implemented for ${typeHint}`);\n            }\n        },\n        /**\n         * In SQLite, `%` ONLY does integer remainder\n         */\n        [squill.OperatorType.INTEGER_REMAINDER]: ({ operands, typeHint }, toSql) => {\n            if (typeHint == squill.TypeHint.DOUBLE) {\n                return squill.functionCall(\"CAST\", [\n                    toSql(insertBetween(operands.map(op => squill.functionCall(\"CAST\", [\n                        toSql(op) + \" AS INTEGER\"\n                    ])), \"%\")) + \" AS DOUBLE\"\n                ]);\n            }\n            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return insertBetween(operands, \"%\");\n            }\n            else {\n                throw new Error(`INTEGER_REMAINDER not implemented for ${typeHint}`);\n            }\n        },\n        [squill.OperatorType.FRACTIONAL_REMAINDER]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.DOUBLE) {\n                function naiveFractionalRemainder(dividend, divisor) {\n                    const absDivisor = squill.functionCall(\"ABS\", [divisor]);\n                    return squill.parentheses([\n                        dividend,\n                        \"-\",\n                        squill.functionCall(\"FLOOR\", [\n                            [\n                                dividend,\n                                \"/\",\n                                absDivisor\n                            ]\n                        ]),\n                        \"*\",\n                        absDivisor\n                    ], false);\n                }\n                const dividend = operands[0];\n                const divisor = operands[1];\n                return [\n                    \"CASE\",\n                    \"WHEN\", dividend, \"= 1e999 THEN NULL\",\n                    \"WHEN\", dividend, \"= -1e999 THEN NULL\",\n                    \"WHEN\", divisor, \"= 1e999 THEN\",\n                    dividend,\n                    \"WHEN\", divisor, \"= -1e999 THEN\",\n                    dividend,\n                    \"WHEN\", dividend, \">= 0 THEN\", naiveFractionalRemainder(dividend, divisor),\n                    \"ELSE\",\n                    \"-\", naiveFractionalRemainder(squill.parentheses([\"-\", dividend], false), divisor),\n                    \"END\"\n                ];\n            }\n            else {\n                throw new Error(`FRACTIONAL_REMAINDER not implemented for ${typeHint}`);\n            }\n        },\n        [squill.OperatorType.ADDITION]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"bigint_add\", operands);\n            }\n            else {\n                return squill.functionCall(\"COALESCE\", [\n                    insertBetween(operands, \"+\"),\n                    exports.THROW_AST\n                ]);\n            }\n        },\n        [squill.OperatorType.SUBTRACTION]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"bigint_sub\", operands);\n            }\n            else {\n                return squill.functionCall(\"COALESCE\", [\n                    insertBetween(operands, \"-\"),\n                    exports.THROW_AST\n                ]);\n            }\n        },\n        [squill.OperatorType.MULTIPLICATION]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"bigint_mul\", operands);\n            }\n            else {\n                return squill.functionCall(\"COALESCE\", [\n                    insertBetween(operands, \"*\"),\n                    exports.THROW_AST\n                ]);\n            }\n        },\n        [squill.OperatorType.UNARY_MINUS]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"bigint_neg\", operands);\n            }\n            else {\n                return [\"-\", operands[0]];\n            }\n        },\n        /*\n            Mathematical Functions\n            https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html\n        */\n        [squill.OperatorType.ABSOLUTE_VALUE]: ({ operands }) => squill.functionCall(\"ABS\", operands),\n        [squill.OperatorType.ARC_COSINE]: ({ operands }) => squill.functionCall(\"ACOS\", operands),\n        [squill.OperatorType.ARC_SINE]: ({ operands }) => squill.functionCall(\"ASIN\", operands),\n        [squill.OperatorType.ARC_TANGENT]: ({ operands }) => squill.functionCall(\"ATAN\", operands),\n        [squill.OperatorType.ARC_TANGENT_2]: ({ operands }) => squill.functionCall(\"ATAN2\", operands),\n        [squill.OperatorType.CUBE_ROOT]: ({ operands }) => squill.functionCall(\"CBRT\", operands),\n        [squill.OperatorType.CEILING]: ({ operands }) => squill.functionCall(\"CEILING\", operands),\n        [squill.OperatorType.COSINE]: ({ operands }) => squill.functionCall(\"COS\", operands),\n        [squill.OperatorType.COTANGENT]: ({ operands }) => squill.functionCall(\"COT\", operands),\n        [squill.OperatorType.DEGREES]: ({ operands }) => [operands[0], \"* (180.0/3.141592653589793)\"],\n        [squill.OperatorType.NATURAL_EXPONENTIATION]: ({ operands }) => squill.functionCall(\"EXP\", operands),\n        [squill.OperatorType.FLOOR]: ({ operands }) => squill.functionCall(\"FLOOR\", operands),\n        [squill.OperatorType.LN]: ({ operands }) => squill.functionCall(\"LN\", operands),\n        [squill.OperatorType.LOG]: ({ operands }) => squill.functionCall(\"LOG\", operands),\n        [squill.OperatorType.LOG2]: ({ operands }) => squill.functionCall(\"LOG2\", operands),\n        [squill.OperatorType.LOG10]: ({ operands }) => squill.functionCall(\"LOG10\", operands),\n        [squill.OperatorType.PI]: () => squill.functionCall(\"PI\", []),\n        [squill.OperatorType.POWER]: ({ operands }) => squill.functionCall(\"POWER\", operands),\n        [squill.OperatorType.RADIANS]: ({ operands }) => [operands[0], \"* (3.141592653589793/180.0)\"],\n        [squill.OperatorType.RANDOM]: ({ operands, typeHint }) => {\n            if (typeHint == squill.TypeHint.DOUBLE) {\n                return squill.functionCall(\"FRANDOM\", operands);\n            }\n            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {\n                return squill.functionCall(\"RANDOM\", operands);\n            }\n            else {\n                throw new Error(`RANDOM not implemented for ${typeHint}`);\n            }\n        },\n        //[squill.OperatorType.ROUND] : ({operands}) => squill.functionCall(\"ROUND\", operands),\n        [squill.OperatorType.SIGN]: ({ operands }) => squill.functionCall(\"SIGN\", operands),\n        [squill.OperatorType.SINE]: ({ operands }) => squill.functionCall(\"SIN\", operands),\n        [squill.OperatorType.SQUARE_ROOT]: ({ operands }) => squill.functionCall(\"SQRT\", operands),\n        [squill.OperatorType.TANGENT]: ({ operands }) => squill.functionCall(\"TAN\", operands),\n        //[squill.OperatorType.TRUNCATE] : ({operands}) => squill.functionCall(\"TRUNCATE\", operands),\n        /*\n            Date and Time Functions\n            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html\n        */\n        [squill.OperatorType.CURRENT_DATE]: () => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d\"),\n            squill.pascalStyleEscapeString(\"now\")\n        ]),\n        [squill.OperatorType.CURRENT_TIMESTAMP_0]: () => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%S\"),\n            squill.pascalStyleEscapeString(\"now\")\n        ]),\n        [squill.OperatorType.CURRENT_TIMESTAMP_1]: () => squill.functionCall(\"substr\", [\n            squill.functionCall(\"strftime\", [\n                squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n                squill.pascalStyleEscapeString(\"now\")\n            ]),\n            \"1\",\n            \"21\"\n        ]),\n        [squill.OperatorType.CURRENT_TIMESTAMP_2]: () => squill.functionCall(\"substr\", [\n            squill.functionCall(\"strftime\", [\n                squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n                squill.pascalStyleEscapeString(\"now\")\n            ]),\n            \"1\",\n            \"22\"\n        ]),\n        [squill.OperatorType.CURRENT_TIMESTAMP_3]: () => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            squill.pascalStyleEscapeString(\"now\")\n        ]),\n        [squill.OperatorType.EXTRACT_YEAR]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%Y\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_MONTH]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%m\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_DAY]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%d\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_HOUR]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%H\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_MINUTE]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%M\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_INTEGER_SECOND]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%S\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.EXTRACT_FRACTIONAL_SECOND_3]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%f\"),\n                    operands[0]\n                ]),\n                \"AS DOUBLE\"\n            ]\n        ]),\n        [squill.OperatorType.LAST_DAY]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d\"),\n            operands[0],\n            squill.pascalStyleEscapeString(\"+1 month\"),\n            [\n                squill.pascalStyleEscapeString(\"-\"),\n                \"||\",\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%d\"),\n                    operands[0]\n                ]),\n                \"||\",\n                squill.pascalStyleEscapeString(\" day\")\n            ]\n        ]),\n        [squill.OperatorType.TIMESTAMPADD_YEAR]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            [\n                operands[0],\n                \"||\",\n                squill.pascalStyleEscapeString(\" year\")\n            ]\n        ]),\n        /**\n         * @todo Just use a polyfill, rather than trying to emulate with SQLite built-ins.\n         * Seriously. But, for now, this actually works, which surprises me.\n         */\n        [squill.OperatorType.TIMESTAMPADD_MONTH]: ({ operands }, toSql, sqlfier) => {\n            /*\n                The following gives SQLite's and JS' understanding of what\n                \"adding months\" means. However, it is different from what\n                MySQL understands as \"adding months\".\n\n                Since the function is named for MySQL's `TIMESTAMPADD()`,\n                we follow MySQL's convention, and emultate MySQL's behaviour.\n\n                squill.functionCall(\n                    \"strftime\",\n                    [\n                        squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n                        operands[1],\n                        [\n                            operands[0],\n                            \"||\",\n                            squill.pascalStyleEscapeString(\" month\")\n                        ]\n                    ]\n                )\n            */\n            const rawDeltaMonth = operands[0];\n            const dateTime = operands[1];\n            const curYear = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_YEAR](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_YEAR, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);\n            const curMonth = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_MONTH](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_MONTH, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);\n            const curDay = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_DAY](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_DAY, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);\n            const curTimeComponent = squill.functionCall(\"strftime\", [\n                squill.pascalStyleEscapeString(\" %H:%M:%f\"),\n                dateTime\n            ]);\n            function lastDay(year, month) {\n                return squill.parentheses([\n                    \"CASE\",\n                    \"WHEN\", month, \"= 2 THEN (CASE WHEN\", year, \"%4 = 0 THEN 29 ELSE 28 END)\",\n                    \"WHEN\", month, \"IN(1,3,5,7,8,10,12) THEN 31\",\n                    \"ELSE 30\",\n                    \"END\"\n                ], false);\n            }\n            function setYearMonth(resultYear, resultMonth) {\n                const lastDayOfResult = lastDay(resultYear, resultMonth);\n                const lastDayOfAdd = squill.parentheses([\"CASE WHEN\", curDay, \">\", lastDayOfResult, \"THEN\", lastDayOfResult, \"ELSE\", curDay, \"END\"], false);\n                /**\n                 * @todo Instead of `LPAD()`, use this?\n                 * https://stackoverflow.com/a/9603175\n                 */\n                return [\n                    squill.functionCall(\"LPAD\", [squill.functionCall(\"CAST\", [[resultYear, \"AS TEXT\"]]), \"4\", \"'0'\"]),\n                    \"|| '-' ||\",\n                    squill.functionCall(\"LPAD\", [squill.functionCall(\"CAST\", [[resultMonth, \"AS TEXT\"]]), \"2\", \"'0'\"]),\n                    \"|| '-' ||\",\n                    squill.functionCall(\"LPAD\", [squill.functionCall(\"CAST\", [[lastDayOfAdd, \"AS TEXT\"]]), \"2\", \"'0'\"]),\n                    \"||\",\n                    curTimeComponent\n                ];\n            }\n            const monthsSince_0000_01 = squill.parentheses([curYear, \"* 12 + (\", curMonth, \"-1) +\", rawDeltaMonth], false);\n            const resultYear = squill.functionCall(\"FLOOR\", [[monthsSince_0000_01, \"/12\"]]);\n            const resultMonth = squill.parentheses([monthsSince_0000_01, \"%12 + 1\"], false);\n            return [\n                \"CASE\",\n                \"WHEN\", monthsSince_0000_01, \"BETWEEN 0 AND 119999 THEN\", setYearMonth(resultYear, resultMonth),\n                \"ELSE NULL\",\n                \"END\"\n            ];\n        },\n        [squill.OperatorType.TIMESTAMPADD_DAY]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            insertBetween([\n                operands[0],\n                squill.pascalStyleEscapeString(\" day\")\n            ], \"||\")\n        ]),\n        [squill.OperatorType.TIMESTAMPADD_HOUR]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            insertBetween([\n                operands[0],\n                squill.pascalStyleEscapeString(\" hour\")\n            ], \"||\")\n        ]),\n        [squill.OperatorType.TIMESTAMPADD_MINUTE]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            insertBetween([\n                operands[0],\n                squill.pascalStyleEscapeString(\" minute\")\n            ], \"||\")\n        ]),\n        [squill.OperatorType.TIMESTAMPADD_SECOND]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            insertBetween([\n                operands[0],\n                squill.pascalStyleEscapeString(\" second\")\n            ], \"||\")\n        ]),\n        [squill.OperatorType.TIMESTAMPADD_MILLISECOND]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[1],\n            insertBetween([\n                squill.parentheses(insertBetween([\n                    operands[0],\n                    \"1000e0\"\n                ], \"/\"), \n                //canUnwrap\n                false),\n                squill.pascalStyleEscapeString(\" second\")\n            ], \"||\")\n        ]),\n        [squill.OperatorType.TIMESTAMPDIFF_DAY]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%J\"),\n                    operands[1]\n                ]),\n                \"-\",\n                squill.functionCall(\"strftime\", [\n                    squill.pascalStyleEscapeString(\"%J\"),\n                    operands[0]\n                ]),\n                \"AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.TIMESTAMPDIFF_HOUR]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 24 AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.TIMESTAMPDIFF_MINUTE]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 24 * 60 AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.TIMESTAMPDIFF_SECOND]: ({ operands }) => squill.functionCall(\"CAST\", [\n            [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 24 * 60 * 60 AS BIGINT\"\n            ]\n        ]),\n        [squill.OperatorType.TIMESTAMPDIFF_MILLISECOND]: ({ operands }) => {\n            /*\n                This naive implementation suffers from precision problems,\n                squill.functionCall(\n                    \"CAST\",\n                    [\n                        [\n                            squill.parentheses(\n                                [\n                                    squill.functionCall(\n                                        \"strftime\",\n                                        [\n                                            squill.pascalStyleEscapeString(\"%J\"),\n                                            operands[1]\n                                        ]\n                                    ),\n                                    \"-\",\n                                    squill.functionCall(\n                                        \"strftime\",\n                                        [\n                                            squill.pascalStyleEscapeString(\"%J\"),\n                                            operands[0]\n                                        ]\n                                    )\n                                ],\n                                false\n                            ),\n                            \"* 24 * 60 * 60 * 1000 AS BIGINT\"\n                        ]\n                    ]\n                )\n            */\n            function castAsBigInt(x) {\n                return squill.functionCall(\"CAST\", [[x, \"AS BIGINT\"]]);\n            }\n            const diffDate = [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        squill.functionCall(\"strftime\", [\n                            squill.pascalStyleEscapeString(\"%Y-%m-%d\"),\n                            operands[1]\n                        ])\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%J\"),\n                        squill.functionCall(\"strftime\", [\n                            squill.pascalStyleEscapeString(\"%Y-%m-%d\"),\n                            operands[0]\n                        ])\n                    ])\n                ], false),\n                \"* 24 * 60 * 60 * 1000\"\n            ];\n            const diffHour = [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%H\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%H\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 60 * 60 * 1000\"\n            ];\n            const diffMinute = [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%M\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%M\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 60 * 1000\"\n            ];\n            const diffSecond = [\n                squill.parentheses([\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%S\"),\n                        operands[1]\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"strftime\", [\n                        squill.pascalStyleEscapeString(\"%S\"),\n                        operands[0]\n                    ])\n                ], false),\n                \"* 1000\"\n            ];\n            const diffMillisecond = [\n                squill.parentheses([\n                    squill.functionCall(\"substr\", [\n                        squill.functionCall(\"strftime\", [\n                            squill.pascalStyleEscapeString(\"%f\"),\n                            operands[1]\n                        ]),\n                        \"4\"\n                    ]),\n                    \"-\",\n                    squill.functionCall(\"substr\", [\n                        squill.functionCall(\"strftime\", [\n                            squill.pascalStyleEscapeString(\"%f\"),\n                            operands[0]\n                        ]),\n                        \"4\"\n                    ])\n                ], false)\n            ];\n            return castAsBigInt(insertBetween([\n                diffDate,\n                diffHour,\n                diffMinute,\n                diffSecond,\n                diffMillisecond\n            ], \"+\"));\n        },\n        [squill.OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR]: ({ operands }) => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%Y-%m-%d %H:%M:%f\"),\n            operands[0]\n        ]),\n        [squill.OperatorType.UNIX_TIMESTAMP_NOW]: () => squill.functionCall(\"strftime\", [\n            squill.pascalStyleEscapeString(\"%s\"),\n            squill.pascalStyleEscapeString(\"now\")\n        ]),\n        /*\n            Cast Functions and Operators\n            https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html\n        */\n        [squill.OperatorType.CAST_AS_DECIMAL]: ({ operands: [arg, precision, scale] }) => squill.functionCall(\"decimal_ctor\", [\n            arg,\n            precision,\n            scale\n        ]) /*functionCall(\n            \"CAST\",\n            [\n                toSql(arg) + `AS DECIMAL(${toSql(precision)}, ${toSql(scale)})`\n            ]\n        )*/,\n        [squill.OperatorType.CAST_AS_DOUBLE]: ({ operands }, toSql) => squill.functionCall(\"CAST\", [`${toSql(operands)} AS DOUBLE`]),\n        [squill.OperatorType.CAST_AS_BIGINT_SIGNED]: ({ operands }, toSql) => squill.functionCall(\"CAST\", [`${toSql(operands)} AS BIGINT`]),\n        [squill.OperatorType.CAST_AS_BINARY]: ({ operands }) => squill.functionCall(\"CAST\", [[operands[0], `AS BLOB`]]),\n        [squill.OperatorType.CAST_AS_VARCHAR]: ({ operands }) => squill.functionCall(\"CAST\", [[operands[0], `AS VARCHAR`]]),\n        [squill.OperatorType.CAST_AS_JSON]: ({ operands }) => squill.functionCall(\"CAST\", [[operands[0], `AS TEXT`]]),\n        /*\n            Bit Functions and Operators\n            https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html\n        */\n        [squill.OperatorType.BITWISE_AND]: ({ operands }) => insertBetween(operands, \"&\"),\n        [squill.OperatorType.BITWISE_OR]: ({ operands }) => insertBetween(operands, \"|\"),\n        [squill.OperatorType.BITWISE_XOR]: ({ operands }) => [\n            [\"~\", squill.parentheses(insertBetween(operands, \"&\"), false)],\n            \"&\",\n            squill.parentheses(insertBetween(operands, \"|\"), false)\n        ],\n        [squill.OperatorType.BITWISE_NOT]: ({ operands }) => [\"~\", operands],\n        [squill.OperatorType.BITWISE_LEFT_SHIFT]: ({ operands }) => insertBetween(operands, \"<<\"),\n        [squill.OperatorType.BITWISE_RIGHT_SHIFT]: ({ operands }) => insertBetween(operands, \">>\"),\n        /*\n            Aggregate (GROUP BY) Function Descriptions\n            https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html\n        */\n        [squill.OperatorType.AGGREGATE_COUNT_ALL]: () => squill.functionCall(\"COUNT\", [\"*\"]),\n        [squill.OperatorType.AGGREGATE_COUNT_EXPR]: ({ operands, operatorType }) => {\n            if (operands.length == 2) {\n                const [isDistinct, expr] = operands;\n                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&\n                    isDistinct.literalValue === true) {\n                    return squill.functionCall(\"COUNT\", [[\"DISTINCT\", expr]]);\n                }\n                else {\n                    return squill.functionCall(\"COUNT\", [expr]);\n                }\n            }\n            else {\n                throw new Error(`${operatorType} only implemented for 2 args`);\n            }\n        },\n        [squill.OperatorType.AGGREGATE_AVERAGE]: ({ operands, operatorType }) => {\n            if (operands.length == 2) {\n                const [isDistinct, expr] = operands;\n                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&\n                    isDistinct.literalValue === true) {\n                    return squill.functionCall(\"AVG\", [[\"DISTINCT\", expr]]);\n                }\n                else {\n                    return squill.functionCall(\"AVG\", [expr]);\n                }\n            }\n            else {\n                throw new Error(`${operatorType} only implemented for 2 args`);\n            }\n        },\n        [squill.OperatorType.AGGREGATE_MAX]: ({ operands }) => {\n            return squill.functionCall(\"MAX\", operands);\n        },\n        [squill.OperatorType.AGGREGATE_MIN]: ({ operands }) => {\n            return squill.functionCall(\"MIN\", operands);\n        },\n        [squill.OperatorType.AGGREGATE_SUM]: ({ operands, operatorType }) => {\n            if (operands.length == 2) {\n                const [isDistinct, expr] = operands;\n                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&\n                    isDistinct.literalValue === true) {\n                    return squill.functionCall(\"SUM\", [[\"DISTINCT\", expr]]);\n                }\n                else {\n                    return squill.functionCall(\"SUM\", [expr]);\n                }\n            }\n            else {\n                throw new Error(`${operatorType} only implemented for 2 args`);\n            }\n        },\n        [squill.OperatorType.AGGREGATE_SUM_AS_BIGINT_SIGNED]: ({ operands, operatorType }) => {\n            if (operands.length == 2) {\n                const [isDistinct, expr] = operands;\n                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&\n                    isDistinct.literalValue === true) {\n                    return squill.functionCall(\"SUM\", [[\"DISTINCT\", expr]]);\n                }\n                else {\n                    return squill.functionCall(\"SUM\", [expr]);\n                }\n            }\n            else {\n                throw new Error(`${operatorType} only implemented for 2 args`);\n            }\n        },\n        [squill.OperatorType.AGGREGATE_SUM_AS_DECIMAL]: ({ operands, operatorType }) => {\n            if (operands.length == 2) {\n                const [isDistinct, expr] = operands;\n                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&\n                    isDistinct.literalValue === true) {\n                    return squill.functionCall(\"SUM\", [\n                        [\n                            \"DISTINCT\",\n                            //@todo\n                            squill.functionCall(\"CAST\", [\n                                [expr, \"AS REAL\"]\n                            ])\n                        ]\n                    ]);\n                }\n                else {\n                    return squill.functionCall(\"SUM\", [\n                        //@todo\n                        squill.functionCall(\"CAST\", [\n                            [expr, \"AS REAL\"]\n                        ])\n                    ]);\n                }\n            }\n            else {\n                throw new Error(`${operatorType} only implemented for 2 args`);\n            }\n        },\n        [squill.OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT]: ({ operands }) => squill.functionCall(\"GROUP_CONCAT\", [\n            [\"DISTINCT\", operands[0]]\n        ]),\n        [squill.OperatorType.AGGREGATE_GROUP_CONCAT_ALL]: ({ operands }) => squill.functionCall(\"GROUP_CONCAT\", operands),\n        [squill.OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION]: ({ operands }) => {\n            return squill.functionCall(\"STDDEV_POP\", operands);\n        },\n        [squill.OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION]: ({ operands }) => {\n            return squill.functionCall(\"STDDEV_SAMP\", operands);\n        },\n        [squill.OperatorType.AGGREGATE_POPULATION_VARIANCE]: ({ operands }) => {\n            return squill.functionCall(\"VAR_POP\", operands);\n        },\n        [squill.OperatorType.AGGREGATE_SAMPLE_VARIANCE]: ({ operands }) => {\n            return squill.functionCall(\"VAR_SAMP\", operands);\n        },\n        [squill.OperatorType.EXISTS]: ({ operands: [query] }, toSql) => {\n            if (squill.QueryBaseUtil.isAfterFromClause(query)) {\n                //EXISTS(... FROM table)\n                if (squill.QueryBaseUtil.isAfterSelectClause(query)) {\n                    //EXISTS(SELECT x FROM table)\n                    return squill.functionCall(\"EXISTS\", [query]);\n                }\n                else {\n                    //EXISTS(FROM table)\n                    return squill.functionCall(\"EXISTS\", [\n                        \"SELECT 1 \" + toSql(query)\n                    ]);\n                }\n            }\n            else {\n                if (squill.QueryBaseUtil.isAfterSelectClause(query)) {\n                    //EXISTS(SELECT x)\n                    return squill.functionCall(\"EXISTS\", [query]);\n                }\n                else {\n                    throw new Error(`Query should have either FROM or SELECT clause`);\n                }\n            }\n        },\n        /*\n            https://dev.mysql.com/doc/refman/5.7/en/information-functions.html\n\n            Information Functions\n        */\n        [squill.OperatorType.CURRENT_SCHEMA]: () => squill.pascalStyleEscapeString(constants_1.DEFAULT_SCHEMA_NAME),\n        [squill.OperatorType.CURRENT_USER]: () => \"NULL\",\n        /*\n            Custom library functions\n\n            These functions are not standard SQL,\n            but can be implemented using standard SQL.\n        */\n        [squill.OperatorType.THROW_IF_NULL]: ({ operands: [arg] }) => {\n            return squill.functionCall(\"COALESCE\", [\n                arg,\n                exports.THROW_AST\n            ]);\n        },\n    },\n    queryBaseSqlfier: (rawQuery, toSql) => {\n        const sql = queryToSql(rawQuery, toSql, false);\n        //console.log(sql);\n        return sql;\n    },\n    caseValueSqlfier: (node) => {\n        const result = [\n            \"CASE\", node.value,\n        ];\n        for (const [compareValue, thenResult] of node.cases) {\n            result.push([\"WHEN\", compareValue, \"THEN\", thenResult]);\n        }\n        if (node.else != undefined) {\n            result.push([\"ELSE\", node.else]);\n        }\n        result.push(\"END\");\n        return result;\n    },\n    caseConditionSqlfier: (node) => {\n        const result = [\n            \"CASE\"\n        ];\n        for (const [condition, thenResult] of node.branches) {\n            result.push([\"WHEN\", condition, \"THEN\", thenResult]);\n        }\n        if (node.else != undefined) {\n            result.push([\"ELSE\", node.else]);\n        }\n        result.push(\"END\");\n        return result;\n    }\n};\n//# sourceMappingURL=sqlfier.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst squill = require(\"@squill/squill\");\nconst sqlfier_1 = require(\"./sqlfier\");\nfunction updateSqlString(table, whereClause, assignmentMap) {\n    const mutableColumnAlias = Object.keys(assignmentMap)\n        .filter(columnAlias => {\n        const value = assignmentMap[columnAlias];\n        return (value !== undefined &&\n            table.mutableColumns.indexOf(columnAlias) >= 0);\n    })\n        .sort();\n    if (mutableColumnAlias.length == 0) {\n        //Empty assignment list...\n        return undefined;\n    }\n    const assignmentList = mutableColumnAlias.reduce((ast, columnAlias) => {\n        const value = assignmentMap[columnAlias];\n        const assignment = [\n            squill.escapeIdentifierWithDoubleQuotes(columnAlias),\n            \"=\",\n            squill.BuiltInExprUtil.buildAst(value)\n        ];\n        if (ast.length > 0) {\n            ast.push(\",\");\n        }\n        ast.push(assignment);\n        return ast;\n    }, []);\n    const ast = [\n        \"UPDATE\",\n        table.unaliasedAst,\n        \"SET\",\n        ...assignmentList,\n        \"WHERE\",\n        whereClause.ast\n    ];\n    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);\n    return sql;\n}\nexports.updateSqlString = updateSqlString;\n//# sourceMappingURL=update-sql-string.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SqliteAction;\n(function (SqliteAction) {\n    SqliteAction[\"OPEN\"] = \"OPEN\";\n    SqliteAction[\"EXEC\"] = \"EXEC\";\n    SqliteAction[\"EXPORT\"] = \"EXPORT\";\n    SqliteAction[\"CLOSE\"] = \"CLOSE\";\n    SqliteAction[\"CREATE_GLOBAL_JS_FUNCTION\"] = \"CREATE_GLOBAL_JS_FUNCTION\";\n    SqliteAction[\"CREATE_FUNCTION\"] = \"CREATE_FUNCTION\";\n    SqliteAction[\"CREATE_AGGREGATE\"] = \"CREATE_AGGREGATE\";\n})(SqliteAction = exports.SqliteAction || (exports.SqliteAction = {}));\nclass SqliteWorker {\n    constructor(rawWorker) {\n        this.onResult = (data) => {\n            if (this.onmessage == undefined) {\n                return;\n            }\n            this.onmessage({ data });\n        };\n        this.processMessage = rawWorker.postMessage;\n        rawWorker.setOnMessage(this.onResult);\n    }\n    postMessage(message) {\n        this.processMessage(message);\n    }\n}\nexports.SqliteWorker = SqliteWorker;\n//# sourceMappingURL=worker.js.map","import * as sql from \"@squill/squill\";\nimport * as sqlite3 from \"../../dist/driver\";\nimport {ExecResult} from \"../../dist/sql-wasm/sql-wasm-debug\";\n\nconst worker = new Worker(\"worker-browser.js\");\n\nconst sqlite3Worker = new sqlite3.SqliteWorker({\n    postMessage : worker.postMessage.bind(worker),\n    setOnMessage : (onMessage) => {\n        worker.onmessage = (event) => {\n            onMessage(event.data);\n            if (event.data.action == sqlite3.SqliteAction.CLOSE) {\n                worker.terminate();\n            }\n        };\n    },\n});\n\nconst pool = new sqlite3.Pool(sqlite3Worker);\n\ndeclare global {\n    interface Window {\n        rawQuery : (sqlString : string) => Promise<sql.RawQueryResult>;\n        exec : (sqlString : string) => Promise<{ execResult : ExecResult, rowsModified : number }>;\n        exportDb : () => Promise<Uint8Array>;\n        importDb : (dbFile : Uint8Array) => Promise<void>;\n    }\n}\n\nwindow.rawQuery = (sqlString) => pool.acquire(\n    connection => connection.rawQuery(sqlString)\n);\n\nwindow.exec = (sqlString) => pool.acquire(\n    connection => connection.exec(sqlString)\n);\n\nwindow.exportDb = () => pool.acquire(\n    connection => connection.export()\n);\n\nwindow.importDb = (dbFile : Uint8Array) => pool.acquire(\n    connection => connection.open(dbFile)\n);\n"],"sourceRoot":""}