/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"index": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./test-browser/src/index.ts","vendors"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../tsql/dist/aliased-expr/aliased-expr-impl.js":
/*!******************************************************!*\
  !*** ../tsql/dist/aliased-expr/aliased-expr-impl.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../expr */ "../tsql/dist/expr/index.js");
/**
 * An aliased expression
 *
 * ```sql
 *  SELECT
 *      (1+2) AS x --This is an `AliasedExpr`
 * ```
 *
 * -----
 *
 * ### Using `AliasedExpr` as "normal" expression
 *
 * Normally, you cannot use an aliased expression as a "normal" expression.
 *
 * This is usually invalid,
 * ```sql
 *  SELECT
 *      (((1+2) AS x) + 3) AS y
 * ```
 *
 * However, `tsql` allows this!
 *
 * When the query is generated, it extracts the inner unaliased expression,
 *
 * ```sql
 *  SELECT
 *      ((1+2) + 3) AS y
 * ```
 *
 * -----
 *
 * Allowing the above lets us write composable expressions that
 * can also be used in `SELECT` clauses more consistently!
 *
 * For example,
 * ```ts
 *  function x () {
 *      return tsql.add(1, 2).as("x");
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //SELECT (1+2) AS x, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 * If we did not allow aliased expressions to be used as "normal" expressions,
 * we would have an increased risk of typos,
 *
 * ```ts
 *  function x () {
 *      //Removed `.as("x")`
 *      return tsql.add(1, 2);
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x().as("x"),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //Intended: SELECT (1+2) AS x, (1+2+3+4+5) AS y
 *  //Actual  : SELECT (1+2) AS typo, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x().as("typo"),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 * -----
 *
 * ### Re-aliasing
 *
 * Normally, you can only alias an expression once,
 * ```sql
 *  SELECT
 *      (1+2) AS x AS y --Error: Cannot alias an expression more than once!
 * ```
 *
 * However, `tsql` allows this!
 *
 * When the query is generated, it uses the **last** set alias,
 * ```sql
 *  SELECT
 *      (1+2) AS y
 * ```
 *
 * -----
 *
 * With re-aliasing, you can set a **default alias** for your composable expressions.
 * Then, when you want a different alias, you can change it.
 *
 * For example,
 * ```ts
 *  function x () {
 *      //Default alias is `x`
 *      return tsql.add(1, 2).as("x");
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //SELECT (1+2) AS realiased, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x().as("realiased"),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 */
class AliasedExpr extends expr_1.ExprImpl {
    constructor(data, ast) {
        super(data, ast);
        this.tableAlias = data.tableAlias;
        this.alias = data.alias;
        this.unaliasedAst = ast;
    }
}
exports.AliasedExpr = AliasedExpr;
//# sourceMappingURL=aliased-expr-impl.js.map

/***/ }),

/***/ "../tsql/dist/aliased-expr/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/aliased-expr/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-expr-impl */ "../tsql/dist/aliased-expr/aliased-expr-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/aliased-table.js":
/*!***************************************************!*\
  !*** ../tsql/dist/aliased-table/aliased-table.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A table can be aliased,
 *
 * ```sql
 * SELECT
 *  *
 * FROM
 *  myTable
 * CROSS JOIN
 *  (
 *      myTable
 *  ) AS otherTable --This is an `AliasedTable`
 * ```
 *
 * For aliasing a query (derived tables), @see {@link DerivedTable}
 */
class AliasedTable {
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
    }
}
exports.AliasedTable = AliasedTable;
//# sourceMappingURL=aliased-table.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/array-util/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/aliased-table/array-util/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/aliased-table/array-util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/aliased-table/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js":
/*!******************************************************************************************!*\
  !*** ../tsql/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/aliased-table/array-util/query/index.js");
function assertNoDuplicateTableAlias(arr) {
    const duplicates = query_1.duplicateTableAlias(arr);
    if (duplicates.length > 0) {
        throw new Error(`Duplicate table alias not allowed; ${duplicates.join(", ")}`);
    }
}
exports.assertNoDuplicateTableAlias = assertNoDuplicateTableAlias;
//# sourceMappingURL=assert-no-duplicate-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/array-util/predicate/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/aliased-table/array-util/predicate/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-no-duplicate-table-alias */ "../tsql/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/array-util/query/duplicate-table-alias.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/aliased-table/array-util/query/duplicate-table-alias.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function duplicateTableAlias(arr) {
    const result = [];
    for (let i = 0; i < arr.length; ++i) {
        const cur = arr[i].alias;
        for (let j = i + 1; j < arr.length; ++j) {
            const nxt = arr[j].alias;
            if (cur == nxt && !result.includes(cur)) {
                result.push(cur);
            }
        }
    }
    return result;
}
exports.duplicateTableAlias = duplicateTableAlias;
//# sourceMappingURL=duplicate-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/array-util/query/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/aliased-table/array-util/query/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./duplicate-table-alias */ "../tsql/dist/aliased-table/array-util/query/duplicate-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/aliased-table/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-table */ "../tsql/dist/aliased-table/aliased-table.js"));
const AliasedTableArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/aliased-table/array-util/index.js");
exports.AliasedTableArrayUtil = AliasedTableArrayUtil;
const AliasedTableUtil = __webpack_require__(/*! ./util */ "../tsql/dist/aliased-table/util/index.js");
exports.AliasedTableUtil = AliasedTableUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/aliased-table/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/aliased-table/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/query/candidate-keys.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/aliased-table/util/query/candidate-keys.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function candidateKeys(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.candidateKeys;
    }
    else {
        return [];
    }
}
exports.candidateKeys = candidateKeys;
//# sourceMappingURL=candidate-keys.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/query/delete-enabled.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/aliased-table/util/query/delete-enabled.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function deleteEnabled(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.deleteEnabled;
    }
    else {
        return false;
    }
}
exports.deleteEnabled = deleteEnabled;
//# sourceMappingURL=delete-enabled.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/query/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/aliased-table/util/query/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./candidate-keys */ "../tsql/dist/aliased-table/util/query/candidate-keys.js"));
__export(__webpack_require__(/*! ./delete-enabled */ "../tsql/dist/aliased-table/util/query/delete-enabled.js"));
__export(__webpack_require__(/*! ./mutable-columns */ "../tsql/dist/aliased-table/util/query/mutable-columns.js"));
__export(__webpack_require__(/*! ./primary-key */ "../tsql/dist/aliased-table/util/query/primary-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/query/mutable-columns.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/aliased-table/util/query/mutable-columns.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function mutableColumns(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.mutableColumns;
    }
    else {
        return [];
    }
}
exports.mutableColumns = mutableColumns;
//# sourceMappingURL=mutable-columns.js.map

/***/ }),

/***/ "../tsql/dist/aliased-table/util/query/primary-key.js":
/*!************************************************************!*\
  !*** ../tsql/dist/aliased-table/util/query/primary-key.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function primaryKey(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.primaryKey;
    }
    else {
        return undefined;
    }
}
exports.primaryKey = primaryKey;
//# sourceMappingURL=primary-key.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-condition-node/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/ast/case-condition-node/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CaseConditionNodeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/case-condition-node/util/index.js");
exports.CaseConditionNodeUtil = CaseConditionNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-condition-node/util/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/ast/case-condition-node/util/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/ast/case-condition-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-condition-node/util/predicate/index.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/ast/case-condition-node/util/predicate/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-case-condition-node */ "../tsql/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "../tsql/dist/type-util/index.js");
function isCaseConditionNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "branches",
        "else"
    ])) {
        return false;
    }
    return (mixed.type === "CaseCondition");
}
exports.isCaseConditionNode = isCaseConditionNode;
//# sourceMappingURL=is-case-condition-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-value-node/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/ast/case-value-node/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CaseValueNodeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/case-value-node/util/index.js");
exports.CaseValueNodeUtil = CaseValueNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-value-node/util/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/ast/case-value-node/util/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/ast/case-value-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-value-node/util/predicate/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/ast/case-value-node/util/predicate/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-case-value-node */ "../tsql/dist/ast/case-value-node/util/predicate/is-case-value-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/case-value-node/util/predicate/is-case-value-node.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/ast/case-value-node/util/predicate/is-case-value-node.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "../tsql/dist/type-util/index.js");
function isCaseValueNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "value",
        "cases",
        "else"
    ])) {
        return false;
    }
    return (mixed.type === "CaseValue");
}
exports.isCaseValueNode = isCaseValueNode;
//# sourceMappingURL=is-case-value-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/function-call.js":
/*!*****************************************!*\
  !*** ../tsql/dist/ast/function-call.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ./parentheses */ "../tsql/dist/ast/parentheses.js");
const AstUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/util/index.js");
class FunctionArg {
    constructor(ast) {
        this.type = "FunctionArg";
        this.toSql = (sqlfier) => {
            return AstUtil.toSql(this.ast, sqlfier);
        };
        if (parentheses_1.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
            //No need to wrap arguments in parentheses...
            //Unless the argument is a sub-query...
            this.ast = ast.ast;
        }
        else {
            this.ast = ast;
        }
    }
    static IsFunctionArg(x) {
        if (x instanceof FunctionArg) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "FunctionArg") &&
            /**
             * @todo Debate if this is necessary.
             * Safer, but slower.
             */
            //AstUtil.isAst(mixed.ast) &&
            (typeof mixed.toSql == "function"));
    }
}
exports.FunctionArg = FunctionArg;
class FunctionCall {
    constructor(functionName, args) {
        this.type = "FunctionCall";
        this.toSql = (sqlfier) => {
            const argsSql = this.args
                .map(arg => arg.toSql(sqlfier))
                .join(", ");
            return `${this.functionName}(${argsSql})`;
        };
        this.functionName = functionName;
        this.args = args;
    }
    static IsFunctionCall(x) {
        if (x instanceof FunctionCall) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "FunctionCall") &&
            (typeof mixed.functionName == "string") &&
            /**
             * @todo Debate if we should check each element is `FunctionArg`
             * Safer, but slower.
             */
            (Array.isArray(mixed.args)) &&
            (typeof mixed.toSql == "function"));
    }
}
exports.FunctionCall = FunctionCall;
function functionArg(ast) {
    if (FunctionArg.IsFunctionArg(ast)) {
        return ast;
    }
    return new FunctionArg(ast);
}
exports.functionArg = functionArg;
function functionCall(functionName, args) {
    return new FunctionCall(functionName, args.map(functionArg));
}
exports.functionCall = functionCall;
//# sourceMappingURL=function-call.js.map

/***/ }),

/***/ "../tsql/dist/ast/identifier-node.js":
/*!*******************************************!*\
  !*** ../tsql/dist/ast/identifier-node.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../type-util */ "../tsql/dist/type-util/index.js");
function identifierNode(...identifiers) {
    return {
        type: "Identifier",
        identifiers,
    };
}
exports.identifierNode = identifierNode;
/**
 * Does not check that each element of the `identifiers` property is a `string`
 *
 * @param mixed
 */
function isIdentifierNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "identifiers",
    ])) {
        return false;
    }
    return (mixed.type === "Identifier" &&
        Array.isArray(mixed.identifiers) &&
        mixed.identifiers.length >= 1);
}
exports.isIdentifierNode = isIdentifierNode;
//# sourceMappingURL=identifier-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/index.js":
/*!*********************************!*\
  !*** ../tsql/dist/ast/index.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition-node */ "../tsql/dist/ast/case-condition-node/index.js"));
__export(__webpack_require__(/*! ./case-value-node */ "../tsql/dist/ast/case-value-node/index.js"));
__export(__webpack_require__(/*! ./literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js"));
__export(__webpack_require__(/*! ./operator-node */ "../tsql/dist/ast/operator-node/index.js"));
__export(__webpack_require__(/*! ./sqlfier */ "../tsql/dist/ast/sqlfier/index.js"));
__export(__webpack_require__(/*! ./function-call */ "../tsql/dist/ast/function-call.js"));
__export(__webpack_require__(/*! ./identifier-node */ "../tsql/dist/ast/identifier-node.js"));
__export(__webpack_require__(/*! ./parentheses */ "../tsql/dist/ast/parentheses.js"));
const AstUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/util/index.js");
exports.AstUtil = AstUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js"));
const LiteralValueNodeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/literal-value-node/util/index.js");
exports.LiteralValueNodeUtil = LiteralValueNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/literal-value-node.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/literal-value-node.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//import {BuiltInValueExpr} from "../../built-in-value-expr";
//import * as tm from "type-mapping";
Object.defineProperty(exports, "__esModule", { value: true });
var LiteralValueType;
(function (LiteralValueType) {
    /**
     * Can only be created using the `decimalLiteral()` function
     */
    LiteralValueType["DECIMAL"] = "DECIMAL";
    /**
     * ```ts
     * typeof x == "string"
     * ```
     */
    LiteralValueType["STRING"] = "STRING";
    /**
     * ```ts
     * typeof x == "number"
     * ```
     */
    LiteralValueType["DOUBLE"] = "DOUBLE";
    /**
     * ```ts
     * tm.TypeUtil.isBigInt(x) &&
     * //bigint signed minimum value
     * tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
     * //bigint signed maximum value
     * tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807"))
     * ```
     */
    LiteralValueType["BIGINT_SIGNED"] = "BIGINT_SIGNED";
    /**
     * ```ts
     * typeof x == "boolean"
     * ```
     */
    LiteralValueType["BOOLEAN"] = "BOOLEAN";
    /**
     * An unsigned char array (8-bit unsigned integer)
     * ```ts
     * x instanceof Uint8Array
     * ```
     * @todo Rename this to `UINT8ARRAY`?
     */
    LiteralValueType["BUFFER"] = "BUFFER";
    /**
     * ```ts
     * x === null
     * ```
     */
    LiteralValueType["NULL"] = "NULL";
    /**
     * ```ts
     * DateUtil.isDate(x)
     * ```
     */
    LiteralValueType["DATE_TIME"] = "DATE_TIME";
})(LiteralValueType = exports.LiteralValueType || (exports.LiteralValueType = {}));
exports.literalValueTypeElements = Object.values(LiteralValueType);
//# sourceMappingURL=literal-value-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function isBigIntSigned(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint signed minimum value
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
        //bigint signed maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807")));
}
exports.isBigIntSigned = isBigIntSigned;
/**
 * @todo Remove
 * @deprecated
 */
function isBigIntUnsigned(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint unsigned minimum value
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("0")) &&
        //bigint unsigned maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
}
exports.isBigIntUnsigned = isBigIntUnsigned;
function isBigIntSignedLiteral(x) {
    return isBigIntSigned(x);
}
exports.isBigIntSignedLiteral = isBigIntSignedLiteral;
/**
 * @todo Remove
 * @deprecated
 */
function isBigIntUnsignedLiteral(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint signed maximum value + 1
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("9223372036854775808")) &&
        //bigint unsigned maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
}
exports.isBigIntUnsignedLiteral = isBigIntUnsignedLiteral;
function bigIntSignedLiteralNode(literalValue) {
    if (isBigIntSignedLiteral(literalValue)) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_1.LiteralValueType.BIGINT_SIGNED,
            literalValue,
        };
    }
    else {
        //Can only really be an `BIGINT UNSIGNED` or `DECIMAL` value
        throw new Error(`Literal value is too small/large to be a signed bigint; consider using BIGINT UNSIGNED or DECIMAL`);
    }
}
exports.bigIntSignedLiteralNode = bigIntSignedLiteralNode;
//# sourceMappingURL=bigint-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function booleanLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.BOOLEAN,
        literalValue,
    };
}
exports.booleanLiteralNode = booleanLiteralNode;
//# sourceMappingURL=boolean-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function bufferLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.BUFFER,
        literalValue,
    };
}
exports.bufferLiteralNode = bufferLiteralNode;
//# sourceMappingURL=buffer-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function dateTimeLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DATE_TIME,
        literalValue,
    };
}
exports.dateTimeLiteralNode = dateTimeLiteralNode;
//# sourceMappingURL=date-time-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
const ExprLib = __webpack_require__(/*! ../../../../expr-library */ "../tsql/dist/expr-library/index.js");
function decimalLiteralNode(rawDecimalLiteral, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const mapper = tm.mysql.decimal(precision, scale);
    const decimalDefinition = ExprLib.assertValidDecimalPrecisionAndScale(precision, scale);
    const literalValue = mapper("rawDecimalLiteral", rawDecimalLiteral).toString();
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DECIMAL,
        literalValue,
        precision: decimalDefinition.precision,
        scale: decimalDefinition.scale,
    };
}
exports.decimalLiteralNode = decimalLiteralNode;
//# sourceMappingURL=decimal-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/double-literal-node.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/double-literal-node.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function doubleLiteralNode(literalValue) {
    /**
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    /*
    if (!isFinite(literalValue)) {
        throw new Error(`Double literal must be finite`);
    }
    */
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DOUBLE,
        literalValue,
    };
}
exports.doubleLiteralNode = doubleLiteralNode;
//# sourceMappingURL=double-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/index.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js"));
__export(__webpack_require__(/*! ./boolean-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js"));
__export(__webpack_require__(/*! ./buffer-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js"));
__export(__webpack_require__(/*! ./date-time-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js"));
__export(__webpack_require__(/*! ./decimal-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js"));
__export(__webpack_require__(/*! ./double-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/double-literal-node.js"));
__export(__webpack_require__(/*! ./null-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/null-literal-node.js"));
__export(__webpack_require__(/*! ./string-literal-node */ "../tsql/dist/ast/literal-value-node/util/constructor/string-literal-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/null-literal-node.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/null-literal-node.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function nullLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.NULL,
        literalValue,
    };
}
exports.nullLiteralNode = nullLiteralNode;
//# sourceMappingURL=null-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/constructor/string-literal-node.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/constructor/string-literal-node.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
function stringLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.STRING,
        literalValue,
    };
}
exports.stringLiteralNode = stringLiteralNode;
//# sourceMappingURL=string-literal-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/ast/literal-value-node/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/ast/literal-value-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/predicate/index.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/predicate/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-literal-value-node */ "../tsql/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "../tsql/dist/ast/literal-value-node/literal-value-node.js");
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "../tsql/dist/type-util/index.js");
/**
 * Does not check for `precision` and `scale` for `DecimalLiteralNode`.
 * Just assumes it exists.
 */
function isLiteralValueNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "literalValueType",
        "literalValue"
    ])) {
        return false;
    }
    return (mixed.type === "LiteralValue" &&
        literal_value_node_1.literalValueTypeElements.includes(mixed.literalValueType));
}
exports.isLiteralValueNode = isLiteralValueNode;
//# sourceMappingURL=is-literal-value-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/ast/operator-node/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OperatorNodeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/operator-node/util/index.js");
exports.OperatorNodeUtil = OperatorNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operator-node-0 */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-0.js"));
__export(__webpack_require__(/*! ./operator-node-1-to-n */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js"));
__export(__webpack_require__(/*! ./operator-node-1 */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-1.js"));
__export(__webpack_require__(/*! ./operator-node-2-to-n */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js"));
__export(__webpack_require__(/*! ./operator-node-2 */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-2.js"));
__export(__webpack_require__(/*! ./operator-node-3 */ "../tsql/dist/ast/operator-node/util/constructor/operator-node-3.js"));
__export(__webpack_require__(/*! ./operator-node */ "../tsql/dist/ast/operator-node/util/constructor/operator-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-0.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-0.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode0(operatorType, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: [],
        typeHint,
    };
}
exports.operatorNode0 = operatorNode0;
//# sourceMappingURL=operator-node-0.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode1ToN(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode1ToN = operatorNode1ToN;
//# sourceMappingURL=operator-node-1-to-n.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-1.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-1.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode1(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode1 = operatorNode1;
//# sourceMappingURL=operator-node-1.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode2ToN(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode2ToN = operatorNode2ToN;
//# sourceMappingURL=operator-node-2-to-n.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-2.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-2.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode2(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode2 = operatorNode2;
//# sourceMappingURL=operator-node-2.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node-3.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node-3.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode3(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode3 = operatorNode3;
//# sourceMappingURL=operator-node-3.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/constructor/operator-node.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/constructor/operator-node.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands,
        typeHint,
    };
}
exports.operatorNode = operatorNode;
//# sourceMappingURL=operator-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/ast/operator-node/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/ast/operator-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/predicate/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/predicate/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-operator-node */ "../tsql/dist/ast/operator-node/util/predicate/is-operator-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/operator-node/util/predicate/is-operator-node.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/ast/operator-node/util/predicate/is-operator-node.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "../tsql/dist/type-util/index.js");
function isOperatorNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "operatorType",
        "operands",
        "typeHint"
    ])) {
        return false;
    }
    return (mixed.type === "Operator");
}
exports.isOperatorNode = isOperatorNode;
//# sourceMappingURL=is-operator-node.js.map

/***/ }),

/***/ "../tsql/dist/ast/parentheses.js":
/*!***************************************!*\
  !*** ../tsql/dist/ast/parentheses.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AstUtil = __webpack_require__(/*! ./util */ "../tsql/dist/ast/util/index.js");
const function_call_1 = __webpack_require__(/*! ./function-call */ "../tsql/dist/ast/function-call.js");
const identifier_node_1 = __webpack_require__(/*! ./identifier-node */ "../tsql/dist/ast/identifier-node.js");
const literal_value_node_1 = __webpack_require__(/*! ./literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
function shouldWrap(ast, canUnwrap) {
    if (Parentheses.IsParentheses(ast)) {
        if (!canUnwrap && ast.canUnwrap) {
            return true;
        }
        else {
            return false;
        }
    }
    if (function_call_1.FunctionCall.IsFunctionCall(ast)) {
        return false;
    }
    if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
        return false;
    }
    if (identifier_node_1.isIdentifierNode(ast)) {
        return false;
    }
    if (typeof ast == "string") {
        return false;
    }
    if (Array.isArray(ast)) {
        if (ast.length == 0) {
            throw new Error(`Attempt to add parentheses around empty query tree`);
        }
        else if (ast.length == 1) {
            return shouldWrap(ast[0], canUnwrap);
        }
        else {
            return true;
        }
    }
    return true;
}
class Parentheses {
    constructor(ast, canUnwrap) {
        this.type = "Parentheses";
        this.toSql = (sqlfier) => {
            /**
             * @todo Investigate this logic
             */
            const sqlAst = (sqlfier.parenthesesSqlfier == undefined ?
                AstUtil.toSqlAst(this.ast, sqlfier) :
                sqlfier.parenthesesSqlfier(this, (ast2) => AstUtil.toSql(ast2, sqlfier), sqlfier));
            if (!this.canUnwrap || shouldWrap(sqlAst, this.canUnwrap)) {
                return `(${AstUtil.toSql(sqlAst, sqlfier)})`;
            }
            else {
                return AstUtil.toSql(sqlAst, sqlfier);
            }
        };
        this.ast = ast;
        this.canUnwrap = canUnwrap;
    }
    static IsParentheses(x) {
        if (x instanceof Parentheses) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "Parentheses") &&
            /**
             * @todo Debate if this is necessary.
             * Safer, but slower.
             */
            //AstUtil.isAst(mixed.ast) &&
            (typeof mixed.canUnwrap == "boolean") &&
            (typeof mixed.toSql == "function"));
    }
    static Create(ast, canUnwrap = true) {
        if (shouldWrap(ast, canUnwrap)) {
            if (Parentheses.IsParentheses(ast)) {
                return new Parentheses(ast.ast, canUnwrap);
            }
            else {
                return new Parentheses(ast, canUnwrap);
            }
        }
        else {
            return ast;
        }
    }
}
exports.Parentheses = Parentheses;
function parentheses(ast, canUnwrap) {
    return Parentheses.Create(ast, canUnwrap);
}
exports.parentheses = parentheses;
//# sourceMappingURL=parentheses.js.map

/***/ }),

/***/ "../tsql/dist/ast/sqlfier/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/ast/sqlfier/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./not-implemented-sqlfier */ "../tsql/dist/ast/sqlfier/not-implemented-sqlfier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/sqlfier/not-implemented-sqlfier.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/ast/sqlfier/not-implemented-sqlfier.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const notImplemented = () => {
    throw new Error(`Not implemented`);
};
const operatorNotImplemented = (operatorNode) => {
    throw new Error(`Not implemented ${operatorNode.operatorType}`);
};
const literalValueNotImplemented = (literalValueNode) => {
    throw new Error(`Not implemented ${literalValueNode.literalValueType}`);
};
exports.notImplementedSqlfier = {
    identifierSqlfier: notImplemented,
    literalValueSqlfier: Object
        .values(literal_value_node_1.LiteralValueType)
        .reduce((memo, literalValueType) => {
        memo[literalValueType] = literalValueNotImplemented;
        return memo;
    }, {}),
    operatorSqlfier: Object
        .values(operator_type_1.OperatorType)
        .reduce((memo, operatorType) => {
        memo[operatorType] = operatorNotImplemented;
        return memo;
    }, {}),
    queryBaseSqlfier: notImplemented,
    caseValueSqlfier: notImplemented,
    caseConditionSqlfier: notImplemented,
};
//# sourceMappingURL=not-implemented-sqlfier.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/ast/util/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-between */ "../tsql/dist/ast/util/insert-between.js"));
__export(__webpack_require__(/*! ./is-ast */ "../tsql/dist/ast/util/is-ast.js"));
__export(__webpack_require__(/*! ./to-sql-pretty */ "../tsql/dist/ast/util/to-sql-pretty.js"));
__export(__webpack_require__(/*! ./to-sql */ "../tsql/dist/ast/util/to-sql.js"));
__export(__webpack_require__(/*! ./try-extract-ast */ "../tsql/dist/ast/util/try-extract-ast.js"));
__export(__webpack_require__(/*! ./try-unwrap-parentheses */ "../tsql/dist/ast/util/try-unwrap-parentheses.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/insert-between.js":
/*!***********************************************!*\
  !*** ../tsql/dist/ast/util/insert-between.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function insertBetween(operands, insertElement) {
    const result = [];
    for (const operand of operands) {
        if (result.length > 0) {
            result.push(insertElement);
        }
        result.push(operand);
    }
    return result;
}
exports.insertBetween = insertBetween;
//# sourceMappingURL=insert-between.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/is-ast.js":
/*!***************************************!*\
  !*** ../tsql/dist/ast/util/is-ast.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "../tsql/dist/ast/parentheses.js");
const function_call_1 = __webpack_require__(/*! ../function-call */ "../tsql/dist/ast/function-call.js");
const operator_node_1 = __webpack_require__(/*! ../operator-node */ "../tsql/dist/ast/operator-node/index.js");
const identifier_node_1 = __webpack_require__(/*! ../identifier-node */ "../tsql/dist/ast/identifier-node.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "../tsql/dist/query-base/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const case_value_node_1 = __webpack_require__(/*! ../case-value-node */ "../tsql/dist/ast/case-value-node/index.js");
const case_condition_node_1 = __webpack_require__(/*! ../case-condition-node */ "../tsql/dist/ast/case-condition-node/index.js");
/**
 * A type guard for the `Ast` type
 *
 * @param raw
 */
function isAst(raw) {
    if (typeof raw == "string") {
        return true;
    }
    if (parentheses_1.Parentheses.IsParentheses(raw)) {
        return true;
    }
    if (function_call_1.FunctionCall.IsFunctionCall(raw)) {
        return true;
    }
    if (operator_node_1.OperatorNodeUtil.isOperatorNode(raw)) {
        return true;
    }
    if (identifier_node_1.isIdentifierNode(raw)) {
        return true;
    }
    if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(raw)) {
        return true;
    }
    if (Array.isArray(raw)) {
        for (const item of raw) {
            if (!isAst(item)) {
                return false;
            }
        }
        return true;
    }
    if (query_base_1.QueryBaseUtil.isQuery(raw)) {
        return true;
    }
    if (case_value_node_1.CaseValueNodeUtil.isCaseValueNode(raw)) {
        return true;
    }
    if (case_condition_node_1.CaseConditionNodeUtil.isCaseConditionNode(raw)) {
        return true;
    }
    return false;
}
exports.isAst = isAst;
//# sourceMappingURL=is-ast.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/to-sql-pretty.js":
/*!**********************************************!*\
  !*** ../tsql/dist/ast/util/to-sql-pretty.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const formatter_1 = __webpack_require__(/*! ../../formatter */ "../tsql/dist/formatter/index.js");
const to_sql_1 = __webpack_require__(/*! ./to-sql */ "../tsql/dist/ast/util/to-sql.js");
/**
 * Converts an AST to a SQL string.
 *
 * Prettifies the output.
 *
 * -----
 *
 * Perfomance is generally "okay" but when queries become
 * hundreds of thousands of characters long,
 * it can take a long time.
 *
 * Use this with caution.
 *
 * @param ast
 */
function toSqlPretty(ast, sqlfier, tokenizerConfig) {
    const sql = to_sql_1.toSql(ast, sqlfier);
    return new formatter_1.SqlFormatter(undefined, tokenizerConfig).format(sql);
}
exports.toSqlPretty = toSqlPretty;
//# sourceMappingURL=to-sql-pretty.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/to-sql.js":
/*!***************************************!*\
  !*** ../tsql/dist/ast/util/to-sql.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "../tsql/dist/ast/parentheses.js");
const function_call_1 = __webpack_require__(/*! ../function-call */ "../tsql/dist/ast/function-call.js");
const operator_node_1 = __webpack_require__(/*! ../operator-node */ "../tsql/dist/ast/operator-node/index.js");
const identifier_node_1 = __webpack_require__(/*! ../identifier-node */ "../tsql/dist/ast/identifier-node.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "../tsql/dist/query-base/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const case_value_node_1 = __webpack_require__(/*! ../case-value-node */ "../tsql/dist/ast/case-value-node/index.js");
const case_condition_node_1 = __webpack_require__(/*! ../case-condition-node */ "../tsql/dist/ast/case-condition-node/index.js");
function toSqlAst(ast, sqlfier) {
    if (typeof ast == "string") {
        return ast;
    }
    else if (parentheses_1.Parentheses.IsParentheses(ast)) {
        return ast.toSql(sqlfier);
    }
    else if (function_call_1.FunctionCall.IsFunctionCall(ast)) {
        return ast.toSql(sqlfier);
    }
    else if (operator_node_1.OperatorNodeUtil.isOperatorNode(ast)) {
        return sqlfier.operatorSqlfier[ast.operatorType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (identifier_node_1.isIdentifierNode(ast)) {
        return sqlfier.identifierSqlfier(ast);
    }
    else if (query_base_1.QueryBaseUtil.isQuery(ast)) {
        return sqlfier.queryBaseSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
        return sqlfier.literalValueSqlfier[ast.literalValueType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (case_value_node_1.CaseValueNodeUtil.isCaseValueNode(ast)) {
        return sqlfier.caseValueSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (case_condition_node_1.CaseConditionNodeUtil.isCaseConditionNode(ast)) {
        return sqlfier.caseConditionSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else {
        return ast.map(subAst => toSql(subAst, sqlfier)).join(" ");
    }
}
exports.toSqlAst = toSqlAst;
/**
 * Converts an AST to a SQL string.
 *
 * **DOES NOT** prettify the output.
 *
 * @see {@link toSqlPretty} for prettified output.
 *
 * @param ast
 */
function toSql(ast, sqlfier) {
    const result = toSqlAst(ast, sqlfier);
    if (typeof result == "string") {
        return result;
    }
    else {
        return toSql(result, sqlfier);
    }
}
exports.toSql = toSql;
//# sourceMappingURL=to-sql.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/try-extract-ast.js":
/*!************************************************!*\
  !*** ../tsql/dist/ast/util/try-extract-ast.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "../tsql/dist/ast/parentheses.js");
/**
 * + If the AST satisfies the predicate, it is returned.
 * + If the AST is a `Parentheses` that contains an AST satisfying the predicate,
 * the `Parentheses` is returned.
 * + Else, `undefined` is returned.
 */
function tryExtractAst(operand, extractDelegate) {
    const extractResult = extractDelegate(operand);
    if (extractResult != undefined) {
        if (typeof extractResult == "boolean") {
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (extractResult) {
                return operand;
            }
        }
        else {
            return extractResult;
        }
    }
    if (parentheses_1.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
        return tryExtractAst(operand.ast, extractDelegate);
    }
    return undefined;
}
exports.tryExtractAst = tryExtractAst;
function tryExtractAstOr(operand, extractDelegate, noMatchDelegate) {
    const extractResult = extractDelegate(operand);
    if (extractResult != undefined) {
        if (typeof extractResult == "boolean") {
            if (extractResult) {
                return operand;
            }
        }
        else {
            return extractResult;
        }
    }
    if (parentheses_1.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
        return tryExtractAstOr(operand.ast, extractDelegate, noMatchDelegate);
    }
    return noMatchDelegate(operand);
}
exports.tryExtractAstOr = tryExtractAstOr;
//# sourceMappingURL=try-extract-ast.js.map

/***/ }),

/***/ "../tsql/dist/ast/util/try-unwrap-parentheses.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/ast/util/try-unwrap-parentheses.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "../tsql/dist/ast/parentheses.js");
function tryUnwrapParentheses(ast) {
    if (parentheses_1.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
        return ast.ast;
    }
    else {
        return ast;
    }
}
exports.tryUnwrapParentheses = tryUnwrapParentheses;
//# sourceMappingURL=try-unwrap-parentheses.js.map

/***/ }),

/***/ "../tsql/dist/async-queue.js":
/*!***********************************!*\
  !*** ../tsql/dist/async-queue.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const promise_util_1 = __webpack_require__(/*! ./promise-util */ "../tsql/dist/promise-util/index.js");
const emptyPromise = Promise.resolve();
class AsyncQueueStoppingError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, AsyncQueueStoppingError.prototype);
    }
}
exports.AsyncQueueStoppingError = AsyncQueueStoppingError;
AsyncQueueStoppingError.prototype.name = "AsyncQueueStoppingError";
/**
 * Only one `ItemT` can be allocated at a time.
 * Only one enqueued callback can be running at a time.
 *
 * This can be used to implement `IConnection.lock()`
 */
class AsyncQueue {
    constructor(allocateDelegate) {
        this.shouldStop = false;
        this.lastPromise = emptyPromise;
        this.deallocateErr = undefined;
        /**
         * Enqueues a callback that will be run asynchronously.
         *
         * Only one callback will be running at any given time.
         */
        this.enqueue = (callback) => {
            if (this.shouldStop) {
                return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
            }
            if (this.deallocateErr != undefined) {
                /**
                 * We should not enqueue anymore callbacks,
                 * our allocator/deallocator has run into problems.
                 */
                return Promise.reject(this.deallocateErr);
            }
            const tryResetQueue = () => {
                if (this.lastPromise == callbackPromise) {
                    this.lastPromise = emptyPromise;
                }
            };
            const runCallback = () => {
                /**
                 * It's okay if this throws because we execute
                 * `runCallback` inside of a `.then()`
                 */
                const { item, deallocate } = this.allocateDelegate();
                return promise_util_1.invokeAsyncCallbackSafely(() => callback(item), (result) => {
                    return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                        tryResetQueue();
                        return result;
                    }, (deallocateErr) => {
                        tryResetQueue();
                        this.deallocateErr = deallocateErr;
                        return result;
                    });
                }, (callbackErr) => {
                    return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                        tryResetQueue();
                        return Promise.reject(callbackErr);
                    }, (deallocateErr) => {
                        tryResetQueue();
                        this.deallocateErr = deallocateErr;
                        return Promise.reject(callbackErr);
                    });
                });
            };
            const callbackPromise = this.lastPromise.then(runCallback, runCallback);
            this.lastPromise = callbackPromise;
            return callbackPromise;
        };
        /**
         * This makes all future calls to `.enqueue()` throw a run-time error.
         *
         * Returns a promise that resolves when the last enqueued
         * callback resolves.
         */
        this.stop = () => {
            this.shouldStop = true;
            return this.lastPromise.then(() => { }, () => { });
        };
        /**
         * Enqueues a callback that will be run asynchronously.
         * This callback will be given another `AsyncQueue` instance.
         *
         * This `AsyncQueue` will wait for the other instance to
         * complete before continuing.
         *
         * Only one callback will be running at any given time.
         */
        this.lock = (callback) => {
            if (this.shouldStop) {
                return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
            }
            if (this.deallocateErr != undefined) {
                /**
                 * We should not enqueue anymore callbacks,
                 * our allocator/deallocator has run into problems.
                 */
                return Promise.reject(this.deallocateErr);
            }
            const tryResetQueue = () => {
                if (this.lastPromise == callbackPromise) {
                    this.lastPromise = emptyPromise;
                }
            };
            const runCallback = () => {
                const nestedAsyncQueue = new AsyncQueue(this.allocateDelegate);
                return promise_util_1.invokeAsyncCallbackSafely(() => callback(nestedAsyncQueue), (result) => {
                    const onStop = () => {
                        tryResetQueue();
                        /**
                         * Copy over the `deallocateErr` because
                         * they share the same `allocateDelegate`
                         */
                        this.deallocateErr = nestedAsyncQueue.deallocateErr;
                        return result;
                    };
                    /**
                     * Calling `.stop()` should never throw a synchronous error...
                     * I think.
                     */
                    return nestedAsyncQueue.stop()
                        .then(onStop, onStop);
                }, (callbackErr) => {
                    const onStop = () => {
                        tryResetQueue();
                        /**
                         * Copy over the `deallocateErr` because
                         * they share the same `allocateDelegate`
                         */
                        this.deallocateErr = nestedAsyncQueue.deallocateErr;
                        return Promise.reject(callbackErr);
                    };
                    /**
                     * Calling `.stop()` should never throw a synchronous error...
                     * I think.
                     */
                    return nestedAsyncQueue.stop()
                        .then(onStop, onStop);
                });
            };
            const callbackPromise = this.lastPromise.then(runCallback, runCallback);
            this.lastPromise = callbackPromise;
            return callbackPromise;
        };
        this.allocateDelegate = allocateDelegate;
    }
    getShouldStop() {
        return this.shouldStop;
    }
}
exports.AsyncQueue = AsyncQueue;
//# sourceMappingURL=async-queue.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/built-in-expr/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BuiltInExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/built-in-expr/util/index.js");
exports.BuiltInExprUtil = BuiltInExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/built-in-expr/util/predicate/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/built-in-expr/util/query/index.js");
const from_value_expr_1 = __webpack_require__(/*! ./from-value-expr */ "../tsql/dist/built-in-expr/util/constructor/from-value-expr.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
 * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
 */
function fromCustomExpr_MapCorrelated(mapper, allowed, customExpr) {
    if (predicate_1.isAnyNonValueExpr(customExpr)) {
        used_ref_1.UsedRefUtil.assertAllowed(allowed, query_1.usedRef(customExpr));
        return customExpr;
    }
    else {
        return from_value_expr_1.fromValueExpr(mapper, customExpr);
    }
}
exports.fromCustomExpr_MapCorrelated = fromCustomExpr_MapCorrelated;
//# sourceMappingURL=from-custom-expr-map-correlated.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/constructor/from-value-expr.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/constructor/from-value-expr.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
 * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
 */
function fromValueExpr(mapper, value) {
    let valueName = "literal-value";
    if (column_1.ColumnUtil.isColumn(mapper)) {
        valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
        mapper = mapper.mapper;
    }
    if (data_type_1.DataTypeUtil.isDataType(mapper)) {
        return mapper.toBuiltInExpr_NonCorrelated(
        /**
         * Validate the incoming value again, just to be sure...
         */
        mapper(valueName, value));
    }
    else {
        if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(value)) {
            return mapper(valueName, value);
        }
        else {
            /**
             * @todo Custom `Error` type
             */
            throw new Error(`Don't know how to convert ${tm.TypeUtil.toTypeStr(value)} value with keys ${Object.keys(value).map(k => JSON.stringify(k)).join(", ")} to RawExpr`);
        }
    }
}
exports.fromValueExpr = fromValueExpr;
//# sourceMappingURL=from-value-expr.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/constructor/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/constructor/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-custom-expr-map-correlated */ "../tsql/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js"));
__export(__webpack_require__(/*! ./from-value-expr */ "../tsql/dist/built-in-expr/util/constructor/from-value-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/built-in-expr/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/built-in-expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/built-in-expr/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/built-in-expr/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/operation/build-ast.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/operation/build-ast.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "../tsql/dist/date-util/index.js");
/**
 * + `bigint` is considered a `signed bigint` by this library.
 * +`DECIMAL` is not supported by this function.
 * +`BIGINT UNSIGNED` is not supported by this function.
 */
function buildAst(builtInExpr) {
    //Check built-in cases first
    if (typeof builtInExpr == "number") {
        return ast_1.LiteralValueNodeUtil.doubleLiteralNode(builtInExpr);
    }
    if (tm.TypeUtil.isBigInt(builtInExpr)) {
        return ast_1.LiteralValueNodeUtil.bigIntSignedLiteralNode(builtInExpr);
    }
    if (typeof builtInExpr == "string") {
        return ast_1.LiteralValueNodeUtil.stringLiteralNode(builtInExpr);
    }
    if (typeof builtInExpr == "boolean") {
        return ast_1.LiteralValueNodeUtil.booleanLiteralNode(builtInExpr);
    }
    if (date_util_1.isDate(builtInExpr)) {
        return ast_1.LiteralValueNodeUtil.dateTimeLiteralNode(builtInExpr);
    }
    if (builtInExpr instanceof Uint8Array) {
        //escape(Buffer.from("hello")) == "X'68656c6c6f'"
        return ast_1.LiteralValueNodeUtil.bufferLiteralNode(builtInExpr);
    }
    if (builtInExpr === null) {
        return ast_1.LiteralValueNodeUtil.nullLiteralNode(builtInExpr);
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.ast;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return column_1.ColumnUtil.buildAst(builtInExpr);
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(builtInExpr)) {
        /**
         * @todo Check if this is desirable
         */
        //return builtInExpr.buildExprAst();
        return ast_1.parentheses(builtInExpr, false /*canUnwrap*/);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        /**
         * @todo Check if this is desirable.
         * If anything, the `query` ast, when used as a value query,
         * should wrap an unwrappable parentheses around itself.
         */
        //return Parentheses.Create(builtInExpr.unaliasedAst, false/*canUnwrap*/);
        return ast_1.parentheses(builtInExpr.unaliasedAst);
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.buildAst = buildAst;
//# sourceMappingURL=build-ast.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./build-ast */ "../tsql/dist/built-in-expr/util/operation/build-ast.js"));
__export(__webpack_require__(/*! ./intersect-used-ref */ "../tsql/dist/built-in-expr/util/operation/intersect-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/operation/intersect-used-ref.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/operation/intersect-used-ref.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/built-in-expr/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function intersectUsedRef(...arr) {
    const result = used_ref_1.UsedRefUtil.intersect(...arr.map(u => query_1.usedRef(u)));
    return result;
}
exports.intersectUsedRef = intersectUsedRef;
//# sourceMappingURL=intersect-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/assert-non-aggregate.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/assert-non-aggregate.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/built-in-expr/util/query/index.js");
function assertNonAggregate(name, builtInExpr) {
    if (query_1.isAggregate(builtInExpr)) {
        throw new Error(`${name} must not be an aggregate expression`);
    }
}
exports.assertNonAggregate = assertNonAggregate;
function assertAllNonAggregate(name, builtInExprArr) {
    for (let i = 0; i < builtInExprArr.length; ++i) {
        assertNonAggregate(`${name}[${i}]`, builtInExprArr[i]);
    }
}
exports.assertAllNonAggregate = assertAllNonAggregate;
//# sourceMappingURL=assert-non-aggregate.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/assert-non-null.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/assert-non-null.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/built-in-expr/util/query/index.js");
/**
 * @todo Rename to `assertNonNullable`
 */
function assertNonNull(name, builtInExpr) {
    if (tm.canOutputNull(query_1.mapper(builtInExpr))) {
        throw new Error(`${name} must not be nullable`);
    }
}
exports.assertNonNull = assertNonNull;
//# sourceMappingURL=assert-non-null.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-non-aggregate */ "../tsql/dist/built-in-expr/util/predicate/assert-non-aggregate.js"));
__export(__webpack_require__(/*! ./assert-non-null */ "../tsql/dist/built-in-expr/util/predicate/assert-non-null.js"));
__export(__webpack_require__(/*! ./is-any-non-value-expr */ "../tsql/dist/built-in-expr/util/predicate/is-any-non-value-expr.js"));
__export(__webpack_require__(/*! ./is-any-subquery-expr */ "../tsql/dist/built-in-expr/util/predicate/is-any-subquery-expr.js"));
__export(__webpack_require__(/*! ./is-built-in-expr */ "../tsql/dist/built-in-expr/util/predicate/is-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/is-any-non-value-expr.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/is-any-non-value-expr.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
function isAnyNonValueExpr(mixed) {
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mixed)) {
        return false;
    }
    if (expr_1.ExprUtil.isExpr(mixed)) {
        return true;
    }
    if (column_1.ColumnUtil.isColumn(mixed)) {
        return true;
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(mixed)) {
        return true;
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(mixed)) {
        return true;
    }
    return false;
}
exports.isAnyNonValueExpr = isAnyNonValueExpr;
//# sourceMappingURL=is-any-non-value-expr.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/is-any-subquery-expr.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/is-any-subquery-expr.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
function isAnySubqueryExpr(x) {
    return query_base_1.QueryBaseUtil.isOneSelectItem(x) && query_base_1.QueryBaseUtil.isZeroOrOneRow(x);
}
exports.isAnySubqueryExpr = isAnySubqueryExpr;
//# sourceMappingURL=is-any-subquery-expr.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/predicate/is-built-in-expr.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/predicate/is-built-in-expr.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const is_any_non_value_expr_1 = __webpack_require__(/*! ./is-any-non-value-expr */ "../tsql/dist/built-in-expr/util/predicate/is-any-non-value-expr.js");
function isBuiltInExpr(raw) {
    return (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(raw) ||
        is_any_non_value_expr_1.isAnyNonValueExpr(raw));
}
exports.isBuiltInExpr = isBuiltInExpr;
//# sourceMappingURL=is-built-in-expr.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/query/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/query/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-aggregate */ "../tsql/dist/built-in-expr/util/query/is-aggregate.js"));
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/built-in-expr/util/query/mapper.js"));
__export(__webpack_require__(/*! ./used-ref */ "../tsql/dist/built-in-expr/util/query/used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/query/is-aggregate.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/query/is-aggregate.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isAggregate(builtInExpr) {
    if (builtInExpr instanceof Object &&
        "isAggregate" in builtInExpr &&
        typeof builtInExpr.isAggregate == "boolean") {
        return builtInExpr.isAggregate;
    }
    /**
     * If this came from the`SELECT` clause,
     * it may be an aggregate expression, or a non-aggregate expression.
     *
     * We need to know if this is an aggregate expression to avoid the following query,
     * ```sql
     *  SELECT
     *      COUNT(*) AS x
     *  FROM
     *      T
     *  GROUP BY
     *      id
     *  ORDER BY
     *      -- Error, Cannot nest aggregate expressions
     *      SUM(x) ASC;
     * ```
     *
     * @todo Fix the `OrderByDelegate` to not use `ColumnRef`
     */
    return false;
}
exports.isAggregate = isAggregate;
//# sourceMappingURL=is-aggregate.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/query/mapper.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/query/mapper.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "../tsql/dist/date-util/index.js");
function mapper(builtInExpr) {
    //Check built-in cases first
    if (typeof builtInExpr == "number") {
        /**
         * The SQL standard forbids NaN, Infinity, -Infinity.
         * However, SQLite supports infinities.
         *
         * The job of throwing on these 3 values will have to
         * fall to the sqlfiers.
         */
        return tm.toUnsafeNumber();
    }
    if (tm.TypeUtil.isBigInt(builtInExpr)) {
        return tm.toBigInt();
    }
    if (typeof builtInExpr == "string") {
        return tm.string();
    }
    if (typeof builtInExpr == "boolean") {
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        builtInExpr ?
            tm.mysql.true() :
            tm.mysql.false());
    }
    if (date_util_1.isDate(builtInExpr)) {
        return tm.mysql.dateTime(3);
    }
    if (builtInExpr instanceof Uint8Array) {
        return tm.instanceOfUint8Array();
    }
    if (builtInExpr === null) {
        return tm.null();
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.mapper;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return builtInExpr.mapper;
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(builtInExpr) &&
        query_base_1.QueryBaseUtil.isZeroOrOneRow(builtInExpr)) {
        return query_base_1.QueryBaseUtil.mapper(builtInExpr);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return builtInExpr.mapper;
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/built-in-expr/util/query/used-ref.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/built-in-expr/util/query/used-ref.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
function usedRef(builtInExpr) {
    //Check built-in cases first
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromColumnRef({});
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.usedRef;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromColumn(builtInExpr);
    }
    if (query_base_1.QueryBaseUtil.isQuery(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromFromClause(builtInExpr.fromClause);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return builtInExpr.usedRef;
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.usedRef = usedRef;
//# sourceMappingURL=used-ref.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/array-util/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/array-util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/built-in-value-expr/array-util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/array-util/predicate/index.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/array-util/predicate/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-non-null-built-in-value-expr-array */ "../tsql/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js"));
__export(__webpack_require__(/*! ./is-built-in-value-expr-array */ "../tsql/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_built_in_value_expr_1 = __webpack_require__(/*! ../../util/predicate/is-built-in-value-expr */ "../tsql/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js");
function isBuiltInValueExprArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!is_built_in_value_expr_1.isBuiltInValueExpr(item)) {
            return false;
        }
    }
    return true;
}
exports.isBuiltInValueExprArray = isBuiltInValueExprArray;
//# sourceMappingURL=is-built-in-value-expr-array.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js":
/*!******************************************************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_non_null_built_in_value_expr_1 = __webpack_require__(/*! ../../util/predicate/is-non-null-built-in-value-expr */ "../tsql/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js");
function isNonNullBuiltInValueExprArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!is_non_null_built_in_value_expr_1.isNonNullBuiltInValueExpr(item)) {
            return false;
        }
    }
    return true;
}
exports.isNonNullBuiltInValueExprArray = isNonNullBuiltInValueExprArray;
//# sourceMappingURL=is-non-null-built-in-value-expr-array.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BuiltInValueExprArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/built-in-value-expr/array-util/index.js");
exports.BuiltInValueExprArrayUtil = BuiltInValueExprArrayUtil;
const BuiltInValueExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/built-in-value-expr/util/index.js");
exports.BuiltInValueExprUtil = BuiltInValueExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/util/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/util/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/built-in-value-expr/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/util/predicate/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/util/predicate/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-equal */ "../tsql/dist/built-in-value-expr/util/predicate/is-equal.js"));
__export(__webpack_require__(/*! ./is-non-null-built-in-value-expr */ "../tsql/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js"));
__export(__webpack_require__(/*! ./is-built-in-value-expr */ "../tsql/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "../tsql/dist/date-util/index.js");
function isBuiltInValueExpr(raw) {
    if (tm.TypeUtil.isBigInt(raw)) {
        return true;
    }
    switch (typeof raw) {
        case "number":
        case "string":
        case "boolean": {
            return true;
        }
    }
    if (date_util_1.isDate(raw)) {
        return true;
    }
    if (raw instanceof Uint8Array) {
        return true;
    }
    if (raw === null) {
        return true;
    }
    return false;
}
exports.isBuiltInValueExpr = isBuiltInValueExpr;
//# sourceMappingURL=is-built-in-value-expr.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/util/predicate/is-equal.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/util/predicate/is-equal.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "../tsql/dist/date-util/index.js");
function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (date_util_1.isDate(a)) {
        if (date_util_1.isDate(b)) {
            if (isNaN(a.getTime()) && isNaN(b.getTime())) {
                return true;
            }
            return a.getTime() === b.getTime();
        }
        else {
            return false;
        }
    }
    if (a instanceof Uint8Array) {
        if (b instanceof Uint8Array) {
            return tm.ArrayBufferUtil.equals(a, b);
        }
        else {
            return false;
        }
    }
    /**
     * Use `strictEqual()` algorithm that handles `bigint` polyfill
     */
    return tm.TypeUtil.strictEqual(a, b);
}
exports.isEqual = isEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "../tsql/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js":
/*!******************************************************************************************!*\
  !*** ../tsql/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_built_in_value_expr_1 = __webpack_require__(/*! ./is-built-in-value-expr */ "../tsql/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js");
function isNonNullBuiltInValueExpr(raw) {
    if (raw === null) {
        return false;
    }
    return is_built_in_value_expr_1.isBuiltInValueExpr(raw);
}
exports.isNonNullBuiltInValueExpr = isNonNullBuiltInValueExpr;
//# sourceMappingURL=is-non-null-built-in-value-expr.js.map

/***/ }),

/***/ "../tsql/dist/candidate-key/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/candidate-key/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CandidateKeyUtil = __webpack_require__(/*! ./util */ "../tsql/dist/candidate-key/util/index.js");
exports.CandidateKeyUtil = CandidateKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/candidate-key/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/candidate-key/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/candidate-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/candidate-key/util/query/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/candidate-key/util/query/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/candidate-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/candidate-key/util/query/mapper.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/candidate-key/util/query/mapper.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
function mapper(table) {
    return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
        return column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, candidateKey));
    }));
}
exports.mapper = mapper;
function mapperPreferPrimaryKey(table) {
    if (table.primaryKey == undefined) {
        return mapper(table);
    }
    return tm.unsafeOr(primary_key_1.PrimaryKeyUtil.mapper(table), mapper(table));
}
exports.mapperPreferPrimaryKey = mapperPreferPrimaryKey;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column-identifier-map/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierMapUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column-identifier-map/util/index.js");
exports.ColumnIdentifierMapUtil = ColumnIdentifierMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/constructor/from-column-map.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/constructor/from-column-map.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
function fromColumnMap(columnMap) {
    return Object.keys(columnMap).reduce((memo, columnAlias) => {
        memo[columnAlias] = column_identifier_1.ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]);
        return memo;
    }, {});
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/constructor/index.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/constructor/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier-map/util/constructor/from-column-map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-identifier-map/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/column-identifier-map/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-identifier-map/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/column-identifier-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/operation/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/operation/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/column-identifier-map/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/operation/intersect.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/operation/intersect.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function intersect(mapA, mapB) {
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...mapA,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/predicate/has-column-identifier.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/predicate/has-column-identifier.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
function hasColumnIdentifier(map, identifier) {
    const column = map[identifier.columnAlias];
    if (!column_identifier_1.ColumnIdentifierUtil.isColumnIdentifier(column)) {
        return false;
    }
    return column_identifier_1.ColumnIdentifierUtil.isEqual(column, identifier);
}
exports.hasColumnIdentifier = hasColumnIdentifier;
function assertHasColumnIdentifier(map, identifier) {
    if (!hasColumnIdentifier(map, identifier)) {
        throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier map`);
    }
}
exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
function assertHasColumnIdentifiers(map, identifiers) {
    for (const columnIdentifier of identifiers) {
        assertHasColumnIdentifier(map, columnIdentifier);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=has-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/predicate/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/predicate/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-column-identifier */ "../tsql/dist/column-identifier-map/util/predicate/has-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/query/extract-column-identifier.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/query/extract-column-identifier.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Does not check `tableAlias`
 */
function extractColumnIdentifiers(map, columnIdentifiers) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-map/util/query/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column-identifier-map/util/query/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "../tsql/dist/column-identifier-map/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierRefUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column-identifier-ref/util/index.js");
exports.ColumnIdentifierRefUtil = ColumnIdentifierRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/constructor/from-column-map.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/constructor/from-column-map.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier-ref/util/constructor/from-column.js");
function appendColumnMap(ref, columnMap) {
    for (const columnAlias of Object.keys(columnMap)) {
        from_column_1.appendColumn(ref, columnMap[columnAlias]);
    }
    return ref;
}
exports.appendColumnMap = appendColumnMap;
function fromColumnMap(columnMap) {
    const result = appendColumnMap({}, columnMap);
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/constructor/from-column.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/constructor/from-column.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
function appendColumn(ref, column) {
    let map = ref[column.tableAlias];
    if (map == undefined) {
        map = {};
        ref[column.tableAlias] = map;
    }
    map[column.columnAlias] = column_identifier_1.ColumnIdentifierUtil.fromColumn(column);
    return ref;
}
exports.appendColumn = appendColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/constructor/from-join-array.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/constructor/from-join-array.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier-ref/util/constructor/from-column-map.js");
function appendJoin(ref, join) {
    from_column_map_1.appendColumnMap(ref, join.columns);
    return ref;
}
exports.appendJoin = appendJoin;
function appendJoinArray(ref, arr) {
    for (const join of arr) {
        appendJoin(ref, join);
    }
    return ref;
}
exports.appendJoinArray = appendJoinArray;
function fromJoinArray(arr) {
    const result = {};
    appendJoinArray(result, arr);
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/constructor/from-select-clause.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/constructor/from-select-clause.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier-ref/util/constructor/from-column.js");
function fromSelectClause(selectClause) {
    const result = {};
    for (const columnIdentifier of column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selectClause)) {
        from_column_1.appendColumn(result, columnIdentifier);
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/constructor/index.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/constructor/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier-ref/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-join-array */ "../tsql/dist/column-identifier-ref/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "../tsql/dist/column-identifier-ref/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-identifier-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/column-identifier-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-identifier-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/column-identifier-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/operation/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/operation/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/column-identifier-ref/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./left-intersect */ "../tsql/dist/column-identifier-ref/util/operation/left-intersect.js"));
__export(__webpack_require__(/*! ./try-flatten */ "../tsql/dist/column-identifier-ref/util/operation/try-flatten.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/operation/intersect.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/operation/intersect.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "../tsql/dist/column-identifier-ref/util/operation/left-intersect.js");
function intersect(refA, refB) {
    const left = left_intersect_1.leftIntersect(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/operation/left-intersect.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/operation/left-intersect.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function leftIntersect(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_identifier_map_1.ColumnIdentifierMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/operation/try-flatten.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/operation/try-flatten.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryFlatten(ref) {
    const tableAliases = Object.keys(ref);
    if (tableAliases.length == 1) {
        return ref[tableAliases[0]];
    }
    else {
        return ref;
    }
}
exports.tryFlatten = tryFlatten;
//# sourceMappingURL=try-flatten.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/predicate/has-column-identifier.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/predicate/has-column-identifier.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function hasColumnIdentifier(ref, identifier) {
    if (!Object.prototype.hasOwnProperty.call(ref, identifier.tableAlias)) {
        return false;
    }
    const columnMap = ref[identifier.tableAlias];
    return column_identifier_map_1.ColumnIdentifierMapUtil.hasColumnIdentifier(columnMap, identifier);
}
exports.hasColumnIdentifier = hasColumnIdentifier;
function assertHasColumnIdentifier(ref, identifier) {
    if (!hasColumnIdentifier(ref, identifier)) {
        throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier ref`);
    }
}
exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
function assertHasColumnIdentifiers(ref, identifiers) {
    for (const identifier of identifiers) {
        assertHasColumnIdentifier(ref, identifier);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=has-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/predicate/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/predicate/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-column-identifier */ "../tsql/dist/column-identifier-ref/util/predicate/has-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/query/extract-column-identifier.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/query/extract-column-identifier.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function extractColumnIdentifiers(ref, columnIdentifiers) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
        if (arr.length > 0) {
            result[tableAlias] = column_identifier_map_1.ColumnIdentifierMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier-ref/util/query/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column-identifier-ref/util/query/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "../tsql/dist/column-identifier-ref/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/constructor/from-column-map.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/constructor/from-column-map.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/column-identifier/util/index.js");
function fromColumnMap(columnMap) {
    const result = [];
    for (const columnAlias of Object.keys(columnMap)) {
        result.push(ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]));
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/constructor/from-column-ref.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/constructor/from-column-ref.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier/array-util/constructor/from-column-map.js");
function fromColumnRef(columnRef) {
    const result = [];
    for (const tableAlias of Object.keys(columnRef)) {
        result.push(...from_column_map_1.fromColumnMap(columnRef[tableAlias]));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/constructor/index.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/constructor/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier/array-util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column-identifier/array-util/constructor/from-column-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-identifier/array-util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-identifier/array-util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/predicate/assert-disjoint.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/predicate/assert-disjoint.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../util */ "../tsql/dist/column-identifier/util/index.js");
function assertDisjoint(arrA, arrB) {
    for (const a of arrA) {
        for (const b of arrB) {
            if (util_1.isEqual(a, b)) {
                throw new Error(`Duplicate column identifier ${a.tableAlias}.${a.columnAlias} found; consider aliasing`);
            }
        }
    }
}
exports.assertDisjoint = assertDisjoint;
//# sourceMappingURL=assert-disjoint.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/predicate/assert-no-duplicate.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/predicate/assert-no-duplicate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../util */ "../tsql/dist/column-identifier/util/index.js");
function assertNoDuplicate(arr) {
    for (let i = 0; i < arr.length; ++i) {
        for (let j = i + 1; j < arr.length; ++j) {
            if (util_1.isEqual(arr[i], arr[j])) {
                throw new Error(`Duplicate column identifier ${arr[i].tableAlias}.${arr[i].columnAlias}`);
            }
        }
    }
}
exports.assertNoDuplicate = assertNoDuplicate;
//# sourceMappingURL=assert-no-duplicate.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/array-util/predicate/index.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-identifier/array-util/predicate/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-disjoint */ "../tsql/dist/column-identifier/array-util/predicate/assert-disjoint.js"));
__export(__webpack_require__(/*! ./assert-no-duplicate */ "../tsql/dist/column-identifier/array-util/predicate/assert-no-duplicate.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/column-identifier/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/column-identifier/array-util/index.js");
exports.ColumnIdentifierArrayUtil = ColumnIdentifierArrayUtil;
const ColumnIdentifierUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column-identifier/util/index.js");
exports.ColumnIdentifierUtil = ColumnIdentifierUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-column-map.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-column-map.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier/util/constructor/from-column.js");
function fromColumnMap(map) {
    const result = [];
    for (const columnAlias of Object.keys(map)) {
        result.push(from_column_1.fromColumn(map[columnAlias]));
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-column-ref.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-column-ref.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier/util/constructor/from-column-map.js");
function fromColumnRef(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        result.push(...from_column_map_1.fromColumnMap(ref[tableAlias]));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-column.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-column.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = {
        tableAlias: column.tableAlias,
        columnAlias: column.columnAlias,
    };
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-expr-select-item.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-expr-select-item.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromExprSelectItem(column) {
    const result = {
        tableAlias: column.tableAlias,
        columnAlias: column.alias,
    };
    return result;
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-select-clause.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-select-clause.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "../tsql/dist/column-identifier/util/constructor/from-select-item.js");
/**
 * Does not remove duplicate identifiers
 *
 * @param selectClause
 */
function fromSelectClause(selectClause) {
    const result = [];
    for (const selectItem of selectClause) {
        result.push(...from_select_item_1.fromSelectItem(selectItem));
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/from-select-item.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/from-select-item.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "../tsql/dist/column-identifier/util/constructor/from-expr-select-item.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier/util/constructor/from-column.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column-identifier/util/constructor/from-column-ref.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier/util/constructor/from-column-map.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function fromSelectItem(selectItem) {
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
        return [from_expr_select_item_1.fromExprSelectItem(selectItem)];
    }
    else if (column_1.ColumnUtil.isColumn(selectItem)) {
        return [from_column_1.fromColumn(selectItem)];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
        return from_column_map_1.fromColumnMap(selectItem);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(selectItem)) {
        return from_column_ref_1.fromColumnRef(selectItem);
    }
    else {
        throw new Error(`Unknown SelectItem`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/constructor/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/constructor/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-identifier/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column-identifier/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/column-identifier/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-expr-select-item */ "../tsql/dist/column-identifier/util/constructor/from-expr-select-item.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "../tsql/dist/column-identifier/util/constructor/from-select-clause.js"));
__export(__webpack_require__(/*! ./from-select-item */ "../tsql/dist/column-identifier/util/constructor/from-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/column-identifier/util/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-identifier/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-identifier/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/predicate/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/predicate/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column-identifier */ "../tsql/dist/column-identifier/util/predicate/is-column-identifier.js"));
__export(__webpack_require__(/*! ./is-equal */ "../tsql/dist/column-identifier/util/predicate/is-equal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/predicate/is-column-identifier.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/predicate/is-column-identifier.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function isColumnIdentifier(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias"
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string"));
}
exports.isColumnIdentifier = isColumnIdentifier;
//# sourceMappingURL=is-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-identifier/util/predicate/is-equal.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/column-identifier/util/predicate/is-equal.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isEqual(a, b) {
    return (a.tableAlias == b.tableAlias &&
        a.columnAlias == b.columnAlias);
}
exports.isEqual = isEqual;
function assertIsEqual(a, b) {
    if (a.tableAlias != b.tableAlias) {
        throw new Error(`Table alias mismatch ${a.tableAlias} != ${b.tableAlias}`);
    }
    if (a.columnAlias != b.columnAlias) {
        throw new Error(`Column alias mismatch ${a.columnAlias} != ${b.columnAlias}`);
    }
}
exports.assertIsEqual = assertIsEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "../tsql/dist/column-map/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/column-map/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnMapUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column-map/util/index.js");
exports.ColumnMapUtil = ColumnMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-column-array.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-column-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnArray(columns) {
    const result = {};
    for (const column of columns) {
        result[column.columnAlias] = column;
    }
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-column-ref.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-column-ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnRef(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const columnMap = ref[tableAlias];
        for (const columnAlias in columnMap) {
            const column = columnMap[columnAlias];
            result[column.columnAlias] = column;
        }
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-column.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-column.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    return {
        [column.columnAlias]: column
    };
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-expr-select-item.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-expr-select-item.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-map/util/constructor/from-column.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function fromExprSelectItem(item) {
    return from_column_1.fromColumn(column_1.ColumnUtil.fromExprSelectItem(item));
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-field-array.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-field-array.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function fromFieldArray(tableAlias, fields) {
    const result = {};
    for (const field of fields) {
        result[field.__name] = new column_1.Column({
            tableAlias: tableAlias,
            columnAlias: field.__name,
            mapper: field,
        }, undefined);
    }
    return result;
}
exports.fromFieldArray = fromFieldArray;
//# sourceMappingURL=from-field-array.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-join.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-join.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/column-map/util/operation/index.js");
function fromJoin(join) {
    if (join.nullable) {
        return operation_1.toNullable(join.columns);
    }
    else {
        return join.columns;
    }
}
exports.fromJoin = fromJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-mapper-map.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-mapper-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function fromMapperMap(tableAlias, mapperMap) {
    const result = {};
    for (const columnAlias of Object.keys(mapperMap)) {
        result[columnAlias] = new column_1.Column({
            tableAlias,
            columnAlias,
            mapper: mapperMap[columnAlias],
        }, undefined);
    }
    return result;
}
exports.fromMapperMap = fromMapperMap;
//# sourceMappingURL=from-mapper-map.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-select-clause.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-select-clause.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "../tsql/dist/column-map/util/constructor/from-select-item.js");
/**
 * Assumes no duplicate `columnAlias` in `SelectClauseT`
 */
function fromSelectClause(selectsClause, tableAlias, preserveUnaliasedAst) {
    const result = {};
    for (const item of selectsClause) {
        const map = from_select_item_1.fromSelectItem(item);
        for (const columnAlias of Object.keys(map)) {
            if (preserveUnaliasedAst) {
                result[columnAlias] = column_1.ColumnUtil.withTableAlias(map[columnAlias], tableAlias);
            }
            else {
                result[columnAlias] = column_1.ColumnUtil.withUnaliasedAst(column_1.ColumnUtil.withTableAlias(map[columnAlias], tableAlias), undefined);
            }
        }
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/from-select-item.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/from-select-item.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-map/util/constructor/from-column.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "../tsql/dist/column-map/util/constructor/from-expr-select-item.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column-map/util/constructor/from-column-ref.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/column-map/util/predicate/index.js");
function fromSelectItem(item) {
    if (column_1.ColumnUtil.isColumn(item)) {
        return from_column_1.fromColumn(item);
    }
    else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(item)) {
        return from_expr_select_item_1.fromExprSelectItem(item);
    }
    else if (predicate_1.isColumnMap(item)) {
        return item;
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
        return from_column_ref_1.fromColumnRef(item);
    }
    else {
        throw new Error(`Unknown select item`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/constructor/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/column-map/util/constructor/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "../tsql/dist/column-map/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/column-map/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-field-array */ "../tsql/dist/column-map/util/constructor/from-field-array.js"));
__export(__webpack_require__(/*! ./from-join */ "../tsql/dist/column-map/util/constructor/from-join.js"));
__export(__webpack_require__(/*! ./from-mapper-map */ "../tsql/dist/column-map/util/constructor/from-mapper-map.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "../tsql/dist/column-map/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/column-map/util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-map/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/column-map/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-map/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/column-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/compound.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/compound.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_compound_1 = __webpack_require__(/*! ./left-compound */ "../tsql/dist/column-map/util/operation/left-compound.js");
function compound(mapA, mapB) {
    const left = left_compound_1.leftCompound(mapA, mapB);
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.compound = compound;
//# sourceMappingURL=compound.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound */ "../tsql/dist/column-map/util/operation/compound.js"));
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/column-map/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./left-compound */ "../tsql/dist/column-map/util/operation/left-compound.js"));
__export(__webpack_require__(/*! ./left-intersect */ "../tsql/dist/column-map/util/operation/left-intersect.js"));
__export(__webpack_require__(/*! ./omit */ "../tsql/dist/column-map/util/operation/omit.js"));
__export(__webpack_require__(/*! ./pick */ "../tsql/dist/column-map/util/operation/pick.js"));
__export(__webpack_require__(/*! ./replace-column */ "../tsql/dist/column-map/util/operation/replace-column.js"));
__export(__webpack_require__(/*! ./to-nullable */ "../tsql/dist/column-map/util/operation/to-nullable.js"));
__export(__webpack_require__(/*! ./with-table-alias */ "../tsql/dist/column-map/util/operation/with-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/intersect.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/intersect.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "../tsql/dist/column-map/util/operation/left-intersect.js");
function intersect(mapA, mapB) {
    const left = left_intersect_1.leftIntersect(mapA, mapB);
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/left-compound.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/left-compound.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function leftCompound(mapA, mapB) {
    const result = {};
    for (const columnAlias of Object.keys(mapA)) {
        const columnA = mapA[columnAlias];
        const columnB = mapB[columnAlias];
        if (column_1.ColumnUtil.isColumn(columnB)) {
            result[columnAlias] = new column_1.Column({
                tableAlias: columnA.tableAlias,
                columnAlias: columnA.columnAlias,
                mapper: tm.or(columnA.mapper, mapB[columnAlias].mapper),
            }, columnA.unaliasedAst);
        }
        else {
            result[columnAlias] = columnA;
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/left-intersect.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/left-intersect.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
function leftIntersect(mapA, mapB) {
    const result = {};
    for (const columnAlias of Object.keys(mapA)) {
        const columnA = mapA[columnAlias];
        const columnB = mapB[columnAlias];
        if (column_1.ColumnUtil.isColumn(columnB)) {
            result[columnAlias] = new column_1.Column({
                tableAlias: columnA.tableAlias,
                columnAlias: columnA.columnAlias,
                mapper: data_type_1.DataTypeUtil.intersect(columnA.mapper, mapB[columnAlias].mapper),
            }, columnA.unaliasedAst);
        }
        else {
            result[columnAlias] = columnA;
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/omit.js":
/*!******************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/omit.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function omit(map, arr) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (arr.indexOf(columnAlias) < 0) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.omit = omit;
//# sourceMappingURL=omit.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/pick.js":
/*!******************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/pick.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function pick(map, arr) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (arr.indexOf(columnAlias) >= 0) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.pick = pick;
//# sourceMappingURL=pick.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/replace-column.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/replace-column.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function replaceColumn(map, columnAlias, mapper) {
    const result = {};
    for (const myColumnAlias of Object.keys(map)) {
        if (myColumnAlias == columnAlias) {
            result[myColumnAlias] = column_1.ColumnUtil.withType(map[myColumnAlias], mapper);
        }
        else {
            result[myColumnAlias] = map[myColumnAlias];
        }
    }
    return result;
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/to-nullable.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/to-nullable.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function toNullable(columnMap) {
    const result = {};
    for (const columnAlias of Object.keys(columnMap)) {
        result[columnAlias] = column_1.ColumnUtil.toNullable(columnMap[columnAlias]);
    }
    return result;
}
exports.toNullable = toNullable;
//# sourceMappingURL=to-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/operation/with-table-alias.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-map/util/operation/with-table-alias.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function withTableAlias(columnMap, newTableAlias) {
    const result = {};
    for (const columnAlias of Object.keys(columnMap)) {
        result[columnAlias] = column_1.ColumnUtil.withTableAlias(columnMap[columnAlias], newTableAlias);
    }
    return result;
}
exports.withTableAlias = withTableAlias;
//# sourceMappingURL=with-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/predicate/assert-is-null-safe-comparable.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/column-map/util/predicate/assert-is-null-safe-comparable.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_null_safe_comparable_1 = __webpack_require__(/*! ./is-null-safe-comparable */ "../tsql/dist/column-map/util/predicate/is-null-safe-comparable.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/column-map/util/query/index.js");
function assertIsNullSafeComparable(a, b) {
    if (!is_null_safe_comparable_1.isNullSafeComparable(a, b)) {
        const myTableAlias = query_1.tableAlias(a);
        const myColumnAliases = Object.keys(a).join(",");
        const otherTableAlias = query_1.tableAlias(b);
        const otherColumnAliases = Object.keys(a)
            .filter(myColumnAlias => (Object.prototype.hasOwnProperty.call(b, myColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(b, myColumnAlias)))
            .join(",");
        throw new Error(`${myTableAlias} (${myColumnAliases}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
    }
}
exports.assertIsNullSafeComparable = assertIsNullSafeComparable;
//# sourceMappingURL=assert-is-null-safe-comparable.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/predicate/has-column-alias.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-map/util/predicate/has-column-alias.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function hasColumnAlias(map, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(map, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(map, columnAlias));
}
exports.hasColumnAlias = hasColumnAlias;
//# sourceMappingURL=has-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/predicate/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column-map/util/predicate/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-is-null-safe-comparable */ "../tsql/dist/column-map/util/predicate/assert-is-null-safe-comparable.js"));
__export(__webpack_require__(/*! ./has-column-alias */ "../tsql/dist/column-map/util/predicate/has-column-alias.js"));
__export(__webpack_require__(/*! ./is-column-map */ "../tsql/dist/column-map/util/predicate/is-column-map.js"));
__export(__webpack_require__(/*! ./is-null-safe-comparable */ "../tsql/dist/column-map/util/predicate/is-null-safe-comparable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/predicate/is-column-map.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-map/util/predicate/is-column-map.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function isColumnMap(mixed) {
    if (!(mixed instanceof Object)) {
        return false;
    }
    for (const columnAlias of Object.keys(mixed)) {
        const possiblyColumn = mixed[columnAlias];
        if (!column_1.ColumnUtil.isColumn(possiblyColumn)) {
            return false;
        }
    }
    return true;
}
exports.isColumnMap = isColumnMap;
//# sourceMappingURL=is-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/predicate/is-null-safe-comparable.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/column-map/util/predicate/is-null-safe-comparable.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ideally, we'd want to have run-time checks
 * ensuring columns in `a` and columns in `b`
 * have null-safe comparable types.
 *
 * However, due to how the project is structured,
 * this is not possible.
 *
 * So, at the very least, we just check
 * the columns exist.
 */
function isNullSafeComparable(a, b) {
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring columns in `a` and columns in `b`
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    const otherColumnAliases = Object.keys(b);
    for (const myColumnAlias of Object.keys(a)) {
        if (!otherColumnAliases.includes(myColumnAlias)) {
            /**
             * Other column does not exist
             */
            return false;
        }
    }
    return true;
}
exports.isNullSafeComparable = isNullSafeComparable;
//# sourceMappingURL=is-null-safe-comparable.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/column-alias.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column-map/util/query/column-alias.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function columnAlias(map) {
    return Object.keys(map);
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/extract-column-identifier.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/extract-column-identifier.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Does not check `tableAlias`
 */
function extractColumnIdentifiers(map, columnIdentifiers) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/extract-non-nullable.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/extract-non-nullable.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const non_nullable_column_alias_1 = __webpack_require__(/*! ./non-nullable-column-alias */ "../tsql/dist/column-map/util/query/non-nullable-column-alias.js");
function extractNonNullable(map) {
    const result = {};
    for (const columnAlias of non_nullable_column_alias_1.nonNullableColumnAliases(map)) {
        result[columnAlias] = map[columnAlias];
    }
    return result;
}
exports.extractNonNullable = extractNonNullable;
//# sourceMappingURL=extract-non-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/extract-nullable.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/extract-nullable.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "../tsql/dist/column-map/util/query/nullable-column-alias.js");
function extractNullable(map) {
    const result = {};
    for (const columnAlias of nullable_column_alias_1.nullableColumnAliases(map)) {
        result[columnAlias] = map[columnAlias];
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column-map/util/query/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "../tsql/dist/column-map/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./extract-column-identifier */ "../tsql/dist/column-map/util/query/extract-column-identifier.js"));
__export(__webpack_require__(/*! ./extract-non-nullable */ "../tsql/dist/column-map/util/query/extract-non-nullable.js"));
__export(__webpack_require__(/*! ./extract-nullable */ "../tsql/dist/column-map/util/query/extract-nullable.js"));
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/column-map/util/query/mapper.js"));
__export(__webpack_require__(/*! ./non-nullable-column-alias */ "../tsql/dist/column-map/util/query/non-nullable-column-alias.js"));
__export(__webpack_require__(/*! ./nullable-column-alias */ "../tsql/dist/column-map/util/query/nullable-column-alias.js"));
__export(__webpack_require__(/*! ./partial-mapper */ "../tsql/dist/column-map/util/query/partial-mapper.js"));
__export(__webpack_require__(/*! ./table-alias */ "../tsql/dist/column-map/util/query/table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/mapper.js":
/*!****************************************************!*\
  !*** ../tsql/dist/column-map/util/query/mapper.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function mapper(map) {
    const fields = [];
    for (const columnAlias of Object.keys(map)) {
        /**
         * It's possible that this is not an `IColumnUtil`.
         * But, in general, if we pass in candidateKey and columnMap
         * without any outside hack-ery, this should be correct.
         */
        const column = map[columnAlias];
        fields.push(tm.withName(column.mapper, column.columnAlias));
    }
    return tm.objectFromArray(...fields);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/non-nullable-column-alias.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/non-nullable-column-alias.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function nonNullableColumnAliases(map) {
    return Object.keys(map)
        .filter(columnAlias => !tm.canOutputNull(map[columnAlias].mapper));
}
exports.nonNullableColumnAliases = nonNullableColumnAliases;
//# sourceMappingURL=non-nullable-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/nullable-column-alias.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/nullable-column-alias.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function nullableColumnAliases(map) {
    return Object.keys(map)
        .filter(columnAlias => tm.canOutputNull(map[columnAlias].mapper));
}
exports.nullableColumnAliases = nullableColumnAliases;
//# sourceMappingURL=nullable-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/partial-mapper.js":
/*!************************************************************!*\
  !*** ../tsql/dist/column-map/util/query/partial-mapper.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function partialMapper(map) {
    const fields = [];
    for (const columnAlias of Object.keys(map)) {
        /**
         * It's possible that this is not an `IColumnUtil`.
         * But, in general, if we pass in candidateKey and columnMap
         * without any outside hack-ery, this should be correct.
         */
        const column = map[columnAlias];
        fields.push(tm.withName(column.mapper, column.columnAlias));
    }
    return tm.partialObjectFromArray(...fields);
}
exports.partialMapper = partialMapper;
//# sourceMappingURL=partial-mapper.js.map

/***/ }),

/***/ "../tsql/dist/column-map/util/query/table-alias.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/column-map/util/query/table-alias.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the **first** table alias found.
 *
 * All columns in a `ColumnMap` should have the same table alias.
 * If multiple table aliases exist, the one it returns is arbitrary.
 *
 * If no columns exist, it throws an error.
 */
function tableAlias(map) {
    const columnAliases = Object.keys(map);
    if (columnAliases.length == 0) {
        throw new Error(`No columns in ColumnMap`);
    }
    else {
        return map[columnAliases[0]].tableAlias;
    }
}
exports.tableAlias = tableAlias;
//# sourceMappingURL=table-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/column-ref/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnRefUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column-ref/util/index.js");
exports.ColumnRefUtil = ColumnRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-column-array.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-column-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-ref/util/constructor/from-column.js");
function fromColumnArray(columns) {
    const result = {};
    for (const column of columns) {
        from_column_1.setColumn(result, column);
    }
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-column-map.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-column-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-ref/util/constructor/from-column.js");
function setColumnMap(ref, map) {
    for (const columnAlias of Object.keys(map)) {
        from_column_1.setColumn(ref, map[columnAlias]);
    }
}
exports.setColumnMap = setColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-column.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-column.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function setColumn(ref, column) {
    let map = ref[column.tableAlias];
    if (map == undefined) {
        map = {};
        ref[column.tableAlias] = map;
    }
    map[column.columnAlias] = column;
    return ref;
}
exports.setColumn = setColumn;
function fromColumn(column) {
    return setColumn({}, column);
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-from-clause.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-from-clause.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_array_1 = __webpack_require__(/*! ./from-join-array */ "../tsql/dist/column-ref/util/constructor/from-join-array.js");
function setFromClause(ref, fromClause) {
    if (fromClause.currentJoins != undefined) {
        from_join_array_1.setJoinArray(ref, fromClause.currentJoins);
    }
    if (fromClause.outerQueryJoins != undefined) {
        from_join_array_1.setJoinArray(ref, fromClause.outerQueryJoins);
    }
}
exports.setFromClause = setFromClause;
function fromFromClause(fromClause) {
    const result = {};
    setFromClause(result, fromClause);
    return result;
}
exports.fromFromClause = fromFromClause;
//# sourceMappingURL=from-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-join-array.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-join-array.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_1 = __webpack_require__(/*! ./from-join */ "../tsql/dist/column-ref/util/constructor/from-join.js");
function setJoinArray(ref, joins) {
    for (const join of joins) {
        from_join_1.setJoin(ref, join);
    }
}
exports.setJoinArray = setJoinArray;
function fromJoinArray(joins) {
    const result = {};
    setJoinArray(result, joins);
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-join.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-join.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column-ref/util/constructor/from-column-map.js");
function setJoin(ref, join) {
    from_column_map_1.setColumnMap(ref, column_map_1.ColumnMapUtil.fromJoin(join));
}
exports.setJoin = setJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/from-select-clause.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/from-select-clause.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "../tsql/dist/column-ref/util/constructor/from-column.js");
function fromSelectClause(selectClause) {
    const result = {};
    for (const column of column_1.ColumnUtil.fromSelectClause(selectClause)) {
        from_column_1.setColumn(result, column);
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/constructor/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/column-ref/util/constructor/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "../tsql/dist/column-ref/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/column-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-from-clause */ "../tsql/dist/column-ref/util/constructor/from-from-clause.js"));
__export(__webpack_require__(/*! ./from-join-array */ "../tsql/dist/column-ref/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "../tsql/dist/column-ref/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/column-ref/util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/column-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/column-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/compound.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/compound.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_compound_1 = __webpack_require__(/*! ./left-compound */ "../tsql/dist/column-ref/util/operation/left-compound.js");
function compound(refA, refB) {
    const left = left_compound_1.leftCompound(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.compound = compound;
//# sourceMappingURL=compound.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound */ "../tsql/dist/column-ref/util/operation/compound.js"));
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/column-ref/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./try-flatten */ "../tsql/dist/column-ref/util/operation/try-flatten.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/intersect.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/intersect.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "../tsql/dist/column-ref/util/operation/left-intersect.js");
function intersect(refA, refB) {
    const left = left_intersect_1.leftIntersect(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/left-compound.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/left-compound.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function leftCompound(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_map_1.ColumnMapUtil.compound(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/left-intersect.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/left-intersect.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function leftIntersect(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_map_1.ColumnMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/operation/try-flatten.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/column-ref/util/operation/try-flatten.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryFlatten(ref) {
    const tableAliases = Object.keys(ref);
    if (tableAliases.length == 1) {
        return ref[tableAliases[0]];
    }
    else {
        return ref;
    }
}
exports.tryFlatten = tryFlatten;
//# sourceMappingURL=try-flatten.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/predicate/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column-ref/util/predicate/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column-ref */ "../tsql/dist/column-ref/util/predicate/is-column-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/predicate/is-column-ref.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-ref/util/predicate/is-column-ref.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function isColumnRef(mixed) {
    if (!(mixed instanceof Object)) {
        return false;
    }
    for (const tableAlias of Object.keys(mixed)) {
        const possiblyColumnMap = mixed[tableAlias];
        if (!column_map_1.ColumnMapUtil.isColumnMap(possiblyColumnMap)) {
            return false;
        }
    }
    return true;
}
exports.isColumnRef = isColumnRef;
//# sourceMappingURL=is-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/column-alias.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/column-alias.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function columnAlias(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        result.push(...column_map_1.ColumnMapUtil.columnAlias(ref[tableAlias]));
    }
    return result;
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/duplicate-column-alias.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/duplicate-column-alias.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function duplicateColumnAlias(ref) {
    const duplicateTracker = {};
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        for (const columnAlias of column_map_1.ColumnMapUtil.columnAlias(ref[tableAlias])) {
            const isDuplicate = duplicateTracker[columnAlias];
            if (isDuplicate === undefined) {
                /**
                 * We had never encountered it, and now we have.
                 * But it isn't a duplicate.
                 */
                duplicateTracker[columnAlias] = false;
            }
            else if (!isDuplicate) {
                /**
                 * We had encountered it when it wasn't a duplicate.
                 * Now, it is a duplicate.
                 */
                duplicateTracker[columnAlias] = true;
                result.push(columnAlias);
            }
        }
    }
    return result;
}
exports.duplicateColumnAlias = duplicateColumnAlias;
//# sourceMappingURL=duplicate-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/extract-column-identifier.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/extract-column-identifier.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function extractColumnIdentifiers(ref, columnIdentifiers) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
        if (arr.length > 0) {
            result[tableAlias] = column_map_1.ColumnMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/extract-non-nullable.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/extract-non-nullable.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function extractNonNullable(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        result[tableAlias] = column_map_1.ColumnMapUtil.extractNonNullable(ref[tableAlias]);
    }
    return result;
}
exports.extractNonNullable = extractNonNullable;
//# sourceMappingURL=extract-non-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/extract-nullable.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/extract-nullable.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function extractNullable(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        result[tableAlias] = column_map_1.ColumnMapUtil.extractNullable(ref[tableAlias]);
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/extract-with-type.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/extract-with-type.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns `ref` without modifying it.
 * Is basically a no-op.
 *
 * This function merely exists to enforce compile-time safety.
 */
function __noOp_extractWithType() {
    return (ref) => ref;
}
exports.__noOp_extractWithType = __noOp_extractWithType;
//# sourceMappingURL=extract-with-type.js.map

/***/ }),

/***/ "../tsql/dist/column-ref/util/query/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column-ref/util/query/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "../tsql/dist/column-ref/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./duplicate-column-alias */ "../tsql/dist/column-ref/util/query/duplicate-column-alias.js"));
__export(__webpack_require__(/*! ./extract-column-identifier */ "../tsql/dist/column-ref/util/query/extract-column-identifier.js"));
__export(__webpack_require__(/*! ./extract-non-nullable */ "../tsql/dist/column-ref/util/query/extract-non-nullable.js"));
__export(__webpack_require__(/*! ./extract-nullable */ "../tsql/dist/column-ref/util/query/extract-nullable.js"));
__export(__webpack_require__(/*! ./extract-with-type */ "../tsql/dist/column-ref/util/query/extract-with-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/array-util/constructor/from-column-map.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/column/array-util/constructor/from-column-map.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnMap(columnMap) {
    const result = [];
    for (const columnAlias of Object.keys(columnMap)) {
        result.push(columnMap[columnAlias]);
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
function fromColumnMapArray(columnMapArr) {
    const result = [];
    for (const columnMap of columnMapArr) {
        for (const columnAlias of Object.keys(columnMap)) {
            result.push(columnMap[columnAlias]);
        }
    }
    return result;
}
exports.fromColumnMapArray = fromColumnMapArray;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column/array-util/constructor/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/column/array-util/constructor/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column/array-util/constructor/from-column-map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/array-util/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/column/array-util/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column/array-util/constructor/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/column-impl.js":
/*!******************************************!*\
  !*** ../tsql/dist/column/column-impl.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column/util/index.js");
class Column {
    /**
     * You should never need to explicitly instantiate a `Column`.
     * Use `myTable.addColumns()` instead.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.tableAlias = data.tableAlias;
        this.columnAlias = data.columnAlias;
        this.mapper = data.mapper;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * ```sql
     * SELECT
     *  myTable.myColumn AS alias
     * FROM
     *  myTable
     * ```
     *
     * @param alias - The new column name
     */
    as(alias) {
        return ColumnUtil.as(this, alias);
    }
    ;
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC
     * ```
     */
    asc() {
        return ColumnUtil.asc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn DESC
     * ```
     */
    desc() {
        return ColumnUtil.desc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC,
     *  myTable.myOtherColumn DESC
     * ```
     */
    sort(sortDirection) {
        return ColumnUtil.sort(this, sortDirection);
    }
}
exports.Column = Column;
//# sourceMappingURL=column-impl.js.map

/***/ }),

/***/ "../tsql/dist/column/index.js":
/*!************************************!*\
  !*** ../tsql/dist/column/index.js ***!
  \************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-impl */ "../tsql/dist/column/column-impl.js"));
const ColumnArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/column/array-util/index.js");
exports.ColumnArrayUtil = ColumnArrayUtil;
const ColumnUtil = __webpack_require__(/*! ./util */ "../tsql/dist/column/util/index.js");
exports.ColumnUtil = ColumnUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-column-map.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-column-map.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnMap(map) {
    const result = [];
    for (const columnAlias of Object.keys(map)) {
        result.push(map[columnAlias]);
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-column-ref.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-column-ref.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column/util/constructor/from-column-map.js");
function fromColumnRef(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        const map = ref[tableAlias];
        result.push(...from_column_map_1.fromColumnMap(map));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-expr-select-item.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-expr-select-item.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_column_1 = __webpack_require__(/*! ../../../expr-column */ "../tsql/dist/expr-column/index.js");
function fromExprSelectItem(exprSelectItem) {
    const result = new expr_column_1.ExprColumn({
        tableAlias: exprSelectItem.tableAlias,
        columnAlias: exprSelectItem.alias,
        mapper: exprSelectItem.mapper,
        isAggregate: exprSelectItem.isAggregate,
    }, exprSelectItem.unaliasedAst);
    return result;
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-join-array.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-join-array.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_1 = __webpack_require__(/*! ./from-join */ "../tsql/dist/column/util/constructor/from-join.js");
function fromJoinArray(joins) {
    const result = [];
    for (const join of joins) {
        result.push(...from_join_1.fromJoin(join));
    }
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-join.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-join.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column/util/constructor/from-column-map.js");
function fromJoin(join) {
    const result = from_column_map_1.fromColumnMap(column_map_1.ColumnMapUtil.fromJoin(join));
    return result;
}
exports.fromJoin = fromJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-select-clause.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-select-clause.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "../tsql/dist/column/util/constructor/from-select-item.js");
/**
 * Does not remove duplicate identifiers
 *
 * @param selectClause
 */
function fromSelectClause(selectClause) {
    const result = [];
    for (const selectItem of selectClause) {
        result.push(...from_select_item_1.fromSelectItem(selectItem));
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/from-select-item.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column/util/constructor/from-select-item.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "../tsql/dist/column/util/constructor/from-expr-select-item.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column/util/constructor/from-column-ref.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "../tsql/dist/column/util/constructor/from-column-map.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
function fromSelectItem(selectItem) {
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
        return [from_expr_select_item_1.fromExprSelectItem(selectItem)];
    }
    else if (column_1.ColumnUtil.isColumn(selectItem)) {
        return [selectItem];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
        return from_column_map_1.fromColumnMap(selectItem);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(selectItem)) {
        return from_column_ref_1.fromColumnRef(selectItem);
    }
    else {
        throw new Error(`Unknown SelectItem`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "../tsql/dist/column/util/constructor/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/column/util/constructor/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/column/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "../tsql/dist/column/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-expr-select-item */ "../tsql/dist/column/util/constructor/from-expr-select-item.js"));
__export(__webpack_require__(/*! ./from-join-array */ "../tsql/dist/column/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-join */ "../tsql/dist/column/util/constructor/from-join.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "../tsql/dist/column/util/constructor/from-select-clause.js"));
__export(__webpack_require__(/*! ./from-select-item */ "../tsql/dist/column/util/constructor/from-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/util/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/column/util/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/column/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/column/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/column/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/column/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/as.js":
/*!************************************************!*\
  !*** ../tsql/dist/column/util/operation/as.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const build_ast_1 = __webpack_require__(/*! ./build-ast */ "../tsql/dist/column/util/operation/build-ast.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const aliased_expr_1 = __webpack_require__(/*! ../../../aliased-expr */ "../tsql/dist/aliased-expr/index.js");
function as(column, alias) {
    return new aliased_expr_1.AliasedExpr({
        usedRef: used_ref_1.UsedRefUtil.fromColumn(column),
        mapper: column.mapper,
        tableAlias: column.tableAlias,
        alias: alias,
        isAggregate: false,
    }, build_ast_1.buildAst(column));
    /*
    return {
        usedRef : UsedRefUtil.fromColumn(column),
        mapper : column.mapper,
        tableAlias : column.tableAlias,
        alias : alias,
        unaliasedAst : buildAst(column),
    };
    */
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/asc.js":
/*!*************************************************!*\
  !*** ../tsql/dist/column/util/operation/asc.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
function asc(column) {
    return [column, sort_direction_1.SortDirection.ASC];
}
exports.asc = asc;
//# sourceMappingURL=asc.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/build-ast.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column/util/operation/build-ast.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(/*! ../../../constants */ "../tsql/dist/constants.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
function buildAst({ tableAlias, columnAlias, unaliasedAst, }) {
    if (tableAlias == constants_1.ALIASED) {
        /**
         * When you want to write,
         * `(1 + 2) AS three`
         *
         * You write,
         * `add(1, 2).as("three")`
         *
         * This `"three"` is an `IExprSelectItem` but has no `tableAlias`
         * associated with it.
         *
         * So, this library makes up a table alias that is very
         * unlikely to be used naturally by others.
         *
         * The table alias is the value of the variable `ALIASED`,
         * which should be `$aliased`
         */
        return ast_1.identifierNode(`${tableAlias}${constants_1.SEPARATOR}${columnAlias}`);
    }
    else {
        if (unaliasedAst == undefined) {
            /*
                The most common case, I think.
            */
            return ast_1.identifierNode(tableAlias, columnAlias);
        }
        else {
            /**
             * @todo Investigate what should be here.
             * Does the `SELECT` clause even ever have an `IColumn` with `unaliasedAst` set?
             * Initial inspection says "No"
             */
            //throw new Error(`Should use unaliasedAst, tableAlias, columnAlias in SELECT clause, use tableAlias, columnAlias in ORDER BY clause`);
            return ast_1.identifierNode(`${tableAlias}${constants_1.SEPARATOR}${columnAlias}`);
        }
    }
}
exports.buildAst = buildAst;
//# sourceMappingURL=build-ast.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/desc.js":
/*!**************************************************!*\
  !*** ../tsql/dist/column/util/operation/desc.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
function desc(column) {
    return [column, sort_direction_1.SortDirection.DESC];
}
exports.desc = desc;
//# sourceMappingURL=desc.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column/util/operation/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./as */ "../tsql/dist/column/util/operation/as.js"));
__export(__webpack_require__(/*! ./asc */ "../tsql/dist/column/util/operation/asc.js"));
__export(__webpack_require__(/*! ./build-ast */ "../tsql/dist/column/util/operation/build-ast.js"));
__export(__webpack_require__(/*! ./desc */ "../tsql/dist/column/util/operation/desc.js"));
__export(__webpack_require__(/*! ./sort */ "../tsql/dist/column/util/operation/sort.js"));
__export(__webpack_require__(/*! ./to-non-nullable */ "../tsql/dist/column/util/operation/to-non-nullable.js"));
__export(__webpack_require__(/*! ./to-nullable */ "../tsql/dist/column/util/operation/to-nullable.js"));
__export(__webpack_require__(/*! ./with-table-alias */ "../tsql/dist/column/util/operation/with-table-alias.js"));
__export(__webpack_require__(/*! ./with-type */ "../tsql/dist/column/util/operation/with-type.js"));
__export(__webpack_require__(/*! ./with-unaliased-ast */ "../tsql/dist/column/util/operation/with-unaliased-ast.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/sort.js":
/*!**************************************************!*\
  !*** ../tsql/dist/column/util/operation/sort.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function sort(column, sortDirection) {
    return [column, sortDirection];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/to-non-nullable.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/column/util/operation/to-non-nullable.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "../tsql/dist/column/column-impl.js");
function toNonNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
    return new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: tm.notNull(mapper),
    }, unaliasedAst);
}
exports.toNonNullable = toNonNullable;
//# sourceMappingURL=to-non-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/to-nullable.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/column/util/operation/to-nullable.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "../tsql/dist/column/column-impl.js");
function toNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
    return new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: tm.orNull(mapper),
    }, unaliasedAst);
}
exports.toNullable = toNullable;
//# sourceMappingURL=to-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/with-table-alias.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/column/util/operation/with-table-alias.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "../tsql/dist/column/column-impl.js");
function withTableAlias({ columnAlias, mapper, unaliasedAst, }, newTableAlias) {
    const result = new column_impl_1.Column({
        tableAlias: newTableAlias,
        columnAlias,
        mapper,
    }, unaliasedAst);
    return result;
}
exports.withTableAlias = withTableAlias;
//# sourceMappingURL=with-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/with-type.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column/util/operation/with-type.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "../tsql/dist/column/column-impl.js");
function withType({ tableAlias, columnAlias, unaliasedAst, }, newMapper) {
    const result = new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: newMapper,
    }, unaliasedAst);
    return result;
}
exports.withType = withType;
//# sourceMappingURL=with-type.js.map

/***/ }),

/***/ "../tsql/dist/column/util/operation/with-unaliased-ast.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/column/util/operation/with-unaliased-ast.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "../tsql/dist/column/column-impl.js");
function withUnaliasedAst({ tableAlias, columnAlias, mapper, }, unaliasedAst) {
    const result = new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper,
    }, unaliasedAst);
    return result;
}
exports.withUnaliasedAst = withUnaliasedAst;
//# sourceMappingURL=with-unaliased-ast.js.map

/***/ }),

/***/ "../tsql/dist/column/util/predicate/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/column/util/predicate/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column */ "../tsql/dist/column/util/predicate/is-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/column/util/predicate/is-column.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/column/util/predicate/is-column.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
function isColumn(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias",
        "mapper",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string") &&
        (typeof raw.mapper == "function") &&
        (raw.unaliasedAst == undefined ||
            ast_1.AstUtil.isAst(raw.unaliasedAst)));
}
exports.isColumn = isColumn;
//# sourceMappingURL=is-column.js.map

/***/ }),

/***/ "../tsql/dist/column/util/query/extract-nullable.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/column/util/query/extract-nullable.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function extractNullable(columns) {
    const result = [];
    for (const column of columns) {
        if (tm.canOutputNull(column.mapper)) {
            result.push(column);
        }
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "../tsql/dist/column/util/query/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/column/util/query/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-nullable */ "../tsql/dist/column/util/query/extract-nullable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/compound-query-clause/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CompoundQueryClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/compound-query-clause/util/index.js");
exports.CompoundQueryClauseUtil = CompoundQueryClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/compound-query-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/compound-query-clause/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/operation/compound-query.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/operation/compound-query.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/compound-query-clause/util/predicate/index.js");
function compoundQuery(fromClause, selectClause, compoundQueryClause, compoundQueryType, isDistinct, targetQuery) {
    predicate_1.assertCompatible(fromClause, selectClause, targetQuery);
    return {
        selectClause: select_clause_1.SelectClauseUtil.leftCompound(selectClause, targetQuery.selectClause),
        compoundQueryClause: [
            ...(compoundQueryClause == undefined ?
                [] :
                compoundQueryClause),
            {
                compoundQueryType,
                isDistinct,
                query: targetQuery,
            }
        ]
    };
}
exports.compoundQuery = compoundQuery;
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/operation/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/operation/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query */ "../tsql/dist/compound-query-clause/util/operation/compound-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/predicate/assert-compatible.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/predicate/assert-compatible.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_select_clause_compatible_1 = __webpack_require__(/*! ./assert-select-clause-compatible */ "../tsql/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js");
const assert_outer_query_joins_compatible_1 = __webpack_require__(/*! ./assert-outer-query-joins-compatible */ "../tsql/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js");
function assertCompatible(fromClause, selectClause, targetQuery) {
    assert_select_clause_compatible_1.assertSelectClauseCompatible(selectClause, targetQuery.selectClause);
    assert_outer_query_joins_compatible_1.assertOuterQueryJoinsCompatible(fromClause, targetQuery.fromClause);
}
exports.assertCompatible = assertCompatible;
//# sourceMappingURL=assert-compatible.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js":
/*!************************************************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function assertOuterQueryJoinsCompatible(fromClause, targetFromClause) {
    used_ref_1.UsedRefUtil.assertAllowed(used_ref_1.UsedRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins), used_ref_1.UsedRefUtil.fromJoinArray(targetFromClause.outerQueryJoins == undefined ?
        [] :
        targetFromClause.outerQueryJoins));
}
exports.assertOuterQueryJoinsCompatible = assertOuterQueryJoinsCompatible;
//# sourceMappingURL=assert-outer-query-joins-compatible.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js":
/*!********************************************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
function assertMapCompatibilityError(identifier, a, b) {
    const aColumnAliases = Object.keys(a);
    const bColumnAliases = Object.keys(b);
    const missingColumnAliases = aColumnAliases.filter(columnAlias => !bColumnAliases.includes(columnAlias));
    if (missingColumnAliases.length > 0) {
        throw new Error(`Expected ${identifier.join(" ")} to have columns ${missingColumnAliases.join(", ")}`);
    }
    const extraColumnAliases = bColumnAliases.filter(columnAlias => !aColumnAliases.includes(columnAlias));
    if (extraColumnAliases.length > 0) {
        throw new Error(`${identifier.join(" ")} has extra columns ${extraColumnAliases.join(", ")}`);
    }
    /**
     * Can't check subtype requirement during run-time
     */
}
exports.assertMapCompatibilityError = assertMapCompatibilityError;
function assertRefCompatibilityError(identifier, a, b) {
    const aTableAliases = Object.keys(a);
    const bTableAliases = Object.keys(b);
    const missingTableAliases = aTableAliases.filter(tableAlias => !bTableAliases.includes(tableAlias));
    if (missingTableAliases.length > 0) {
        throw new Error(`Expected ${identifier.join(" ")} to have tables ${missingTableAliases.join(", ")}`);
    }
    const extraTableAliases = bTableAliases.filter(tableAlias => !aTableAliases.includes(tableAlias));
    if (extraTableAliases.length > 0) {
        throw new Error(`${identifier.join(" ")} has extra tables ${extraTableAliases.join(", ")}`);
    }
    for (const tableAlias of aTableAliases) {
        assertMapCompatibilityError([...identifier, "table", tableAlias], a[tableAlias], b[tableAlias]);
    }
}
exports.assertRefCompatibilityError = assertRefCompatibilityError;
function assertSelectClauseCompatible(a, b) {
    if (a.length != b.length) {
        throw new Error(`SELECT clause length mismatch; expected ${a.length} received ${b.length}`);
    }
    for (let index = 0; index < a.length; ++index) {
        const itemA = a[index];
        const itemB = b[index];
        if (column_1.ColumnUtil.isColumn(itemA) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                /**
                 * Can't check subtype requirement during run-time
                 */
            }
            else {
                throw new Error(`Expected index ${index} to be Column or ExprSelectItem`);
            }
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(itemA)) {
            if (column_map_1.ColumnMapUtil.isColumnMap(itemB)) {
                assertMapCompatibilityError(["index", index], itemA, itemB);
            }
            else {
                throw new Error(`Expected index ${index} to be ColumnMap`);
            }
        }
        else if (column_ref_1.ColumnRefUtil.isColumnRef(itemA)) {
            if (column_ref_1.ColumnRefUtil.isColumnRef(itemB)) {
                assertRefCompatibilityError(["index", index], itemA, itemB);
            }
            else {
                throw new Error(`Expected index ${index} to be ColumnRef`);
            }
        }
        else {
            throw new Error(`Unknown SELECT item at index ${index}`);
        }
    }
}
exports.assertSelectClauseCompatible = assertSelectClauseCompatible;
//# sourceMappingURL=assert-select-clause-compatible.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-clause/util/predicate/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/compound-query-clause/util/predicate/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-compatible */ "../tsql/dist/compound-query-clause/util/predicate/assert-compatible.js"));
__export(__webpack_require__(/*! ./assert-outer-query-joins-compatible */ "../tsql/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js"));
__export(__webpack_require__(/*! ./assert-select-clause-compatible */ "../tsql/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CompoundQueryOrderByClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/compound-query-order-by-clause/util/index.js");
exports.CompoundQueryOrderByClauseUtil = CompoundQueryOrderByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/util/index.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/compound-query-order-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/compound-query-order-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/compound-query-order-by-clause/util/query/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const order_1 = __webpack_require__(/*! ../../../order */ "../tsql/dist/order/index.js");
/**
 * Returns the MySQL equivalent of `...compoundQueryOrderByClause, ...compoundQueryOrderByDelegate(columns)`
 *
 * @param selectClause
 * @param compoundQueryOrderByClause
 * @param compoundQueryOrderByDelegate
 */
function compoundQueryOrderBy(selectClause, compoundQueryOrderByClause, compoundQueryOrderByDelegate) {
    const columns = query_1.allowedColumnRef(selectClause);
    const compoundQueryOrderBy = compoundQueryOrderByDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    for (const rawOrder of compoundQueryOrderBy) {
        const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
        column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
    }
    return (compoundQueryOrderByClause == undefined ?
        compoundQueryOrderBy.map(order_1.OrderUtil.fromRawOrder) :
        [...compoundQueryOrderByClause, ...compoundQueryOrderBy.map(order_1.OrderUtil.fromRawOrder)]);
}
exports.compoundQueryOrderBy = compoundQueryOrderBy;
//# sourceMappingURL=compound-query-order-by.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/util/operation/index.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/util/operation/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-order-by */ "../tsql/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
function allowedColumnRef(selectClause) {
    const result = column_ref_1.ColumnRefUtil.fromSelectClause(selectClause);
    return result;
}
exports.allowedColumnRef = allowedColumnRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/compound-query-order-by-clause/util/query/index.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/compound-query-order-by-clause/util/query/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/compound-query/compound-query.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/compound-query/compound-query.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CompoundQueryType;
(function (CompoundQueryType) {
    CompoundQueryType["UNION"] = "UNION";
    CompoundQueryType["INTERSECT"] = "INTERSECT";
    CompoundQueryType["EXCEPT"] = "EXCEPT";
})(CompoundQueryType = exports.CompoundQueryType || (exports.CompoundQueryType = {}));
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "../tsql/dist/compound-query/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/compound-query/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query */ "../tsql/dist/compound-query/compound-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/constants.js":
/*!*********************************!*\
  !*** ../tsql/dist/constants.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This string value `$aliased` was picked
 * as it is unlikely to be part of an identifier
 * in a database.
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  RAND() AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  RAND() AS `$aliased--r`
 * ```
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
 * ```
 *
 * @todo Make this a reserved `tableAlias`
 * No `ITable/IAliasedTable` should be able to have
 * a `tableAlias` value of `typeof ALIASED`.
 *
 * If such a thing were to happen,
 * it would make enforcing safe interactions between
 * `SELECT` and `FROM` clause very difficult/troublesome.
 *
 * But... What's the probability of someone using `$aliased`
 * as a table name?
 */
exports.ALIASED = "$aliased";
/**
 * This string value `--` was picked
 * as it is unlikely to be part of an identifier
 * in a database.
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  RAND() AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  RAND() AS `$aliased--r`
 * ```
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
 * ```
 */
exports.SEPARATOR = "--";
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/custom-expr/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CustomExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/custom-expr/util/index.js");
exports.CustomExprUtil = CustomExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/custom-expr/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/custom-expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/custom-expr/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/operation/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/custom-expr/util/operation/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./map-non-correlated */ "../tsql/dist/custom-expr/util/operation/map-non-correlated.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/operation/map-non-correlated.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/custom-expr/util/operation/map-non-correlated.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/custom-expr/util/query/index.js");
/**
 * If `value` is `AnyNonValueExpr`, we don't bother checking.
 * We can't really check, anyway.
 *
 * Else, we return `mapper(, value)`,
 * which will throw an error if `value` is invalid.
 */
function mapNonCorrelated(mapper, customExpr) {
    let valueName = "literal-value";
    if (column_1.ColumnUtil.isColumn(mapper)) {
        valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
        mapper = mapper.mapper;
    }
    if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
        /**
         * Cannot map a `NonValueExpr`
         */
        used_ref_1.UsedRefUtil.assertEmpty(query_1.usedRef(customExpr));
        return customExpr;
    }
    else {
        return mapper(valueName, customExpr);
    }
}
exports.mapNonCorrelated = mapNonCorrelated;
//# sourceMappingURL=map-non-correlated.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/query/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/custom-expr/util/query/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-aggregate */ "../tsql/dist/custom-expr/util/query/is-aggregate.js"));
__export(__webpack_require__(/*! ./used-ref */ "../tsql/dist/custom-expr/util/query/used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/query/is-aggregate.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/custom-expr/util/query/is-aggregate.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function isAggregate(customExpr) {
    if (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
        return built_in_expr_1.BuiltInExprUtil.isAggregate(customExpr);
    }
    else {
        return false;
    }
}
exports.isAggregate = isAggregate;
//# sourceMappingURL=is-aggregate.js.map

/***/ }),

/***/ "../tsql/dist/custom-expr/util/query/used-ref.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/custom-expr/util/query/used-ref.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function usedRef(customExpr) {
    if (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
        return built_in_expr_1.BuiltInExprUtil.usedRef(customExpr);
    }
    else {
        return used_ref_1.UsedRefUtil.fromColumnRef({});
    }
}
exports.usedRef = usedRef;
//# sourceMappingURL=used-ref.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/blob.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/blob.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
const equals = tm.ArrayBufferUtil.equals;
function makeBlobDataType(mapperFactory) {
    const result = (a, b, c) => {
        if (c != undefined) {
            return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals, c);
        }
        else if (b != undefined) {
            if (typeof b == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals, b);
            }
        }
        else if (a != undefined) {
            if (typeof a == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals, a);
            }
        }
        else {
            return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals);
        }
    };
    result.maxLength = mapperFactory.maxLength;
    return result;
}
exports.makeBlobDataType = makeBlobDataType;
/**
 * + MySQL      : `BINARY`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `BINARY` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
/**
 * + MySQL      : `VARBINARY`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `VARBINARY` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtVarBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `TINY BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `TINY BLOB` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtTinyBlob = makeBlobDataType(tm.mysql.uint8ArrayTinyBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `BLOB` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtBlob = makeBlobDataType(tm.mysql.uint8ArrayBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `MEDIUM BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `MEDIUM BLOB` data type.
 * + Max length: `16,777,215`; `(2^24)-1`
 */
exports.dtMediumBlob = makeBlobDataType(tm.mysql.uint8ArrayMediumBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `LONG BLOB`
 * + PostgreSQL : `LO` (Large Object)
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `LONG BLOB` data type.
 * + Max length: `4,294,967,295`; `(2^32)-1`
 *
 * -----
 *
 * `bytea` supports up to 1GB. So, we cannot use `bytea`.
 *
 * https://dba.stackexchange.com/questions/127270/what-are-the-limits-of-postgresqls-large-object-facility
 * > A large object cannot exceed 4TB for PostgreSQL 9.3 or newer, or 2GB for older versions.
 * > This is based on the [release notes](https://www.postgresql.org/docs/9.3/release-9-3.html)
 *
 * From the release notes,
 * > Increase the maximum size of large objects from 2GB to 4TB (Nozomi Anzai, Yugo Nagata)
 *
 * -----
 *
 * Realistically, SQLite should support this,
 * https://www.sqlite.org/limits.html
 *
 * However, it is possible that the underlying implementation
 * may be restricted from having a `Uint8Array` of that length.
 */
exports.dtLongBlob = makeBlobDataType(tm.mysql.uint8ArrayLongBlob);
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/boolean.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/boolean.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
function makeBooleanDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
}
exports.makeBooleanDataType = makeBooleanDataType;
/**
 * + MySQL      : `TINYINT` (Emulates `boolean`)
 * + PostgreSQL : `boolean`
 * + SQLite     : `INTEGER` (Emulates `boolean`)
 */
exports.dtBoolean = makeBooleanDataType(tm.mysql.boolean());
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/date-time.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/date-time.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
function makeDateTimeDataType(mapperFactory) {
    return (fractionalSecondPrecision /*|4|5|6*/, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(fractionalSecondPrecision), value => value, (a, b) => built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b), extraMapper);
}
exports.makeDateTimeDataType = makeDateTimeDataType;
/**
 * + MySQL      : `DATETIME`
 * + PostgreSQL : `TIMESTAMP`
 * + SQLite     : `TEXT` (Emulates `DATETIME`)
 *
 * SQLite only supports up to millisecond precision.
 *
 * JS only supports up to millisecond precision.
 *
 * + `0` = second
 * + `1` = deci-second
 * + `2` = centi-second
 * + `3` = millisecond
 *
 * @param fractionalSecondPrecision - `3` is recommended; millisecond precision.
 */
exports.dtDateTime = makeDateTimeDataType(tm.mysql.dateTime);
//# sourceMappingURL=date-time.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/double.js":
/*!************************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/double.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
function makeDoubleDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
}
exports.makeDoubleDataType = makeDoubleDataType;
/**
 * 8-byte floating point number.
 *
 * + MySQL      : `DOUBLE`
 * + PostgreSQL : `double precision`
 * + SQLite     : `REAL`; is actually 8-byte floating point number
 *
 * The SQL standard forbids NaN, Infinity, -Infinity.
 * However, SQLite supports infinities.
 *
 * The job of throwing on these 3 values will have to
 * fall to the sqlfiers.
 */
exports.dtDouble = makeDoubleDataType(tm.toUnsafeNumber());
/**
 * 4-byte floating point number.
 *
 * JS does not have a 4-byte floating point number type.
 * So, attempting to use `FLOAT` will cause a loss in precision.
 *
 * + MySQL      : `FLOAT`
 * + PostgreSQL : `real`
 * + SQLite     : `REAL`; does not actually have 4-byte floating point numbers
 *
 * The SQL standard forbids NaN, Infinity, -Infinity.
 * However, SQLite supports infinities.
 *
 * The job of throwing on these 3 values will have to
 * fall to the sqlfiers.
 */
exports.dtFloat = makeDoubleDataType(tm.toUnsafeNumber());
//# sourceMappingURL=double.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./blob */ "../tsql/dist/data-type/built-in-value-expr/blob.js"));
__export(__webpack_require__(/*! ./boolean */ "../tsql/dist/data-type/built-in-value-expr/boolean.js"));
__export(__webpack_require__(/*! ./date-time */ "../tsql/dist/data-type/built-in-value-expr/date-time.js"));
__export(__webpack_require__(/*! ./double */ "../tsql/dist/data-type/built-in-value-expr/double.js"));
__export(__webpack_require__(/*! ./integer */ "../tsql/dist/data-type/built-in-value-expr/integer.js"));
__export(__webpack_require__(/*! ./text */ "../tsql/dist/data-type/built-in-value-expr/text.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/integer.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/integer.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
function makeIntegerDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => tm.TypeUtil.strictEqual(a, b), extraMapper);
}
exports.makeIntegerDataType = makeIntegerDataType;
/**
 * 1-byte integer.
 *
 * + MySQL      : `TINYINT SIGNED`
 * + PostgreSQL : `smallint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `TINYINT SIGNED` data type.
 * + Min: -128; `-(2^7)`
 * + Max:  127; `(2^7)-1`
 */
exports.dtTinyIntSigned = makeIntegerDataType(tm.mysql.tinyIntSigned());
/**
 * 2-byte integer.
 *
 * + MySQL      : `SMALLINT SIGNED`
 * + PostgreSQL : `smallint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `SMALLINT SIGNED` data type.
 * + Min: -32,768; `-(2^15)`
 * + Max:  32,767; `(2^15)-1`
 */
exports.dtSmallIntSigned = makeIntegerDataType(tm.mysql.smallIntSigned());
/**
 * 3-byte integer.
 *
 * + MySQL      : `MEDIUMINT SIGNED`
 * + PostgreSQL : `integer`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `MEDIUMINT SIGNED` data type.
 * + Min: -8,388,608; `-(2^23)`
 * + Max:  8,388,607; `(2^23)-1`
 */
exports.dtMediumIntSigned = makeIntegerDataType(tm.mysql.mediumIntSigned());
/**
 * 4-byte integer.
 *
 * + MySQL      : `INT SIGNED`
 * + PostgreSQL : `integer`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `INT SIGNED` data type.
 * + Min: -2,147,483,648; `-(2^31)`
 * + Max:  2,147,483,647; `(2^31)-1`
 */
exports.dtIntSigned = makeIntegerDataType(tm.mysql.intSigned());
/**
 * 8-byte integer.
 *
 * + MySQL      : `BIGINT SIGNED`
 * + PostgreSQL : `bigint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `BIGINT SIGNED` data type.
 * + Min: -9,223,372,036,854,775,808; `-(2^63)`
 * + Max:  9,223,372,036,854,775,807; `(2^63)-1`
 */
exports.dtBigIntSigned = makeIntegerDataType(tm.mysql.bigIntSigned());
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ "../tsql/dist/data-type/built-in-value-expr/text.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/data-type/built-in-value-expr/text.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
function makeTextDataType(mapperFactory) {
    const result = (a, b, c) => {
        if (c != undefined) {
            return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b, c);
        }
        else if (b != undefined) {
            if (typeof b == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b, b);
            }
        }
        else if (a != undefined) {
            if (typeof a == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b, a);
            }
        }
        else {
            return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b);
        }
    };
    result.maxLength = mapperFactory.maxLength;
    return result;
}
exports.makeTextDataType = makeTextDataType;
/**
 * + MySQL      : `CHAR`
 * + PostgreSQL : `CHAR`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `CHAR` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtChar = makeTextDataType(tm.mysql.char);
/**
 * + MySQL      : `VARCHAR`
 * + PostgreSQL : `VARCHAR`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `VARCHAR` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtVarChar = makeTextDataType(tm.mysql.varChar);
/**
 * + MySQL      : `TINY TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `TINY TEXT` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtTinyText = makeTextDataType(tm.mysql.tinyText);
/**
 * + MySQL      : `TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `TEXT` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtText = makeTextDataType(tm.mysql.text);
/**
 * + MySQL      : `MEDIUM TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `MEDIUM TEXT` data type.
 * + Max length: `16,777,215`; `(2^24)-1`
 */
exports.dtMediumText = makeTextDataType(tm.mysql.mediumText);
/**
 * + MySQL      : `LONG TEXT`
 * + PostgreSQL : -NA-
 * + SQLite     : `TEXT`
 *
 * This corresponds to MySQL's `LONG TEXT` data type.
 * + Max length: `4,294,967,295`; `(2^32)-1`
 *
 * -----
 *
 * `text` supports up to 1GB. So, we cannot use `text`.
 *
 * https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F
 *
 * > Maximum size for a field? 1 GB
 *
 * -----
 *
 * Realistically, SQLite should support this,
 * https://www.sqlite.org/limits.html
 *
 * However, it is possible that the underlying implementation
 * may be restricted from having a `string` of that length.
 */
exports.dtLongText = makeTextDataType(tm.mysql.longText);
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "../tsql/dist/data-type/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/data-type/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./non-built-in-value-expr */ "../tsql/dist/data-type/non-built-in-value-expr/index.js"));
__export(__webpack_require__(/*! ./built-in-value-expr */ "../tsql/dist/data-type/built-in-value-expr/index.js"));
const DataTypeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/data-type/util/index.js");
exports.DataTypeUtil = DataTypeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/non-built-in-value-expr/decimal.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/data-type/non-built-in-value-expr/decimal.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "../tsql/dist/data-type/util/index.js");
const ExprLib = __webpack_require__(/*! ../../expr-library */ "../tsql/dist/expr-library/index.js");
function makeDecimalDataType(mapperFactory) {
    return (
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(precision, scale), value => ExprLib.decimalLiteral(value, precision, scale), 
    /**
     * We consider +0 and -0 to be the same
     */
    (a, b) => {
        if (a === b) {
            //Early-exit
            return true;
        }
        if (a.toString() === b.toString()) {
            //Early-exit
            return true;
        }
        const parsedA = tm.FixedPointUtil.tryParse(a.toString());
        if (parsedA == undefined) {
            /**
             * This should never happen...
             */
            throw new Error(`Invalid DECIMAL a found`);
        }
        const parsedB = tm.FixedPointUtil.tryParse(b.toString());
        if (parsedB == undefined) {
            /**
             * This should never happen...
             */
            throw new Error(`Invalid DECIMAL b found`);
        }
        return tm.FixedPointUtil.isEqual(parsedA, parsedB, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL);
    }, extraMapper);
}
exports.makeDecimalDataType = makeDecimalDataType;
/**
 * Fixed-point number.
 *
 * + MySQL      : `DECIMAL(p, s)`
 * + PostgreSQL : `DECIMAL(p, s)`
 * + SQLite     : -NA-; Should be emulated using `TEXT` and custom functions.
 *
 * @param precision
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 *
 * @param scale
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 *
 * @param extraMapper
 */
exports.dtDecimal = makeDecimalDataType(tm.mysql.decimal);
//# sourceMappingURL=decimal.js.map

/***/ }),

/***/ "../tsql/dist/data-type/non-built-in-value-expr/index.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/data-type/non-built-in-value-expr/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./decimal */ "../tsql/dist/data-type/non-built-in-value-expr/decimal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/constructor/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/data-type/util/constructor/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-data-type */ "../tsql/dist/data-type/util/constructor/make-data-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/constructor/make-data-type.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/data-type/util/constructor/make-data-type.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function makeDataType(mapper, toBuiltInExpr_NonCorrelated, isNullSafeEqual, extraMapper) {
    const myMapper = (extraMapper == undefined ?
        mapper :
        tm.pipe(mapper, extraMapper));
    function dataType(name, mixed) {
        return myMapper(name, mixed);
    }
    dataType.toBuiltInExpr_NonCorrelated = toBuiltInExpr_NonCorrelated;
    dataType.isNullSafeEqual = isNullSafeEqual;
    dataType.orNull = () => {
        return makeDataType(tm.orNull(myMapper), (value) => {
            if (value === null) {
                return null;
            }
            else {
                const rawExpr = toBuiltInExpr_NonCorrelated(value);
                return rawExpr;
            }
        }, (a, b) => {
            if (a === null) {
                if (b === null) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                if (b === null) {
                    return false;
                }
                else {
                    return isNullSafeEqual(a, b);
                }
            }
        });
    };
    return dataType;
}
exports.makeDataType = makeDataType;
//# sourceMappingURL=make-data-type.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/data-type/util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/data-type/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/data-type/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/data-type/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/evaluate-candidate-key.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/evaluate-candidate-key.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "../tsql/dist/data-type/util/operation/evaluate-columns.js");
const evaluate_primary_key_1 = __webpack_require__(/*! ./evaluate-primary-key */ "../tsql/dist/data-type/util/operation/evaluate-primary-key.js");
async function tryEvaluateCandidateKey(table, connection, row) {
    const mappingErrors = [];
    for (const candidateKey of table.candidateKeys) {
        const evaluateResult = await evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.candidateKey`, candidateKey, row);
        if (evaluateResult.success) {
            return evaluateResult;
        }
        if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
            mappingErrors.push(evaluateResult.error);
        }
    }
    return {
        success: false,
        error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.candidateKey`, row, mappingErrors),
    };
}
exports.tryEvaluateCandidateKey = tryEvaluateCandidateKey;
async function tryEvaluateCandidateKeyPreferPrimaryKey(table, connection, row) {
    if (table.primaryKey == undefined) {
        return tryEvaluateCandidateKey(table, connection, row);
    }
    const evaluatePrimaryKeyResult = await evaluate_primary_key_1.tryEvaluatePrimaryKey(table, connection, row);
    if (evaluatePrimaryKeyResult.success) {
        return evaluatePrimaryKeyResult;
    }
    return tryEvaluateCandidateKey(table, connection, row);
}
exports.tryEvaluateCandidateKeyPreferPrimaryKey = tryEvaluateCandidateKeyPreferPrimaryKey;
//# sourceMappingURL=evaluate-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/evaluate-columns.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/evaluate-columns.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
async function tryEvaluateColumns(table, connection, name, columnAliases, row) {
    /**
     * We do not want extra properties
     */
    row = tm.TypeUtil.pick(row, ...columnAliases);
    const rowKeys = Object.keys(row);
    if (rowKeys.length < columnAliases.length) {
        const missingColumns = columnAliases
            .filter(columnAlias => !rowKeys.includes(columnAlias));
        return {
            success: false,
            error: new Error(`Input row is missing columns ${missingColumns.join(", ")}`),
        };
    }
    const outputRowMapper = column_map_1.ColumnMapUtil.mapper(column_map_1.ColumnMapUtil.pick(table.columns, columnAliases));
    const outputRowResult = tm.tryMapHandled(outputRowMapper, name, row);
    if (outputRowResult.success) {
        /**
         * The best case scenario
         */
        return {
            success: true,
            outputRow: outputRowResult.value,
        };
    }
    /**
     * Not so great.
     * We have to make a DB call to evaluate the expression(s)
     */
    const query = unified_query_1.QueryUtil
        .newInstance()
        .select(() => columnAliases
        .map(columnAlias => {
        const rawExprInput = row[columnAlias];
        return expr_1.ExprUtil.fromRawExprNoUsedRefInput(table.columns[columnAlias], rawExprInput).as(columnAlias);
    }));
    row = await execution_1.ExecutionUtil.fetchOne(query, connection);
    const outputRowResult2 = tm.tryMapHandled(outputRowMapper, name, row);
    if (outputRowResult2.success) {
        return {
            success: true,
            outputRow: outputRowResult2.value,
        };
    }
    else {
        return {
            success: false,
            error: outputRowResult2.mappingError,
        };
    }
}
exports.tryEvaluateColumns = tryEvaluateColumns;
//# sourceMappingURL=evaluate-columns.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/evaluate-custom-expr.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/evaluate-custom-expr.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const util_1 = __webpack_require__(/*! ../../../built-in-expr/util */ "../tsql/dist/built-in-expr/util/index.js");
/**
 * Given a type `T`, we may have a `CustomExpr_NonCorrelated<T>`.
 *
 * This may be `T` itself, or `IExpr<T>` or `IColumn<T>` or
 * any other non-`T`.
 *
 * However, we **want** `T`.
 * This function helps us resolve non-`T` types to `T` itself.
 */
async function evaluateCustomExpr(column, connection, customExpr) {
    if (util_1.isAnyNonValueExpr(customExpr)) {
        //We have a non-value expression, evaluate it to figure out what its value is
        const rawEvaluatedValue = await unified_query_1.QueryUtil
            .newInstance()
            .selectValue(() => customExpr)
            .fetchValue(connection);
        //We must have a value now
        const evaluatedValue = column.mapper(`${column.tableAlias}.${column.columnAlias}`, rawEvaluatedValue);
        return evaluatedValue;
    }
    const valueResult = tm.mapHandled(column.mapper, `${column.tableAlias}.${column.columnAlias}`, customExpr);
    return valueResult;
}
exports.evaluateCustomExpr = evaluateCustomExpr;
//# sourceMappingURL=evaluate-custom-expr.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/evaluate-insertable-candidate-key.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/evaluate-insertable-candidate-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "../tsql/dist/data-type/util/operation/evaluate-columns.js");
const evaluate_primary_key_1 = __webpack_require__(/*! ./evaluate-primary-key */ "../tsql/dist/data-type/util/operation/evaluate-primary-key.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
async function tryEvaluateInsertableCandidateKey(table, connection, row) {
    const insertableColumnAliases = table_1.TableUtil.insertableColumnAlias(table);
    const mappingErrors = [];
    for (const candidateKey of table.candidateKeys) {
        if (!key_1.KeyUtil.isSubKey(candidateKey, insertableColumnAliases)) {
            continue;
        }
        const evaluateResult = await evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.insertableCandidateKey`, candidateKey, row);
        if (evaluateResult.success) {
            return evaluateResult;
        }
        if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
            mappingErrors.push(evaluateResult.error);
        }
    }
    return {
        success: false,
        error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.insertableCandidateKey`, row, mappingErrors),
    };
}
exports.tryEvaluateInsertableCandidateKey = tryEvaluateInsertableCandidateKey;
async function tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row) {
    if (table.primaryKey == undefined) {
        return tryEvaluateInsertableCandidateKey(table, connection, row);
    }
    if (table.primaryKey.every(columnAlias => table_1.TableUtil.isInsertableColumnAlias(table, columnAlias))) {
        const evaluatePrimaryKeyResult = await evaluate_primary_key_1.tryEvaluatePrimaryKey(table, connection, row);
        if (evaluatePrimaryKeyResult.success) {
            return evaluatePrimaryKeyResult;
        }
    }
    return tryEvaluateInsertableCandidateKey(table, connection, row);
}
exports.tryEvaluateInsertableCandidateKeyPreferPrimaryKey = tryEvaluateInsertableCandidateKeyPreferPrimaryKey;
//# sourceMappingURL=evaluate-insertable-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/evaluate-primary-key.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/evaluate-primary-key.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "../tsql/dist/data-type/util/operation/evaluate-columns.js");
async function tryEvaluatePrimaryKey(table, connection, row) {
    return evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.primaryKey`, table.primaryKey, row);
}
exports.tryEvaluatePrimaryKey = tryEvaluatePrimaryKey;
//# sourceMappingURL=evaluate-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./evaluate-candidate-key */ "../tsql/dist/data-type/util/operation/evaluate-candidate-key.js"));
__export(__webpack_require__(/*! ./evaluate-columns */ "../tsql/dist/data-type/util/operation/evaluate-columns.js"));
__export(__webpack_require__(/*! ./evaluate-custom-expr */ "../tsql/dist/data-type/util/operation/evaluate-custom-expr.js"));
__export(__webpack_require__(/*! ./evaluate-insertable-candidate-key */ "../tsql/dist/data-type/util/operation/evaluate-insertable-candidate-key.js"));
__export(__webpack_require__(/*! ./evaluate-primary-key */ "../tsql/dist/data-type/util/operation/evaluate-primary-key.js"));
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/data-type/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/operation/intersect.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/data-type/util/operation/intersect.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/data-type/util/predicate/index.js");
const constructor_1 = __webpack_require__(/*! ../constructor */ "../tsql/dist/data-type/util/constructor/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
/**
 * @todo Implement something more efficient to generalize intersect `N` mappers.
 *
 * This runs a `mixed` value through both `mapperA` and `mapperB`.
 * Then, it checks that both mapped results are equal.
 *
 * It **does not** try to "deep-merge" both mapped results.
 *
 * So, you cannot combine mappers for `{x:number}` and `{y:number}`
 * and hope to have a value of type `{x:number, y:number}` during run-time.
 *
 * it will just throw a run-time error because a value of exactly type `{x:number}`
 * is not equal to a value of exactly type `{y:number}`.
 */
function intersect(mapperA, mapperB) {
    if (predicate_1.isDataType(mapperA)) {
        if (predicate_1.isDataType(mapperB)) {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperA.isNullSafeEqual(mappedA, 
                /**
                 * This may throw
                 */
                mapperA(name, mappedB))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                if (!mapperB.isNullSafeEqual(mappedB, 
                /**
                 * This may throw
                 */
                mapperB(name, mappedA))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} ${tm.TypeUtil.toTypeStr(mappedB)} fails RHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperA.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperA.isNullSafeEqual(a, b);
            });
        }
        else {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperA.isNullSafeEqual(mappedA, 
                /**
                 * This may throw
                 */
                mapperA(name, mappedB))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 *
                 * Well, we couldn't perform RHS equality checks...
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperA.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperA.isNullSafeEqual(a, b);
            });
        }
    }
    else {
        if (predicate_1.isDataType(mapperB)) {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperB.isNullSafeEqual(mappedB, 
                /**
                 * This may throw
                 */
                mapperB(name, mappedA))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 *
                 * Well, we couldn't perform LHS equality checks...
                 */
                return mappedB;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperB.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperB.isNullSafeEqual(a, b);
            });
        }
        else {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedA)) {
                    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                        if (!built_in_value_expr_1.BuiltInValueExprUtil.isEqual(mappedA, mappedB)) {
                            /**
                             * @todo Find a way to make better messages.
                             */
                            throw tm.ErrorUtil.makeMappingError({
                                message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                inputName: name,
                                actualValue: mixed,
                                expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                expectedMeta: {
                                    mapperA,
                                    mapperB,
                                },
                            });
                        }
                    }
                    else {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                }
                else {
                    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    else {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check; use IDataType instead of SafeMapper`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 *
                 * So, we can assume they are built-in values
                 */
                return built_in_expr_1.BuiltInExprUtil.fromValueExpr(mapperA, value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we can assume they are built-in values
                 */
                return (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(a) &&
                    built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(b) &&
                    built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b));
            });
        }
    }
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/predicate/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/data-type/util/predicate/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-data-type */ "../tsql/dist/data-type/util/predicate/is-data-type.js"));
__export(__webpack_require__(/*! ./is-null-safe-equal */ "../tsql/dist/data-type/util/predicate/is-null-safe-equal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/predicate/is-data-type.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/data-type/util/predicate/is-data-type.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function isDataType(raw) {
    if (typeof raw != "function") {
        return false;
    }
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "toBuiltInExpr_NonCorrelated",
        "isNullSafeEqual",
    ])) {
        return false;
    }
    return ((typeof raw.toBuiltInExpr_NonCorrelated == "function") &&
        (typeof raw.isNullSafeEqual == "function"));
}
exports.isDataType = isDataType;
//# sourceMappingURL=is-data-type.js.map

/***/ }),

/***/ "../tsql/dist/data-type/util/predicate/is-null-safe-equal.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/data-type/util/predicate/is-null-safe-equal.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const is_data_type_1 = __webpack_require__(/*! ./is-data-type */ "../tsql/dist/data-type/util/predicate/is-data-type.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.isNullSafeEqual()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`,
 * but may not be suitable for custom data types.
 */
function isNullSafeEqual(mapper, a, b) {
    if (column_1.ColumnUtil.isColumn(mapper)) {
        mapper = mapper.mapper;
    }
    if (is_data_type_1.isDataType(mapper)) {
        return mapper.isNullSafeEqual(a, b);
    }
    else {
        if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(a)) {
            if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(b)) {
                return built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b);
            }
            else {
                return false;
            }
        }
        else {
            return tm.TypeUtil.strictEqual(a, b);
        }
    }
}
exports.isNullSafeEqual = isNullSafeEqual;
//# sourceMappingURL=is-null-safe-equal.js.map

/***/ }),

/***/ "../tsql/dist/date-time-util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/date-time-util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./util */ "../tsql/dist/date-time-util/util.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/date-time-util/util.js":
/*!*******************************************!*\
  !*** ../tsql/dist/date-time-util/util.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Right now, this is MySQL-specific.
 *
 * But I imagine this should work on most (all?) SQL databases.
 *
 * @todo Investigate. If incompatible, fix.
 */
const StringUtil = __webpack_require__(/*! ../string-util */ "../tsql/dist/string-util/index.js");
//Uses UTC
//Truncates if fractionSecondPrecision is too small.
function toSqlUtc(d, fractionalSecondPrecision /*|4|5|6*/) {
    if (!isFinite(d.getTime())) {
        throw new Error("Invalid date passed");
    }
    const year = StringUtil.zeroPad(d.getUTCFullYear(), 4);
    //getUTCMonth() returns [0, 11]
    //We want [1, 12]
    const month = StringUtil.zeroPad(d.getUTCMonth() + 1, 2);
    const day = StringUtil.zeroPad(d.getUTCDate(), 2);
    const hour = StringUtil.zeroPad(d.getUTCHours(), 2);
    const minute = StringUtil.zeroPad(d.getUTCMinutes(), 2);
    const second = StringUtil.zeroPad(d.getUTCSeconds(), 2);
    if (fractionalSecondPrecision == 0) {
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
    }
    else {
        const ms = StringUtil.zeroPad(d.getUTCMilliseconds(), fractionalSecondPrecision).substr(0, fractionalSecondPrecision);
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;
    }
}
exports.toSqlUtc = toSqlUtc;
//Month is zero-based
//Day is one-based
function isValidDate(year, month, day) {
    var d = new Date(year, month, day);
    if (d.getFullYear() === year && d.getMonth() === month && d.getDate() === day) {
        return true;
    }
    return false;
}
const mySqlDateTimeRegex = /^(\d{4})-(\d{2})-(\d{2})( (\d{2}):(\d{2}):(\d{2})(\.(\d{1,6}))?)?$/;
//Assumes UTC
function fromSqlUtc(sql, fractionalSecondPrecision /*|4|5|6*/) {
    const match = mySqlDateTimeRegex.exec(sql);
    if (match == undefined) {
        throw new Error(`Invalid MySQL DATETIME string`);
    }
    const year = parseInt(match[1]);
    //1-based
    const month = parseInt(match[2]);
    //1-based
    const dayOfMonth = parseInt(match[3]);
    if (!isValidDate(year, month - 1, dayOfMonth)) {
        throw new Error(`Invalid MySQL DATETIME string; month or day does not exist for given year`);
    }
    const hour = (match[5] == undefined) ?
        0 :
        parseInt(match[5]);
    if (hour > 23) {
        throw new Error(`Hour must be [0, 23]`);
    }
    const minute = (match[6] == undefined) ?
        0 :
        parseInt(match[6]);
    if (minute > 59) {
        throw new Error(`Minute must be [0, 59]`);
    }
    const second = (match[7] == undefined) ?
        0 :
        parseInt(match[7]);
    if (second > 59) {
        throw new Error(`Second must be [0, 59]`);
    }
    const microsecondPart = (match[9] == undefined) ?
        0 :
        parseInt(StringUtil.trailingZeroPad(match[9], 6));
    if (microsecondPart > 999999) {
        throw new Error(`Microsecond must be [0, 999999]`);
    }
    const millisecond = Math.floor(microsecondPart / 1000);
    const microsecond = microsecondPart % 1000;
    if (match[9] != undefined &&
        match[9].length > fractionalSecondPrecision) {
        throw new Error(`Expected DATETIME(${fractionalSecondPrecision}), received DATETIME(${match[9].length})`);
    }
    //TODO-FEATURE Microsecond support
    //BEGIN TEMPORARY NON-SUPPORT FOR MICROSECOND
    if (microsecond != 0) {
        throw new Error(`Microsecond support for DATETIME is not supported yet`);
    }
    //END TEMPORARY NON-SUPPORT FOR MICROSECOND
    const utcMillisecondTimestamp = Date.UTC(year, 
    //Date.UTC() expects [0, 11]
    month - 1, dayOfMonth, hour, minute, second, millisecond);
    return new Date(utcMillisecondTimestamp);
}
exports.fromSqlUtc = fromSqlUtc;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "../tsql/dist/date-util/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/date-util/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-date */ "../tsql/dist/date-util/is-date.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/date-util/is-date.js":
/*!*****************************************!*\
  !*** ../tsql/dist/date-util/is-date.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isDate(x) {
    return Object.prototype.toString.call(x) === "[object Date]";
}
exports.isDate = isDate;
//# sourceMappingURL=is-date.js.map

/***/ }),

/***/ "../tsql/dist/derived-table-select-item/derived-table-select-item-impl.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/derived-table-select-item/derived-table-select-item-impl.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_1 = __webpack_require__(/*! ../derived-table */ "../tsql/dist/derived-table/index.js");
const expr_1 = __webpack_require__(/*! ../expr */ "../tsql/dist/expr/index.js");
/**
 * Meant to be a combination of `DerivedTable` and `AliasedExpr`.
 */
class DerivedTableSelectItem {
    constructor(data, unaliasedAst) {
        this.mapper = data.mapper;
        this.isLateral = data.isLateral;
        this.tableAlias = data.tableAlias;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.isAggregate = data.isAggregate;
        this.ast = unaliasedAst;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * For now, the moment you use the `LATERAL` modifier,
     * it can no longer be used as an expression or aliased expression.
     *
     * No real reason for this rule, just laziness.
     */
    lateral() {
        return derived_table_1.DerivedTableUtil.lateral(this);
    }
    /**
     * For now, the moment you try to re-alias,
     * it can no longer be used as a derived table.
     *
     * No real reason for this rule, just laziness.
     *
     * -----
     *
     * If you are running into "max instantiation depth" errors,
     * consider adding explicit `TableExpr<>` type annotations.
     *
     * If that doesn't help,
     * consider using `ExprUtil.as()` instead.
     *
     * Also, consider reading this to understand my frustration,
     * https://github.com/microsoft/TypeScript/issues/29511
     *
     * @param alias
     */
    as(alias) {
        return expr_1.ExprUtil.as(this, alias);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() ASC
     * ```
     */
    asc() {
        return expr_1.ExprUtil.asc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() DESC
     * ```
     */
    desc() {
        return expr_1.ExprUtil.desc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  (myTable.myColumn IS NOT NULL) ASC,
     *  RAND() DESC
     * ```
     */
    sort(sortDirection) {
        return expr_1.ExprUtil.sort(this, sortDirection);
    }
}
exports.DerivedTableSelectItem = DerivedTableSelectItem;
//# sourceMappingURL=derived-table-select-item-impl.js.map

/***/ }),

/***/ "../tsql/dist/derived-table-select-item/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/derived-table-select-item/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./derived-table-select-item-impl */ "../tsql/dist/derived-table-select-item/derived-table-select-item-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/derived-table/derived-table-impl.js":
/*!********************************************************!*\
  !*** ../tsql/dist/derived-table/derived-table-impl.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DerivedTableUtil = __webpack_require__(/*! ./util */ "../tsql/dist/derived-table/util/index.js");
/**
 * A query can be aliased,
 *
 * ```sql
 * SELECT
 *  *
 * FROM
 *  myTable
 * CROSS JOIN
 *  (
 *      SELECT
 *          RAND() AS randomNumber,
 *          UTC_TIMESTAMP() AS timeNow
 *  ) AS tmpTable --This is a `DerivedTable`
 * ```
 *
 */
class DerivedTable {
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * Makes a derived table a `LATERAL` derived table.
     *
     * -----
     *
     * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      (
     *          SELECT
     *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * However, a `LATERAL` derived table can,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      LATERAL (
     *          SELECT
     *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * Note:
     * + Not supported in MySQL 5.7
     * + Supported as of MySQL 8.0.14
     */
    lateral() {
        return DerivedTableUtil.lateral(this);
    }
}
exports.DerivedTable = DerivedTable;
//# sourceMappingURL=derived-table-impl.js.map

/***/ }),

/***/ "../tsql/dist/derived-table/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/derived-table/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./derived-table-impl */ "../tsql/dist/derived-table/derived-table-impl.js"));
const DerivedTableUtil = __webpack_require__(/*! ./util */ "../tsql/dist/derived-table/util/index.js");
exports.DerivedTableUtil = DerivedTableUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/derived-table/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/derived-table/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/derived-table/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/derived-table/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/derived-table/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lateral */ "../tsql/dist/derived-table/util/operation/lateral.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/derived-table/util/operation/lateral.js":
/*!************************************************************!*\
  !*** ../tsql/dist/derived-table/util/operation/lateral.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_impl_1 = __webpack_require__(/*! ../../derived-table-impl */ "../tsql/dist/derived-table/derived-table-impl.js");
/**
 * Makes a derived table a `LATERAL` derived table.
 *
 * -----
 *
 * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable
 *  CROSS JOIN
 *      (
 *          SELECT
 *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
 *              myTable.x + otherTable.y AS z
 *          FROM
 *              otherTable
 *      ) AS tmpTable
 * ```
 *
 * However, a `LATERAL` derived table can,
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable
 *  CROSS JOIN
 *      LATERAL (
 *          SELECT
 *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
 *              myTable.x + otherTable.y AS z
 *          FROM
 *              otherTable
 *      ) AS tmpTable
 * ```
 *
 * Note:
 * + Not supported in MySQL 5.7
 * + Supported as of MySQL 8.0.14
 */
function lateral(derivedTable) {
    const result = new derived_table_impl_1.DerivedTable({
        isLateral: true,
        alias: derivedTable.alias,
        columns: derivedTable.columns,
        usedRef: derivedTable.usedRef,
    }, derivedTable.unaliasedAst);
    return result;
}
exports.lateral = lateral;
//# sourceMappingURL=lateral.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/design-pattern-log/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./log-impl */ "../tsql/dist/design-pattern-log/log-impl.js"));
const LogUtil = __webpack_require__(/*! ./util */ "../tsql/dist/design-pattern-log/util/index.js");
exports.LogUtil = LogUtil;
const util_1 = __webpack_require__(/*! ./util */ "../tsql/dist/design-pattern-log/util/index.js");
exports.log = util_1.log;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/log-impl.js":
/*!***************************************************!*\
  !*** ../tsql/dist/design-pattern-log/log-impl.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LogUtil = __webpack_require__(/*! ./util */ "../tsql/dist/design-pattern-log/util/index.js");
class Log {
    constructor(data, extraData) {
        /**
         * A collection of correlated subqueries/expressions,
         * these require the `ownerTable` to be in the `FROM` clause.
         */
        this.correlatedSubquery = {
            exists: () => {
                return LogUtil.CorrelatedSubquery.exists(this);
            },
            latest: () => {
                return LogUtil.CorrelatedSubquery.latest(this);
            },
            latestValue: (selectValueDelegate) => {
                return LogUtil.CorrelatedSubquery.latestValue(this, selectValueDelegate);
            },
            latestValueOrDefault: (selectValueDelegate) => {
                return LogUtil.CorrelatedSubquery.latestValueOrDefault(this, selectValueDelegate);
            },
        };
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
        this.trackedWithDefaultValue = data.trackedWithDefaultValue;
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.copyDefaultsDelegate = extraData.copyDefaultsDelegate;
        this.trackedDefaults = extraData.trackedDefaults;
    }
    fetchDefault(connection, primaryKey) {
        return LogUtil.fetchDefault(this, connection, primaryKey);
    }
    fetchLatest(connection, primaryKey) {
        return LogUtil.fetchLatest(this, connection, primaryKey);
    }
    fetchLatestValue(connection, primaryKey, selectValueDelegate) {
        return LogUtil.fetchLatestValue(this, connection, primaryKey, selectValueDelegate);
    }
    /**
     * @todo Make this part of fluent API of `fetchLatest()`?
     */
    fetchLatestOrDefault(connection, primaryKey) {
        return LogUtil.fetchLatestOrDefault(this, connection, primaryKey);
    }
    fetchLatestValueOrDefault(connection, primaryKey, selectValueDelegate) {
        return LogUtil.fetchLatestValueOrDefault(this, connection, primaryKey, selectValueDelegate);
    }
    exists(connection, primaryKey) {
        return LogUtil.exists(this, connection, primaryKey);
    }
    trackOrInsert(connection, primaryKey, trackOrInsertRow) {
        return LogUtil.trackOrInsert(this, connection, primaryKey, trackOrInsertRow);
    }
    unsafeTrack(connection, primaryKey, unsafeTrackRow) {
        return LogUtil.unsafeTrack(this, connection, primaryKey, unsafeTrackRow);
    }
    track(connection, primaryKey, trackRow) {
        return LogUtil.track(this, connection, primaryKey, trackRow);
    }
}
exports.Log = Log;
//# sourceMappingURL=log-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/00-log.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/00-log.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const _01_set_owner_1 = __webpack_require__(/*! ./01-set-owner */ "../tsql/dist/design-pattern-log/util/constructor/01-set-owner.js");
function log(logTable) {
    return new _01_set_owner_1.LogMustSetOwner({
        logTable,
    });
}
exports.log = log;
/*
import {table} from "../../../table";
import * as tm from "type-mapping";
import {KeyArrayUtil} from "../../../key";
import {Identity} from "../../../type-util";
import {from, requireOuterQueryJoins} from "../../../unified-query";
import {eqPrimaryKeyOfTable} from "../../../expr-library";

export const businessFile = table("businessFile")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessFileId : tm.mysql.bigIntSigned(),
        awsS3PresignedUploadId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
        fileTypeId : tm.mysql.bigIntSigned(),
        updatedAt : tm.mysql.dateTime(),
        updatedAt2 : tm.mysql.dateTime(),
        updatedByExternalUserId : tm.mysql.varChar().orNull(),
    })
    .setAutoIncrement(c => c.businessFileId)
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt,
    ])
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt2,
    ])
    .addExplicitDefaultValue(c => [c.updatedAt])
    .addExplicitDefaultValue(c => [c.updatedAt2])
    .removeAllMutable();

export const businessFileType = table("businessFileType")
    .addColumns({
        businessId : tm.mysql.bigIntSigned(),
        businessTypeId : tm.mysql.bigIntSigned(),
        fileTypeId : tm.mysql.bigIntSigned(),
        createdAt : tm.mysql.dateTime(),
    })
    .setPrimaryKey(c => [c.businessId, c.fileTypeId])
    .addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

export const business = table("business")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
    })
    .setAutoIncrement(c => c.businessId)
    //.addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

businessFile.candidateKeys
type ca = LatestOrderColumnAlias<typeof businessFile, typeof businessFileType>;
type cm = LatestOrderColumnMap<typeof businessFile, typeof businessFileType>;

const businessFileLog = log(
    {
        logTable : businessFile,
        ownerTable : businessFileType
    },
    columns => columns.updatedAt.desc(),
    columns => [columns.awsS3PresignedUploadId]
).setDoNotCopy(
    columns => [columns.updatedByExternalUserId]
).setCopyDefaults(({ownerPrimaryKey, connection}) => {
    return business.fetchOneByPrimaryKey(
        connection,
        ownerPrimaryKey,
        c => [c.appId, c.externalUserId]
    );
}).setTrackedDefaults({
    awsS3PresignedUploadId : 1n
});
businessFileLog.setDoNotCopy(columns => [])
*/
//# sourceMappingURL=00-log.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/01-set-owner.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/01-set-owner.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const _02_set_latest_order_1 = __webpack_require__(/*! ./02-set-latest-order */ "../tsql/dist/design-pattern-log/util/constructor/02-set-latest-order.js");
class LogMustSetOwner {
    constructor(data) {
        this.logTable = data.logTable;
    }
    setOwner(ownerTable) {
        return new _02_set_latest_order_1.LogMustSetLatestOrder({
            logTable: this.logTable,
            ownerTable,
        });
    }
}
exports.LogMustSetOwner = LogMustSetOwner;
//# sourceMappingURL=01-set-owner.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/02-set-latest-order.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/02-set-latest-order.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const _03_set_tracked_1 = __webpack_require__(/*! ./03-set-tracked */ "../tsql/dist/design-pattern-log/util/constructor/03-set-tracked.js");
function latestOrderColumnAlias(data) {
    const { logTable, ownerTable } = data;
    const possibleColumnAliases = [
        ...logTable.explicitDefaultValueColumns,
        ...logTable.generatedColumns,
    ];
    const result = possibleColumnAliases.filter(columnAlias => key_1.KeyArrayUtil.hasKey(logTable.candidateKeys, [...ownerTable.primaryKey, columnAlias]));
    return result;
}
exports.latestOrderColumnAlias = latestOrderColumnAlias;
class LogMustSetLatestOrder {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
    }
    setLatestOrder(latestOrderDelegate) {
        const latestOrderColumns = column_map_1.ColumnMapUtil.pick(this.logTable.columns, latestOrderColumnAlias(this));
        const latestOrder = latestOrderDelegate(latestOrderColumns);
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(latestOrderColumns, [latestOrder[0]]);
        return new _03_set_tracked_1.LogMustSetTracked({
            logTable: this.logTable,
            ownerTable: this.ownerTable,
            latestOrder,
        });
    }
}
exports.LogMustSetLatestOrder = LogMustSetLatestOrder;
//# sourceMappingURL=02-set-latest-order.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/03-set-tracked.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/03-set-tracked.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const _04_set_do_not_copy_1 = __webpack_require__(/*! ./04-set-do-not-copy */ "../tsql/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js");
class LogMustSetTracked {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
    }
    setTracked(trackedDelegate) {
        const trackedColumns = column_map_1.ColumnMapUtil.omit(this.logTable.columns, [
            ...this.ownerTable.primaryKey,
            ...this.logTable.generatedColumns,
            this.latestOrder[0].columnAlias,
        ]);
        const tracked = trackedDelegate(trackedColumns);
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(trackedColumns, tracked);
        const invalidCopy = [
            ...this.ownerTable.primaryKey,
            ...this.logTable.generatedColumns,
            ...(this.logTable.autoIncrement == undefined ?
                [] :
                [this.logTable.autoIncrement]),
            this.latestOrder[0].columnAlias,
            ...tracked.map(column => column.columnAlias),
        ];
        const copy = column_1.ColumnArrayUtil.fromColumnMap(this.logTable.columns)
            .map(column => column.columnAlias)
            .filter(columnAlias => {
            return !invalidCopy.includes(columnAlias);
        });
        return new _04_set_do_not_copy_1.LogMustSetDoNotCopy({
            logTable: this.logTable,
            ownerTable: this.ownerTable,
            latestOrder: this.latestOrder,
            tracked: tracked.map(column => column.columnAlias),
            copy: copy,
        });
    }
}
exports.LogMustSetTracked = LogMustSetTracked;
//# sourceMappingURL=03-set-tracked.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const _06_set_tracked_defaults_1 = __webpack_require__(/*! ./06-set-tracked-defaults */ "../tsql/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js");
const _05_set_copy_defaults_delegate_1 = __webpack_require__(/*! ./05-set-copy-defaults-delegate */ "../tsql/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js");
function setDoNotCopy(log, delegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.copy);
    const doNotCopy = delegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columns, doNotCopy);
    const { logTable, ownerTable, latestOrder, tracked, } = log;
    const copy = log.copy
        .filter((columnName) => {
        return !doNotCopy.some(c => c.columnAlias == columnName);
    });
    if (copy.length == 0) {
        const result = new _06_set_tracked_defaults_1.LogMustSetTrackedDefaults({
            logTable,
            ownerTable,
            latestOrder,
            tracked,
            doNotCopy: doNotCopy.map(c => c.columnAlias),
            copy,
            copyDefaultsDelegate: () => Promise.resolve({}),
        });
        return result;
    }
    else {
        const result = new _05_set_copy_defaults_delegate_1.LogMustSetCopyDefaultsDelegate({
            logTable,
            ownerTable,
            latestOrder,
            tracked,
            doNotCopy: doNotCopy.map(c => c.columnAlias),
            copy,
        });
        return result;
    }
}
exports.setDoNotCopy = setDoNotCopy;
class LogMustSetDoNotCopy {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.copy = data.copy;
    }
    setDoNotCopy(delegate) {
        return setDoNotCopy(this, delegate);
    }
}
exports.LogMustSetDoNotCopy = LogMustSetDoNotCopy;
//# sourceMappingURL=04-set-do-not-copy.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js":
/*!*****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
const custom_expr_1 = __webpack_require__(/*! ../../../custom-expr */ "../tsql/dist/custom-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const _06_set_tracked_defaults_1 = __webpack_require__(/*! ./06-set-tracked-defaults */ "../tsql/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
function setCopyDefaultsDelegate(log, rawCopyDefaultsDelegate) {
    /**
     * Nothing is allowed
     */
    const allowedRef = used_ref_1.UsedRefUtil.fromColumnRef({});
    const requiredColumnAliases = table_1.TableUtil.requiredColumnAlias(log.logTable)
        .filter(columnName => (log.copy.indexOf(columnName) >= 0));
    const optionalColumnAliases = table_1.TableUtil.optionalColumnAlias(log.logTable)
        .filter(columnName => (log.copy.indexOf(columnName) >= 0));
    const copyDefaults = async (args) => {
        const customExprResult = await rawCopyDefaultsDelegate({
            ...args,
            ownerPrimaryKey: primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, args.ownerPrimaryKey),
        });
        const valueExprResult = {};
        for (const columnAlias of requiredColumnAliases) {
            const customExpr = customExprResult[columnAlias];
            if (customExpr === undefined) {
                throw new Error(`Expected a value for ${log.logTable.alias}.${columnAlias}`);
            }
            const usedRef = custom_expr_1.CustomExprUtil.usedRef(customExpr);
            used_ref_1.UsedRefUtil.assertAllowed(allowedRef, usedRef);
            valueExprResult[columnAlias] = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
        }
        for (const columnAlias of optionalColumnAliases) {
            const customExpr = customExprResult[columnAlias];
            if (customExpr === undefined) {
                continue;
            }
            const usedRef = custom_expr_1.CustomExprUtil.usedRef(customExpr);
            used_ref_1.UsedRefUtil.assertAllowed(allowedRef, usedRef);
            valueExprResult[columnAlias] = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
        }
        return valueExprResult;
    };
    const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, } = log;
    return new _06_set_tracked_defaults_1.LogMustSetTrackedDefaults({
        logTable,
        ownerTable,
        latestOrder,
        tracked,
        doNotCopy,
        copy,
        copyDefaultsDelegate: copyDefaults,
    });
}
exports.setCopyDefaultsDelegate = setCopyDefaultsDelegate;
class LogMustSetCopyDefaultsDelegate {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
    }
    setCopyDefaults(rawCopyDefaultsDelegate) {
        return setCopyDefaultsDelegate(this, rawCopyDefaultsDelegate);
    }
}
exports.LogMustSetCopyDefaultsDelegate = LogMustSetCopyDefaultsDelegate;
//# sourceMappingURL=05-set-copy-defaults-delegate.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const log_impl_1 = __webpack_require__(/*! ../../log-impl */ "../tsql/dist/design-pattern-log/log-impl.js");
const custom_expr_1 = __webpack_require__(/*! ../../../custom-expr */ "../tsql/dist/custom-expr/index.js");
function setTrackedDefaults(log, rawTrackedDefaults) {
    const trackedDefaults = {};
    for (const columnAlias of log.tracked) {
        const customExpr = rawTrackedDefaults[columnAlias];
        if (customExpr === undefined) {
            continue;
        }
        const value = custom_expr_1.CustomExprUtil.mapNonCorrelated(log.logTable.columns[columnAlias], customExpr);
        trackedDefaults[columnAlias] = value;
    }
    const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, copyDefaultsDelegate, } = log;
    return new log_impl_1.Log({
        tracked,
        doNotCopy,
        copy,
        trackedWithDefaultValue: Object.keys(trackedDefaults),
        logTable,
        ownerTable,
        latestOrder,
    }, {
        copyDefaultsDelegate,
        trackedDefaults,
    });
}
exports.setTrackedDefaults = setTrackedDefaults;
class LogMustSetTrackedDefaults {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
        this.copyDefaultsDelegate = data.copyDefaultsDelegate;
    }
    setTrackedDefaults(rawTrackedDefaults) {
        return setTrackedDefaults(this, rawTrackedDefaults);
    }
}
exports.LogMustSetTrackedDefaults = LogMustSetTrackedDefaults;
//# sourceMappingURL=06-set-tracked-defaults.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/constructor/index.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/constructor/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./00-log */ "../tsql/dist/design-pattern-log/util/constructor/00-log.js"));
__export(__webpack_require__(/*! ./01-set-owner */ "../tsql/dist/design-pattern-log/util/constructor/01-set-owner.js"));
__export(__webpack_require__(/*! ./02-set-latest-order */ "../tsql/dist/design-pattern-log/util/constructor/02-set-latest-order.js"));
__export(__webpack_require__(/*! ./03-set-tracked */ "../tsql/dist/design-pattern-log/util/constructor/03-set-tracked.js"));
__export(__webpack_require__(/*! ./04-set-do-not-copy */ "../tsql/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js"));
__export(__webpack_require__(/*! ./05-set-copy-defaults-delegate */ "../tsql/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js"));
__export(__webpack_require__(/*! ./06-set-tracked-defaults */ "../tsql/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/correlated-subquery/exists.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/correlated-subquery/exists.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function exists(log) {
    return ExprLib.exists(unified_query_1.QueryUtil.newInstance()
        .requireOuterQueryJoins(...[log.ownerTable])
        .from(log.logTable)
        .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable)));
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/correlated-subquery/index.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/correlated-subquery/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "../tsql/dist/design-pattern-log/util/correlated-subquery/exists.js"));
__export(__webpack_require__(/*! ./latest-value-or-default */ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js"));
__export(__webpack_require__(/*! ./latest-value */ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value.js"));
__export(__webpack_require__(/*! ./latest */ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js":
/*!*******************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const exists_1 = __webpack_require__(/*! ./exists */ "../tsql/dist/design-pattern-log/util/correlated-subquery/exists.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const latest_1 = __webpack_require__(/*! ./latest */ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest.js");
function latestValueOrDefault(log, selectValueDelegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
    const column = selectValueDelegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
    if (tm.canOutputNull(column.mapper)) {
        /**
         * It is possible for a row to exist but the value is `NULL`.
         * Especially when the column is nullable.
         */
        return ExprLib.if(exists_1.exists(log), latest_1.latest(log)
            .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
    }
    else {
        /**
         * Column is not nullable, we should never have `NULL`
         * unless it's because a row does not exist.
         */
        return ExprLib.coalesce(latest_1.latest(log)
            .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
    }
}
exports.latestValueOrDefault = latestValueOrDefault;
//# sourceMappingURL=latest-value-or-default.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/correlated-subquery/latest-value.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_1 = __webpack_require__(/*! ./latest */ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
function latestValue(log, selectValueDelegate) {
    return expr_1.ExprUtil.fromBuiltInExpr(latest_1.latest(log)
        .selectValue(selectValueDelegate));
}
exports.latestValue = latestValue;
//# sourceMappingURL=latest-value.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/correlated-subquery/latest.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/correlated-subquery/latest.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function latest(log) {
    return unified_query_1.QueryUtil.newInstance()
        .requireOuterQueryJoins(...[log.ownerTable])
        .from(log.logTable)
        .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable))
        .orderBy(() => [log.latestOrder])
        .limit(1);
}
exports.latest = latest;
//# sourceMappingURL=latest.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/exists.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/exists.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
async function exists(log, connection, primaryKey) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return unified_query_1.QueryUtil.newInstance()
        .from(log.logTable)
        .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
        .exists(connection);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/fetch-default.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/fetch-default.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
function assertAllTrackedHasDefaultValue(log) {
    if (!key_1.KeyUtil.isEqual(log.tracked, log.trackedWithDefaultValue)) {
        throw new Error(`Not all tracked columns have a default value`);
    }
}
exports.assertAllTrackedHasDefaultValue = assertAllTrackedHasDefaultValue;
async function fetchDefault(log, // & AssertAllTrackedHasDefaultValue<LogT>,
connection, primaryKey) {
    //assertAllTrackedHasDefaultValue(log);
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        //If the owner does not exist, there is no default value
        await table_1.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
        const copyDefaults = await log.copyDefaultsDelegate({
            ownerPrimaryKey: primaryKey,
            connection,
        });
        const trackedColumnAliases = Object.keys(log.trackedDefaults);
        const selectClause = trackedColumnAliases.map((trackedColumnAlias) => {
            const rawExprNoUsedRef = log.trackedDefaults[trackedColumnAlias];
            return expr_1.ExprUtil.fromBuiltInExpr(built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], rawExprNoUsedRef)).as(trackedColumnAlias);
        });
        const trackedDefaults = await execution_1.ExecutionUtil.fetchOne(unified_query_1.QueryUtil.newInstance()
            .select(() => selectClause), connection);
        return {
            ...copyDefaults,
            ...trackedDefaults,
            ...primaryKey,
        };
    });
}
exports.fetchDefault = fetchDefault;
//# sourceMappingURL=fetch-default.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-or-default.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/fetch-latest-or-default.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_default_1 = __webpack_require__(/*! ./fetch-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-default.js");
const fetch_latest_1 = __webpack_require__(/*! ./fetch-latest */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function fetchLatestOrDefault(log, connection, primaryKey) {
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const latestOrUndefined = await fetch_latest_1.fetchLatest(log, connection, primaryKey).orUndefined();
        if (latestOrUndefined != undefined) {
            return {
                isDefault: false,
                row: latestOrUndefined,
            };
        }
        return fetch_default_1.fetchDefault(log, connection, primaryKey)
            .then((def) => {
            return {
                isDefault: true,
                row: def,
            };
        });
    });
}
exports.fetchLatestOrDefault = fetchLatestOrDefault;
//# sourceMappingURL=fetch-latest-or-default.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_latest_value_1 = __webpack_require__(/*! ./fetch-latest-value */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-value.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function fetchLatestValueOrDefault(log, connection, primaryKey, selectValueDelegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
    const column = selectValueDelegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
    const latestValueOrUndefined = await fetch_latest_value_1.fetchLatestValue(log, connection, primaryKey, () => column).orUndefined();
    if (latestValueOrUndefined !== undefined) {
        return latestValueOrUndefined;
    }
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        //If the owner does not exist, there is no default value
        await table_1.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
        return data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[column.columnAlias], connection, log.trackedDefaults[column.columnAlias]);
    });
}
exports.fetchLatestValueOrDefault = fetchLatestValueOrDefault;
//# sourceMappingURL=fetch-latest-value-or-default.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-value.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/fetch-latest-value.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_by_primary_key_1 = __webpack_require__(/*! ./latest-by-primary-key */ "../tsql/dist/design-pattern-log/util/execution/latest-by-primary-key.js");
function fetchLatestValue(log, connection, primaryKey, selectValueDelegate) {
    const result = latest_by_primary_key_1.latestByPrimaryKey(log, primaryKey)
        .selectValue(selectValueDelegate)
        .fetchValue(connection);
    return result;
}
exports.fetchLatestValue = fetchLatestValue;
//# sourceMappingURL=fetch-latest-value.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/fetch-latest.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/fetch-latest.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_by_primary_key_1 = __webpack_require__(/*! ./latest-by-primary-key */ "../tsql/dist/design-pattern-log/util/execution/latest-by-primary-key.js");
function fetchLatest(log, connection, primaryKey) {
    const result = latest_by_primary_key_1.latestByPrimaryKey(log, primaryKey)
        .select(((columns) => [columns]))
        .fetchOne(connection);
    return result;
}
exports.fetchLatest = fetchLatest;
//# sourceMappingURL=fetch-latest.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/index.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "../tsql/dist/design-pattern-log/util/execution/exists.js"));
__export(__webpack_require__(/*! ./fetch-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-or-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-or-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-value-or-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-value */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-value.js"));
__export(__webpack_require__(/*! ./fetch-latest */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest.js"));
__export(__webpack_require__(/*! ./latest-by-primary-key */ "../tsql/dist/design-pattern-log/util/execution/latest-by-primary-key.js"));
__export(__webpack_require__(/*! ./track-or-insert */ "../tsql/dist/design-pattern-log/util/execution/track-or-insert.js"));
__export(__webpack_require__(/*! ./track */ "../tsql/dist/design-pattern-log/util/execution/track.js"));
__export(__webpack_require__(/*! ./unsafe-track */ "../tsql/dist/design-pattern-log/util/execution/unsafe-track.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/latest-by-primary-key.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/latest-by-primary-key.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function latestByPrimaryKey(log, primaryKey) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return unified_query_1.QueryUtil.newInstance()
        .from(log.logTable)
        .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
        .orderBy(() => [log.latestOrder])
        .limit(1);
}
exports.latestByPrimaryKey = latestByPrimaryKey;
//# sourceMappingURL=latest-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/track-or-insert.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/track-or-insert.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unsafe_track_1 = __webpack_require__(/*! ./unsafe-track */ "../tsql/dist/design-pattern-log/util/execution/unsafe-track.js");
async function trackOrInsert(log, connection, primaryKey, trackOrInsertRow) {
    return unsafe_track_1.unsafeTrack(log, connection, primaryKey, trackOrInsertRow);
}
exports.trackOrInsert = trackOrInsert;
//# sourceMappingURL=track-or-insert.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/track.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/track.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_default_1 = __webpack_require__(/*! ./fetch-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-default.js");
const unsafe_track_1 = __webpack_require__(/*! ./unsafe-track */ "../tsql/dist/design-pattern-log/util/execution/unsafe-track.js");
async function track(log, connection, primaryKey, trackRow) {
    fetch_default_1.assertAllTrackedHasDefaultValue(log);
    return unsafe_track_1.unsafeTrack(log, connection, primaryKey, trackRow);
}
exports.track = track;
//# sourceMappingURL=track.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/execution/unsafe-track.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/execution/unsafe-track.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const fetch_latest_or_default_1 = __webpack_require__(/*! ./fetch-latest-or-default */ "../tsql/dist/design-pattern-log/util/execution/fetch-latest-or-default.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "../tsql/dist/sqlstring/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function toInsertRow(log, connection, prvRow, newRow) {
    const result = {};
    /**
     * Copy `prvRow`'s primary key
     */
    for (const primaryKeyColumnAlias of log.ownerTable.primaryKey) {
        const prvValueExpr = prvRow[primaryKeyColumnAlias];
        result[primaryKeyColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[primaryKeyColumnAlias], prvValueExpr);
    }
    /**
     * Copy all `tracked` values, if no new value is provided.
     */
    let changed = false;
    for (const trackedColumnAlias of log.tracked) {
        const newCustomExpr = newRow[trackedColumnAlias];
        const prvValueExpr = prvRow[trackedColumnAlias];
        if (newCustomExpr === undefined) {
            if (prvValueExpr === undefined) {
                throw new Error(`No new or previous value for ${sqlstring_1.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(trackedColumnAlias)} was found`);
            }
            else {
                /**
                 * Use the previous value, since we don't have a new value.
                 */
                result[trackedColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], prvValueExpr);
            }
        }
        else {
            const newValueExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[trackedColumnAlias], connection, newCustomExpr);
            result[trackedColumnAlias] = newValueExpr;
            if (!data_type_1.DataTypeUtil.isNullSafeEqual(log.logTable.columns[trackedColumnAlias].mapper, newValueExpr, prvValueExpr)) {
                /**
                 * New value is used, we consider this a change.
                 */
                changed = true;
            }
        }
    }
    /**
     * We expect new values for all required `doNotCopy` columns
     */
    for (const doNotCopyColumnAlias of log.doNotCopy) {
        const newCustomExpr = newRow[doNotCopyColumnAlias];
        if (newCustomExpr === undefined) {
            if (table_1.TableUtil.isRequiredColumnAlias(log.logTable, doNotCopyColumnAlias)) {
                throw new Error(`Expected a new value for ${sqlstring_1.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(doNotCopyColumnAlias)}`);
            }
            else {
                continue;
            }
        }
        const newValueExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[doNotCopyColumnAlias], connection, newCustomExpr);
        result[doNotCopyColumnAlias] = newValueExpr;
    }
    /**
     * Copy the previous row's `copy`
     */
    for (const copyColumnAlias of log.copy) {
        const prvValueExpr = prvRow[copyColumnAlias];
        result[copyColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[copyColumnAlias], prvValueExpr);
    }
    return {
        changed,
        insertRow: result,
    };
}
/**
 * Allows `tracked` columns without default values to be unset.
 * However, this comes with the risk of run-time errors, if no previous row is found.
 */
async function unsafeTrack(log, connection, primaryKey, unsafeTrackRow) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const latestOrDefault = await fetch_latest_or_default_1.fetchLatestOrDefault(log, connection, primaryKey);
        const { changed, insertRow } = await toInsertRow(log, connection, latestOrDefault.row, unsafeTrackRow);
        if (changed) {
            return {
                changed,
                previous: latestOrDefault,
                current: await execution_1.ExecutionUtil.insertAndFetch(log.logTable, connection, insertRow),
            };
        }
        else {
            return {
                changed,
                previous: latestOrDefault,
            };
        }
    });
}
exports.unsafeTrack = unsafeTrack;
//# sourceMappingURL=unsafe-track.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-log/util/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/design-pattern-log/util/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/design-pattern-log/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "../tsql/dist/design-pattern-log/util/execution/index.js"));
//export * from "./operation";
const CorrelatedSubquery = __webpack_require__(/*! ./correlated-subquery */ "../tsql/dist/design-pattern-log/util/correlated-subquery/index.js");
exports.CorrelatedSubquery = CorrelatedSubquery;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-per-type-impl */ "../tsql/dist/design-pattern-table-per-type/table-per-type-impl.js"));
const TablePerTypeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/design-pattern-table-per-type/util/index.js");
exports.TablePerTypeUtil = TablePerTypeUtil;
exports.tablePerType = TablePerTypeUtil.tablePerType;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/table-per-type-impl.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/table-per-type-impl.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TablePerTypeUtil = __webpack_require__(/*! ./util */ "../tsql/dist/design-pattern-table-per-type/util/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
class TablePerType {
    constructor(data, joins) {
        this.childTable = data.childTable;
        this.parentTables = data.parentTables;
        this.autoIncrement = data.autoIncrement;
        this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
        this.insertAndFetchPrimaryKey = data.insertAndFetchPrimaryKey;
        this.joins = joins;
    }
    addParent(parentTable) {
        return TablePerTypeUtil.addParent(this, parentTable);
    }
    fetchOne(connection, whereDelegate) {
        return TablePerTypeUtil.fetchOne(this, connection, whereDelegate);
    }
    fetchOneByCandidateKey(connection, candidateKey) {
        return TablePerTypeUtil.fetchOneByCandidateKey(this, connection, candidateKey);
    }
    fetchOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.fetchOneByPrimaryKey(this, connection, primaryKey);
    }
    fetchOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.fetchOneBySuperKey(this, connection, superKey);
    }
    insertAndFetch(connection, row) {
        return TablePerTypeUtil.insertAndFetch(this, connection, row);
    }
    updateAndFetchOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
    }
    updateAndFetchOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
    }
    updateAndFetchOneBySuperKey(connection, superKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneBySuperKey(connection, superKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
    }
    deleteOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.deleteOneByCandidateKey(this, connection, candidateKey);
    }
    deleteOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.deleteOneByPrimaryKey(this, connection, primaryKey);
    }
    deleteOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.deleteOneBySuperKey(this, connection, superKey);
    }
    deleteZeroOrOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.deleteZeroOrOneByCandidateKey(this, connection, candidateKey);
    }
    deleteZeroOrOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.deleteZeroOrOneByPrimaryKey(this, connection, primaryKey);
    }
    deleteZeroOrOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.deleteZeroOrOneBySuperKey(this, connection, superKey);
    }
    existsByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey)).then(result => result.exists);
    }
    existsByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey)).then(result => result.exists);
    }
    existsBySuperKey(connection, superKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey)).then(result => result.exists);
    }
    assertExistsByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey));
    }
    assertExistsByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey));
    }
    assertExistsBySuperKey(connection, superKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey));
    }
}
exports.TablePerType = TablePerType;
//# sourceMappingURL=table-per-type-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/constructor/index.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/constructor/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-per-type */ "../tsql/dist/design-pattern-table-per-type/util/constructor/table-per-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/constructor/table-per-type.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/constructor/table-per-type.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_per_type_impl_1 = __webpack_require__(/*! ../../table-per-type-impl */ "../tsql/dist/design-pattern-table-per-type/table-per-type-impl.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
function tablePerType(childTable) {
    return new table_per_type_impl_1.TablePerType({
        childTable,
        parentTables: [],
        autoIncrement: query_1.extractAutoIncrement(childTable),
        explicitAutoIncrementValueEnabled: query_1.extractExplicitAutoIncrementValueEnabled(childTable),
        insertAndFetchPrimaryKey: query_1.extractInsertAndFetchPrimaryKey(childTable),
    }, []);
}
exports.tablePerType = tablePerType;
//# sourceMappingURL=table-per-type.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
/**
 * @todo Better name
 *
 * Adds properties from `row` to `result`.
 *
 * If a property from `row` already exists on `result`,
 * we use `table` to check if the values on both objects are equal.
 *
 * If they are not equal, an `Error` is thrown.
 */
function absorbRow(result, table, row) {
    for (const columnAlias of Object.keys(row)) {
        /**
         * This is guaranteed to be a value expression.
         */
        const newValue = row[columnAlias];
        if (Object.prototype.hasOwnProperty.call(result, columnAlias)) {
            /**
             * This `curValue` could be a non-value expression.
             * We only want value expressions.
             */
            const curValue = result[columnAlias];
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(curValue)) {
                /**
                 * Add this new value to the `result`
                 * so we can use it to update rows of tables
                 * further down the inheritance hierarchy.
                 */
                result[columnAlias] = newValue;
                continue;
            }
            if (curValue === newValue) {
                /**
                 * They are equal, do nothing.
                 */
                continue;
            }
            /**
             * We need some custom equality checking logic
             */
            if (!data_type_1.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], 
            /**
             * This may throw
             */
            table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, curValue), newValue)) {
                /**
                 * @todo Custom `Error` type
                 */
                throw new Error(`All columns with the same name in an inheritance hierarchy must have the same value; mismatch found for ${table.alias}.${columnAlias}`);
            }
        }
        else {
            /**
             * Add this new value to the `result`
             * so we can use it to update rows of tables
             * further down the inheritance hierarchy.
             */
            result[columnAlias] = newValue;
        }
    }
}
exports.absorbRow = absorbRow;
//# sourceMappingURL=absorb-row.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js":
/*!********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const from_1 = __webpack_require__(/*! ./from */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js");
async function assertExistsImpl(tpt, connection, whereDelegate) {
    return execution_1.ExecutionUtil.assertExists(from_1.from(tpt)
        .where(whereDelegate), connection);
}
exports.assertExistsImpl = assertExistsImpl;
//# sourceMappingURL=assert-exists-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js":
/*!*****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function deleteOneImpl(tpt, connection, whereDelegate) {
    /**
     * @todo Add `assertDeletable()` or something
     */
    /**
     * Using `SERIALIZABLE` because it's possible for a different transaction to
     * `UPDATE` primary key values between the `fetchOne()` and multiple `deleteOne()` calls.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.SERIALIZABLE, async (connection) => {
        return connection.savepoint(async (connection) => {
            const primaryKeys = await execution_1.ExecutionUtil.fetchOne(execution_impl_1.from(tpt)
                .where(whereDelegate)
                .select(() => query_1.primaryKeyColumnAliases(tpt).map(columnAlias => {
                const table = query_1.findTableWithColumnAlias(tpt, columnAlias);
                return table.columns[columnAlias];
            })), connection);
            const deleteChildResult = await execution_1.ExecutionUtil.deleteOne(tpt.childTable, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKeys));
            const deleteOneResults = [
                {
                    ...deleteChildResult,
                    table: tpt.childTable,
                },
            ];
            let deletedRowCount = deleteChildResult.deletedRowCount;
            let warningCount = deleteChildResult.warningCount;
            /**
             * We use `.reverse()` here to `DELETE` the parents
             * as we go up the inheritance hierarchy.
             */
            for (const parentTable of [...tpt.parentTables].reverse()) {
                const deleteParentResult = await execution_1.ExecutionUtil.deleteOne(parentTable, connection, () => ExprLib.eqPrimaryKey(parentTable, primaryKeys));
                deleteOneResults.push({
                    ...deleteParentResult,
                    table: parentTable,
                });
                deletedRowCount = tm.BigIntUtil.add(deletedRowCount, deleteParentResult.deletedRowCount);
                warningCount = tm.BigIntUtil.add(warningCount, deleteParentResult.warningCount);
            }
            return {
                deleteOneResults,
                deletedRowCount,
                warningCount,
            };
        });
    });
}
exports.deleteOneImpl = deleteOneImpl;
//# sourceMappingURL=delete-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js":
/*!*************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const delete_one_impl_1 = __webpack_require__(/*! ./delete-one-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js");
const exists_impl_1 = __webpack_require__(/*! ./exists-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function deleteZeroOrOneImpl(tpt, connection, whereDelegate) {
    /**
     * @todo Add `assertDeletable()` or something
     */
    /**
     * `SERIALIZABLE` because it uses `deleteOneImpl()`, which uses `SERIALIZABLE`
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.SERIALIZABLE, async (connection) => {
        const existsResult = await exists_impl_1.existsImpl(tpt, connection, whereDelegate);
        if (!existsResult.exists) {
            return {
                /**
                 * Used as a discriminant.
                 */
                deleteOneResults: undefined,
                query: { sql: existsResult.sql },
                //Alias for affectedRows
                deletedRowCount: tm.BigInt(0),
                /**
                 * @todo MySQL sometimes gives a `warningCount` value `> 0` for
                 * `DELETE` statements. Recall why.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
            };
        }
        return delete_one_impl_1.deleteOneImpl(tpt, connection, whereDelegate);
    });
}
exports.deleteZeroOrOneImpl = deleteZeroOrOneImpl;
//# sourceMappingURL=delete-zero-or-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const from_1 = __webpack_require__(/*! ./from */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js");
async function existsImpl(tpt, connection, whereDelegate) {
    return execution_1.ExecutionUtil.existsImpl(from_1.from(tpt)
        .where(whereDelegate), connection);
}
exports.existsImpl = existsImpl;
//# sourceMappingURL=exists-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js":
/*!****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExecutionImpl = __webpack_require__(/*! ../../../execution/util/operation/impl */ "../tsql/dist/execution/util/operation/impl/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const from_1 = __webpack_require__(/*! ./from */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
function cleanFetchedRow(tpt, rawRow) {
    const cleanRow = {};
    for (const columnAlias of query_1.columnAliases(tpt)) {
        const tables = query_1.extractAllTablesWithColumnAlias(tpt, columnAlias);
        for (let i = 0; i < tables.length; ++i) {
            const table = tables[i];
            const value = rawRow[table.alias][columnAlias];
            for (let j = i + 1; j < tables.length; ++j) {
                const otherTable = tables[j];
                const otherValue = rawRow[otherTable.alias][columnAlias];
                if (!data_type_1.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], value, 
                /**
                 * This may throw
                 */
                table.columns[columnAlias].mapper(`(${otherTable.alias}->${table.alias}).${columnAlias}`, otherValue))) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Expected ${table.alias}.${columnAlias} and ${otherTable.alias}.${columnAlias} to have the same value`);
                }
                if (!data_type_1.DataTypeUtil.isNullSafeEqual(otherTable.columns[columnAlias], otherValue, 
                /**
                 * This may throw
                 */
                otherTable.columns[columnAlias].mapper(`(${table.alias}->${otherTable.alias}).${columnAlias}`, value))) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Expected ${otherTable.alias}.${columnAlias} and ${table.alias}.${columnAlias} to have the same value`);
                }
            }
        }
        //If we are here, then it doesn't matter which value of `columnAlias` we use.
        cleanRow[columnAlias] = rawRow[tables[0].alias][columnAlias];
    }
    return cleanRow;
}
/**
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function fetchOneImpl(tpt, connection, whereDelegate) {
    try {
        if (tpt.parentTables.length == 0) {
            return ExecutionImpl.fetchOneImpl(unified_query_1.QueryUtil.newInstance()
                .from(tpt.childTable)
                .where(whereDelegate)
                .select(columns => [columns]), connection);
        }
        const query = from_1.from(tpt)
            .where(whereDelegate)
            .select(columns => [columns]);
        const limitedQuery = ExecutionImpl.trySetLimit2(query);
        const fetchLimit2Promise = ExecutionImpl.fetchAllImpl(limitedQuery, connection);
        const result = fetchLimit2Promise.then((fetched) => {
            const rawRow = ExecutionImpl.ensureOne(limitedQuery, fetched);
            return {
                sql: fetched.sql,
                row: cleanFetchedRow(tpt, rawRow),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return fetchLimit2Promise
                .then((fetched) => {
                const rawRowOrDefaultValue = ExecutionImpl.ensureOneOr(limitedQuery, fetched, defaultValue);
                return {
                    sql: fetched.sql,
                    row: (rawRowOrDefaultValue === defaultValue ?
                        defaultValue :
                        cleanFetchedRow(tpt, rawRowOrDefaultValue)),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOneImpl = fetchOneImpl;
//# sourceMappingURL=fetch-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
/**
 * This is used to implement a more efficient `fetchOne` operation.
 *
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function from(tpt) {
    if (tpt.parentTables.length == 0) {
        return unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable);
    }
    let query = unified_query_1.QueryUtil.newInstance()
        .from(tpt.childTable);
    /**
     * We are iterating **backwards**.
     * This is intentional.
     */
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parent = tpt.parentTables[i];
        const [fromTableAlias,] = query_1.findLastJoinToTable(tpt, parent.alias);
        query = unified_query_1.QueryUtil.innerJoinUsingPrimaryKey(query, src => src[fromTableAlias], parent);
    }
    return query;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./absorb-row */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js"));
__export(__webpack_require__(/*! ./assert-exists-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js"));
__export(__webpack_require__(/*! ./delete-one-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js"));
__export(__webpack_require__(/*! ./exists-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js"));
__export(__webpack_require__(/*! ./from */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/from.js"));
__export(__webpack_require__(/*! ./invoke-assignment-delegate */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js":
/*!****************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
/**
 * Not meant to be called externally.
 *
 * @todo Better name
 */
async function invokeAssignmentDelegate(tpt, connection, whereDelegate, assignmentMapDelegate) {
    const columns = column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnArrayUtil.fromColumnMapArray([
        tpt.childTable.columns,
        ...tpt.parentTables.map(parentTable => parentTable.columns)
    ]));
    /**
     * May contain extra properties that are not mutable columns,
     * or even columns at all.
     */
    const rawAssignmentMap = assignmentMapDelegate(columns);
    const columnAliasArr = Object.keys(rawAssignmentMap);
    if (columnAliasArr.length == 0) {
        /**
         * @todo Perform an exists check, if the row does not exist,
         * throw rowNotFound, for early-exit.
         *
         * At the moment, this isn't so important because we have
         * other methods downstream that will throw it.
         */
        return {};
    }
    const query = execution_impl_1.from(tpt)
        .where(whereDelegate)
        .select(() => columnAliasArr
        .filter(columnAlias => query_1.isMutableColumnAlias(tpt, columnAlias))
        .map(columnAlias => {
        const customExpr = rawAssignmentMap[columnAlias];
        if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
            /**
             * We have a non-value expression
             */
            return expr_1.expr({
                mapper: data_type_1.DataTypeUtil.intersect(query_1.columnMapper(tpt, columnAlias), built_in_expr_1.BuiltInExprUtil.mapper(customExpr)),
                usedRef: built_in_expr_1.BuiltInExprUtil.usedRef(customExpr),
                isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(customExpr),
            }, built_in_expr_1.BuiltInExprUtil.buildAst(customExpr)).as(columnAlias);
        }
        else {
            /**
             * We have a value expression
             */
            return expr_1.ExprUtil.fromRawExprNoUsedRefInput(query_1.columnMapper(tpt, columnAlias), customExpr).as(columnAlias);
        }
    }));
    /**
     * Should only contain value expressions now.
     */
    return execution_1.ExecutionUtil.fetchOne(query, connection);
}
exports.invokeAssignmentDelegate = invokeAssignmentDelegate;
//# sourceMappingURL=invoke-assignment-delegate.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js":
/*!***************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const absorb_row_1 = __webpack_require__(/*! ./absorb-row */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
/**
 * Not meant to be called externally.
 *
 * **DOES NOT** use savepoints, internally.
 * You **SHOULD** use savepoints before calling this function.
 */
async function updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const updateOneResults = [
            {
                ...updateAndFetchChildResult,
                table: tpt.childTable,
            },
        ];
        let updatedRowCount = updateAndFetchChildResult.updatedRowCount;
        let warningCount = updateAndFetchChildResult.warningCount;
        const result = updateAndFetchChildResult.row;
        /**
         * We use `.reverse()` here to `UPDATE` the parents
         * as we go up the inheritance hierarchy.
         */
        for (const parentTable of [...tpt.parentTables].reverse()) {
            const updateAndFetchParentResult = await execution_1.ExecutionUtil.updateAndFetchOneByPrimaryKey(parentTable, connection, 
            /**
             * The `result` should contain the primary key values we are interested in
             */
            result, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, parentTable.mutableColumns));
            updateOneResults.push({
                ...updateAndFetchParentResult,
                table: parentTable,
            });
            updatedRowCount = tm.BigIntUtil.add(updatedRowCount, updateAndFetchParentResult.updatedRowCount);
            warningCount = tm.BigIntUtil.add(warningCount, updateAndFetchParentResult.warningCount);
            absorb_row_1.absorbRow(result, parentTable, updateAndFetchParentResult.row);
        }
        return {
            updateOneResults,
            /**
             * +1 for the `childTable`.
             */
            foundRowCount: tm.BigInt(tpt.parentTables.length + 1),
            updatedRowCount,
            warningCount,
            row: result,
        };
    });
}
exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
//# sourceMappingURL=update-and-fetch-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js":
/*!************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.deleteOneByCandidateKey = deleteOneByCandidateKey;
//# sourceMappingURL=delete-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js":
/*!**********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteOneByPrimaryKey(tpt, connection, primaryKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.deleteOneByPrimaryKey = deleteOneByPrimaryKey;
//# sourceMappingURL=delete-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js":
/*!********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js");
async function deleteOneBySuperKey(tpt, connection, superKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.deleteOneBySuperKey = deleteOneBySuperKey;
//# sourceMappingURL=delete-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js":
/*!********************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteZeroOrOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.deleteZeroOrOneByCandidateKey = deleteZeroOrOneByCandidateKey;
//# sourceMappingURL=delete-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js":
/*!******************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteZeroOrOneByPrimaryKey(tpt, connection, primaryKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.deleteZeroOrOneByPrimaryKey = deleteZeroOrOneByPrimaryKey;
//# sourceMappingURL=delete-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js":
/*!****************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js");
async function deleteZeroOrOneBySuperKey(tpt, connection, superKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.deleteZeroOrOneBySuperKey = deleteZeroOrOneBySuperKey;
//# sourceMappingURL=delete-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js":
/*!***********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
function fetchOneByCandidateKey(tpt, connection, candidateKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.fetchOneByCandidateKey = fetchOneByCandidateKey;
//# sourceMappingURL=fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
function fetchOneByPrimaryKey(tpt, connection, primaryKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.fetchOneByPrimaryKey = fetchOneByPrimaryKey;
//# sourceMappingURL=fetch-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js":
/*!*******************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js");
function fetchOneBySuperKey(tpt, connection, superKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.fetchOneBySuperKey = fetchOneBySuperKey;
//# sourceMappingURL=fetch-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
/**
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function fetchOne(tpt, connection, whereDelegate) {
    try {
        const p = execution_impl_1.fetchOneImpl(tpt, connection, whereDelegate);
        const result = p.then(({ row }) => row);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ row }) => row);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/index.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./delete-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./delete-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./delete-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./fetch-one */ "../tsql/dist/design-pattern-table-per-type/util/execution/fetch-one.js"));
__export(__webpack_require__(/*! ./insert-and-fetch */ "../tsql/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
/**
 * Assumes there are no duplicate `parentTables`.
 *
 * `.addParent()` should remove duplicates.
 */
async function insertAndFetch(tpt, connection, insertRow) {
    /**
     * @todo Add `assertInsertable()` or something
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const generated = query_1.generatedColumnAliases(tpt);
            const result = type_util_1.omitOwnEnumerable(insertRow, [
                /**
                 * We omit implicit auto-increment values because we do not
                 * want them to be set by users of the library.
                 */
                ...query_1.implicitAutoIncrement(tpt),
                /**
                 * We omit generated values because users can't set them, anyway.
                 */
                ...generated,
            ]);
            for (const columnAlias of generated) {
                const table = query_1.findTableWithGeneratedColumnAlias(tpt, columnAlias);
                const sqlString = await connection.tryFetchGeneratedColumnExpression(table_1.TableUtil.tryGetSchemaName(table), table.alias, columnAlias);
                if (sqlString == undefined) {
                    throw new Error(`Generated column ${table.alias}.${columnAlias} should have generation expression`);
                }
                result[columnAlias] = expr_1.expr({
                    mapper: table.columns[columnAlias].mapper,
                    usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
                    /**
                     * `GENERATED` columns should not have aggregate expressions.
                     */
                    isAggregate: false,
                }, 
                /**
                 * This `sqlString` is not allowed to reference any columns.
                 * If it does, there is a very high chance that it will cause an error.
                 *
                 * @todo Find use case where we need to allow this to reference columns.
                 */
                sqlString);
            }
            for (const table of [...tpt.parentTables, tpt.childTable]) {
                const fetchedRow = await execution_1.ExecutionUtil.insertAndFetch(
                /**
                 * We use `InsertAndFetchOptions`, instead of creating
                 * a new table instance because we want events to use the
                 * original `table` instance.
                 *
                 * `event.isFor()` methods use `===` internally
                 */
                table, connection, result, {
                    /**
                     * We want to allow explicit auto-increment values internally,
                     * so that the same value is used for all tables of the same
                     * inheritance hierarchy.
                     */
                    explicitAutoIncrementValueEnabled: true,
                });
                execution_impl_1.absorbRow(result, table, fetchedRow);
            }
            return result;
        });
    });
}
exports.insertAndFetch = insertAndFetch;
//# sourceMappingURL=insert-and-fetch.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js":
/*!**********************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, candidateKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js":
/*!********************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByPrimaryKey(tpt.childTable, connection, primaryKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js":
/*!******************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, 
            /**
             * We have already used the `superKey` to "clean" our assignment map.
             * So, we can be reasonably sure that the `superKey` itself
             * refers to exactly one row that exists.
             *
             * Now, we can pretend this `superKey` is a `candidateKey`,
             * discarding all non-key columns.
             *
             * This should not introduce any bugs.
             */
            superKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
//# sourceMappingURL=update-and-fetch-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js":
/*!******************************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchZeroOrOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_1.ExecutionUtil.existsImpl(unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable)
            .where(() => ExprLib.eqCandidateKey(tpt.childTable, candidateKey)), connection);
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_candidate_key_1.updateAndFetchOneByCandidateKey(tpt, connection, candidateKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js":
/*!****************************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "../tsql/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const update_and_fetch_one_by_primary_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchZeroOrOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_1.ExecutionUtil.existsImpl(unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable)
            .where(() => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey)), connection);
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_primary_key_1.updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js":
/*!**************************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js");
const update_and_fetch_one_by_super_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "../tsql/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateAndFetchZeroOrOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_impl_1.existsImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_super_key_1.updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/design-pattern-table-per-type/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "../tsql/dist/design-pattern-table-per-type/util/execution/index.js"));
__export(__webpack_require__(/*! ./execution-impl */ "../tsql/dist/design-pattern-table-per-type/util/execution-impl/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/operation/add-parent.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/operation/add-parent.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const table_per_type_impl_1 = __webpack_require__(/*! ../../table-per-type-impl */ "../tsql/dist/design-pattern-table-per-type/table-per-type-impl.js");
const remove_duplicate_parents_1 = __webpack_require__(/*! ./remove-duplicate-parents */ "../tsql/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
function addParent_AutoIncrement(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractAutoIncrement(parent),
        ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
function addParent_ExplicitAutoIncrementValueEnabled(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractExplicitAutoIncrementValueEnabled(parent).filter(columnAlias => (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
            !tpt.autoIncrement.includes(columnAlias))),
        ...tpt.explicitAutoIncrementValueEnabled.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
function addParent_InsertAndFetchPrimaryKey(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractInsertAndFetchPrimaryKey(parent),
        ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
/**
 * @todo Check that a column is not both auto-increment and generated at the same time
 *
 * @todo Check that `tpt.childTable` can join to `parent.childTable` using `parent.childTable`'s primary key
 *
 * @todo Check that columns have compatible types; must be assigble from child to parent
 *       Example: child.type = "red"|"blue", parent.type = "red"|"blue"|"green"
 *
 * @todo Check that inheritance is not circular
 *       Example: `Animal` cannot be a child of `Animal`.
 *       Example: This is invalid: `Dog extends Animal extends Mammal extends Dog`
 */
function addParent(tpt, parent) {
    let joins = undefined;
    if (table_1.TableUtil.isTable(parent)) {
        joins = [
            [
                tpt.childTable.alias,
                parent.alias,
            ],
            ...tpt.joins,
        ];
    }
    else if (predicate_1.isTablePerType(parent)) {
        joins = [
            ...parent.joins,
            [
                tpt.childTable.alias,
                parent.childTable.alias,
            ],
            ...tpt.joins,
        ];
    }
    else {
        throw new Error(`Expected ITable or ITablePerType for parent`);
    }
    return new table_per_type_impl_1.TablePerType({
        childTable: tpt.childTable,
        parentTables: remove_duplicate_parents_1.removeDuplicateParents([
            ...query_1.extractAllTables(parent),
            ...tpt.parentTables,
        ]),
        autoIncrement: addParent_AutoIncrement(tpt, parent),
        explicitAutoIncrementValueEnabled: addParent_ExplicitAutoIncrementValueEnabled(tpt, parent),
        insertAndFetchPrimaryKey: addParent_InsertAndFetchPrimaryKey(tpt, parent),
    }, joins);
}
exports.addParent = addParent;
//# sourceMappingURL=add-parent.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/operation/eq-super-key.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/operation/eq-super-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/design-pattern-table-per-type/util/query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
exports.eqSuperKey = ((tpt, superKeyInput) => {
    const superKey = query_1.superKeyMapper(tpt)(`${tpt.childTable}.superKey`, superKeyInput);
    const arr = Object.keys(superKey)
        .filter((columnAlias) => {
        return superKey[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `superKey` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const table = query_1.findTableWithColumnAlias(tpt, columnAlias);
        const expr = ExprLib.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
        return expr;
    });
    const result = ExprLib.and(...arr);
    return result;
});
//# sourceMappingURL=eq-super-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/operation/index.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/operation/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./add-parent */ "../tsql/dist/design-pattern-table-per-type/util/operation/add-parent.js"));
__export(__webpack_require__(/*! ./eq-super-key */ "../tsql/dist/design-pattern-table-per-type/util/operation/eq-super-key.js"));
__export(__webpack_require__(/*! ./remove-duplicate-parents */ "../tsql/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removeDuplicateParents(arr) {
    const result = [];
    for (const parentTable of arr) {
        /**
         * @todo Add `.schemaName` property?
         * When checking `.alias` only, it may think a different
         * table from a different schema is the same table.
         */
        if (result.find(r => r.alias == parentTable.alias) != undefined) {
            continue;
        }
        result.push(parentTable);
    }
    return result;
}
exports.removeDuplicateParents = removeDuplicateParents;
//# sourceMappingURL=remove-duplicate-parents.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/predicate/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-table-per-type */ "../tsql/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
/**
 * Actually only checks if it has all the properties of `ITablePerType`.
 *
 * So, if it has all the properties but they're of the wrong data type...
 */
function isTablePerType(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "childTable",
        "parentTables",
        "autoIncrement",
        "explicitAutoIncrementValueEnabled",
        "insertAndFetchPrimaryKey",
        "joins"
    ])) {
        return false;
    }
    return (table_1.TableUtil.isTable(mixed.childTable) &&
        /**
         * Does not check if all elements are `ITable`
         */
        (mixed.parentTables instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.autoIncrement instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.explicitAutoIncrementValueEnabled instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.insertAndFetchPrimaryKey instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.joins instanceof Array));
}
exports.isTablePerType = isTablePerType;
//# sourceMappingURL=is-table-per-type.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function columnAliases(tpt) {
    const result = table_1.TableUtil.columnAlias(tpt.childTable);
    for (const parentTable of tpt.parentTables) {
        result.push(...table_1.TableUtil.columnAlias(parentTable));
    }
    return key_1.KeyUtil.removeDuplicates(result);
}
exports.columnAliases = columnAliases;
function isColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isColumnAlias = isColumnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/column-type.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/column-type.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const extract_all_tables_with_column_alias_1 = __webpack_require__(/*! ./extract-all-tables-with-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
function columnMapper(tpt, columnAlias) {
    const mappers = extract_all_tables_with_column_alias_1.extractAllTablesWithColumnAlias(tpt, columnAlias)
        .map(table => table.columns[columnAlias].mapper);
    if (mappers.length == 0) {
        throw new Error(`Table-per-type hierarchy for ${tpt.childTable.alias} does not have column alias ${columnAlias}`);
    }
    if (mappers.length == 1) {
        return mappers[0];
    }
    let result = data_type_1.DataTypeUtil.intersect(mappers[0], mappers[1]);
    for (let i = 2; i < mappers.length; ++i) {
        result = data_type_1.DataTypeUtil.intersect(result, mappers[i]);
    }
    return result;
}
exports.columnMapper = columnMapper;
//# sourceMappingURL=column-type.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js":
/*!****************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const parent_column_alias_1 = __webpack_require__(/*! ./parent-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/parent-column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function isExplicitDefaultValueColumnAlias(tpt, columnAlias) {
    if (parent_column_alias_1.isParentColumnAlias(tpt, columnAlias)) {
        for (const parentTable of tpt.parentTables) {
            if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
                !parentTable.explicitDefaultValueColumns.includes(columnAlias)) {
                return false;
            }
        }
        return true;
    }
    else {
        return tpt.childTable.explicitDefaultValueColumns.includes(columnAlias);
    }
}
exports.isExplicitDefaultValueColumnAlias = isExplicitDefaultValueColumnAlias;
function explicitDefaultValueColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isExplicitDefaultValueColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.explicitDefaultValueColumnAliases = explicitDefaultValueColumnAliases;
//# sourceMappingURL=explicit-default-value-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js":
/*!*****************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function extractAllTablesWithColumnAlias(tpt, columnAlias) {
    const result = [];
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        result.push(tpt.childTable);
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            result.push(parentTable);
        }
    }
    return result;
}
exports.extractAllTablesWithColumnAlias = extractAllTablesWithColumnAlias;
//# sourceMappingURL=extract-all-tables-with-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractAllTables(t) {
    if (predicate_1.isTablePerType(t)) {
        return [
            ...t.parentTables,
            t.childTable,
        ];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return [t];
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractAllTables = extractAllTables;
//# sourceMappingURL=extract-all-tables.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractAutoIncrement(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.autoIncrement];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return (t.autoIncrement == undefined ?
            [] :
            [t.autoIncrement]);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractAutoIncrement = extractAutoIncrement;
//# sourceMappingURL=extract-auto-increment.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-child-table.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-child-table.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function extractChildTable(t) {
    if (table_1.TableUtil.isTable(t)) {
        return t;
    }
    else {
        return t.childTable;
    }
}
exports.extractChildTable = extractChildTable;
//# sourceMappingURL=extract-child-table.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-column-alias.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-column-alias.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractColumnAliases(t) {
    if (predicate_1.isTablePerType(t)) {
        return column_alias_1.columnAliases(t);
    }
    else if (table_1.TableUtil.isTable(t)) {
        return table_1.TableUtil.columnAlias(t);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractColumnAliases = extractColumnAliases;
//# sourceMappingURL=extract-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js":
/*!**************************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractExplicitAutoIncrementValueEnabled(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.explicitAutoIncrementValueEnabled];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        t.explicitAutoIncrementValueEnabled ?
            (t.autoIncrement == undefined ?
                [] :
                [t.autoIncrement]) :
            []);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractExplicitAutoIncrementValueEnabled = extractExplicitAutoIncrementValueEnabled;
//# sourceMappingURL=extract-explicit-auto-increment-value-enabled.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js":
/*!*****************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractInsertAndFetchPrimaryKey(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.insertAndFetchPrimaryKey];
    }
    else if (table_1.TableUtil.isTable(t) && t.primaryKey != undefined) {
        return (t.autoIncrement == undefined ?
            t.primaryKey.filter(columnAlias => (!t.generatedColumns.includes(columnAlias) &&
                t.autoIncrement != columnAlias)) :
            []);
    }
    else {
        throw new Error(`Expected TableWithPrimaryKey or ITablePerType`);
    }
}
exports.extractInsertAndFetchPrimaryKey = extractInsertAndFetchPrimaryKey;
//# sourceMappingURL=extract-insert-and-fetch-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function extractParentTables(t) {
    if (table_1.TableUtil.isTable(t)) {
        return [];
    }
    else {
        return [...t.parentTables];
    }
}
exports.extractParentTables = extractParentTables;
//# sourceMappingURL=extract-parent-tables.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js":
/*!****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function findLastJoinToTable(tpt, toTableAlias) {
    for (let i = tpt.joins.length - 1; i >= 0; --i) {
        if (tpt.joins[i][1] == toTableAlias) {
            return tpt.joins[i];
        }
    }
    throw new Error(`No join to ${toTableAlias} exists in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findLastJoinToTable = findLastJoinToTable;
//# sourceMappingURL=find-last-join-to-table.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
/**
 * Goes up the inheritance hierarchy, starting from `childTable`,
 * to look for a table with `columnAlias` as a column
 */
function findTableWithColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        return tpt.childTable;
    }
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parentTable = tpt.parentTables[i];
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return parentTable;
        }
    }
    throw new Error(`No column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findTableWithColumnAlias = findTableWithColumnAlias;
//# sourceMappingURL=find-table-with-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js":
/*!*******************************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Goes up the inheritance hierarchy, starting from `childTable`,
 * to look for a table with `columnAlias` as a generated column
 */
function findTableWithGeneratedColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.generatedColumns.includes(columnAlias)) {
        return tpt.childTable;
    }
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parentTable = tpt.parentTables[i];
        if (parentTable.generatedColumns.includes(columnAlias)) {
            return parentTable;
        }
    }
    throw new Error(`No generated column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findTableWithGeneratedColumnAlias = findTableWithGeneratedColumnAlias;
//# sourceMappingURL=find-table-with-generated-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isGeneratedColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.generatedColumns.includes(columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (parentTable.generatedColumns.includes(columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isGeneratedColumnAlias = isGeneratedColumnAlias;
function generatedColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isGeneratedColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.generatedColumnAliases = generatedColumnAliases;
//# sourceMappingURL=generated-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js":
/*!****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function implicitAutoIncrement(tpt) {
    return tpt.autoIncrement.filter(columnAlias => {
        return !tpt.explicitAutoIncrementValueEnabled.includes(columnAlias);
    });
}
exports.implicitAutoIncrement = implicitAutoIncrement;
//# sourceMappingURL=implicit-auto-increment.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/index.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./column-type */ "../tsql/dist/design-pattern-table-per-type/util/query/column-type.js"));
__export(__webpack_require__(/*! ./explicit-default-value-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js"));
__export(__webpack_require__(/*! ./extract-all-tables-with-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js"));
__export(__webpack_require__(/*! ./extract-all-tables */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-all-tables.js"));
__export(__webpack_require__(/*! ./extract-auto-increment */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js"));
__export(__webpack_require__(/*! ./extract-explicit-auto-increment-value-enabled */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js"));
__export(__webpack_require__(/*! ./extract-insert-and-fetch-primary-key */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js"));
//export * from "./extract-child-column-alias";
__export(__webpack_require__(/*! ./extract-child-table */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-child-table.js"));
__export(__webpack_require__(/*! ./extract-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-column-alias.js"));
//export * from "./extract-parent-column-alias";
__export(__webpack_require__(/*! ./extract-parent-tables */ "../tsql/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js"));
__export(__webpack_require__(/*! ./find-last-join-to-table */ "../tsql/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js"));
__export(__webpack_require__(/*! ./find-table-with-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js"));
__export(__webpack_require__(/*! ./find-table-with-generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js"));
__export(__webpack_require__(/*! ./generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js"));
__export(__webpack_require__(/*! ./implicit-auto-increment */ "../tsql/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js"));
__export(__webpack_require__(/*! ./mutable-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js"));
__export(__webpack_require__(/*! ./non-generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js"));
__export(__webpack_require__(/*! ./nullable-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js"));
__export(__webpack_require__(/*! ./optional-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/optional-column-alias.js"));
__export(__webpack_require__(/*! ./parent-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/parent-column-alias.js"));
__export(__webpack_require__(/*! ./primary-key-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js"));
__export(__webpack_require__(/*! ./required-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/required-column-alias.js"));
__export(__webpack_require__(/*! ./row */ "../tsql/dist/design-pattern-table-per-type/util/query/row.js"));
__export(__webpack_require__(/*! ./super-key-mapper */ "../tsql/dist/design-pattern-table-per-type/util/query/super-key-mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function isMutableColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
        !tpt.childTable.mutableColumns.includes(columnAlias)) {
        return false;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
            !parentTable.mutableColumns.includes(columnAlias)) {
            return false;
        }
    }
    return column_alias_1.isColumnAlias(tpt, columnAlias);
}
exports.isMutableColumnAlias = isMutableColumnAlias;
function mutableColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isMutableColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.mutableColumnAliases = mutableColumnAliases;
//# sourceMappingURL=mutable-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js":
/*!*******************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
function nonGeneratedColumnAliases(tpt) {
    const generated = generated_column_alias_1.generatedColumnAliases(tpt);
    const result = column_alias_1.columnAliases(tpt)
        .filter(columnAlias => {
        return !generated.includes(columnAlias);
    });
    return result;
}
exports.nonGeneratedColumnAliases = nonGeneratedColumnAliases;
//# sourceMappingURL=non-generated-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function isNullableColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
        !tpt.childTable.nullableColumns.includes(columnAlias)) {
        return false;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
            !parentTable.nullableColumns.includes(columnAlias)) {
            return false;
        }
    }
    return column_alias_1.isColumnAlias(tpt, columnAlias);
}
exports.isNullableColumnAlias = isNullableColumnAlias;
function nullableColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isNullableColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.nullableColumnAliases = nullableColumnAliases;
//# sourceMappingURL=nullable-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/optional-column-alias.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/optional-column-alias.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const explicit_default_value_column_alias_1 = __webpack_require__(/*! ./explicit-default-value-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js");
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isOptionalColumnAlias(tpt, columnAlias) {
    return (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
        ((nullable_column_alias_1.isNullableColumnAlias(tpt, columnAlias) ||
            explicit_default_value_column_alias_1.isExplicitDefaultValueColumnAlias(tpt, columnAlias)) &&
            !generated_column_alias_1.isGeneratedColumnAlias(tpt, columnAlias)));
}
exports.isOptionalColumnAlias = isOptionalColumnAlias;
function optionalColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isOptionalColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.optionalColumnAliases = optionalColumnAliases;
//# sourceMappingURL=optional-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/parent-column-alias.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/parent-column-alias.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function parentColumnAliases(tpt) {
    const result = [];
    for (const parentTable of tpt.parentTables) {
        result.push(...table_1.TableUtil.columnAlias(parentTable));
    }
    return key_1.KeyUtil.removeDuplicates(result);
}
exports.parentColumnAliases = parentColumnAliases;
function isParentColumnAlias(tpt, columnAlias) {
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isParentColumnAlias = isParentColumnAlias;
//# sourceMappingURL=parent-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js":
/*!*****************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isPrimaryColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.primaryKey.includes(columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (parentTable.primaryKey.includes(columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isPrimaryColumnAlias = isPrimaryColumnAlias;
function primaryKeyColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isPrimaryColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.primaryKeyColumnAliases = primaryKeyColumnAliases;
//# sourceMappingURL=primary-key-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/required-column-alias.js":
/*!**************************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/required-column-alias.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const explicit_default_value_column_alias_1 = __webpack_require__(/*! ./explicit-default-value-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js");
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isRequiredColumnAlias(tpt, columnAlias) {
    return (column_alias_1.isColumnAlias(tpt, columnAlias) &&
        !(generated_column_alias_1.isGeneratedColumnAlias(tpt, columnAlias) ||
            nullable_column_alias_1.isNullableColumnAlias(tpt, columnAlias) ||
            explicit_default_value_column_alias_1.isExplicitDefaultValueColumnAlias(tpt, columnAlias) ||
            tpt.autoIncrement.includes(columnAlias)));
}
exports.isRequiredColumnAlias = isRequiredColumnAlias;
function requiredColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isRequiredColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.requiredColumnAliases = requiredColumnAliases;
//# sourceMappingURL=required-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/row.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/row.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_type_1 = __webpack_require__(/*! ./column-type */ "../tsql/dist/design-pattern-table-per-type/util/query/column-type.js");
function rowMapper(tpt) {
    const result = tm.objectFromArray(...column_alias_1.columnAliases(tpt)
        .map(columnAlias => tm.withName(column_type_1.columnMapper(tpt, columnAlias), columnAlias)));
    return result;
}
exports.rowMapper = rowMapper;
//# sourceMappingURL=row.js.map

/***/ }),

/***/ "../tsql/dist/design-pattern-table-per-type/util/query/super-key-mapper.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/design-pattern-table-per-type/util/query/super-key-mapper.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_type_1 = __webpack_require__(/*! ./column-type */ "../tsql/dist/design-pattern-table-per-type/util/query/column-type.js");
function superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey) {
    const result = tm.objectFromArray(...column_alias_1.columnAliases(tpt).map(columnAlias => {
        const mapper = tm.withName(column_type_1.columnMapper(tpt, columnAlias), columnAlias);
        if (candidateKey.includes(columnAlias)) {
            return mapper;
        }
        else {
            return tm.optional(mapper);
        }
    }));
    return result;
}
function superKeyMapper(tpt) {
    const arr = tpt.childTable.candidateKeys.map(candidateKey => {
        return superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey);
    });
    return tm.unsafeOr(...arr);
}
exports.superKeyMapper = superKeyMapper;
//# sourceMappingURL=super-key-mapper.js.map

/***/ }),

/***/ "../tsql/dist/error/clean-insert-row/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/error/clean-insert-row/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./missing-required-insert-column */ "../tsql/dist/error/clean-insert-row/missing-required-insert-column.js"));
__export(__webpack_require__(/*! ./potential-null-in-required-insert-column */ "../tsql/dist/error/clean-insert-row/potential-null-in-required-insert-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/error/clean-insert-row/missing-required-insert-column.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/error/clean-insert-row/missing-required-insert-column.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
class MissingRequiredInsertColumnError extends sql_error_1.SqlError {
    constructor(args) {
        super({
            message: args.message,
            sql: undefined,
        });
        Object.setPrototypeOf(this, MissingRequiredInsertColumnError.prototype);
        this.table = args.table;
        this.columnAlias = args.columnAlias;
    }
}
exports.MissingRequiredInsertColumnError = MissingRequiredInsertColumnError;
MissingRequiredInsertColumnError.prototype.name = "MissingRequiredInsertColumnError";
//# sourceMappingURL=missing-required-insert-column.js.map

/***/ }),

/***/ "../tsql/dist/error/clean-insert-row/potential-null-in-required-insert-column.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/error/clean-insert-row/potential-null-in-required-insert-column.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
class PotentialNullInRequiredInsertColumnError extends sql_error_1.SqlError {
    constructor(args) {
        super({
            message: args.message,
            sql: undefined,
        });
        Object.setPrototypeOf(this, PotentialNullInRequiredInsertColumnError.prototype);
        this.table = args.table;
        this.columnAlias = args.columnAlias;
    }
}
exports.PotentialNullInRequiredInsertColumnError = PotentialNullInRequiredInsertColumnError;
PotentialNullInRequiredInsertColumnError.prototype.name = "PotentialNullInRequiredInsertColumnError";
//# sourceMappingURL=potential-null-in-required-insert-column.js.map

/***/ }),

/***/ "../tsql/dist/error/execution/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/error/execution/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./invalid-sql */ "../tsql/dist/error/execution/invalid-sql.js"));
__export(__webpack_require__(/*! ./row-not-found */ "../tsql/dist/error/execution/row-not-found.js"));
__export(__webpack_require__(/*! ./too-many-rows-found */ "../tsql/dist/error/execution/too-many-rows-found.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/error/execution/invalid-sql.js":
/*!***************************************************!*\
  !*** ../tsql/dist/error/execution/invalid-sql.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
/**
 * This error happens when the database is unable to parse the SQL string.
 *
 * + MySQL      : `ER_SYNTAX_ERROR`, `ER_PARSE_ERROR`
 * + PostgreSQL : `syntax error at`
 */
class InvalidSqlError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, InvalidSqlError.prototype);
    }
}
exports.InvalidSqlError = InvalidSqlError;
InvalidSqlError.prototype.name = "InvalidSqlError";
//# sourceMappingURL=invalid-sql.js.map

/***/ }),

/***/ "../tsql/dist/error/execution/row-not-found.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/error/execution/row-not-found.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
class RowNotFoundError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, RowNotFoundError.prototype);
        this.sql = args.sql;
    }
}
exports.RowNotFoundError = RowNotFoundError;
RowNotFoundError.prototype.name = "RowNotFoundError";
//# sourceMappingURL=row-not-found.js.map

/***/ }),

/***/ "../tsql/dist/error/execution/too-many-rows-found.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/error/execution/too-many-rows-found.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
class TooManyRowsFoundError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, TooManyRowsFoundError.prototype);
        this.sql = args.sql;
    }
}
exports.TooManyRowsFoundError = TooManyRowsFoundError;
TooManyRowsFoundError.prototype.name = "TooManyRowsFoundError";
//# sourceMappingURL=too-many-rows-found.js.map

/***/ }),

/***/ "../tsql/dist/error/expr/cannot-count.js":
/*!***********************************************!*\
  !*** ../tsql/dist/error/expr/cannot-count.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
class CannotCountError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, CannotCountError.prototype);
    }
}
exports.CannotCountError = CannotCountError;
CannotCountError.prototype.name = "CannotCountError";
//# sourceMappingURL=cannot-count.js.map

/***/ }),

/***/ "../tsql/dist/error/expr/data-out-of-range.js":
/*!****************************************************!*\
  !*** ../tsql/dist/error/expr/data-out-of-range.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `MAX_BIGINT_SIGNED + 1`
 * + `MIN_BIGINT_SIGNED - 1`
 * + General overflow errors
 *
 * + MySQL      : `ER_DATA_OUT_OF_RANGE`
 * + PostgreSQL : `out of range`
 */
class DataOutOfRangeError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, DataOutOfRangeError.prototype);
    }
}
exports.DataOutOfRangeError = DataOutOfRangeError;
DataOutOfRangeError.prototype.name = "DataOutOfRangeError";
//# sourceMappingURL=data-out-of-range.js.map

/***/ }),

/***/ "../tsql/dist/error/expr/divide-by-zero.js":
/*!*************************************************!*\
  !*** ../tsql/dist/error/expr/divide-by-zero.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `1 / 0`
 * + `0 / 0`
 *
 * + MySQL      : -NA- (Returns `null`)
 * + PostgreSQL : `division by zero`
 */
class DivideByZeroError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, DivideByZeroError.prototype);
    }
}
exports.DivideByZeroError = DivideByZeroError;
DivideByZeroError.prototype.name = "DivideByZeroError";
//# sourceMappingURL=divide-by-zero.js.map

/***/ }),

/***/ "../tsql/dist/error/expr/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/error/expr/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cannot-count */ "../tsql/dist/error/expr/cannot-count.js"));
__export(__webpack_require__(/*! ./data-out-of-range */ "../tsql/dist/error/expr/data-out-of-range.js"));
__export(__webpack_require__(/*! ./divide-by-zero */ "../tsql/dist/error/expr/divide-by-zero.js"));
__export(__webpack_require__(/*! ./invalid-input */ "../tsql/dist/error/expr/invalid-input.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/error/expr/invalid-input.js":
/*!************************************************!*\
  !*** ../tsql/dist/error/expr/invalid-input.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "../tsql/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `'qwerty'::timestamp` (PostgreSQL)
 * + General input errors
 *
 * + MySQL      : `ER_INVALID_JSON_TEXT_IN_PARAM` (`CAST('qwerty' AS JSON)`), etc.
 * + PostgreSQL : `invalid input syntax for type`
 */
class InvalidInputError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, InvalidInputError.prototype);
    }
}
exports.InvalidInputError = InvalidInputError;
InvalidInputError.prototype.name = "InvalidInputError";
//# sourceMappingURL=invalid-input.js.map

/***/ }),

/***/ "../tsql/dist/error/index.js":
/*!***********************************!*\
  !*** ../tsql/dist/error/index.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-row */ "../tsql/dist/error/clean-insert-row/index.js"));
__export(__webpack_require__(/*! ./execution */ "../tsql/dist/error/execution/index.js"));
__export(__webpack_require__(/*! ./expr */ "../tsql/dist/error/expr/index.js"));
__export(__webpack_require__(/*! ./sql-error */ "../tsql/dist/error/sql-error.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/error/sql-error.js":
/*!***************************************!*\
  !*** ../tsql/dist/error/sql-error.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * All errors in this library should extend this class.
 */
class SqlError extends Error {
    constructor(args) {
        super("innerError" in args ?
            (args.innerError instanceof Object && "message" in args.innerError ?
                args.innerError.message :
                String(args.innerError)) :
            args.message);
        if ("innerError" in args && args.innerError instanceof Object && "stack" in args.innerError) {
            this.stack += `\n${args.innerError.stack}`;
        }
        Object.setPrototypeOf(this, SqlError.prototype);
        this.sql = args.sql;
        this.innerError = ("innerError" in args ?
            args.innerError :
            undefined);
    }
}
exports.SqlError = SqlError;
SqlError.prototype.name = "SqlError";
function isSqlError(mixed) {
    /**
     * @todo Should we check prototype.name or nah?
     */
    return (mixed instanceof Error &&
        (mixed.sql === undefined ||
            typeof mixed.sql == "string") &&
        "innerError" in mixed);
}
exports.isSqlError = isSqlError;
//# sourceMappingURL=sql-error.js.map

/***/ }),

/***/ "../tsql/dist/event/connection-event-emitter-collection.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/event/connection-event-emitter-collection.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const connection_event_emitter_1 = __webpack_require__(/*! ./connection-event-emitter */ "../tsql/dist/event/connection-event-emitter.js");
class ConnectionEventEmitterCollection {
    constructor(pool) {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove events while invoking a handler.
         */
        this.transactionListenerCollections = [
            []
        ];
        this.addTransactionListenerCollectionImpl = (event) => {
            const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
            const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
            this.transactionListenerCollections = [
                ...parentAndAncestors,
                [
                    ...bottom,
                    event
                ]
            ];
        };
        this.onInsert = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsert, this.addTransactionListenerCollectionImpl);
        this.onInsertOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertOne, this.addTransactionListenerCollectionImpl);
        this.onInsertAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertAndFetch, this.addTransactionListenerCollectionImpl);
        this.onInsertSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertSelect, this.addTransactionListenerCollectionImpl);
        this.onReplace = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplace, this.addTransactionListenerCollectionImpl);
        this.onReplaceOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceOne, this.addTransactionListenerCollectionImpl);
        this.onReplaceSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceSelect, this.addTransactionListenerCollectionImpl);
        this.onUpdate = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdate, this.addTransactionListenerCollectionImpl);
        this.onUpdateAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdateAndFetch, this.addTransactionListenerCollectionImpl);
        this.onDelete = new connection_event_emitter_1.ConnectionEventEmitter(pool.onDelete, this.addTransactionListenerCollectionImpl);
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is created
     */
    savepoint() {
        this.transactionListenerCollections = [
            ...this.transactionListenerCollections,
            []
        ];
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is released
     */
    releaseSavepoint() {
        if (this.transactionListenerCollections.length == 1) {
            throw new Error(`Cannot unnest top-level transaction listener collection`);
        }
        const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
        const parent = this.transactionListenerCollections[this.transactionListenerCollections.length - 2];
        const ancestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 2);
        this.transactionListenerCollections = [
            ...ancestors,
            [
                ...parent,
                ...bottom
            ]
        ];
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is rolled back
     */
    rollbackToSavepoint() {
        if (this.transactionListenerCollections.length == 1) {
            throw new Error(`Cannot unnest top-level transaction listener collection`);
        }
        const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
        const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
        this.transactionListenerCollections = parentAndAncestors;
        const syncErrors = [];
        for (const collection of bottom) {
            const invokeResult = collection.invokeOnRollbackListeners();
            syncErrors.push(...invokeResult.syncErrors);
        }
        return { syncErrors };
    }
    /**
     * This should not throw
     *
     * Used when a transaction is committed
     */
    commit() {
        const syncErrors = [];
        const scopes = this.transactionListenerCollections;
        this.transactionListenerCollections = [[]];
        for (const scope of scopes) {
            for (const collection of scope) {
                const invokeResult = collection.invokeOnCommitListeners();
                syncErrors.push(...invokeResult.syncErrors);
            }
        }
        return { syncErrors };
    }
    /**
     * This should not throw
     *
     * Used when a transaction is rolled back
     */
    rollback() {
        const syncErrors = [];
        const scopes = this.transactionListenerCollections;
        this.transactionListenerCollections = [[]];
        for (const scope of scopes) {
            for (const collection of scope) {
                const invokeResult = collection.invokeOnRollbackListeners();
                syncErrors.push(...invokeResult.syncErrors);
            }
        }
        return { syncErrors };
    }
}
exports.ConnectionEventEmitterCollection = ConnectionEventEmitterCollection;
//# sourceMappingURL=connection-event-emitter-collection.js.map

/***/ }),

/***/ "../tsql/dist/event/connection-event-emitter.js":
/*!******************************************************!*\
  !*** ../tsql/dist/event/connection-event-emitter.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ConnectionEventEmitter {
    constructor(poolEventEmitter, addTransactionListenerCollectionImpl) {
        this.poolEventEmitter = poolEventEmitter;
        this.addEventImpl = addTransactionListenerCollectionImpl;
    }
    /**
     * This may throw
     */
    async invoke(event) {
        const handlers = this.poolEventEmitter.getHandlers();
        if (handlers.length == 0) {
            /**
             * There are no handlers.
             * There's nothing for us to do here.
             */
            return;
        }
        //This should not throw.
        this.addEventImpl(event);
        //This loop may throw.
        for (const handler of handlers) {
            await handler(event);
        }
    }
}
exports.ConnectionEventEmitter = ConnectionEventEmitter;
//# sourceMappingURL=connection-event-emitter.js.map

/***/ }),

/***/ "../tsql/dist/event/delete-event.js":
/*!******************************************!*\
  !*** ../tsql/dist/event/delete-event.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class DeleteEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.whereClause = args.whereClause;
        this.deleteResult = args.deleteResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.DeleteEvent = DeleteEvent;
//# sourceMappingURL=delete-event.js.map

/***/ }),

/***/ "../tsql/dist/event/event-base.js":
/*!****************************************!*\
  !*** ../tsql/dist/event/event-base.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class EventBase {
    constructor(args) {
        this.onCommitListeners = [];
        this.onRollbackListeners = [];
        this.pool = args.connection.pool;
        this.connection = args.connection;
    }
    /**
     * If the `listener` has already been added, it will be ignored.
     */
    addOnCommitListener(listener) {
        if (this.onCommitListeners.includes(listener)) {
            /**
             * We do not want duplicate listener references.
             */
            return;
        }
        this.onCommitListeners = [...this.onCommitListeners, listener];
    }
    /**
     * If the `listener` has already been added, it will be ignored.
     */
    addOnRollbackListener(listener) {
        if (this.onRollbackListeners.includes(listener)) {
            /**
             * We do not want duplicate listener references.
             */
            return;
        }
        this.onRollbackListeners = [...this.onRollbackListeners, listener];
    }
    /**
     * For now,
     * + This should not throw.
     * + This must not wait for `async` listeners to complete.
     * + This will not catch `async` errors.
     *
     * @returns - All synchronous errors.
     */
    invokeOnCommitListeners() {
        const syncErrors = [];
        for (const listener of this.onCommitListeners) {
            try {
                listener();
            }
            catch (err) {
                syncErrors.push(err);
            }
        }
        return { syncErrors };
    }
    /**
     * For now,
     * + This should not throw.
     * + This must not wait for `async` listeners to complete.
     * + This will not catch `async` errors.
     *
     * @returns - All synchronous errors.
     */
    invokeOnRollbackListeners() {
        const syncErrors = [];
        for (const listener of this.onRollbackListeners) {
            try {
                listener();
            }
            catch (err) {
                syncErrors.push(err);
            }
        }
        return { syncErrors };
    }
}
exports.EventBase = EventBase;
//# sourceMappingURL=event-base.js.map

/***/ }),

/***/ "../tsql/dist/event/index.js":
/*!***********************************!*\
  !*** ../tsql/dist/event/index.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection-event-emitter-collection */ "../tsql/dist/event/connection-event-emitter-collection.js"));
__export(__webpack_require__(/*! ./connection-event-emitter */ "../tsql/dist/event/connection-event-emitter.js"));
__export(__webpack_require__(/*! ./delete-event */ "../tsql/dist/event/delete-event.js"));
__export(__webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js"));
__export(__webpack_require__(/*! ./insert-and-fetch-event */ "../tsql/dist/event/insert-and-fetch-event.js"));
__export(__webpack_require__(/*! ./insert-event */ "../tsql/dist/event/insert-event.js"));
__export(__webpack_require__(/*! ./insert-one-event */ "../tsql/dist/event/insert-one-event.js"));
__export(__webpack_require__(/*! ./insert-select-event */ "../tsql/dist/event/insert-select-event.js"));
__export(__webpack_require__(/*! ./pool-event-emitter */ "../tsql/dist/event/pool-event-emitter.js"));
__export(__webpack_require__(/*! ./replace-event */ "../tsql/dist/event/replace-event.js"));
__export(__webpack_require__(/*! ./replace-one-event */ "../tsql/dist/event/replace-one-event.js"));
__export(__webpack_require__(/*! ./replace-select-event */ "../tsql/dist/event/replace-select-event.js"));
__export(__webpack_require__(/*! ./update-and-fetch-event */ "../tsql/dist/event/update-and-fetch-event.js"));
__export(__webpack_require__(/*! ./update-event */ "../tsql/dist/event/update-event.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/event/insert-and-fetch-event.js":
/*!****************************************************!*\
  !*** ../tsql/dist/event/insert-and-fetch-event.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class InsertAndFetchEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.insertResult = args.insertResult;
        this.fetchedRow = args.fetchedRow;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertAndFetchEvent = InsertAndFetchEvent;
//# sourceMappingURL=insert-and-fetch-event.js.map

/***/ }),

/***/ "../tsql/dist/event/insert-event.js":
/*!******************************************!*\
  !*** ../tsql/dist/event/insert-event.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "../tsql/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "../tsql/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class InsertEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeysCache = undefined;
        this.fetchPromises = {};
        this.table = args.table;
        this.insertRows = args.insertRows;
        this.insertResult = args.insertResult;
    }
    get candidateKeys() {
        if (this.candidateKeysCache == undefined) {
            const mapper = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
            this.candidateKeysCache = this.insertRows.map(insertRow => {
                const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                return candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            });
        }
        return this.candidateKeysCache;
    }
    async getOrFetch(index) {
        let fetchPromise = this.fetchPromises[index];
        if (fetchPromise == undefined) {
            const candidateKey = this.candidateKeys[index];
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
            }
            fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            this.fetchPromises[index] = fetchPromise;
        }
        return fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertEvent = InsertEvent;
//# sourceMappingURL=insert-event.js.map

/***/ }),

/***/ "../tsql/dist/event/insert-one-event.js":
/*!**********************************************!*\
  !*** ../tsql/dist/event/insert-one-event.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "../tsql/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "../tsql/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class InsertOneEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeyCache = "uninitialized";
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.insertResult = args.insertResult;
    }
    get candidateKey() {
        if (this.candidateKeyCache == "uninitialized") {
            const candidateKeyResult = tm.tryMapHandled(candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
            this.candidateKeyCache = candidateKeyResult.success ?
                candidateKeyResult.value :
                undefined;
        }
        return this.candidateKeyCache;
    }
    async getOrFetch() {
        if (this.fetchPromise == undefined) {
            const candidateKey = this.candidateKey;
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey from insertRow`);
            }
            this.fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
        }
        return this.fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertOneEvent = InsertOneEvent;
//# sourceMappingURL=insert-one-event.js.map

/***/ }),

/***/ "../tsql/dist/event/insert-select-event.js":
/*!*************************************************!*\
  !*** ../tsql/dist/event/insert-select-event.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class InsertSelectEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.query = args.query;
        this.table = args.table;
        this.insertSelectRow = args.insertSelectRow;
        this.insertResult = args.insertResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertSelectEvent = InsertSelectEvent;
//# sourceMappingURL=insert-select-event.js.map

/***/ }),

/***/ "../tsql/dist/event/pool-event-emitter.js":
/*!************************************************!*\
  !*** ../tsql/dist/event/pool-event-emitter.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class PoolEventEmitter {
    constructor() {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove handlers while invoking a handler.
         */
        this.handlers = [];
    }
    /**
     * If the `handler` has already been added, it will be ignored.
     */
    addHandler(handler) {
        if (this.handlers.includes(handler)) {
            /**
             * We do not want duplicate handler references.
             */
            return;
        }
        this.handlers = [...this.handlers, handler];
    }
    removeHandler(handler) {
        /**
         * We should not have duplicates
         */
        const index = this.handlers.indexOf(handler);
        if (index < 0) {
            return;
        }
        this.handlers = [
            ...this.handlers.slice(0, index),
            ...this.handlers.slice(index + 1),
        ];
    }
    getHandlers() {
        return this.handlers;
    }
}
exports.PoolEventEmitter = PoolEventEmitter;
//# sourceMappingURL=pool-event-emitter.js.map

/***/ }),

/***/ "../tsql/dist/event/replace-event.js":
/*!*******************************************!*\
  !*** ../tsql/dist/event/replace-event.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "../tsql/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "../tsql/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class ReplaceEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeysCache = undefined;
        this.fetchPromises = {};
        this.table = args.table;
        this.insertRows = args.insertRows;
        this.replaceResult = args.replaceResult;
    }
    get candidateKeys() {
        if (this.candidateKeysCache == undefined) {
            const mapper = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
            this.candidateKeysCache = this.insertRows.map(insertRow => {
                const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                return candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            });
        }
        return this.candidateKeysCache;
    }
    async getOrFetch(index) {
        let fetchPromise = this.fetchPromises[index];
        if (fetchPromise == undefined) {
            const candidateKey = this.candidateKeys[index];
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
            }
            fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            this.fetchPromises[index] = fetchPromise;
        }
        return fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceEvent = ReplaceEvent;
//# sourceMappingURL=replace-event.js.map

/***/ }),

/***/ "../tsql/dist/event/replace-one-event.js":
/*!***********************************************!*\
  !*** ../tsql/dist/event/replace-one-event.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "../tsql/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "../tsql/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class ReplaceOneEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeyCache = "uninitialized";
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.replaceResult = args.replaceResult;
    }
    get candidateKey() {
        if (this.candidateKeyCache == "uninitialized") {
            const candidateKeyResult = tm.tryMapHandled(candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
            this.candidateKeyCache = candidateKeyResult.success ?
                candidateKeyResult.value :
                undefined;
        }
        return this.candidateKeyCache;
    }
    async getOrFetch() {
        if (this.fetchPromise == undefined) {
            const candidateKey = this.candidateKey;
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey from insertRow`);
            }
            this.fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
        }
        return this.fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceOneEvent = ReplaceOneEvent;
//# sourceMappingURL=replace-one-event.js.map

/***/ }),

/***/ "../tsql/dist/event/replace-select-event.js":
/*!**************************************************!*\
  !*** ../tsql/dist/event/replace-select-event.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class ReplaceSelectEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.query = args.query;
        this.table = args.table;
        this.replaceSelectRow = args.replaceSelectRow;
        this.replaceResult = args.replaceResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceSelectEvent = ReplaceSelectEvent;
//# sourceMappingURL=replace-select-event.js.map

/***/ }),

/***/ "../tsql/dist/event/update-and-fetch-event.js":
/*!****************************************************!*\
  !*** ../tsql/dist/event/update-and-fetch-event.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class UpdateAndFetchEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.assignmentMap = args.assignmentMap;
        this.updateResult = args.updateResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.UpdateAndFetchEvent = UpdateAndFetchEvent;
//# sourceMappingURL=update-and-fetch-event.js.map

/***/ }),

/***/ "../tsql/dist/event/update-event.js":
/*!******************************************!*\
  !*** ../tsql/dist/event/update-event.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "../tsql/dist/event/event-base.js");
class UpdateEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.whereClause = args.whereClause;
        this.assignmentMap = args.assignmentMap;
        this.updateResult = args.updateResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.UpdateEvent = UpdateEvent;
//# sourceMappingURL=update-event.js.map

/***/ }),

/***/ "../tsql/dist/execution/connection/component/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/execution/connection/component/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/connection/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/execution/connection/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ConnectionComponent = __webpack_require__(/*! ./component */ "../tsql/dist/execution/connection/component/index.js");
exports.ConnectionComponent = ConnectionComponent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/execution/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection */ "../tsql/dist/execution/connection/index.js"));
const ExecutionUtil = __webpack_require__(/*! ./util */ "../tsql/dist/execution/util/index.js");
exports.ExecutionUtil = ExecutionUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/execution/util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/execution/util/operation/index.js"));
__export(__webpack_require__(/*! ./operation-delete */ "../tsql/dist/execution/util/operation-delete/index.js"));
__export(__webpack_require__(/*! ./operation-insert */ "../tsql/dist/execution/util/operation-insert/index.js"));
__export(__webpack_require__(/*! ./operation-insert-select */ "../tsql/dist/execution/util/operation-insert-select/index.js"));
__export(__webpack_require__(/*! ./operation-update */ "../tsql/dist/execution/util/operation-update/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/execution/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-delete/delete-one.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-delete/delete-one.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const impl = __webpack_require__(/*! ./delete */ "../tsql/dist/execution/util/operation-delete/delete.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function deleteOne(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
         * It should execute no other statements.
         */
        const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0))) {
                    throw new error_1.RowNotFoundError({
                        message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                        sql: deleteResult.query.sql,
                    });
                }
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        deleteResult: deleteResult,
                    };
                }
                throw new error_1.TooManyRowsFoundError({
                    message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                    sql: deleteResult.query.sql,
                });
            });
        });
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                connection: fullConnection,
                table,
                whereClause,
                deleteResult,
            }));
        }
        return deleteResult;
    });
}
exports.deleteOne = deleteOne;
//# sourceMappingURL=delete-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-delete/delete-zero-or-one.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-delete/delete-zero-or-one.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const impl = __webpack_require__(/*! ./delete */ "../tsql/dist/execution/util/operation-delete/delete.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function deleteZeroOrOne(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
         * It should execute no other statements.
         */
        const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        deleteResult: deleteResult,
                    };
                }
                throw new error_1.TooManyRowsFoundError({
                    message: `Expected to delete zero or one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                    sql: deleteResult.query.sql,
                });
            });
        });
        if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    deleteResult,
                }));
            }
        }
        return deleteResult;
    });
}
exports.deleteZeroOrOne = deleteZeroOrOne;
//# sourceMappingURL=delete-zero-or-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-delete/delete.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-delete/delete.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function deleteImplNoEvent(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    const whereClause = where_clause_1.WhereClauseUtil.where(from_clause_1.FromClauseUtil.from(from_clause_1.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
    const deleteResult = await connection.delete(table, whereClause);
    return {
        whereClause,
        deleteResult,
    };
}
exports.deleteImplNoEvent = deleteImplNoEvent;
async function del(table, connection, whereDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, deleteResult, } = await deleteImplNoEvent(table, connection, whereDelegate);
        if (tm.BigIntUtil.greaterThan(deleteResult.deletedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    deleteResult,
                }));
            }
        }
        return deleteResult;
    });
}
exports.delete = del;
//# sourceMappingURL=delete.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-delete/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-delete/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./delete-one */ "../tsql/dist/execution/util/operation-delete/delete-one.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one */ "../tsql/dist/execution/util/operation-delete/delete-zero-or-one.js"));
__export(__webpack_require__(/*! ./delete */ "../tsql/dist/execution/util/operation-delete/delete.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert-select/index.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert-select/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-ignore-select */ "../tsql/dist/execution/util/operation-insert-select/insert-ignore-select.js"));
__export(__webpack_require__(/*! ./insert-select */ "../tsql/dist/execution/util/operation-insert-select/insert-select.js"));
__export(__webpack_require__(/*! ./replace-select */ "../tsql/dist/execution/util/operation-insert-select/replace-select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert-select/insert-ignore-select.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert-select/insert-ignore-select.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "../tsql/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function insertIgnoreSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    return connection.lock(async (connection) => {
        const insertSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const insertResult = await connection.insertIgnoreSelect(query, table, insertSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsertSelect.invoke(new event_1.InsertSelectEvent({
                connection: fullConnection,
                query,
                table,
                insertSelectRow,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertIgnoreSelect = insertIgnoreSelect;
//# sourceMappingURL=insert-ignore-select.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert-select/insert-select.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert-select/insert-select.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "../tsql/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function insertSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    return connection.lock(async (connection) => {
        const insertSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const insertResult = await connection.insertSelect(query, table, insertSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsertSelect.invoke(new event_1.InsertSelectEvent({
                connection: fullConnection,
                query,
                table,
                insertSelectRow,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertSelect = insertSelect;
//# sourceMappingURL=insert-select.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert-select/replace-select.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert-select/replace-select.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "../tsql/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function replaceSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        const replaceSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const replaceResult = await connection.replaceSelect(query, table, replaceSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onReplaceSelect.invoke(new event_1.ReplaceSelectEvent({
                connection: fullConnection,
                query,
                table,
                replaceSelectRow,
                replaceResult,
            }));
        }
        return replaceResult;
    });
}
exports.replaceSelect = replaceSelect;
//# sourceMappingURL=replace-select.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-and-fetch */ "../tsql/dist/execution/util/operation-insert/insert-and-fetch.js"));
__export(__webpack_require__(/*! ./insert-ignore-many */ "../tsql/dist/execution/util/operation-insert/insert-ignore-many.js"));
__export(__webpack_require__(/*! ./insert-ignore-one */ "../tsql/dist/execution/util/operation-insert/insert-ignore-one.js"));
__export(__webpack_require__(/*! ./insert-many */ "../tsql/dist/execution/util/operation-insert/insert-many.js"));
__export(__webpack_require__(/*! ./insert-one */ "../tsql/dist/execution/util/operation-insert/insert-one.js"));
__export(__webpack_require__(/*! ./replace-many */ "../tsql/dist/execution/util/operation-insert/replace-many.js"));
__export(__webpack_require__(/*! ./replace-one */ "../tsql/dist/execution/util/operation-insert/replace-one.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/insert-and-fetch.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/insert-and-fetch.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_one_1 = __webpack_require__(/*! ./insert-one */ "../tsql/dist/execution/util/operation-insert/insert-one.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function insertAndFetchImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertHasCandidateKey(table);
    /**
     * @todo Check if `SERIALIZABLE` is better.
     * Intuitively, `REPEATABLE_READ` makes sense because
     * we're just reading a row we've inserted inside this transaction.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            if (table.autoIncrement == undefined) {
                const candidateKeyResult = await data_type_1.DataTypeUtil.tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row);
                if (!candidateKeyResult.success) {
                    throw candidateKeyResult.error;
                }
                row = {
                    ...row,
                    ...candidateKeyResult.outputRow,
                };
                const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                const fetchedRow = await table_1.TableUtil.fetchOne(table, connection, () => ExprLib.eqCandidateKey(table, candidateKeyResult.outputRow));
                return {
                    ...insertOneImplResult,
                    fetchedRow,
                };
            }
            else {
                const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                const fetchedRow = await table_1.TableUtil.fetchOne(table, connection, 
                /**
                 * We use this instead of `eqPrimaryKey()` because it's possible
                 * for an `AUTO_INCREMENT` column to not be a primary key
                 * with some databases...
                 *
                 * It's also possible for it to not be a candidate key!
                 */
                () => ExprLib.eqColumns(table, {
                    [table.autoIncrement]: insertOneImplResult.insertResult.autoIncrementId,
                }));
                return {
                    ...insertOneImplResult,
                    fetchedRow,
                };
            }
        });
    });
}
/**
 * Convenience method for
 * ```ts
 *  connection.transactionIfNotInOne(IsolationLevel.REPEATABLE_READ, async (connection) => {
 *      await table.insertOne(connection, ...);
 *      return table.fetchOne(connection, ...);
 *  });
 * ```
 */
async function insertAndFetch(table, connection, row, insertAndFetchOptions) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertHasCandidateKey(table);
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, fetchedRow, } = await insertAndFetchImplNoEvent((insertAndFetchOptions == undefined ?
            table :
            {
                ...table,
                ...insertAndFetchOptions,
            }), connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { insertEvent, insertOneEvent, } = insert_one_1.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
            await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
            await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
            await fullConnection.eventEmitters.onInsertAndFetch.invoke(new event_1.InsertAndFetchEvent({
                connection: fullConnection,
                table,
                insertRow: insertOneEvent.insertRow,
                insertResult: insertOneEvent.insertResult,
                fetchedRow: fetchedRow,
            }));
        }
        return fetchedRow;
    });
}
exports.insertAndFetch = insertAndFetch;
//# sourceMappingURL=insert-and-fetch.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/insert-ignore-many.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/insert-ignore-many.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
/**
 * Inserts zero-to-many rows
 * ```sql
 *  INSERT IGNORE INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function insertIgnoreMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const insertResult = await connection.insertIgnoreMany(table, insertRows);
        if (!tm.BigIntUtil.equal(insertResult.insertedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onInsert.invoke(new event_1.InsertEvent({
                    connection: fullConnection,
                    table,
                    insertRows,
                    insertResult,
                }));
            }
        }
        return insertResult;
    });
}
exports.insertIgnoreMany = insertIgnoreMany;
//# sourceMappingURL=insert-ignore-many.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/insert-ignore-one.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/insert-ignore-one.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const insert_one_1 = __webpack_require__(/*! ./insert-one */ "../tsql/dist/execution/util/operation-insert/insert-one.js");
function isIgnoredResult(result) {
    return tm.BigIntUtil.equal(result.insertedRowCount, tm.BigInt(0));
}
function isInsertOneResult(result) {
    return !isIgnoredResult(result);
}
/**
 * Does not invoke events.
 */
async function insertIgnoreOneImpl(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            insertResult: await connection.insertIgnoreOne(table, row),
        };
    }
    const explicitAutoIncrementValue = row[table.autoIncrement];
    if (explicitAutoIncrementValue === undefined) {
        const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
        if (isIgnoredResult(insertIgnoreResult)) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        if (insertIgnoreResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful insertIgnoreOne() to ${table.alias} should return autoIncrementId`);
    }
    if (typeof explicitAutoIncrementValue != "number" &&
        typeof explicitAutoIncrementValue != "string" &&
        !tm.TypeUtil.isBigInt(explicitAutoIncrementValue)) {
        /**
         * @todo Custom error type
         */
        throw new Error(`Explicit autoIncrement value for ${table.alias} must be bigint|number|string`);
    }
    const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
    if (isIgnoredResult(insertIgnoreResult)) {
        return {
            insertRow: row,
            insertResult: {
                ...insertIgnoreResult,
                [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
            },
        };
    }
    if (insertIgnoreResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            insertResult: {
                ...insertIgnoreResult,
                [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
            },
        };
    }
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        insertResult: {
            ...insertIgnoreResult,
            autoIncrementId: BigInt(explicitAutoIncrementValue),
            [table.autoIncrement]: BigInt(explicitAutoIncrementValue),
        },
    };
}
/**
 * Only inserts zero or one row
 * ```sql
 *  INSERT IGNORE INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 */
async function insertIgnoreOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, } = await insertIgnoreOneImpl(table, connection, row);
        if (isInsertOneResult(insertResult)) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                const { insertEvent, insertOneEvent, } = insert_one_1.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
                await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
                await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
            }
        }
        return insertResult;
    });
}
exports.insertIgnoreOne = insertIgnoreOne;
//# sourceMappingURL=insert-ignore-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/insert-many.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/insert-many.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
/**
 * Inserts zero-to-many rows
 * ```sql
 *  INSERT INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function insertMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const insertResult = await connection.insertMany(table, insertRows);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsert.invoke(new event_1.InsertEvent({
                connection: fullConnection,
                table,
                insertRows,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertMany = insertMany;
//# sourceMappingURL=insert-many.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/insert-one.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/insert-one.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function insertOneImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            insertResult: await connection.insertOne(table, row),
        };
    }
    let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
    if (explicitAutoIncrementBuiltInExpr === undefined) {
        const insertResult = await connection.insertOne(table, row);
        if (insertResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertResult,
                    [table.autoIncrement]: insertResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful insertOne() to ${table.alias} should return autoIncrementId`);
    }
    explicitAutoIncrementBuiltInExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
    const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
    const insertResult = await connection.insertOne(table, {
        ...row,
        [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
    });
    /**
     * We defer to the `autoIncrementId` of the `insertResult`.
     * We assume the `connection` always knows best.
     */
    if (insertResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            insertResult: {
                ...insertResult,
                [table.autoIncrement]: insertResult.autoIncrementId,
            },
        };
    }
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        insertResult: {
            ...insertResult,
            autoIncrementId: autoIncrementBigInt,
            [table.autoIncrement]: autoIncrementBigInt,
        },
    };
}
exports.insertOneImplNoEvent = insertOneImplNoEvent;
function createInsertOneEvents(table, fullConnection, insertRow, insertResult) {
    const augmentedInsertRow = (table.autoIncrement == undefined ?
        insertRow :
        {
            ...insertRow,
            /**
             * The column may be specified to be `string|number|bigint`.
             * So, we need to use the column's mapper,
             * to get the desired data type.
             */
            [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
            /**
             * This **should** be `bigint`
             */
            insertResult.autoIncrementId),
        });
    const insertEvent = new event_1.InsertEvent({
        connection: fullConnection,
        table,
        insertRows: [augmentedInsertRow],
        insertResult,
    });
    const insertOneEvent = new event_1.InsertOneEvent({
        connection: fullConnection,
        table,
        insertRow: augmentedInsertRow,
        insertResult,
    });
    return {
        insertEvent,
        insertOneEvent,
    };
}
exports.createInsertOneEvents = createInsertOneEvents;
/**
 * Only inserts one row
 * ```sql
 *  INSERT INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 */
async function insertOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, } = await insertOneImplNoEvent(table, connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { insertEvent, insertOneEvent, } = createInsertOneEvents(table, fullConnection, insertRow, insertResult);
            await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
            await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
        }
        return insertResult;
    });
}
exports.insertOne = insertOne;
//# sourceMappingURL=insert-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/replace-many.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/replace-many.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
/**
 * Inserts/Replaces zero-to-many rows
 * ```sql
 *  REPLACE INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function replaceMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedOrReplacedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const replaceResult = await connection.replaceMany(table, insertRows);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onReplace.invoke(new event_1.ReplaceEvent({
                connection: fullConnection,
                table,
                insertRows,
                replaceResult,
            }));
        }
        return replaceResult;
    });
}
exports.replaceMany = replaceMany;
//# sourceMappingURL=replace-many.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-insert/replace-one.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-insert/replace-one.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "../tsql/dist/insert/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "../tsql/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function replaceOneImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            replaceResult: await connection.replaceOne(table, row),
        };
    }
    let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
    if (explicitAutoIncrementBuiltInExpr === undefined) {
        const replaceResult = await connection.replaceOne(table, row);
        if (replaceResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                replaceResult: {
                    ...replaceResult,
                    [table.autoIncrement]: replaceResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful replaceOne() to ${table.alias} should return autoIncrementId`);
    }
    explicitAutoIncrementBuiltInExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
    const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
    const replaceResult = await connection.replaceOne(table, {
        ...row,
        [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
    });
    /**
     * We defer to the `autoIncrementId` of the `replaceResult`.
     * We assume the `connection` always knows best.
     */
    if (replaceResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            replaceResult: {
                ...replaceResult,
                [table.autoIncrement]: replaceResult.autoIncrementId,
            },
        };
    }
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        replaceResult: {
            ...replaceResult,
            autoIncrementId: autoIncrementBigInt,
            [table.autoIncrement]: autoIncrementBigInt,
        },
    };
}
exports.replaceOneImplNoEvent = replaceOneImplNoEvent;
function createReplaceOneEvents(table, fullConnection, insertRow, replaceResult) {
    const augmentedInsertRow = (table.autoIncrement == undefined ?
        insertRow :
        {
            ...insertRow,
            /**
             * The column may be specified to be `string|number|bigint`.
             * So, we need to use the column's mapper,
             * to get the desired data type.
             */
            [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
            /**
             * This **should** be `bigint`
             */
            replaceResult.autoIncrementId),
        });
    const replaceEvent = new event_1.ReplaceEvent({
        connection: fullConnection,
        table,
        insertRows: [augmentedInsertRow],
        replaceResult,
    });
    const replaceOneEvent = new event_1.ReplaceOneEvent({
        connection: fullConnection,
        table,
        insertRow: augmentedInsertRow,
        replaceResult,
    });
    return {
        replaceEvent,
        replaceOneEvent,
    };
}
exports.createReplaceOneEvents = createReplaceOneEvents;
/**
 * Only inserts/replaces one row
 * ```sql
 *  REPLACE INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 *
 * The table must allow both `INSERT` and `DELETE`.
 * Replacing a row is essentially deleting the old row and inserting a new row.
 */
async function replaceOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, replaceResult, } = await replaceOneImplNoEvent(table, connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { replaceEvent, replaceOneEvent, } = createReplaceOneEvents(table, fullConnection, insertRow, replaceResult);
            await fullConnection.eventEmitters.onReplace.invoke(replaceEvent);
            await fullConnection.eventEmitters.onReplaceOne.invoke(replaceOneEvent);
        }
        return replaceResult;
    });
}
exports.replaceOne = replaceOne;
//# sourceMappingURL=replace-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-candidate-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-primary-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-super-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js"));
__export(__webpack_require__(/*! ./update-one */ "../tsql/dist/execution/util/operation-update/update-one.js"));
__export(__webpack_require__(/*! ./update-zero-or-one */ "../tsql/dist/execution/util/operation-update/update-zero-or-one.js"));
__export(__webpack_require__(/*! ./update */ "../tsql/dist/execution/util/operation-update/update.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js":
/*!*********************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../../../candidate-key */ "../tsql/dist/candidate-key/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    candidateKey = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${table.alias}[candidateKey]`, candidateKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newCandidateKey = {};
    for (const candidateColumnAlias of Object.keys(candidateKey)) {
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, candidateColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, candidateColumnAlias)) ?
            assignmentMap[candidateColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `candidateKey` column's value will not be updated.
             */
            newCandidateKey[candidateColumnAlias] = candidateKey[candidateColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(candidateColumnAlias) < 0) {
                throw new Error(`${table.alias}.${candidateColumnAlias} is not a mutable candidate key column`);
            }
            /**
             * This `candidateKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqCandidateKey(table, candidateKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[candidateColumnAlias] = newCandidateKey[candidateColumnAlias];
        }
    }
    return {
        success: true,
        curCandidateKey: candidateKey,
        assignmentMap,
        newCandidateKey,
    };
}
exports.__updateAndFetchOneByCandidateKeyHelper = __updateAndFetchOneByCandidateKeyHelper;
async function updateAndFetchOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js":
/*!*******************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "../tsql/dist/primary-key/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(table)(`${table.alias}[primaryKey]`, primaryKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newPrimaryKey = {};
    for (const primaryColumnAlias of Object.keys(primaryKey)) {
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, primaryColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, primaryColumnAlias)) ?
            assignmentMap[primaryColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `primaryKey` column's value will not be updated.
             */
            newPrimaryKey[primaryColumnAlias] = primaryKey[primaryColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(primaryColumnAlias) < 0) {
                throw new Error(`${table.alias}.${primaryColumnAlias} is not a mutable primary key column`);
            }
            /**
             * This `primaryKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqPrimaryKey(table, primaryKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[primaryColumnAlias] = newPrimaryKey[primaryColumnAlias];
        }
    }
    return {
        success: true,
        curPrimaryKey: primaryKey,
        assignmentMap,
        newPrimaryKey,
    };
}
exports.__updateAndFetchOneByPrimaryKeyHelper = __updateAndFetchOneByPrimaryKeyHelper;
async function updateAndFetchOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
            fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js":
/*!*****************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const super_key_1 = __webpack_require__(/*! ../../../super-key */ "../tsql/dist/super-key/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate) {
    superKey = super_key_1.SuperKeyUtil.mapper(table)(`${table.alias}[superKey]`, superKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newSuperKey = {};
    for (const superColumnAlias of Object.keys(superKey)) {
        if (superKey[superColumnAlias] === undefined) {
            continue;
        }
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, superColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, superColumnAlias)) ?
            assignmentMap[superColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `superKey` column's value will not be updated.
             */
            newSuperKey[superColumnAlias] = superKey[superColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(superColumnAlias) < 0) {
                throw new Error(`${table.alias}.${superColumnAlias} is not a mutable super key column`);
            }
            /**
             * This `superKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqSuperKey(table, superKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[superColumnAlias] = newSuperKey[superColumnAlias];
        }
    }
    return {
        success: true,
        curSuperKey: superKey,
        assignmentMap,
        newSuperKey,
    };
}
exports.__updateAndFetchOneBySuperKeyHelper = __updateAndFetchOneBySuperKeyHelper;
async function updateAndFetchOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
            fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
//# sourceMappingURL=update-and-fetch-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const update_one_1 = __webpack_require__(/*! ./update-one */ "../tsql/dist/execution/util/operation-update/update-one.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
/**
 * This should not be called directly by users.
 *
 * A lot can go wrong here...
 */
async function updateAndFetchOneImpl(table, connection, initCallback) {
    return connection.lock(async (connection) => {
        /**
         * `REPEATABLE_READ` should be fine because we're not creating any new rows.
         */
        const { updateWhereClause, updateResult, assignmentMap, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = await initCallback(connection);
                const { whereClause: updateWhereClause, updateResult: updateOneResult, } = await update_one_1.updateOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                const row = await table_1.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                return {
                    updateWhereClause,
                    updateResult: {
                        ...updateOneResult,
                        row,
                    },
                    assignmentMap,
                };
            });
        });
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                connection: fullConnection,
                table,
                whereClause: updateWhereClause,
                assignmentMap,
                updateResult,
            }));
            await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_1.UpdateAndFetchEvent({
                connection: fullConnection,
                table,
                assignmentMap,
                updateResult: updateResult,
            }));
        }
        return updateResult;
    });
}
exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
//# sourceMappingURL=update-and-fetch-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-one.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-one.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const __1 = __webpack_require__(/*! ../.. */ "../tsql/dist/execution/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate) {
    table_1.TableUtil.assertHasCandidateKey(table);
    /**
     * Prefer `primaryKey`
     */
    const candidateKeyColumnAliases = table.primaryKey != undefined ?
        table.primaryKey :
        table.candidateKeys[0];
    const curCandidateKeyOrError = await __1.ExecutionUtil
        .fetchOne(unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .select((columns) => candidateKeyColumnAliases.map(columnAlias => columns[columnAlias])), connection)
        .then((curCandidateKey) => {
        return curCandidateKey;
    }, (err) => {
        if (err instanceof error_1.RowNotFoundError) {
            return err;
        }
        else {
            throw err;
        }
    });
    if (curCandidateKeyOrError instanceof error_1.RowNotFoundError) {
        return {
            success: false,
            rowNotFoundError: curCandidateKeyOrError,
        };
    }
    else {
        return update_and_fetch_one_by_candidate_key_1.__updateAndFetchOneByCandidateKeyHelper(table, connection, curCandidateKeyOrError, assignmentMapDelegate);
    }
}
exports.__updateAndFetchOneHelper = __updateAndFetchOneHelper;
async function updateAndFetchOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOne = updateAndFetchOne;
//# sourceMappingURL=update-and-fetch-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js":
/*!*****************************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_candidate_key_1.__updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js":
/*!***************************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const update_and_fetch_one_by_primary_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_primary_key_1.__updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
            fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js":
/*!*************************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const update_and_fetch_one_by_super_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_super_key_1.__updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
            fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js":
/*!*****************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const update_zero_or_one_1 = __webpack_require__(/*! ./update-zero-or-one */ "../tsql/dist/execution/util/operation-update/update-zero-or-one.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
/**
 * This should not be called directly by users.
 *
 * A lot can go wrong here...
 */
async function updateAndFetchZeroOrOneImpl(table, connection, initCallback) {
    return connection.lock(async (connection) => {
        /**
         * `REPEATABLE_READ` should be fine because we're not creating any new rows.
         */
        const updateAndFetchResult = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const initResult = await initCallback(connection);
                if (!initResult.success) {
                    return {
                        success: false,
                        updateResult: {
                            query: {
                                sql: initResult.rowNotFoundError.sql,
                            },
                            //Alias for affectedRows
                            foundRowCount: tm.BigInt(0),
                            //Alias for changedRows
                            updatedRowCount: tm.BigInt(0),
                            /**
                             * May be the duplicate row count, or some other value.
                             */
                            warningCount: tm.BigInt(0),
                            /**
                             * An arbitrary message.
                             * May be an empty string.
                             */
                            message: "",
                            row: undefined,
                        },
                    };
                }
                const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = initResult;
                const { whereClause: updateWhereClause, updateResult: updateZeroOrOneResult, } = await update_zero_or_one_1.updateZeroOrOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                if (tm.BigIntUtil.equal(updateZeroOrOneResult.foundRowCount, tm.BigInt(0))) {
                    const notFoundUpdateResult = updateZeroOrOneResult;
                    return {
                        success: true,
                        updateWhereClause,
                        updateResult: {
                            ...notFoundUpdateResult,
                            row: undefined,
                        },
                        assignmentMap,
                    };
                }
                else {
                    const updateOneResult = updateZeroOrOneResult;
                    const row = await table_1.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                    return {
                        success: true,
                        updateWhereClause,
                        updateResult: {
                            ...updateOneResult,
                            row,
                        },
                        assignmentMap,
                    };
                }
            });
        });
        if (!updateAndFetchResult.success) {
            return updateAndFetchResult.updateResult;
        }
        const { updateWhereClause, updateResult, assignmentMap, } = updateAndFetchResult;
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause: updateWhereClause,
                    assignmentMap,
                    updateResult,
                }));
                await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_1.UpdateAndFetchEvent({
                    connection: fullConnection,
                    table,
                    assignmentMap,
                    updateResult: updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.updateAndFetchZeroOrOneImpl = updateAndFetchZeroOrOneImpl;
//# sourceMappingURL=update-and-fetch-zero-or-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "../tsql/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
const update_and_fetch_one_1 = __webpack_require__(/*! ./update-and-fetch-one */ "../tsql/dist/execution/util/operation-update/update-and-fetch-one.js");
async function updateAndFetchZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_1.__updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOne = updateAndFetchZeroOrOne;
//# sourceMappingURL=update-and-fetch-zero-or-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-one.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-one.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const impl = __webpack_require__(/*! ./update */ "../tsql/dist/execution/util/operation-update/update.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    /**
     * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
     * It should execute no other statements.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
        return connection.savepoint(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                throw new error_1.RowNotFoundError({
                    message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                    sql: updateResult.query.sql,
                });
            }
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            throw new error_1.TooManyRowsFoundError({
                message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                sql: updateResult.query.sql,
            });
        });
    });
}
exports.updateOneImplNoEvent = updateOneImplNoEvent;
async function updateOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                connection: fullConnection,
                table,
                whereClause,
                assignmentMap,
                updateResult,
            }));
        }
        return updateResult;
    });
}
exports.updateOne = updateOne;
//# sourceMappingURL=update-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update-zero-or-one.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update-zero-or-one.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const impl = __webpack_require__(/*! ./update */ "../tsql/dist/execution/util/operation-update/update.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "../tsql/dist/isolation-level.js");
async function updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    /**
     * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
     * It should execute no other statements.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
        return connection.savepoint(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero rows of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            throw new error_1.TooManyRowsFoundError({
                message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                sql: updateResult.query.sql,
            });
        });
    });
}
exports.updateZeroOrOneImplNoEvent = updateZeroOrOneImplNoEvent;
async function updateZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    assignmentMap,
                    updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.updateZeroOrOne = updateZeroOrOne;
//# sourceMappingURL=update-zero-or-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation-update/update.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/execution/util/operation-update/update.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const update_1 = __webpack_require__(/*! ../../../update */ "../tsql/dist/update/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "../tsql/dist/event/index.js");
async function updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    const whereClause = where_clause_1.WhereClauseUtil.where(from_clause_1.FromClauseUtil.from(from_clause_1.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
    const assignmentMap = update_1.UpdateUtil.set(table, assignmentMapDelegate);
    const updateResult = await connection.update(table, whereClause, assignmentMap);
    return {
        whereClause,
        assignmentMap,
        updateResult,
    };
}
exports.updateImplNoEvent = updateImplNoEvent;
async function update(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    assignmentMap,
                    updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.update = update;
//# sourceMappingURL=update.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/assert-exists.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/assert-exists.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function assertExists(query, connection) {
    const result = await impl_1.existsImpl(query, connection);
    if (!result.exists) {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.RowNotFoundError({
                message: `Row does not exist`,
                sql: result.sql,
            });
        }
        else {
            throw new error_1.RowNotFoundError({
                message: `Row of ${query.fromClause.currentJoins[0].tableAlias} does not exist`,
                sql: result.sql,
            });
        }
    }
}
exports.assertExists = assertExists;
//# sourceMappingURL=assert-exists.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/count.js":
/*!******************************************************!*\
  !*** ../tsql/dist/execution/util/operation/count.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
const fetch_value_1 = __webpack_require__(/*! ./fetch-value */ "../tsql/dist/execution/util/operation/fetch-value.js");
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const paginate_1 = __webpack_require__(/*! ./paginate */ "../tsql/dist/execution/util/operation/paginate/index.js");
/**
 * @todo Optimize this further?
 * Or keep trusting DBMS execution engine?
 */
async function count(query, connection) {
    /**
     * The following clauses may have a reference to the `SELECT` clause,
     *
     * + `groupByClause`
     * + `orderByClause`
     * + `compoundQueryClause`
     * + `compoundQueryOrderByClause`
     *
     */
    if (query_base_1.QueryBaseUtil.isAfterSelectClause(query)) {
        return fetch_value_1.fetchValue(unified_query_1.QueryUtil.selectValue(unified_query_1.QueryUtil.newInstance(), () => expr_1.expr({
            /**
             * Should not return a value less than zero
             */
            mapper: tm.mysql.bigIntUnsigned(),
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast_1.parentheses(
        /**
         * @todo **THIS** is not database agnostic. Change it to a proper AST
         * @todo Find other such occurrences,
         * where we assume the implementing DB will be able to execute SQL strings
         *
         * This should be fine for now, since most DB engines should be able to handle this.
         */
        [
            "SELECT COUNT(*) FROM",
            ast_1.parentheses(paginate_1.removePaginateArgs(query), false),
            "AS tmp"
        ], false))), connection);
    }
    if (query_base_1.QueryBaseUtil.isBeforeSelectClause(query) &&
        query_base_1.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
        return fetch_value_1.fetchValue({
            ...query,
            selectClause: select_clause_1.SelectClauseUtil.selectValue(query.fromClause, query.groupByClause, query.selectClause, () => ExprLib.countAll()),
            compoundQueryClause: query.compoundQueryClause,
        }, connection);
    }
    else {
        //This should never happen...
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.CannotCountError({
                message: `Cannot get count`,
                sql: undefined,
            });
        }
        else {
            throw new error_1.CannotCountError({
                message: `Cannot get count of ${query.fromClause.currentJoins[0].tableAlias}`,
                sql: undefined,
            });
        }
    }
}
exports.count = count;
//# sourceMappingURL=count.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const paginate_1 = __webpack_require__(/*! ../paginate */ "../tsql/dist/execution/util/operation/paginate/index.js");
//In case Symbol.asyncIterator is not defined
if (Symbol.asyncIterator == undefined) {
    Object.defineProperty(Symbol, "asyncIterator", {
        value: Symbol.for("Symbol.asyncIterator")
    });
}
class EmulatedCursorImpl {
    constructor(query, connection, rawArgs) {
        this.buffer = undefined;
        this.query = query;
        this.connection = connection;
        const args = paginate_1.toPaginateArgs(rawArgs);
        this.startPage = args.page;
        this.rowsPerPage = args.rowsPerPage;
        this.rowOffset = args.rowOffset;
        this.BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        this.rowIndex = 0;
        if (tm.BigIntUtil.greaterThan(this.rowsPerPage, Number.MAX_SAFE_INTEGER)) {
            throw new Error(`Cannot safely emulate cursor when buffer size is greater than ${Number.MAX_SAFE_INTEGER}`);
        }
    }
    async getOrFetchBuffer() {
        if (this.buffer == undefined) {
            this.rowIndex = 0;
            this.buffer = await paginate_1.paginate(this.query, this.connection, {
                page: this.startPage,
                rowsPerPage: this.rowsPerPage,
                rowOffset: this.rowOffset,
            });
        }
        return this.buffer;
    }
    async tryGetNextRow() {
        const buffer = await this.getOrFetchBuffer();
        if (this.rowIndex < buffer.rows.length) {
            const row = buffer.rows[this.rowIndex];
            ++this.rowIndex;
            return row;
        }
        else {
            return undefined;
        }
    }
    async tryFetchNextPage() {
        const buffer = await this.getOrFetchBuffer();
        const nextPage = tm.BigIntUtil.add(buffer.info.page, this.BigInt(1));
        if (tm.BigIntUtil.lessThan(nextPage, buffer.info.pagesFound)) {
            this.rowIndex = 0;
            this.buffer = await paginate_1.paginate(this.query, this.connection, {
                page: nextPage,
                rowsPerPage: this.rowsPerPage,
                rowOffset: this.rowOffset,
            });
            return buffer;
        }
        else {
            return undefined;
        }
    }
    async next() {
        /**
         * Try and get the next row of the current page
         */
        const row = await this.tryGetNextRow();
        if (row !== undefined) {
            return {
                done: false,
                value: row,
            };
        }
        /**
         * If we're here, we passed the end of the current page
         */
        {
            await this.tryFetchNextPage();
            const row = await this.tryGetNextRow();
            if (row !== undefined) {
                return {
                    done: false,
                    value: row,
                };
            }
            else {
                /**
                 * We passed the end of the last page
                 */
                return {
                    done: true,
                    /**
                     * The `IteratorResult<>` type really needs to be updated...
                     */
                    value: undefined,
                };
            }
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
exports.EmulatedCursorImpl = EmulatedCursorImpl;
//# sourceMappingURL=emulated-cursor-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const emulated_cursor_impl_1 = __webpack_require__(/*! ./emulated-cursor-impl */ "../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js");
/**
 * Considerations:
 * + MySQL **does not** support cursors at the protocol level
 *   + https://github.com/sidorares/node-mysql2/issues/1014
 *   + https://github.com/sidorares/node-mysql2/pull/822#issuecomment-409415308
 *   + https://github.com/sidorares/node-mysql2/blob/9404163b0dc4bdc24f6dddd18144532f41115842/lib/commands/query.js#L239
 *   + https://github.com/mysqljs/mysql/issues/274
 * + Cursors are useful for processing large amounts of data without loading everything into memory at once
 * + Cursors can prevent out-of-memory exceptions, since data is loaded in batches
 *
 * -----
 *
 * Since cursors are not natively supported (by MySQL), we emulate it using pagination.
 * So, we use the `LIMIT` and `OFFSET` clauses, and load rows in batches as we iterate.
 *
 * -----
 *
 * ### Preventing Duplicate Items
 *
 * ```ts
 *  const cursor = myQuery.emulatedCursor();
 *  for await (const row of cursor) {
 *      console.log(row);
 *      //snip operations on `row`
 *  }
 * ```
 *
 * Given the above, we might be expecting output like,
 * ```ts
 * //batch 1
 * > { rowId : 1 }
 * > { rowId : 2 }
 *
 * //batch 2
 * > { rowId : 3 }
 * > { rowId : 4 }
 *
 * //batch n
 * > etc.
 * ```
 *
 * We might actually get,
 * ```ts
 * //batch 1
 * > { rowId : 1 }
 * > { rowId : 2 }
 *
 * //batch 2
 * > { rowId : 2 } //This is a duplicate item, what gives?
 * > { rowId : 3 }
 *
 * //batch 3
 * > { rowId : 4 }
 * > { rowId : 5 }
 *
 * //batch n
 * > etc.
 * ```
 *
 * This can happen for a variety of reasons,
 * + Missing `ORDER BY` clause
 *   + Without an `ORDER BY` clause, the order that rows are returned in is undefined behaviour.
 *   + Rows are retrieved in batches and a row may appear in multiple batches.
 *   + To fix, add an `ORDER BY` clause
 *
 * + Non-unique ordering
 *   + The `ORDER BY` clause may not guarantee a unique ordering
 *   + To fix, modify the `ORDER BY` clause and guarantee a unique ordering
 *
 * + Not using a transaction
 *   + A different connection may have inserted a row into the table you are iterating over
 *
 *     The new row may have pushed other rows "down" the table,
 *     causing the next retrieved batch to contain rows already seen.
 *
 *   + To fix, use the cursor in a transaction
 *
 * + Modifying the table being iterated over
 *   + `INSERT/DELETE/UPDATE` statements may modify the table you are iterating over.
 *   + Consider buffering mutations into a temporary table first,
 *     then apply the mutations after you are done iterating.
 *   + Consider performing your mutations in a way that does not interfere with your `ORDER BY` clause.
 *
 * -----
 *
 * With an `ORDER BY` clause that guarantees a unique ordering, you can pretend the above `cursor` code is,
 * ```ts
 * declare const cursor : MyRowT[];
 * for (const row of cursor) {
 *      console.log(row);
 *      //snip operations on `row`
 * }
 * ```
 *
 * Modifying the `cursor` array may cause unexpected behaviour during iteration.
 *
 * There are ways to safely iterate and modify an array at the same time,
 * like iterating backwards while adding elements to the end of the array.
 *
 * -----
 *
 * ### Preventing Infinite Loops
 *
 * ```ts
 *  const cursor = myQuery.emulatedCursor();
 *  for await (const row of cursor) {
 *      console.log(row);
 *      const nextRowId = row.rowId+1;
 *      //INSERT INTO myTable (rowId) VALUES(:nextRowId)
 *  }
 * ```
 *
 * Given the above, it is possible for the loop to never terminate.
 * Or, rather, it will terminate after it uses all the disk space it has access to.
 *
 * -----
 *
 * The above code is similar to the following,
 * ```ts
 *  arr = [1];
 *  for (const i of arr) {
 *      console.log(i);
 *      arr.push(i+1);
 *  }
 * ```
 *
 * This will result in an infinite loop (or crash when out of memory).
 */
function emulatedCursor(query, connection, 
/**
 * If set, determines the starting `page` of the cursor.
 * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
 */
rawArgs = {}) {
    return new emulated_cursor_impl_1.EmulatedCursorImpl(query, connection, rawArgs);
}
exports.emulatedCursor = emulatedCursor;
//# sourceMappingURL=emulated-cursor.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/emulated-cursor/index.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/emulated-cursor/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./emulated-cursor-impl */ "../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js"));
__export(__webpack_require__(/*! ./emulated-cursor */ "../tsql/dist/execution/util/operation/emulated-cursor/emulated-cursor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/exists.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/execution/util/operation/exists.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function exists(query, connection) {
    return impl_1.existsImpl(query, connection)
        .then(({ exists }) => exists);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-all-mapped.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-all-mapped.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchAllMapped(query, 
/**
 * We need a full `IConnection` to pass to the `MapDelegate`.
 * However, ideally, it would only need to use transaction and `SELECT` statements...
 */
connection) {
    return impl_1.fetchAllMappedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllMapped = fetchAllMapped;
//# sourceMappingURL=fetch-all-mapped.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-all-unmapped-flattened.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-all-unmapped-flattened.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchAllUnmappedFlattened(query, connection) {
    return impl_1.fetchAllUnmappedFlattenedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllUnmappedFlattened = fetchAllUnmappedFlattened;
//# sourceMappingURL=fetch-all-unmapped-flattened.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-all-unmapped.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-all-unmapped.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchAllUnmapped(query, connection) {
    return impl_1.fetchAllUnmappedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllUnmapped = fetchAllUnmapped;
//# sourceMappingURL=fetch-all-unmapped.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-all.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-all.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
/**
 * Combines `fetchAllUnmappedFlattened()` and `fetchAllMapped()` for convenience.
 */
function fetchAll(query, connection) {
    return impl_1.fetchAllImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAll = fetchAll;
//# sourceMappingURL=fetch-all.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-one-or-undefined.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-one-or-undefined.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchOneOrUndefined(query, connection) {
    return impl_1.fetchOneOrImpl(query, connection, undefined)
        .then(({ row }) => row);
}
exports.fetchOneOrUndefined = fetchOneOrUndefined;
//# sourceMappingURL=fetch-one-or-undefined.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-one-or.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-one-or.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchOneOr(query, connection, defaultValue) {
    return impl_1.fetchOneOrImpl(query, connection, defaultValue)
        .then(({ row }) => row);
}
exports.fetchOneOr = fetchOneOr;
//# sourceMappingURL=fetch-one-or.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-one.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-one.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
function fetchOne(query, connection) {
    try {
        const p = impl_1.fetchOneImpl(query, connection);
        const result = p.then(({ row }) => row);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ row }) => row);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-value-array.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-value-array.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchValueArray(query, connection) {
    return impl_1.fetchValueArrayImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchValueArray = fetchValueArray;
//# sourceMappingURL=fetch-value-array.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-value-or-undefined.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-value-or-undefined.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchValueOrUndefined(query, connection) {
    return impl_1.fetchValueOrImpl(query, connection, undefined)
        .then(({ value }) => value);
}
exports.fetchValueOrUndefined = fetchValueOrUndefined;
//# sourceMappingURL=fetch-value-or-undefined.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-value-or.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-value-or.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
async function fetchValueOr(query, connection, defaultValue) {
    return impl_1.fetchValueOrImpl(query, connection, defaultValue)
        .then(({ value }) => value);
}
exports.fetchValueOr = fetchValueOr;
//# sourceMappingURL=fetch-value-or.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/fetch-value.js":
/*!************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/fetch-value.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js");
function fetchValue(query, connection) {
    try {
        const p = impl_1.fetchValueImpl(query, connection);
        const result = p.then(({ value }) => value);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ value }) => value);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValue = fetchValue;
//# sourceMappingURL=fetch-value.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/ensure-one-or.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/ensure-one-or.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../../error */ "../tsql/dist/error/index.js");
/**
 * @todo Better naming
 */
function ensureOneOr(query, fetched, defaultValue) {
    const resultSet = fetched.resultSet;
    if (resultSet.length == 0) {
        return defaultValue;
    }
    else if (resultSet.length == 1) {
        return resultSet[0];
    }
    else {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected zero or one row, found more than that`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected zero or one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                sql: fetched.sql,
            });
        }
    }
}
exports.ensureOneOr = ensureOneOr;
//# sourceMappingURL=ensure-one-or.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/ensure-one.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/ensure-one.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../../error */ "../tsql/dist/error/index.js");
/**
 * @todo Better naming
 */
function ensureOne(query, fetched) {
    const resultSet = fetched.resultSet;
    if (resultSet.length == 0) {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.RowNotFoundError({
                message: `Expected one row, found zero`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.RowNotFoundError({
                message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found zero`,
                sql: fetched.sql,
            });
        }
    }
    else if (resultSet.length == 1) {
        return resultSet[0];
    }
    else {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected one row, found more than that`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                sql: fetched.sql,
            });
        }
    }
}
exports.ensureOne = ensureOne;
//# sourceMappingURL=ensure-one.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/exists-impl.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/exists-impl.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../../unified-query */ "../tsql/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../../expr-library */ "../tsql/dist/expr-library/index.js");
const fetch_value_impl_1 = __webpack_require__(/*! ./fetch-value-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-impl.js");
async function existsImpl(query, connection) {
    const fetched = await fetch_value_impl_1.fetchValueImpl(unified_query_1.QueryUtil.newInstance()
        .selectValue(() => ExprLib.exists(query)), connection);
    return {
        sql: fetched.sql,
        exists: fetched.value,
    };
}
exports.existsImpl = existsImpl;
//# sourceMappingURL=exists-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-all-impl.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-all-impl.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_all_unmapped_flattened_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-flattened-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js");
const fetch_all_mapped_impl_1 = __webpack_require__(/*! ./fetch-all-mapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-mapped-impl.js");
function fetchAllImpl(query, connection) {
    if (query.mapDelegate == undefined) {
        return fetch_all_unmapped_flattened_impl_1.fetchAllUnmappedFlattenedImpl(query, connection);
    }
    else {
        return fetch_all_mapped_impl_1.fetchAllMappedImpl(query, connection);
    }
}
exports.fetchAllImpl = fetchAllImpl;
//# sourceMappingURL=fetch-all-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-all-mapped-impl.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-all-mapped-impl.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchAllMappedImpl(query, 
/**
 * We need a full `IConnection` to pass to the `MapDelegate`.
 * However, ideally, it would only need to use transaction and `SELECT` statements...
 */
connection) {
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const unmappedResultSet = unmapped.resultSet;
    if (unmappedResultSet.length == 0) {
        return unmapped;
    }
    const mappedResultSet = [];
    for (const unmappedRow of unmappedResultSet) {
        mappedResultSet.push(await query.mapDelegate(unmappedRow, connection, unmappedRow));
    }
    return {
        sql: unmapped.sql,
        resultSet: mappedResultSet,
    };
}
exports.fetchAllMappedImpl = fetchAllMappedImpl;
//# sourceMappingURL=fetch-all-mapped-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../../predicate */ "../tsql/dist/execution/util/predicate/index.js");
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchAllUnmappedFlattenedImpl(query, connection) {
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const unmappedResultSet = unmapped.resultSet;
    if (unmappedResultSet.length == 0 || !predicate_1.canFlattenUnmappedRow(query)) {
        return unmapped;
    }
    return {
        sql: unmapped.sql,
        resultSet: unmappedResultSet.map(unmappedRow => {
            const flattened = {};
            for (const tableAlias of Object.keys(unmappedRow)) {
                const table = unmappedRow[tableAlias];
                if (table == undefined) {
                    continue;
                }
                for (const columnAlias of Object.keys(table)) {
                    flattened[columnAlias] = table[columnAlias];
                }
            }
            return flattened;
        }),
    };
}
exports.fetchAllUnmappedFlattenedImpl = fetchAllUnmappedFlattenedImpl;
//# sourceMappingURL=fetch-all-unmapped-flattened-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../../column-ref */ "../tsql/dist/column-ref/index.js");
const constants_1 = __webpack_require__(/*! ../../../../constants */ "../tsql/dist/constants.js");
async function fetchAllUnmappedImpl(query, connection) {
    const rawResult = await connection.select(query);
    const hasNullableJoins = (query.fromClause.currentJoins == undefined) ?
        false :
        query.fromClause.currentJoins.some(j => j.nullable);
    const ref = column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause);
    const rows = [];
    for (const rawRow of rawResult.rows) {
        const row = {};
        for (const k of Object.keys(rawRow)) {
            const separatorIndex = k.indexOf(constants_1.SEPARATOR);
            const tableAlias = k.substr(0, separatorIndex);
            const columnAlias = k.substr(separatorIndex + constants_1.SEPARATOR.length);
            try {
                const value = ref[tableAlias][columnAlias].mapper(`${tableAlias}.${columnAlias}`, rawRow[k]);
                let table = row[tableAlias];
                if (table == undefined) {
                    table = {};
                    row[tableAlias] = table;
                }
                table[columnAlias] = value;
            }
            catch (err) {
                Object.defineProperty(err, "sql", {
                    value: rawResult.query.sql,
                    enumerable: false,
                    writable: true,
                });
                throw err;
            }
        }
        if (hasNullableJoins) {
            for (const tableAlias of Object.keys(row)) {
                if (query.fromClause.currentJoins != undefined &&
                    query.fromClause.currentJoins.findIndex(j => j.tableAlias == tableAlias) < 0) {
                    //Probably `$aliased`
                    continue;
                }
                if (query.fromClause.currentJoins != undefined) {
                    const join = query.fromClause.currentJoins.find(j => j.tableAlias == tableAlias);
                    if (join != undefined && !join.nullable) {
                        //This is not a nullable join, do not make it `undefined`,
                        //no matter what.
                        continue;
                    }
                }
                const map = row[tableAlias];
                if (map == undefined) {
                    continue;
                }
                const allNull = Object.keys(map)
                    .every(columnAlias => map[columnAlias] === null);
                if (allNull) {
                    row[tableAlias] = undefined;
                }
            }
        }
        rows.push(row);
    }
    return {
        sql: rawResult.query.sql,
        resultSet: rows,
    };
}
exports.fetchAllUnmappedImpl = fetchAllUnmappedImpl;
//# sourceMappingURL=fetch-all-unmapped-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-one-impl.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-one-impl.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const try_set_limit_2_1 = __webpack_require__(/*! ./try-set-limit-2 */ "../tsql/dist/execution/util/operation/impl/try-set-limit-2.js");
const fetch_all_impl_1 = __webpack_require__(/*! ./fetch-all-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-impl.js");
const ensure_one_1 = __webpack_require__(/*! ./ensure-one */ "../tsql/dist/execution/util/operation/impl/ensure-one.js");
const ensure_one_or_1 = __webpack_require__(/*! ./ensure-one-or */ "../tsql/dist/execution/util/operation/impl/ensure-one-or.js");
function fetchOneImpl(query, connection) {
    try {
        const limitedQuery = try_set_limit_2_1.trySetLimit2(query);
        const p = fetch_all_impl_1.fetchAllImpl(limitedQuery, connection);
        const result = p
            .then((fetched) => {
            return {
                sql: fetched.sql,
                row: ensure_one_1.ensureOne(limitedQuery, fetched),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    row: ensure_one_or_1.ensureOneOr(limitedQuery, fetched, defaultValue),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOneImpl = fetchOneImpl;
//# sourceMappingURL=fetch-one-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-one-or-impl.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-one-or-impl.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_one_impl_1 = __webpack_require__(/*! ./fetch-one-impl */ "../tsql/dist/execution/util/operation/impl/fetch-one-impl.js");
async function fetchOneOrImpl(query, connection, defaultValue) {
    return fetch_one_impl_1.fetchOneImpl(query, connection)
        .or(defaultValue);
}
exports.fetchOneOrImpl = fetchOneOrImpl;
//# sourceMappingURL=fetch-one-or-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-value-array-impl.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-value-array-impl.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_base_1 = __webpack_require__(/*! ../../../../query-base */ "../tsql/dist/query-base/index.js");
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchValueArrayImpl(query, connection) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Expected query with one select item`);
    }
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const resultSet = unmapped.resultSet;
    if (resultSet.length == 0) {
        return {
            sql: unmapped.sql,
            resultSet: [],
        };
    }
    /**
     * This should always be a `string` if
     * `isOneSelectItem()` and `fetchAllUnmappedImpl()` are working
     * correctly.
     */
    const tableAlias = Object.keys(resultSet[0])[0];
    const columnAlias = Object.keys(resultSet[0][tableAlias])[0];
    return {
        sql: unmapped.sql,
        resultSet: resultSet.map((row) => row[tableAlias][columnAlias]),
    };
}
exports.fetchValueArrayImpl = fetchValueArrayImpl;
//# sourceMappingURL=fetch-value-array-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-value-impl.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-value-impl.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const try_set_limit_2_1 = __webpack_require__(/*! ./try-set-limit-2 */ "../tsql/dist/execution/util/operation/impl/try-set-limit-2.js");
const fetch_value_array_impl_1 = __webpack_require__(/*! ./fetch-value-array-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-array-impl.js");
const ensure_one_1 = __webpack_require__(/*! ./ensure-one */ "../tsql/dist/execution/util/operation/impl/ensure-one.js");
const ensure_one_or_1 = __webpack_require__(/*! ./ensure-one-or */ "../tsql/dist/execution/util/operation/impl/ensure-one-or.js");
function fetchValueImpl(query, connection) {
    try {
        const limitedQuery = try_set_limit_2_1.trySetLimit2(query);
        const p = fetch_value_array_impl_1.fetchValueArrayImpl(limitedQuery, connection);
        const result = p
            .then((fetched) => {
            return {
                sql: fetched.sql,
                value: ensure_one_1.ensureOne(limitedQuery, fetched),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    value: ensure_one_or_1.ensureOneOr(limitedQuery, fetched, defaultValue),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValueImpl = fetchValueImpl;
//# sourceMappingURL=fetch-value-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/fetch-value-or-impl.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/fetch-value-or-impl.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_value_impl_1 = __webpack_require__(/*! ./fetch-value-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-impl.js");
async function fetchValueOrImpl(query, connection, defaultValue) {
    return fetch_value_impl_1.fetchValueImpl(query, connection)
        .or(defaultValue);
}
exports.fetchValueOrImpl = fetchValueOrImpl;
//# sourceMappingURL=fetch-value-or-impl.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ensure-one-or */ "../tsql/dist/execution/util/operation/impl/ensure-one-or.js"));
__export(__webpack_require__(/*! ./ensure-one */ "../tsql/dist/execution/util/operation/impl/ensure-one.js"));
__export(__webpack_require__(/*! ./exists-impl */ "../tsql/dist/execution/util/operation/impl/exists-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-mapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-mapped-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-flattened-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-impl */ "../tsql/dist/execution/util/operation/impl/fetch-all-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-or-impl */ "../tsql/dist/execution/util/operation/impl/fetch-one-or-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-impl */ "../tsql/dist/execution/util/operation/impl/fetch-one-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-array-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-array-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-or-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-or-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-impl */ "../tsql/dist/execution/util/operation/impl/fetch-value-impl.js"));
__export(__webpack_require__(/*! ./try-set-limit-2 */ "../tsql/dist/execution/util/operation/impl/try-set-limit-2.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/impl/try-set-limit-2.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/impl/try-set-limit-2.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
/**
 * We use `LIMIT 2`,
 * because if we fetch more than one row,
 * we've messed up.
 *
 * But I don't want to fetch 1 million rows if we mess up.
 * This limits our failure.
 *
 * @todo Better naming
 */
function trySetLimit2(query) {
    const limitedQuery = (query.compoundQueryClause == undefined ?
        (query.limitClause == undefined ?
            {
                ...query,
                limitClause: limit_clause_1.LimitClauseUtil.limitNumber(undefined, 2),
            } :
            /**
             * The user already specified a custom limit.
             * We don't want to mess with it.
             *
             * @todo Decide if we **should** mess with it anyway?
             * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
             * But any higher?
             *
             * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
             */
            query) :
        (query.compoundQueryLimitClause == undefined ?
            {
                ...query,
                compoundQueryLimitClause: limit_clause_1.LimitClauseUtil.limitNumber(undefined, 2),
            } :
            /**
             * The user already specified a custom limit.
             * We don't want to mess with it.
             *
             * @todo Decide if we **should** mess with it anyway?
             * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
             * But any higher?
             *
             * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
             */
            query));
    return limitedQuery;
}
exports.trySetLimit2 = trySetLimit2;
//# sourceMappingURL=try-set-limit-2.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/execution/util/operation/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./emulated-cursor */ "../tsql/dist/execution/util/operation/emulated-cursor/index.js"));
__export(__webpack_require__(/*! ./impl */ "../tsql/dist/execution/util/operation/impl/index.js"));
__export(__webpack_require__(/*! ./paginate */ "../tsql/dist/execution/util/operation/paginate/index.js"));
__export(__webpack_require__(/*! ./assert-exists */ "../tsql/dist/execution/util/operation/assert-exists.js"));
__export(__webpack_require__(/*! ./count */ "../tsql/dist/execution/util/operation/count.js"));
__export(__webpack_require__(/*! ./exists */ "../tsql/dist/execution/util/operation/exists.js"));
__export(__webpack_require__(/*! ./fetch-all-mapped */ "../tsql/dist/execution/util/operation/fetch-all-mapped.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-flattened */ "../tsql/dist/execution/util/operation/fetch-all-unmapped-flattened.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped */ "../tsql/dist/execution/util/operation/fetch-all-unmapped.js"));
__export(__webpack_require__(/*! ./fetch-all */ "../tsql/dist/execution/util/operation/fetch-all.js"));
__export(__webpack_require__(/*! ./fetch-one-or-undefined */ "../tsql/dist/execution/util/operation/fetch-one-or-undefined.js"));
__export(__webpack_require__(/*! ./fetch-one-or */ "../tsql/dist/execution/util/operation/fetch-one-or.js"));
__export(__webpack_require__(/*! ./fetch-one */ "../tsql/dist/execution/util/operation/fetch-one.js"));
__export(__webpack_require__(/*! ./fetch-value-array */ "../tsql/dist/execution/util/operation/fetch-value-array.js"));
__export(__webpack_require__(/*! ./fetch-value-or-undefined */ "../tsql/dist/execution/util/operation/fetch-value-or-undefined.js"));
__export(__webpack_require__(/*! ./fetch-value-or */ "../tsql/dist/execution/util/operation/fetch-value-or.js"));
__export(__webpack_require__(/*! ./fetch-value */ "../tsql/dist/execution/util/operation/fetch-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/paginate/apply-paginate-args.js":
/*!*****************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/paginate/apply-paginate-args.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const paginate_args_1 = __webpack_require__(/*! ./paginate-args */ "../tsql/dist/execution/util/operation/paginate/paginate-args.js");
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
function applyPaginateArgs(query, args) {
    const paginateLimitClause = limit_clause_1.LimitClauseUtil.offsetBigInt(limit_clause_1.LimitClauseUtil.limitBigInt(undefined, args.rowsPerPage), paginate_args_1.getPaginationStart(args));
    if (query.compoundQueryClause == undefined) {
        return {
            ...query,
            limitClause: paginateLimitClause,
            compoundQueryLimitClause: undefined,
        };
    }
    else {
        return {
            ...query,
            compoundQueryLimitClause: paginateLimitClause,
        };
    }
}
exports.applyPaginateArgs = applyPaginateArgs;
//# sourceMappingURL=apply-paginate-args.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/paginate/index.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/paginate/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./apply-paginate-args */ "../tsql/dist/execution/util/operation/paginate/apply-paginate-args.js"));
__export(__webpack_require__(/*! ./paginate-args */ "../tsql/dist/execution/util/operation/paginate/paginate-args.js"));
__export(__webpack_require__(/*! ./paginate */ "../tsql/dist/execution/util/operation/paginate/paginate.js"));
__export(__webpack_require__(/*! ./remove-paginate-args */ "../tsql/dist/execution/util/operation/paginate/remove-paginate-args.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/paginate/paginate-args.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/paginate/paginate-args.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
/**
 * We use `BIGINT SIGNED` because PostgreSQL and SQLite do not support
 * `BIGINT UNSIGNED`.
 */
const maybePage = tm.mysql.bigIntSigned().orUndefined();
const maybeRowsPerPage = tm.mysql.bigIntSigned().orUndefined();
const maybeRowOffset = tm.mysql.bigIntSigned().orUndefined();
function toPaginateArgs(rawArgs) {
    const page = maybePage.mapMappable("page", rawArgs.page);
    const rowsPerPage = maybeRowsPerPage.mapMappable("rowsPerPage", rawArgs.rowsPerPage);
    const rowOffset = maybeRowOffset.mapMappable("rowOffset", rawArgs.rowOffset);
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    const args = {
        page: (page == undefined || tm.BigIntUtil.lessThan(page, 0)) ?
            //Default
            BigInt(0) :
            page,
        rowsPerPage: (rowsPerPage == undefined || tm.BigIntUtil.lessThan(rowsPerPage, 1)) ?
            //Default
            BigInt(20) :
            rowsPerPage,
        rowOffset: (rowOffset == undefined || tm.BigIntUtil.lessThan(rowOffset, 0)) ?
            //Default
            BigInt(0) :
            rowOffset,
    };
    const paginationStart = getPaginationStart(args);
    if (tm.BigIntUtil.greaterThan(paginationStart, BigInt("9223372036854775807"))) {
        throw new Error(`Cannot have OFFSET greater than 9223372036854775807`);
    }
    return args;
}
exports.toPaginateArgs = toPaginateArgs;
/**
 * It is possible for this value to be greater than
 * `9223372036854775807n`.
 *
 * When this happens, you will get an error from the RDBMS
 */
function getPaginationStart(args) {
    return tm.BigIntUtil.add(tm.BigIntUtil.mul(args.page, args.rowsPerPage), args.rowOffset);
}
exports.getPaginationStart = getPaginationStart;
function calculatePagesFound(args, rowsFound) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    if (tm.BigIntUtil.lessThan(rowsFound, 0)) {
        /**
         * Should not have negative rows found
         */
        return BigInt(0);
    }
    if (tm.BigIntUtil.lessThanOrEqual(args.rowsPerPage, 0)) {
        /**
         * Avoid divide by zero errors
         */
        return BigInt(0);
    }
    return (tm.BigIntUtil.add(tm.BigIntUtil.div(rowsFound, args.rowsPerPage), (tm.BigIntUtil.equal(tm.BigIntUtil.mod(rowsFound, args.rowsPerPage), BigInt(0)) ?
        BigInt(0) :
        BigInt(1))));
}
exports.calculatePagesFound = calculatePagesFound;
//# sourceMappingURL=paginate-args.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/paginate/paginate.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/paginate/paginate.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ../impl */ "../tsql/dist/execution/util/operation/impl/index.js");
const paginate_args_1 = __webpack_require__(/*! ./paginate-args */ "../tsql/dist/execution/util/operation/paginate/paginate-args.js");
const apply_paginate_args_1 = __webpack_require__(/*! ./apply-paginate-args */ "../tsql/dist/execution/util/operation/paginate/apply-paginate-args.js");
const count_1 = __webpack_require__(/*! ../count */ "../tsql/dist/execution/util/operation/count.js");
const remove_paginate_args_1 = __webpack_require__(/*! ./remove-paginate-args */ "../tsql/dist/execution/util/operation/paginate/remove-paginate-args.js");
async function paginate(query, connection, rawArgs) {
    const args = paginate_args_1.toPaginateArgs(rawArgs);
    const paginateQuery = apply_paginate_args_1.applyPaginateArgs(query, args);
    const fetched = await impl_1.fetchAllImpl(paginateQuery, connection);
    const rowsFound = await count_1.count(remove_paginate_args_1.removePaginateArgs(paginateQuery), connection);
    const pagesFound = paginate_args_1.calculatePagesFound(args, rowsFound);
    const info = {
        rowsFound,
        pagesFound,
        page: args.page,
        rowsPerPage: args.rowsPerPage,
        rowOffset: args.rowOffset,
    };
    return {
        info,
        /**
         * @todo Investigate assignability
         */
        rows: fetched.resultSet,
    };
}
exports.paginate = paginate;
//# sourceMappingURL=paginate.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/operation/paginate/remove-paginate-args.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/execution/util/operation/paginate/remove-paginate-args.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removePaginateArgs(query) {
    if (query.compoundQueryClause == undefined) {
        return {
            ...query,
            limitClause: undefined,
            compoundQueryLimitClause: undefined,
        };
    }
    else {
        return {
            ...query,
            compoundQueryLimitClause: undefined,
        };
    }
}
exports.removePaginateArgs = removePaginateArgs;
//# sourceMappingURL=remove-paginate-args.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/predicate/can-flatten-unmapped-row.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/execution/util/predicate/can-flatten-unmapped-row.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
function canFlattenUnmappedRow(query) {
    if (select_clause_1.SelectClauseUtil.duplicateColumnAlias(query.selectClause).length > 0) {
        /**
         * Cannot flatten if we have duplicate `columnAlias`
         */
        return false;
    }
    if (query.fromClause.currentJoins == undefined) {
        /**
         * No `nullable` joins, we can flatten safely
         */
        return true;
    }
    const hasNullableJoins = query.fromClause.currentJoins.some(j => j.nullable);
    return !hasNullableJoins;
}
exports.canFlattenUnmappedRow = canFlattenUnmappedRow;
//# sourceMappingURL=can-flatten-unmapped-row.js.map

/***/ }),

/***/ "../tsql/dist/execution/util/predicate/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/execution/util/predicate/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./can-flatten-unmapped-row */ "../tsql/dist/execution/util/predicate/can-flatten-unmapped-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-column/expr-column-impl.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-column/expr-column-impl.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../column */ "../tsql/dist/column/index.js");
class ExprColumn {
    /**
     * You should never need to explicitly instantiate an `ExprColumn`.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.tableAlias = data.tableAlias;
        this.columnAlias = data.columnAlias;
        this.mapper = data.mapper;
        this.isAggregate = data.isAggregate;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC
     * ```
     */
    asc() {
        return column_1.ColumnUtil.asc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn DESC
     * ```
     */
    desc() {
        return column_1.ColumnUtil.desc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC,
     *  myTable.myOtherColumn DESC
     * ```
     */
    sort(sortDirection) {
        return column_1.ColumnUtil.sort(this, sortDirection);
    }
}
exports.ExprColumn = ExprColumn;
//# sourceMappingURL=expr-column-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr-column/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/expr-column/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./expr-column-impl */ "../tsql/dist/expr-column/expr-column-impl.js"));
const ExprColumnUtil = __webpack_require__(/*! ./util */ "../tsql/dist/expr-column/util/index.js");
exports.ExprColumnUtil = ExprColumnUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-column/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/expr-column/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/expr-column/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-column/util/predicate/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/expr-column/util/predicate/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr-column */ "../tsql/dist/expr-column/util/predicate/is-expr-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-column/util/predicate/is-expr-column.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-column/util/predicate/is-expr-column.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
function isExprColumn(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias",
        "mapper",
        "isAggregate",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string") &&
        (typeof raw.mapper == "function") &&
        (typeof raw.isAggregate == "boolean") &&
        (raw.unaliasedAst == undefined ||
            ast_1.AstUtil.isAst(raw.unaliasedAst)));
}
exports.isExprColumn = isExprColumn;
//# sourceMappingURL=is-expr-column.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate-factory/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate-factory/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-aggregate-operator-0 */ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-1 */ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-2 */ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-3 */ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
function makeAggregateOperator0(operatorType, mapper, typeHint) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: true,
        }, ast_1.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
    };
    return result;
}
exports.makeAggregateOperator0 = makeAggregateOperator0;
//# sourceMappingURL=make-aggregate-operator-0.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeAggregateOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator1 = makeAggregateOperator1;
//# sourceMappingURL=make-aggregate-operator-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeAggregateOperator2(operatorType, mapper, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator2 = makeAggregateOperator2;
//# sourceMappingURL=make-aggregate-operator-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeAggregateOperator3(operatorType, mapper, typeHint) {
    const result = (left, mid, right) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator3 = makeAggregateOperator3;
//# sourceMappingURL=make-aggregate-operator-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate/count-all.js":
/*!********************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate/count-all.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const aggregate_factory_1 = __webpack_require__(/*! ../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns a count of the number of rows
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(*)`
 * + PostgreSQL : `COUNT(*)`
 * + SQLite     : `COUNT(*)`
 *
 * @todo Rename to `count`? or `countRow`?
 * @todo Or add a function `count()` with overloads for `countExpr` and `countAll`?
 */
exports.countAll = aggregate_factory_1.makeAggregateOperator0(operator_type_1.OperatorType.AGGREGATE_COUNT_ALL, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned());
//# sourceMappingURL=count-all.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate/count-expr.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate/count-expr.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const aggregate_factory_1 = __webpack_require__(/*! ../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const countExprImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_COUNT_EXPR, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned());
/**
 * Returns a count of the number of rows with different non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(DISTINCT x)`
 * + PostgreSQL : `COUNT(DISTINCT x)`
 * + SQLite     : `COUNT(DISTINCT x)`
 */
exports.countExprDistinct = (arg) => {
    return countExprImpl(true, arg);
};
/**
 * Returns a count of the number of rows with non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(x)`
 * + PostgreSQL : `COUNT(x)`
 * + SQLite     : `COUNT(x)`
 */
exports.countExprAll = (arg) => {
    return countExprImpl(false, arg);
};
/**
 * Returns a count of the number of rows with non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(x)`
 * + PostgreSQL : `COUNT(x)`
 * + SQLite     : `COUNT(x)`
 */
exports.countExpr = exports.countExprAll;
//# sourceMappingURL=count-expr.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/aggregate/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/aggregate/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./count-all */ "../tsql/dist/expr-library/aggregate/count-all.js"));
__export(__webpack_require__(/*! ./count-expr */ "../tsql/dist/expr-library/aggregate/count-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/assert/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/assert/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./throw-if-null */ "../tsql/dist/expr-library/assert/throw-if-null.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/assert/throw-if-null.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/assert/throw-if-null.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
function throwIfNull(arg) {
    return expr_1.ExprUtil.intersect(tm.notNull(built_in_expr_1.BuiltInExprUtil.mapper(arg)), [arg], ast_1.OperatorNodeUtil.operatorNode1(operator_type_1.OperatorType.THROW_IF_NULL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg)
    ], undefined));
}
exports.throwIfNull = throwIfNull;
//# sourceMappingURL=throw-if-null.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/bigint-signed-literal.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/bigint-signed-literal.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr/expr-impl */ "../tsql/dist/expr/expr-impl.js");
/**
 * Converts `string|number|bigint|Decimal` to a `BIGINT SIGNED`
 */
function bigIntSignedLiteral(rawBigIntSignedLiteral) {
    const mapper = tm.mysql.bigIntSigned();
    const value = mapper("rawBigIntSignedLiteral", String(rawBigIntSignedLiteral));
    return expr_impl_1.expr({
        mapper,
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        isAggregate: false,
    }, literal_value_node_1.LiteralValueNodeUtil.bigIntSignedLiteralNode(value));
}
exports.bigIntSignedLiteral = bigIntSignedLiteral;
//# sourceMappingURL=bigint-signed-literal.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/decimal-literal.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/cast/decimal-literal.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr/expr-impl */ "../tsql/dist/expr/expr-impl.js");
/**
 *
 * @param rawDecimalLiteral
 *
 * @param precision
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 *
 * @param scale
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
function decimalLiteral(rawDecimalLiteral, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    return expr_impl_1.expr({
        mapper: tm.mysql.decimal(precision, scale),
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        isAggregate: false,
    }, literal_value_node_1.LiteralValueNodeUtil.decimalLiteralNode(rawDecimalLiteral, precision, scale));
}
exports.decimalLiteral = decimalLiteral;
//# sourceMappingURL=decimal-literal.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/cast/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint-signed-literal */ "../tsql/dist/expr-library/cast/bigint-signed-literal.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-decimal */ "../tsql/dist/expr-library/cast/unsafe-cast-as-decimal.js"));
//export * from "./cast-as-n-char";
__export(__webpack_require__(/*! ./decimal-literal */ "../tsql/dist/expr-library/cast/decimal-literal.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-bigint-signed */ "../tsql/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-binary */ "../tsql/dist/expr-library/cast/unsafe-cast-as-binary.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-double */ "../tsql/dist/expr-library/cast/unsafe-cast-as-double.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-json */ "../tsql/dist/expr-library/cast/unsafe-cast-as-json.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-var-char */ "../tsql/dist/expr-library/cast/unsafe-cast-as-var-char.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Attempts to cast to `BIGINT SIGNED`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS SIGNED INTEGER)`
 *   + Actually gives a signed `bigint`
 *   + Trying to cast `'123e2'` gives `123`
 * + PostgreSQL     : `CAST(x AS bigint)`
 *   + Trying to cast `'123e2'` throws an error
 * + SQLite         : `CAST(x AS BIGINT)`
 *   + Trying to cast `'123e2'` gives `123`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 * + https://github.com/AnyhowStep/tsql/issues/244
 * + https://github.com/AnyhowStep/tsql/issues/245
 */
exports.unsafeCastAsBigIntSigned = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull());
//# sourceMappingURL=unsafe-cast-as-bigint-signed.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-binary.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-binary.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "../tsql/node_modules/type-mapping/fluent.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Attempts to cast to `BINARY/bytea/BLOB`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS BINARY)`
 *   + `CAST(1234567890 AS BINARY)` returns `[49,50,51,52,53,54,55,56,57,48]`
 *     + Converts to ASCII string first, then to BINARY
 * + PostgreSQL     : `CAST(x AS bytea)`
 *   + `CAST(1234567890 AS bytea)` throws
 * + SQLite         : `CAST(x AS BLOB)`
 *   + `CAST(1234567890 AS BLOB)` returns `[49,50,51,52,53,54,55,56,57,48]`
 *     + Converts to ASCII string first, then to BLOB
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsBinary = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_BINARY, tm.instanceOfUint8Array().orNull());
//# sourceMappingURL=unsafe-cast-as-binary.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-decimal.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-decimal.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "../tsql/node_modules/type-mapping/fluent.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * @todo Move this elsewhere?
 */
function assertValidDecimalPrecisionAndScale(
/**
 * + PostgreSQL's min precision is `1`
 * + MySQL's max precision is `65`
 */
precision, 
/**
 * + The min scale is `0`.
 * + MySQL's max scale is `30`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    const precisionMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(1)), tm.bigIntLtEq(BigInt(65)));
    precision = precisionMapper("precision", precision);
    const scaleMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(0)), tm.bigIntLtEq(BigInt(30)), tm.bigIntLtEq(precision));
    scale = scaleMapper("scale", scale);
    return {
        precision,
        scale,
    };
}
exports.assertValidDecimalPrecisionAndScale = assertValidDecimalPrecisionAndScale;
function unsafeCastAsDecimal(arg, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const argMapper = built_in_expr_1.BuiltInExprUtil.mapper(arg);
    const decimalDefinition = assertValidDecimalPrecisionAndScale(precision, scale);
    return expr_1.expr({
        mapper: tm.canOutputNull(argMapper) ?
            tm.mysql.decimal(precision, scale).orNull() :
            tm.mysql.decimal(precision, scale),
        usedRef: built_in_expr_1.BuiltInExprUtil.usedRef(arg),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(arg),
    }, ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.CAST_AS_DECIMAL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        built_in_expr_1.BuiltInExprUtil.buildAst(decimalDefinition.precision),
        built_in_expr_1.BuiltInExprUtil.buildAst(decimalDefinition.scale),
    ], undefined));
}
exports.unsafeCastAsDecimal = unsafeCastAsDecimal;
//# sourceMappingURL=unsafe-cast-as-decimal.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-double.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-double.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Attempts to cast to `DOUBLE`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL 5.7      : `x + 0e0`
 *   + `('qwerty' + 0e0)` returns `0e0`
 *   + `(TRUE + 0e0)` returns `1e0`
 *   + `(9223372036854775807 + 0e0)` returns `9223372036854776000e0`
 * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
 *   + `CAST('qwerty' AS DOUBLE PRECISION)` throws
 *   + `CAST(TRUE AS DOUBLE PRECISION)` throws
 *   + `CAST(9223372036854775807 AS DOUBLE PRECISION)` returns `9223372036854780000e0`
 * + SQLite         : `CAST(x AS DOUBLE)`
 *   + `CAST('qwerty' AS DOUBLE)` returns `0e0`
 *   + `CAST(TRUE AS DOUBLE)` returns `1e0`
 *   + `CAST(9223372036854775807 AS DOUBLE)` returns `9223372036854776000e0`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsDouble = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_DOUBLE, tm.orNull(tm.toUnsafeNumber()));
//# sourceMappingURL=unsafe-cast-as-double.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-json.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-json.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Attempts to cast to `JSON`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS JSON)`
 *   + `CAST(1 AS JSON)` returns `'1'`
 *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x": "y"}'`
 * + PostgreSQL     : `CAST(x AS JSON)`
 *   + `CAST(1 AS JSON)` throws
 *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x":"y"}'`
 * + SQLite         : `CAST(x AS TEXT)`
 *   + Or implement with user-defined function.
 *   + Or the `JSON()` function?
 *   + https://www.sqlite.org/json1.html#jmini
 *   + SQLite does not have a `JSON` data type; `TEXT` is used for `JSON` values.
 *   + `JSON(1)` returns `'1'`
 *   + `CAST(1 AS TEXT)` returns `'1'`
 *   + `JSON('{  "x"  :  "y"  }')` returns `'{"x":"y"}'`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsJson = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_JSON, tm.orNull(tm.string()));
//# sourceMappingURL=unsafe-cast-as-json.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/cast/unsafe-cast-as-var-char.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/cast/unsafe-cast-as-var-char.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Attempts to cast to `VARCHAR`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS CHAR)`
 *   + `CAST(TRUE AS CHAR)` returns `'1'`
 *   + `CAST(123e0 AS CHAR)` returns `'123'`
 * + PostgreSQL     : `CAST(x AS VARCHAR)`
 *   + `CAST(TRUE AS VARCHAR)` returns `'true'`
 *   + `CAST(CAST(123e0 AS DOUBLE PRECISION) AS VARCHAR)` returns `'123'`
 * + SQLite         : `CAST(x AS VARCHAR)`
 *   + `CAST(TRUE AS VARCHAR)` returns `'1'`
 *   + `CAST(123e0 AS VARCHAR)` returns `'123.0'`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsVarChar = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_VARCHAR, tm.orNull(tm.string()));
//# sourceMappingURL=unsafe-cast-as-var-char.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/between.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/between.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
 *
 * This version of the `BETWEEN ... AND` operator prevents `NULL`.
 *
 * For null-safe checks, @see {@link nullSafeBetween}
 *
 */
exports.between = factory_1.makeComparison3(operator_type_1.OperatorType.BETWEEN_AND);
//# sourceMappingURL=between.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/greatest.js":
/*!********************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/greatest.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
 *
 * This version of the `GREATEST(x, y, ...)` operator prevents `NULL`.
 *
 * No null-safe version is provided in this unification
 * because the different databases treat `NULL` arguments differently.
 *
 * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
 * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
 *
 * -----
 *
 * This version of the `GREATEST(x, y, ...)` operator requires
 * at least 2 arguments because MySQL's requires at least 2.
 *
 * Also, it does not make much sense to get the `GREATEST` of 1 value.
 */
exports.greatest = factory_1.makeComparisonProjection2ToN(operator_type_1.OperatorType.GREATEST);
//# sourceMappingURL=greatest.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/gt-eq.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/gt-eq.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
 *
 * This version of the `>=` operator prevents `NULL`.
 *
 */
exports.gtEq = factory_1.makeComparison2(operator_type_1.OperatorType.GREATER_THAN_OR_EQUAL);
//# sourceMappingURL=gt-eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/gt.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/gt.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
 *
 * This version of the `>` operator prevents `NULL`.
 *
 */
exports.gt = factory_1.makeComparison2(operator_type_1.OperatorType.GREATER_THAN);
//# sourceMappingURL=gt.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./between */ "../tsql/dist/expr-library/comparison/between.js"));
__export(__webpack_require__(/*! ./greatest */ "../tsql/dist/expr-library/comparison/greatest.js"));
__export(__webpack_require__(/*! ./gt-eq */ "../tsql/dist/expr-library/comparison/gt-eq.js"));
__export(__webpack_require__(/*! ./gt */ "../tsql/dist/expr-library/comparison/gt.js"));
__export(__webpack_require__(/*! ./least */ "../tsql/dist/expr-library/comparison/least.js"));
__export(__webpack_require__(/*! ./lt-eq */ "../tsql/dist/expr-library/comparison/lt-eq.js"));
__export(__webpack_require__(/*! ./lt */ "../tsql/dist/expr-library/comparison/lt.js"));
__export(__webpack_require__(/*! ./not-between */ "../tsql/dist/expr-library/comparison/not-between.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/least.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/least.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
 *
 * This version of the `LEAST(x, y, ...)` operator prevents `NULL`.
 *
 * No null-safe version is provided in this unification
 * because the different databases treat `NULL` arguments differently.
 *
 * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
 * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
 *
 * -----
 *
 * This version of the `LEAST(x, y, ...)` operator requires
 * at least 2 arguments because MySQL's requires at least 2.
 *
 * Also, it does not make much sense to get the `LEAST` of 1 value.
 */
exports.least = factory_1.makeComparisonProjection2ToN(operator_type_1.OperatorType.LEAST);
//# sourceMappingURL=least.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/lt-eq.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/lt-eq.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal
 *
 * This version of the `<=` operator prevents `NULL`.
 *
 */
exports.ltEq = factory_1.makeComparison2(operator_type_1.OperatorType.LESS_THAN_OR_EQUAL);
//# sourceMappingURL=lt-eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/lt.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/lt.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
 *
 * This version of the `<` operator prevents `NULL`.
 *
 */
exports.lt = factory_1.makeComparison2(operator_type_1.OperatorType.LESS_THAN);
//# sourceMappingURL=lt.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/comparison/not-between.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/comparison/not-between.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
 *
 * This version of the `NOT BETWEEN ... AND` operator prevents `NULL`.
 *
 * For null-safe checks, @see {@link nullSafeNotBetween}
 *
 */
exports.notBetween = factory_1.makeComparison3(operator_type_1.OperatorType.NOT_BETWEEN_AND);
//# sourceMappingURL=not-between.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js":
/*!********************************************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../../expr/expr-impl */ "../tsql/dist/expr/expr-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
class CaseConditionBuilderImpl {
    constructor(resultMappers, usedRef, ast, isAggregate) {
        this.resultMappers = resultMappers;
        this.usedRef = usedRef;
        this.ast = ast;
        this.isAggregate = isAggregate;
    }
    when(condition, then) {
        return new CaseConditionBuilderImpl([...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(condition, then)), {
            type: "CaseCondition",
            /**
             * https://github.com/microsoft/TypeScript/issues/33573
             */
            branches: this.ast.branches.concat([
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(condition),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ]),
            else: this.ast.else,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(condition) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
    end() {
        return expr_impl_1.expr({
            mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
            usedRef: this.usedRef,
            isAggregate: this.isAggregate,
        }, this.ast);
    }
    else(elseResult) {
        const end = () => {
            return expr_impl_1.expr({
                mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(elseResult)),
                usedRef: used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.usedRef(elseResult)),
                isAggregate: (this.isAggregate ||
                    built_in_expr_1.BuiltInExprUtil.isAggregate(elseResult))
            }, {
                ...this.ast,
                else: built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
            });
        };
        return {
            end,
        };
    }
}
exports.CaseConditionBuilderImpl = CaseConditionBuilderImpl;
//# sourceMappingURL=case-condition-builder-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-condition/case-condition.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-condition/case-condition.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const uninitialized_case_condition_builder_impl_1 = __webpack_require__(/*! ./uninitialized-case-condition-builder-impl */ "../tsql/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js");
function caseCondition() {
    return new uninitialized_case_condition_builder_impl_1.UninitializedCaseConditionBuilderImpl();
}
exports.caseCondition = caseCondition;
//# sourceMappingURL=case-condition.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-condition/index.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-condition/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition-builder-impl */ "../tsql/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js"));
__export(__webpack_require__(/*! ./case-condition */ "../tsql/dist/expr-library/control-flow/case-condition/case-condition.js"));
__export(__webpack_require__(/*! ./uninitialized-case-condition-builder-impl */ "../tsql/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js":
/*!**********************************************************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const case_condition_builder_impl_1 = __webpack_require__(/*! ./case-condition-builder-impl */ "../tsql/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js");
class UninitializedCaseConditionBuilderImpl {
    constructor() {
    }
    when(condition, then) {
        return new case_condition_builder_impl_1.CaseConditionBuilderImpl([built_in_expr_1.BuiltInExprUtil.mapper(then)], built_in_expr_1.BuiltInExprUtil.intersectUsedRef(condition, then), {
            type: "CaseCondition",
            branches: [
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(condition),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ],
            else: undefined,
        }, (built_in_expr_1.BuiltInExprUtil.isAggregate(condition) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
}
exports.UninitializedCaseConditionBuilderImpl = UninitializedCaseConditionBuilderImpl;
//# sourceMappingURL=uninitialized-case-condition-builder-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-value/case-value-builder-impl.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-value/case-value-builder-impl.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../../expr/expr-impl */ "../tsql/dist/expr/expr-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
class CaseValueBuilderImpl {
    constructor(resultMappers, usedRef, ast, isAggregate) {
        this.resultMappers = resultMappers;
        this.usedRef = usedRef;
        this.ast = ast;
        this.isAggregate = isAggregate;
    }
    when(compareValue, then) {
        return new CaseValueBuilderImpl([...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
            type: "CaseValue",
            value: this.ast.value,
            /**
             * https://github.com/microsoft/TypeScript/issues/33573
             */
            cases: this.ast.cases.concat([
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(compareValue),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ]),
            else: this.ast.else,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(compareValue) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
    end() {
        return expr_impl_1.expr({
            mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
            usedRef: this.usedRef,
            isAggregate: this.isAggregate,
        }, this.ast);
    }
    else(elseResult) {
        const end = () => {
            return expr_impl_1.expr({
                mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(elseResult)),
                usedRef: used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.usedRef(elseResult)),
                isAggregate: (this.isAggregate ||
                    built_in_expr_1.BuiltInExprUtil.isAggregate(elseResult))
            }, {
                ...this.ast,
                else: built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
            });
        };
        return {
            end,
        };
    }
}
exports.CaseValueBuilderImpl = CaseValueBuilderImpl;
//# sourceMappingURL=case-value-builder-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-value/case-value.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-value/case-value.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const uninitialized_case_value_builder_impl_1 = __webpack_require__(/*! ./uninitialized-case-value-builder-impl */ "../tsql/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js");
function caseValue(valueExpr) {
    return new uninitialized_case_value_builder_impl_1.UninitializedCaseValueBuilderImpl(built_in_expr_1.BuiltInExprUtil.usedRef(valueExpr), built_in_expr_1.BuiltInExprUtil.buildAst(valueExpr), built_in_expr_1.BuiltInExprUtil.isAggregate(valueExpr));
}
exports.caseValue = caseValue;
//# sourceMappingURL=case-value.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-value/index.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-value/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-value-builder-impl */ "../tsql/dist/expr-library/control-flow/case-value/case-value-builder-impl.js"));
__export(__webpack_require__(/*! ./case-value */ "../tsql/dist/expr-library/control-flow/case-value/case-value.js"));
__export(__webpack_require__(/*! ./uninitialized-case-value-builder-impl */ "../tsql/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js":
/*!**************************************************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const case_value_builder_impl_1 = __webpack_require__(/*! ./case-value-builder-impl */ "../tsql/dist/expr-library/control-flow/case-value/case-value-builder-impl.js");
class UninitializedCaseValueBuilderImpl {
    constructor(usedRef, valueAst, isAggregate) {
        this.usedRef = usedRef;
        this.valueAst = valueAst;
        this.isAggregate = isAggregate;
    }
    when(compareValue, then) {
        return new case_value_builder_impl_1.CaseValueBuilderImpl([built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
            type: "CaseValue",
            value: this.valueAst,
            cases: [
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(compareValue),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ],
            else: undefined,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(compareValue) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
}
exports.UninitializedCaseValueBuilderImpl = UninitializedCaseValueBuilderImpl;
//# sourceMappingURL=uninitialized-case-value-builder-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/case.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/case.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const case_value_1 = __webpack_require__(/*! ./case-value */ "../tsql/dist/expr-library/control-flow/case-value/index.js");
const case_condition_1 = __webpack_require__(/*! ./case-condition */ "../tsql/dist/expr-library/control-flow/case-condition/index.js");
function caseConstructor(valueExpr) {
    if (valueExpr === undefined) {
        return case_condition_1.caseCondition();
    }
    else {
        return case_value_1.caseValue(valueExpr);
    }
}
exports.case = caseConstructor;
//# sourceMappingURL=case.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/coalesce.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/coalesce.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const util_1 = __webpack_require__(/*! ../../ast/operator-node/util */ "../tsql/dist/ast/operator-node/util/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
function coalesceMapper(...args) {
    const builtInExprMapperArr = [];
    let lastMapperNonNull = false;
    for (const builtInExpr of args) {
        const builtInExprMapper = built_in_expr_1.BuiltInExprUtil.mapper(builtInExpr);
        builtInExprMapperArr.push(builtInExprMapper);
        if (!tm.canOutputNull(builtInExprMapper)) {
            lastMapperNonNull = true;
            break;
        }
    }
    return (lastMapperNonNull ?
        tm.notNull(tm.unsafeOr(...builtInExprMapperArr)) :
        tm.unsafeOr(...builtInExprMapperArr));
}
exports.coalesceMapper = coalesceMapper;
/**
 * Returns the first non-`NULL` value in the list,
 * or `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
 * + https://www.postgresql.org/docs/9.5/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
 * + https://www.sqlite.org/lang_corefunc.html#coalesce
 *
 * -----
 *
 * + MySQL        : `COALESCE(x, ...)`
 * + PostgreSQL   : `COALESCE(x, ...)`
 * + SQLite       : `COALESCE(x, ...)`
 *
 * -----
 *
 * `COALESCE()` with zero args is just the `NULL` constant.
 */
function coalesce(...args) {
    const [arg0, arg1, ...argRest] = args;
    if (arg0 === undefined) {
        /**
         * `COALESCE()` with zero args is just the `NULL` constant.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(null);
    }
    else if (arg1 === undefined) {
        /**
         * `COALESCE(x)` is just `x`
         */
        return expr_1.ExprUtil.fromBuiltInExpr(arg0);
    }
    else {
        return expr_1.ExprUtil.intersect(coalesceMapper(...args), args, util_1.operatorNode2ToN(operator_type_1.OperatorType.COALESCE, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...argRest.map(built_in_expr_1.BuiltInExprUtil.buildAst)
        ], undefined));
    }
}
exports.coalesce = coalesce;
//# sourceMappingURL=coalesce.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/if-is-null.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/if-is-null.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "../tsql/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "../tsql/dist/expr-library/null-safe-equation/index.js");
const ifImpl = __webpack_require__(/*! ./if */ "../tsql/dist/expr-library/control-flow/if.js");
/**
 * A special compile-time type-narrowing function.
 *
 * Narrows a column from `T|null` to `T` in the else-branch.
 *
 * Translated to SQL, we get,
 * ```sql
 *  IF(
 *      myColumn IS NULL,
 *      thenExpr,
 *      -- The `elseExpr` is free to use `myColumn` as a non-nullable column
 *      -- because we know `myColumn` is NOT NULL in the else-branch.
 *      elseExpr
 *  )
 * ```
 *
 *
 * @param column - The column to narrow from `T|null` to `T`
 * @param then - The result of the expression, if the `column` is `null`
 * @param elseDelegate - The result of the expression, if the `column` is `T`
 */
function ifIsNull(column, then, elseDelegate) {
    return ifImpl.if(null_safe_equation_1.isNull(column), then, elseDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.ifIsNull = ifIsNull;
//# sourceMappingURL=if-is-null.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/if-null.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/if-null.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//import * as tm from "type-mapping";
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "../tsql/dist/expr-library/control-flow/coalesce.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Equivalent to `COALESCE()` with two arguments.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
 * + https://www.sqlite.org/lang_corefunc.html#ifnull
 *
 * -----
 *
 * `COALESCE()` is part of the SQL standard.
 * `IFNULL()` is DB-specific.
 *
 * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
 *
 * -----
 *
 * + MySQL        : `IFNULL(x, y)`
 * + PostgreSQL   : `COALESCE(x, y)`
 * + SQLite       : `IFNULL(x, y)`
 *
 * -----
 *
 * @see coalesce
 */
function ifNull(arg0, arg1) {
    return expr_1.ExprUtil.intersect(coalesce_1.coalesceMapper(arg0, arg1), [arg0, arg1], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.IF_NULL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
        built_in_expr_1.BuiltInExprUtil.buildAst(arg1)
    ], undefined));
}
exports.ifNull = ifNull;
//# sourceMappingURL=if-null.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/if.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/if.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
/**
 * Behaves like an `if-else` statement from most programming languages.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
 *
 * -----
 *
 * + MySQL        : `IF(x, y, z)`
 * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
 * + SQLite       : `CASE WHEN x THEN y ELSE z END`
 *
 * -----
 *
 * @param condition - The boolean expression to evaluate
 * @param then - The result if `condition` is `true`
 * @param elseResult - The result if `condition` is `false`
 *
 * @see caseCondition
 */
function ifConstructor(condition, then, elseResult) {
    return expr_1.ExprUtil.intersect(tm.or(built_in_expr_1.BuiltInExprUtil.mapper(then), built_in_expr_1.BuiltInExprUtil.mapper(elseResult)), [condition, then, elseResult], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.IF, [
        built_in_expr_1.BuiltInExprUtil.buildAst(condition),
        built_in_expr_1.BuiltInExprUtil.buildAst(then),
        built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
    ], undefined));
}
exports.if = ifConstructor;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition */ "../tsql/dist/expr-library/control-flow/case-condition/index.js"));
__export(__webpack_require__(/*! ./case-value */ "../tsql/dist/expr-library/control-flow/case-value/index.js"));
__export(__webpack_require__(/*! ./case */ "../tsql/dist/expr-library/control-flow/case.js"));
__export(__webpack_require__(/*! ./coalesce */ "../tsql/dist/expr-library/control-flow/coalesce.js"));
__export(__webpack_require__(/*! ./if-is-null */ "../tsql/dist/expr-library/control-flow/if-is-null.js"));
__export(__webpack_require__(/*! ./if-null */ "../tsql/dist/expr-library/control-flow/if-null.js"));
__export(__webpack_require__(/*! ./if */ "../tsql/dist/expr-library/control-flow/if.js"));
__export(__webpack_require__(/*! ./null-if */ "../tsql/dist/expr-library/control-flow/null-if.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/control-flow/null-if.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/control-flow/null-if.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Returns `null` if both arguments are null-safe equal.
 *
 * Otherwise, returns the first argument.
 *
 * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
 * + https://www.sqlite.org/lang_corefunc.html#nullif
 *
 * -----
 *
 * + MySQL        : `NULLIF(x, y)`
 * + PostgreSQL   : `NULLIF(x, y)`
 * + SQLite       : `NULLIF(x, y)`
 *
 * @see nullIfEqual
 */
function nullIf(arg0, arg1) {
    return expr_1.ExprUtil.intersect(tm.orNull(built_in_expr_1.BuiltInExprUtil.mapper(arg0)), [arg0, arg1], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.NULL_IF_EQUAL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
        built_in_expr_1.BuiltInExprUtil.buildAst(arg1)
    ], undefined));
}
exports.nullIf = nullIf;
/**
 * Synonym for `NULLIF(x, y)`.
 *
 * Returns `null` if both arguments are null-safe equal.
 *
 * Otherwise, returns the first argument.
 *
 * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
 * + https://www.sqlite.org/lang_corefunc.html#nullif
 *
 * -----
 *
 * + MySQL        : `NULLIF(x, y)`
 * + PostgreSQL   : `NULLIF(x, y)`
 * + SQLite       : `NULLIF(x, y)`
 *
 * @see nullIf
 */
exports.nullIfEqual = nullIf;
//# sourceMappingURL=null-if.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/custom-factory/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/custom-factory/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-custom-operator-0 */ "../tsql/dist/expr-library/custom-factory/make-custom-operator-0.js"));
__export(__webpack_require__(/*! ./make-custom-operator-1 */ "../tsql/dist/expr-library/custom-factory/make-custom-operator-1.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/custom-factory/make-custom-operator-0.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/expr-library/custom-factory/make-custom-operator-0.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
function makeCustomOperator0(ast, mapper) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast);
    };
    return result;
}
exports.makeCustomOperator0 = makeCustomOperator0;
//# sourceMappingURL=make-custom-operator-0.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/custom-factory/make-custom-operator-1.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/expr-library/custom-factory/make-custom-operator-1.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
function makeCustomOperator1(astDelegate, mapper) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], astDelegate(arg));
    };
    return result;
}
exports.makeCustomOperator1 = makeCustomOperator1;
//# sourceMappingURL=make-custom-operator-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/current-date.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/current-date.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the current date.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_DATE()`
 * + PostgreSQL     : `CURRENT_DATE()`
 * + SQLite         : `strftime('%Y-%m-%d', 'now')`
 *
 * -----
 *
 * Sets hour, minute, second, millisecond to zero.
 */
exports.currentDate = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_DATE, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=current-date.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/current-timestamp.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/current-timestamp.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the current date-time, accurate to 1-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(0)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
 */
exports.currentTimestamp0 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_0, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.1-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(1)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
 */
exports.currentTimestamp1 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_1, tm.mysql.dateTime(1), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.01-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(2)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
 */
exports.currentTimestamp2 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_2, tm.mysql.dateTime(2), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.001-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(3)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
 */
exports.currentTimestamp3 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_3, tm.mysql.dateTime(3), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=current-timestamp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/extract.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/extract.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Extracts the second from a date-time, including fractional seconds; accurate to 0.001 second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * Behaviour is not defined when using 0.0001 second precision (or more precise).
 * SQLite may alternate between truncating and rounding.
 *
 * -----
 *
 * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000e0) / 1000e0`
 * ```sql
 *  SELECT
 *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
 *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
 *  > 32.456
 * ```
 * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
 * + SQLite         : `CAST(strftime('%f', datetime) AS DOUBLE)`
 * ```sql
 *  SELECT
 *      strftime('%f', '2010-03-27 14:45:32.456789')
 *  > 32.457
 *  -- The result is rounded, not truncated.
 *  -- If it were truncated, we would get 32.456
 * ```
 * ```sql
 *  SELECT
 *      strftime('%f', '2010-03-27 23:59:59.999999')
 *  > 59.999
 *  -- The result is truncated, not rounded.
 *  -- If it were rounded, we would get 60
 * ```
 *
 * @todo Make behaviour consistent?
 */
exports.extractFractionalSecond3 = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_FRACTIONAL_SECOND_3, tm.mysql.double(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the second from a date-time, truncating fractional seconds.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(SECOND FROM datetime)`
 * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
 */
exports.extractIntegerSecond = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_INTEGER_SECOND, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the minute from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
 */
exports.extractMinute = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_MINUTE, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the hour from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(HOUR FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
 */
exports.extractHour = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_HOUR, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the day (of the month) from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(DAY FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
 */
exports.extractDay = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_DAY, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the month from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(MONTH FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
 */
exports.extractMonth = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_MONTH, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the year from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(YEAR FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
 */
exports.extractYear = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_YEAR, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=extract.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./current-date */ "../tsql/dist/expr-library/date-time/current-date.js"));
//export * from "./current-time";
__export(__webpack_require__(/*! ./current-timestamp */ "../tsql/dist/expr-library/date-time/current-timestamp.js"));
__export(__webpack_require__(/*! ./extract */ "../tsql/dist/expr-library/date-time/extract.js"));
__export(__webpack_require__(/*! ./last-day */ "../tsql/dist/expr-library/date-time/last-day.js"));
//export * from "./local-string-to-timestamp";
__export(__webpack_require__(/*! ./timestamp-add */ "../tsql/dist/expr-library/date-time/timestamp-add.js"));
__export(__webpack_require__(/*! ./timestamp-diff */ "../tsql/dist/expr-library/date-time/timestamp-diff.js"));
__export(__webpack_require__(/*! ./unix-timestamp-now */ "../tsql/dist/expr-library/date-time/unix-timestamp-now.js"));
__export(__webpack_require__(/*! ./utc-string-to-timestamp */ "../tsql/dist/expr-library/date-time/utc-string-to-timestamp.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/last-day.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/last-day.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the date of the last day of the month.
 *
 * Sets hour, minute, second, fractional second to zero.
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
 *
 * -----
 *
 * + MySQL          : `LAST_DAY(datetime)`
 * ```sql
 *  SELECT
 *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
 *  > 2010-03-31
 * ```
 * + PostgreSQL     :
 * ```sql
 *  SELECT
 *      (
 *          datetime +
 *          interval '1 month' -
 *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
 *      )::date
 * > 2010-03-31T00:00:00.000Z
 * ```
 * + SQLite         :
 * ```sql
 *  SELECT
 *      strftime(
 *          '%Y-%m-%d',
 *          '2010-03-27 14:45:32.456789',
 *          '+1 month',
 *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
 *      )
 *  > 2010-03-31
 * ```
 */
exports.lastDay = factory_1.makeOperator1(operator_type_1.OperatorType.LAST_DAY, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=last-day.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/timestamp-add.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/timestamp-add.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Adds the specified number of milliseconds to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MICROSECOND, x*1000, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      (x/1000e0) || ' second'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of milliseconds to add; following MySQL convention
 * @param right - The date-time to add milliseconds to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMillisecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MILLISECOND, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of seconds to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' second'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of seconds to add; following MySQL convention
 * @param right - The date-time to add seconds to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddSecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_SECOND, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of minutes to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MINUTE, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' minute'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of minutes to add; following MySQL convention
 * @param right - The date-time to add minutes to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMinute = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MINUTE, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of hours to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(HOUR, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' hour'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of hours to add; following MySQL convention
 * @param right - The date-time to add hours to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddHour = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_HOUR, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of days to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(DAY, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' day'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of days to add; following MySQL convention
 * @param right - The date-time to add days to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddDay = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_DAY, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of months to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
 * + SQLite         : Complicated implementation.
 *
 * -----
 *
 * @param left - The number of months to add; following MySQL convention
 * @param right - The date-time to add months to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMonth = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MONTH, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of years to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' year'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of years to add; following MySQL convention
 * @param right - The date-time to add years to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddYear = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_YEAR, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=timestamp-add.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/timestamp-diff.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/timestamp-diff.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the number of milliseconds between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
 *   + The `TRUNC()` at the end is necessary
 *   + Extracting `SECOND` gives a number with decimal places for milliseconds
 *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in milliseconds
 */
exports.timestampDiffMillisecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_MILLISECOND, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of seconds between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
 *   + The `TRUNC()` at the end is necessary
 *   + Extracting `SECOND` gives a number with decimal places for milliseconds
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in seconds
 */
exports.timestampDiffSecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_SECOND, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of minutes between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in minutes
 */
exports.timestampDiffMinute = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_MINUTE, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of hours between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in hours
 */
exports.timestampDiffHour = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_HOUR, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of days between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
 * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in days
 */
exports.timestampDiffDay = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_DAY, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=timestamp-diff.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/unix-timestamp-now.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/unix-timestamp-now.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `UNIX_TIMESTAMP()`
 * + PostgreSQL     :
 * ```sql
 *  FLOOR(
 *      EXTRACT(EPOCH FROM (
 *          CURRENT_TIMESTAMP -
 *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
 *      ))
 *  )
 * ```
 * + SQLite         : `strftime('%s', 'now')`
 */
exports.unixTimestampNow = factory_1.makeOperator0(operator_type_1.OperatorType.UNIX_TIMESTAMP_NOW, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=unix-timestamp-now.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/date-time/utc-string-to-timestamp.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/expr-library/date-time/utc-string-to-timestamp.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 *
 * -----
 *
 * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
 * ```sql
 *  SET @@session.time_zone = 'EST';
 *  SELECT
 *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
 *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
 *  > 1969-12-31 22:00:00.123
 *  > 10800
 * ```
 * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
 * ```sql
 *  SET TIME ZONE 'EST';
 *  SELECT
 *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
 *      FLOOR(EXTRACT(
 *          EPOCH FROM (
 *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
 *          )
 *      ))
 *  > 1970-01-01T03:00:00.123Z
 *  > 10800
 * ```
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
 * ```sql
 *  SELECT
 *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
 *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
 *  > 1970-01-01 03:00:00.123
 *  > 10800
 * ```
 *
 * -----
 *
 * Treat `x` as representing a `UTC` timestamp.
 *
 */
exports.utcStringToTimestamp = factory_1.makeOperator1(operator_type_1.OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR, tm.mysql.dateTime(3).orNull());
//# sourceMappingURL=utc-string-to-timestamp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/abs.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/abs.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/add.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/add.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
exports.add = factory_1.makeChainableDecimalOperator(operator_type_1.OperatorType.ADDITION, 0, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/aggregate/avg.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/aggregate/avg.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/aggregate/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/aggregate/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "../tsql/dist/expr-library/decimal/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "../tsql/dist/expr-library/decimal/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "../tsql/dist/expr-library/decimal/aggregate/min.js"));
__export(__webpack_require__(/*! ./sum */ "../tsql/dist/expr-library/decimal/aggregate/sum.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/aggregate/max.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/aggregate/max.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/aggregate/min.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/aggregate/min.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/aggregate/sum.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/aggregate/sum.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const sumImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
exports.sumDistinct = (arg) => {
    return sumImpl(true, arg);
};
exports.sumAll = (arg) => {
    return sumImpl(false, arg);
};
exports.sum = exports.sumAll;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/ceiling.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/ceiling.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `CEILING(CEILING(x)) == CEILING(x)`
 */
exports.ceiling = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CEILING, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=ceiling.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/decimal-mapper.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/decimal-mapper.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "../tsql/node_modules/type-mapping/fluent.js");
/**
 * We make this precision and scale far larger than what a database
 * can reasonably reach.
 *
 * PostgreSQL has max precision 1,000.
 *
 * Precision 40,000 and scale 20,000 seems like a safe bet, right?
 */
exports.decimalMapper = tm.mysql.decimal(40000, 20000);
//# sourceMappingURL=decimal-mapper.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/exp.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/exp.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
exports.exp = factory_1.makeOperator1(operator_type_1.OperatorType.NATURAL_EXPONENTIATION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=exp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/floor.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/floor.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `FLOOR(FLOOR(x)) == FLOOR(x)`
 */
exports.floor = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.FLOOR, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=floor.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/fractional-div.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/fractional-div.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Performs regular fixed-point division
 */
exports.fractionalDiv = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_DIVISION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=fractional-div.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "../tsql/dist/expr-library/decimal/aggregate/index.js"));
__export(__webpack_require__(/*! ./abs */ "../tsql/dist/expr-library/decimal/abs.js"));
//export * from "./acos";
__export(__webpack_require__(/*! ./add */ "../tsql/dist/expr-library/decimal/add.js"));
//export * from "./asin";
//export * from "./atan";
//export * from "./atan2";
//export * from "./cbrt";
__export(__webpack_require__(/*! ./ceiling */ "../tsql/dist/expr-library/decimal/ceiling.js"));
//export * from "./cos";
//export * from "./cot";
//export * from "./degrees";
__export(__webpack_require__(/*! ./exp */ "../tsql/dist/expr-library/decimal/exp.js"));
__export(__webpack_require__(/*! ./floor */ "../tsql/dist/expr-library/decimal/floor.js"));
__export(__webpack_require__(/*! ./fractional-div */ "../tsql/dist/expr-library/decimal/fractional-div.js"));
/**
 * PostgreSQL and SQLite do not support fractional remainder `frem(x, y)`
 */
//export * from "./fractional-remainder";
//export * from "./integer-div";
//export * from "./integer-remainder";
__export(__webpack_require__(/*! ./ln */ "../tsql/dist/expr-library/decimal/ln.js"));
__export(__webpack_require__(/*! ./log */ "../tsql/dist/expr-library/decimal/log.js"));
__export(__webpack_require__(/*! ./log2 */ "../tsql/dist/expr-library/decimal/log2.js"));
__export(__webpack_require__(/*! ./log10 */ "../tsql/dist/expr-library/decimal/log10.js"));
__export(__webpack_require__(/*! ./mul */ "../tsql/dist/expr-library/decimal/mul.js"));
__export(__webpack_require__(/*! ./neg */ "../tsql/dist/expr-library/decimal/neg.js"));
//export * from "./pi";
__export(__webpack_require__(/*! ./power */ "../tsql/dist/expr-library/decimal/power.js"));
//export * from "./radians";
__export(__webpack_require__(/*! ./random */ "../tsql/dist/expr-library/decimal/random.js"));
//export * from "./round";
__export(__webpack_require__(/*! ./sign */ "../tsql/dist/expr-library/decimal/sign.js"));
//export * from "./sin";
__export(__webpack_require__(/*! ./sqrt */ "../tsql/dist/expr-library/decimal/sqrt.js"));
__export(__webpack_require__(/*! ./sub */ "../tsql/dist/expr-library/decimal/sub.js"));
//export * from "./tan";
//export * from "./truncate";
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/ln.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/decimal/ln.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LN(0)` === `NULL`
 * + PostgreSQL : `LN(0)` throws error
 */
exports.ln = factory_1.makeOperator1(operator_type_1.OperatorType.LN, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=ln.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/log.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/log.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG(0, 0)` === `NULL`
 * + PostgreSQL : `LOG(0, 0)` throws error
 */
exports.log = factory_1.makeOperator2(operator_type_1.OperatorType.LOG, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/log10.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/log10.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG10(0)` === `NULL`
 * + PostgreSQL : `LOG(10, 0)` throws error
 */
exports.log10 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG10, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log10.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/log2.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/log2.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG2(0)` === `NULL`
 * + PostgreSQL : `LOG(2, 0)` throws error
 */
exports.log2 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG2, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/mul.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/mul.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
exports.mul = factory_1.makeChainableDecimalOperator(operator_type_1.OperatorType.MULTIPLICATION, 1, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/neg.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/neg.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/power.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/power.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
exports.power = factory_1.makeOperator2(operator_type_1.OperatorType.POWER, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=power.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/random.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/random.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
exports.random = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/sign.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/sign.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
 */
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/sqrt.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/sqrt.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `SQRT(-5)` === `null`
 * + PostgreSQL : `SQRT(-5)` throws error
 */
exports.sqrt = factory_1.makeOperator1(operator_type_1.OperatorType.SQUARE_ROOT, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sqrt.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/decimal/sub.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/decimal/sub.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/abs.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/abs.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the absolute value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_corefunc.html#abs
 *
 * -----
 *
 * + MySQL        : `ABS(x)`
 * + PostgreSQL   : `ABS(x)`
 * + SQLite       : `ABS(x)`
 *   + `ABS(Infinity)  = Infinity`
 *   + `ABS(-Infinity) = Infinity`
 *
 * -----
 *
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/acos.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/acos.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the arc cosine.
 *
 * If the argument is not in [-1, 1], may throw, or return `null`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ACOS(x)`
 * + PostgreSQL     : `ACOS(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * + MySQL      : `ACOS(1.5)` === `NULL`
 * + PostgreSQL : `ACOS(1.5)` throws error
 */
exports.acos = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_COSINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=acos.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/add.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/add.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the addition of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
 *
 * -----
 *
 * + MySQL        : `+`
 *   + `1e308+1e308` throws
 *   + `(-1e308)+(-1e308)` throws
 * + PostgreSQL   : `+`
 *   + `CAST(1e308 AS double precision)+CAST(1e308 AS double precision)` throws
 *   + `CAST(-1e308 AS double precision)+CAST(-1e308 AS double precision)` throws
 * + SQLite       : `+`
 *   + `1e308+1e308 = Infinity`
 *   + `(-1e308)+(-1e308) = -Infinity`
 *
 * -----
 *
 * In SQLite, addition with doubles may return `null`,
 * ```sql
 *  SELECT 1e999 + -1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.add = factory_1.makeChainableOperator(operator_type_1.OperatorType.ADDITION, 0, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/avg.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/avg.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(DISTINCT x)`
 * + PostgreSQL : `AVG(DISTINCT x)`
 * + SQLite     : `AVG(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "../tsql/dist/expr-library/double/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "../tsql/dist/expr-library/double/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "../tsql/dist/expr-library/double/aggregate/min.js"));
__export(__webpack_require__(/*! ./stddev-pop */ "../tsql/dist/expr-library/double/aggregate/stddev-pop.js"));
__export(__webpack_require__(/*! ./stddev-samp */ "../tsql/dist/expr-library/double/aggregate/stddev-samp.js"));
__export(__webpack_require__(/*! ./sum */ "../tsql/dist/expr-library/double/aggregate/sum.js"));
__export(__webpack_require__(/*! ./var-pop */ "../tsql/dist/expr-library/double/aggregate/var-pop.js"));
__export(__webpack_require__(/*! ./var-samp */ "../tsql/dist/expr-library/double/aggregate/var-samp.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/max.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/max.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/min.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/min.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/stddev-pop.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/stddev-pop.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the population standard deviation of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
 *
 * -----
 *
 * + MySQL      : `STDDEV_POP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `STDDEV_POP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The population standard deviation is,
 * ```sql
 *  SQRT(
 *      -- SUM() and AVG() should ignore rows with `NULL` values
 *      SUM(
 *          POW((x - AVG(x), 2)
 *      ) /
 *      COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
 *  )
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.stdDevPop = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=stddev-pop.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/stddev-samp.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/stddev-samp.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the sample standard deviation of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * It returns `NULL` if there is only one non-`NULL` value.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
 *
 * -----
 *
 * + MySQL      : `STDDEV_SAMP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `STDDEV_SAMP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The sample standard deviation is,
 * ```sql
 *  SQRT(
 *      -- SUM() and AVG() should ignore rows with `NULL` values
 *      SUM(
 *          POW((x - AVG(x), 2)
 *      ) /
 *      (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
 *  )
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.stdDevSamp = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=stddev-samp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/sum.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/sum.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const sumImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(DISTINCT x)`
 * + PostgreSQL : `SUM(DISTINCT x)`
 * + SQLite     : `SUM(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sumDistinct = (arg) => {
    return sumImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(x)`
 * + SQLite     : `SUM(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sumAll = (arg) => {
    return sumImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(x)`
 * + SQLite     : `SUM(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sum = exports.sumAll;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/var-pop.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/var-pop.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the population variance of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 *
 * -----
 *
 * + MySQL      : `VAR_POP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `VAR_POP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The population variance is,
 * ```sql
 *  -- SUM() and AVG() should ignore rows with `NULL` values
 *  SUM(
 *      POW((x - AVG(x), 2)
 *  ) /
 *  COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.varPop = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_POPULATION_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=var-pop.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/aggregate/var-samp.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/expr-library/double/aggregate/var-samp.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the sample variance of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * It returns `NULL` if there is only one non-`NULL` value.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 *
 * -----
 *
 * + MySQL      : `VAR_SAMP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `VAR_SAMP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The sample variance is,
 * ```sql
 *  -- SUM() and AVG() should ignore rows with `NULL` values
 *  SUM(
 *      POW((x - AVG(x), 2)
 *  ) /
 *  (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.varSamp = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_SAMPLE_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=var-samp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/asin.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/asin.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the arc sine.
 *
 * If the argument is not in [-1, 1], may throw, or return `null`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ASIN(x)`
 * + PostgreSQL     : `ASIN(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * + MySQL      : `ASIN(1.5)` === `NULL`
 * + PostgreSQL : `ASIN(1.5)` throws error
 */
exports.asin = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_SINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=asin.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/atan.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/atan.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the arc tangent.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ATAN(x)`
 * + PostgreSQL     : `ATAN(x)`
 * + SQLite         : None, implement with user-defined function
 */
exports.atan = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_TANGENT, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=atan.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/atan2.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/double/atan2.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Similar to calculating the arc tangent of `Y / X`,
 * except that the signs of both arguments are used
 * to determine the quadrant of the result.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ATAN2(y, x)`
 * + PostgreSQL     : `ATAN2(y, x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * @param left  - The Y of the vector
 * @param right - The X of the vector
 */
exports.atan2 = factory_1.makeOperator2(operator_type_1.OperatorType.ARC_TANGENT_2, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=atan2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/cbrt.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/cbrt.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the cube root
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_pow
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `IF(x >= 0, POWER(x, 1.0/3.0), -POWER(-(x), 1.0/3.0))`
 *   + The `.0` parts are important!
 *   + MySQL's `POWER()` function throws on negative numbers
 * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
 * + SQLite       : Requres creating a `CBRT(x)` user-defined function
 *
 * -----
 *
 * MySQL
 * ```sql
 * SELECT POWER(27, 1.0/3.0)
 * > 3
 * ```
 *
 * PostgreSQL
 * ```sql
 * SELECT POWER(27, 1.0/3.0)
 * > 2.99999999999999999997
 *
 * SELECT CBRT(27)
 * > 3
 * ```
 */
exports.cbrt = factory_1.makeOperator1(operator_type_1.OperatorType.CUBE_ROOT, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cbrt.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/ceiling.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/double/ceiling.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the ceiling of the number
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceiling
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `CEIL(x)/CEILING(x)`
 * + PostgreSQL   : `CEIL(x)/CEILING(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * ```sql
 *  SELECT CEILING(1.1)
 *  > 2
 *
 *  SELECT CEILING(-1.1)
 *  > -1
 * ```
 *
 * -----
 *
 * This function is idempotent.
 * `CEILING(CEILING(x)) == CEILING(x)`
 */
exports.ceiling = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CEILING, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=ceiling.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/cos.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/cos.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the cosine
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `COS(x)`
 * + PostgreSQL     : `COS(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COS(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The cosine
 */
exports.cos = factory_1.makeOperator1(operator_type_1.OperatorType.COSINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cos.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/cot.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/cot.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the cotangent
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `COT(x)`
 * + PostgreSQL     : `COT(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COT(1e999)`
 *
 * -----
 *
 * + MySQL      : `COT(0)` throws error
 * + PostgreSQL : `COT(0)` === `NULL`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The cotangent
 */
exports.cot = factory_1.makeOperator1(operator_type_1.OperatorType.COTANGENT, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cot.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/degrees.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/double/degrees.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Converts from radians to degrees.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `DEGREES(x)`
 * + PostgreSQL     : `DEGREES(x)`
 * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
 *
 * -----
 *
 * @param arg - radians
 * @returns degrees
 */
exports.degrees = factory_1.makeOperator1(operator_type_1.OperatorType.DEGREES, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=degrees.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/exp.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/exp.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * The natural exponential function
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://en.wikipedia.org/wiki/Exponential_function
 *
 * -----
 *
 * + MySQL          : `EXP(x)`
 * + PostgreSQL     : `EXP(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * @param arg - The power value
 * @returns e^arg
 */
exports.exp = factory_1.makeOperator1(operator_type_1.OperatorType.NATURAL_EXPONENTIATION, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=exp.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/floor.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/double/floor.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the floor of the number
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `FLOOR(x)`
 * + PostgreSQL   : `FLOOR(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * ```sql
 *  SELECT FLOOR(1.1)
 *  > 1
 *
 *  SELECT FLOOR(-1.1)
 *  > -2
 * ```
 *
 * -----
 *
 * This function is idempotent.
 * `FLOOR(FLOOR(x)) == FLOOR(x)`
 */
exports.floor = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.FLOOR, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=floor.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/fractional-div.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/double/fractional-div.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Performs regular floating-point division
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `/`
 * + PostgreSQL   : `/`
 * + SQLite       : `/`
 *
 * -----
 *
 * `1e0/0e0`,
 *
 * + MySQL      : `NULL`
 * + PostgreSQL : throws
 * + SQLite     : `NULL`
 *
 * -----
 *
 * `1e308/0.1e0`,
 *
 * + MySQL      : throws
 * + PostgreSQL : throws
 * + SQLite     : `Infinity`
 *
 * -----
 *
 * `1e308/-0.1e0`,
 *
 * + MySQL      : throws
 * + PostgreSQL : throws
 * + SQLite     : `-Infinity`
 *
 * -----
 *
 * MySQL,
 * ```sql
 *  SELECT
 *      3.141592653539793e0 /
 *      6.233523257997525e0;
 *  > 0.5039834654517689
 * ```
 * PostgreSQL,
 * ```sql
 *  SELECT
 *      CAST(3.141592653539793e0 AS DOUBLE PRECISION) /
 *      CAST(6.233523257997525e0 AS DOUBLE PRECISION);
 *  > 0.503983465451769
 * ```
 *
 * SQLite,
 * ```sql
 *  SELECT
 *      3.141592653539793e0 /
 *      6.233523257997525e0;
 *  > 0.5039834654517689
 * ```
 */
exports.fractionalDiv = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_DIVISION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=fractional-div.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/fractional-remainder.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/double/fractional-remainder.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the remainder after fractional division.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_mod
 * + https://stackoverflow.com/questions/53486669/modulo-operation-on-floating-point-numbers-on-postgresql
 *
 * -----
 *
 * + MySQL      : `dividend % divisor`
 * + PostgreSQL : See algorithm below
 * + SQLite     : See algorithm below
 *
 * ```sql
 *  IF(
 *      dividend >= 0,
 *      dividend - FLOOR(dividend / divisor) * divisor,
 *      -((-dividend) - FLOOR((-dividend) / divisor) * divisor)
 *  )
 * ```
 */
exports.fractionalRemainder = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_REMAINDER, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=fractional-remainder.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/double/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "../tsql/dist/expr-library/double/aggregate/index.js"));
__export(__webpack_require__(/*! ./abs */ "../tsql/dist/expr-library/double/abs.js"));
__export(__webpack_require__(/*! ./acos */ "../tsql/dist/expr-library/double/acos.js"));
__export(__webpack_require__(/*! ./add */ "../tsql/dist/expr-library/double/add.js"));
__export(__webpack_require__(/*! ./asin */ "../tsql/dist/expr-library/double/asin.js"));
__export(__webpack_require__(/*! ./atan */ "../tsql/dist/expr-library/double/atan.js"));
__export(__webpack_require__(/*! ./atan2 */ "../tsql/dist/expr-library/double/atan2.js"));
__export(__webpack_require__(/*! ./cbrt */ "../tsql/dist/expr-library/double/cbrt.js"));
__export(__webpack_require__(/*! ./ceiling */ "../tsql/dist/expr-library/double/ceiling.js"));
__export(__webpack_require__(/*! ./cos */ "../tsql/dist/expr-library/double/cos.js"));
__export(__webpack_require__(/*! ./cot */ "../tsql/dist/expr-library/double/cot.js"));
__export(__webpack_require__(/*! ./degrees */ "../tsql/dist/expr-library/double/degrees.js"));
__export(__webpack_require__(/*! ./exp */ "../tsql/dist/expr-library/double/exp.js"));
__export(__webpack_require__(/*! ./floor */ "../tsql/dist/expr-library/double/floor.js"));
__export(__webpack_require__(/*! ./fractional-div */ "../tsql/dist/expr-library/double/fractional-div.js"));
__export(__webpack_require__(/*! ./fractional-remainder */ "../tsql/dist/expr-library/double/fractional-remainder.js"));
/**
 * MySQL's `DIV` is just too... Unintuitive.
 * One would think it converts operands to int before performing int-div.
 * Instead, it performs fractional-div, then converts result to int.
 *
 * If you really want integer-div, just cast and divide yourself.
 */
//export * from "./integer-div";
/**
 * For the same reason that integer-div is removed.
 */
//export * from "./integer-remainder";
__export(__webpack_require__(/*! ./ln */ "../tsql/dist/expr-library/double/ln.js"));
__export(__webpack_require__(/*! ./log */ "../tsql/dist/expr-library/double/log.js"));
__export(__webpack_require__(/*! ./log2 */ "../tsql/dist/expr-library/double/log2.js"));
__export(__webpack_require__(/*! ./log10 */ "../tsql/dist/expr-library/double/log10.js"));
__export(__webpack_require__(/*! ./mul */ "../tsql/dist/expr-library/double/mul.js"));
__export(__webpack_require__(/*! ./neg */ "../tsql/dist/expr-library/double/neg.js"));
__export(__webpack_require__(/*! ./pi */ "../tsql/dist/expr-library/double/pi.js"));
__export(__webpack_require__(/*! ./power */ "../tsql/dist/expr-library/double/power.js"));
__export(__webpack_require__(/*! ./radians */ "../tsql/dist/expr-library/double/radians.js"));
__export(__webpack_require__(/*! ./random */ "../tsql/dist/expr-library/double/random.js"));
//export * from "./round";
__export(__webpack_require__(/*! ./sign */ "../tsql/dist/expr-library/double/sign.js"));
__export(__webpack_require__(/*! ./sin */ "../tsql/dist/expr-library/double/sin.js"));
__export(__webpack_require__(/*! ./sqrt */ "../tsql/dist/expr-library/double/sqrt.js"));
__export(__webpack_require__(/*! ./sub */ "../tsql/dist/expr-library/double/sub.js"));
__export(__webpack_require__(/*! ./tan */ "../tsql/dist/expr-library/double/tan.js"));
//export * from "./truncate";
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/ln.js":
/*!**********************************************!*\
  !*** ../tsql/dist/expr-library/double/ln.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the natural logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `LN(x)`
 * + PostgreSQL     : `LN(x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LN(0)` === `NULL`
 * + PostgreSQL : `LN(0)` throws error
 *
 * -----
 *
 * + MySQL      : `LN(-1)` === `NULL`
 * + PostgreSQL : `LN(-1)` throws error
 */
exports.ln = factory_1.makeOperator1(operator_type_1.OperatorType.LN, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=ln.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/log.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/log.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the logarithm to the specified `base`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `LOG(base, x)`
 * + PostgreSQL     : `LOG(base, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG(0, 0)` === `NULL`
 * + PostgreSQL : `LOG(0, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG(1, 5)` === `NULL`
 * + PostgreSQL : `LOG(1, 5)` throws error
 *
 * -----
 *
 * @param left  - The base
 * @param right - The anti-logarithm
 * @returns log_{base}(anti-logarithm) = logarithm
 */
exports.log = factory_1.makeOperator2(operator_type_1.OperatorType.LOG, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/log10.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/double/log10.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the base-10 logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
 *
 * -----
 *
 * + MySQL          : `LOG10(x)`
 * + PostgreSQL     : `LOG(10.0, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG10(0)` === `NULL`
 * + PostgreSQL : `LOG(10, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG10(-1)` === `NULL`
 * + PostgreSQL : `LOG(10, -1)` throws error
 */
exports.log10 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG10, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log10.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/log2.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/log2.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the base-2 logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
 *
 * -----
 *
 * + MySQL          : `LOG2(x)`
 * + PostgreSQL     : `LOG(2.0, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG2(0)` === `NULL`
 * + PostgreSQL : `LOG(2, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG2(-1)` === `NULL`
 * + PostgreSQL : `LOG(2, -1)` throws error
 */
exports.log2 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG2, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/mul.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/mul.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the multiplication of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
 *
 * -----
 *
 * + MySQL        : `*`
 *   + `1e308*1e308` throws
 *   + `1e308*-1e308` throws
 * + PostgreSQL   : `*`
 *   + `CAST(1e308 AS double precision)*CAST(1e308 AS double precision)` throws
 *   + `CAST(1e308 AS double precision)*CAST(-1e308 AS double precision)` throws
 * + SQLite       : `*`
 *   + `1e308*1e308 = Infinity`
 *   + `1e308*-1e308 = -Infinity`
 *
 * -----
 *
 * In SQLite, multiplication with doubles may return `null`,
 * ```sql
 *  SELECT 0e0 * 1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.mul = factory_1.makeChainableOperator(operator_type_1.OperatorType.MULTIPLICATION, 1, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/neg.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/neg.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the unary minus of the double value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
 *
 * -----
 *
 * + MySQL        : `-`
 * + PostgreSQL   : `-`
 * + SQLite       : `-`
 *
 * -----
 *
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/pi.js":
/*!**********************************************!*\
  !*** ../tsql/dist/expr-library/double/pi.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the value of pi
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://en.wikipedia.org/wiki/Pi
 *
 * -----
 *
 * + MySQL          : `PI()`; MySQL's understanding of pi is... terrible
 *   + https://github.com/AnyhowStep/tsql/issues/252
 *   + The MySQL adapter library **should not** use `PI()`, it should use `3.141592653589793` instead
 * + PostgreSQL     : `PI()` Returns `3.14159265358979`
 * + SQLite         : None, implement using `3.141592653589793`
 *
 * -----
 *
 * In JS, `Math.PI` is `3.141592653589793`
 */
exports.pi = factory_1.makeOperator0(operator_type_1.OperatorType.PI, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=pi.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/power.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/double/power.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns `base^exponent`
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `POWER(base, exponent)`
 * + PostgreSQL   : `^` or `POWER(base, exponent)` (Let's not use the ugly `^` operator)
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `POWER(-1, 0.5)`
 *
 * -----
 *
 * If base is negative, and exponent is fractional,
 * + MySQL throws
 * + PostgreSQL throws
 * + SQLite reutrns `null` (`extension-functions.c`)
 *
 * -----
 *
 * If base is zero, and exponent is negative,
 * + MySQL throws
 * + PostgreSQL throws
 * + SQLite reutrns `Infinity` (`extension-functions.c`)
 *
 * -----
 *
 * @param left  - The base
 * @param right - The exponent
 * @returns base^exponent
 *
 * @todo Decide if we should make SQLite throw instead of return `null`
 */
exports.power = factory_1.makeOperator2(operator_type_1.OperatorType.POWER, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=power.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/radians.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/double/radians.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Converts from degrees to radians.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `RADIANS(x)`
 * + PostgreSQL     : `RADIANS(x)`
 * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
 *
 * -----
 *
 * @param arg - degrees
 * @returns radians
 */
exports.radians = factory_1.makeOperator1(operator_type_1.OperatorType.RADIANS, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=radians.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/random.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/double/random.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns a random floating point number in the range, `[0.0, 1.0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#random
 *
 * -----
 *
 * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
 * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
 * + SQLite         : Incompatible.
 *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
 *   See algorithm below to emulate.
 *   Or just use a user-defined function...
 *
 * -----
 *
 * SQLite emulation,
 * ```sql
 *  COALESCE(
 *      NULLIF(
 *          ABS(RANDOM()+0e0) / 9223372036854775809e0,
 *          1
 *      ),
 *      0.999999999999999
 *  )
 * ```
 */
exports.random = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/sign.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/sign.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * + If the argument is negative, returns -1
 * + If the argument is positive, returns  1
 * + If the argument is zero, returns 0
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `SIGN(x)`
 * + PostgreSQL     : `SIGN(x)`
 * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
 *
 * -----
 *
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
*/
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/sin.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/sin.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the sine
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `SIN(x)`
 * + PostgreSQL     : `SIN(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `SIN(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The sine
 */
exports.sin = factory_1.makeOperator1(operator_type_1.OperatorType.SINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sin.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/sqrt.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/double/sqrt.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the square root
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `SQRT(x)`
 * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
 * + SQLite       : Requres creating a `SQRT(x)` user-defined function
 *
 * -----
 *
 * + MySQL      : `SQRT(-5)` === `null`
 * + PostgreSQL : `SQRT(-5)` throws error
 */
exports.sqrt = factory_1.makeOperator1(operator_type_1.OperatorType.SQUARE_ROOT, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sqrt.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/sub.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/sub.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the subtraction of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
 *
 * -----
 *
 * + MySQL        : `-`
 *   + `-1e308 - 1e308` throws
 *   + `1e308 - -1e308` throws
 * + PostgreSQL   : `-`
 *   + `CAST(-1e308 AS DOUBLE PRECISION) - CAST(1e308 AS DOUBLE PRECISION)` throws
 *   + `CAST(1e308 AS DOUBLE PRECISION) - CAST(-1e308 AS DOUBLE PRECISION)` throws
 * + SQLite       : `-`
 *   + `-1e308 - 1e308 = -Infinity`
 *   + `1e308 - -1e308 = Infinity`
 *
 * -----
 *
 * In SQLite, subtraction with doubles may return `null`,
 * ```sql
 *  SELECT 1e999 - 1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/double/tan.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/double/tan.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Returns the tangent
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `TAN(x)`
 * + PostgreSQL     : `TAN(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `TAN(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The tangent
 */
exports.tan = factory_1.makeOperator1(operator_type_1.OperatorType.TANGENT, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=tan.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/eq-primary-key.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/equation/eq-primary-key.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const primary_key_1 = __webpack_require__(/*! ../../primary-key */ "../tsql/dist/primary-key/index.js");
const eq_1 = __webpack_require__(/*! ./eq */ "../tsql/dist/expr-library/equation/eq.js");
const logical_1 = __webpack_require__(/*! ../logical */ "../tsql/dist/expr-library/logical/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "../tsql/dist/column-map/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
/**
 * Convenience function for,
 * ```ts
 *  tsql.and(
 *      tsql.eq(primaryKeyColumn0, value0),
 *      tsql.eq(primaryKeyColumn1, value1),
 *      tsql.eq(primaryKeyColumn2, value2)
 *      //etc.
 *  );
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 * -----
 *
 * Uses `eq()` internally because the primary key of a table
 * cannot have nullable columns.
 *
 * @todo Change this to use `nullSafeEq()` jusssst in case people start using
 * nullable columns in PKs for whatever reason?
 *
 * @param table - The table with a primary key
 * @param primaryKeyInput - The primary key values to compare against
 */
function eqPrimaryKey(table, primaryKeyInput) {
    const primaryKey = primary_key_1.PrimaryKeyUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.primaryKey`, primaryKeyInput);
    /**
     * We `.sort()` the keys so our resulting SQL is deterministic,
     * regardless of how `primaryKey` was constructed.
     */
    const arr = Object.keys(primaryKey).sort().map((columnAlias) => {
        /**
         * We use `eq` because the primary key of a table cannot have
         * nullable columns... Right?
         *
         * @todo Decide if we should use null-safe equality anyway,
         * just to be super safe
         */
        const expr = eq_1.eq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], primaryKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
}
exports.eqPrimaryKey = eqPrimaryKey;
//# sourceMappingURL=eq-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/eq.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/equation/eq.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
 *
 * This version of the `=` operator prevents `NULL`.
 *
 * For null-safe equality, @see {@link nullSafeEq}
 */
exports.eq = factory_1.makeEquation2(operator_type_1.OperatorType.EQUAL);
//# sourceMappingURL=eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/in-array.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/equation/in-array.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const inArrayImpl = factory_1.makeEquation2ToN(operator_type_1.OperatorType.IN_ARRAY);
/**
 * The `IN` operator has two overloads.
 * + `x IN (y0, y1, y2, y3, ...)`
 * + `x IN (SELECT y FROM ...)`
 *
 * This implementation is for the first overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
 *
 * The array cannot contain `null` because,
 * + `x IN (NULL)` is `NULL`
 * + `1 IN (NULL, 2)` is `NULL`
 * + `1 IN (NULL, 2, 1)` is `true`
 *
 * -----
 *
 * Calling `inArray()` with an empty array will always
 * return `false` because a value is never in an array of zero elements.
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 */
function inArray(arg0, args) {
    const [arg1, ...rest] = args;
    if (arg1 == undefined) {
        /**
         * Calling `inArray()` with an empty array will always
         * return `false` because a value is never in an array of zero elements.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(false);
    }
    else {
        return inArrayImpl(arg0, arg1, ...rest);
    }
}
exports.inArray = inArray;
//# sourceMappingURL=in-array.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/in-query.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/equation/in-query.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "../tsql/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * The `IN` operator has two overloads.
 * + `x IN (y0, y1, y2, y3, ...)`
 * + `x IN (SELECT y FROM ...)`
 *
 * This implementation is for the second overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
 *
 * The query argument cannot `SELECT` `null` because,
 * + `x IN (SELECT NULL)` is `NULL`
 * + `x IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
 *   + At least one row has a `NULL` value
 *   + No rows have the value `x`
 * + `x IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
 *   + No rows have the value `x`
 * + `1 IN (SELECT NULL UNION SELECT 1)` is `true`
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 *
 * -----
 *
 * ### Problems with MySQL
 *
 * The following produced an error,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 IN (SELECT id FROM myTable LIMIT 1);
 * ```
 *
 * The following is a workaround,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
 * ```
 */
function inQuery(builtInExpr, query) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Query must SELECT one item`);
    }
    if (tm.canOutputNull(query.selectClause[0].mapper)) {
        throw new Error(`Query must not SELECT nullable value`);
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr),
    }, ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.IN_QUERY, [
        built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        built_in_expr_1.BuiltInExprUtil.buildAst(query)
    ], undefined));
}
exports.inQuery = inQuery;
//# sourceMappingURL=in-query.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/equation/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./eq-primary-key */ "../tsql/dist/expr-library/equation/eq-primary-key.js"));
__export(__webpack_require__(/*! ./eq */ "../tsql/dist/expr-library/equation/eq.js"));
__export(__webpack_require__(/*! ./in-array */ "../tsql/dist/expr-library/equation/in-array.js"));
__export(__webpack_require__(/*! ./in-query */ "../tsql/dist/expr-library/equation/in-query.js"));
__export(__webpack_require__(/*! ./not-eq */ "../tsql/dist/expr-library/equation/not-eq.js"));
__export(__webpack_require__(/*! ./not-in-array */ "../tsql/dist/expr-library/equation/not-in-array.js"));
__export(__webpack_require__(/*! ./not-in-query */ "../tsql/dist/expr-library/equation/not-in-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/not-eq.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/equation/not-eq.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
 *
 * This version of the `<>` operator prevents `NULL`.
 *
 * For null-safe inequality, @see {@link nullSafeNotEq}
 *
 */
exports.notEq = factory_1.makeEquation2(operator_type_1.OperatorType.NOT_EQUAL);
//# sourceMappingURL=not-eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/not-in-array.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/equation/not-in-array.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Refactor `inArray()` and `notInArray()` so they can share code.
 * Something like a `makeInArray()` factory function.
 */
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const notInArrayImpl = factory_1.makeEquation2ToN(operator_type_1.OperatorType.NOT_IN_ARRAY);
/**
 * The `NOT IN` operator has two overloads.
 * + `x NOT IN (y0, y1, y2, y3, ...)`
 * + `x NOT IN (SELECT y FROM ...)`
 *
 * This implementation is for the first overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
 *
 * The array cannot contain `null` because,
 * + `x NOT IN (NULL)` is `NULL`
 * + `1 NOT IN (NULL, 2)` is `NULL`
 * + `1 NOT IN (NULL, 2, 1)` is `false`
 *
 * -----
 *
 * Calling `notInArray()` with an empty array will always
 * return `true` because a value is always **not** in an array of zero elements.
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 */
function notInArray(arg0, args) {
    const [arg1, ...rest] = args;
    if (arg1 == undefined) {
        /**
         * Calling `notInArray()` with an empty array will always
         * return `true` because a value is always **not** in an array of zero elements.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(true);
    }
    else {
        return notInArrayImpl(arg0, arg1, ...rest);
    }
}
exports.notInArray = notInArray;
//# sourceMappingURL=not-in-array.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/equation/not-in-query.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/equation/not-in-query.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Refactor `inQuery()` and `notInQuery()` so they can share code.
 * Something like a `makeInQuery()` factory function.
 */
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "../tsql/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * The `NOT IN` operator has two overloads.
 * + `x NOT IN (y0, y1, y2, y3, ...)`
 * + `x NOT IN (SELECT y FROM ...)`
 *
 * This implementation is for the second overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
 *
 * The query argument cannot `SELECT` `null` because,
 * + `x NOT IN (SELECT NULL)` is `NULL`
 * + `x NOT IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
 *   + At least one row has a `NULL` value
 *   + No rows have the value `x`
 * + `x NOT IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
 *   + No rows have the value `x`
 * + `1 NOT IN (SELECT NULL UNION SELECT 1)` is `false`
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 *
 * -----
 *
 * ### Problems with MySQL
 *
 * The following produced an error,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 NOT IN (SELECT id FROM myTable LIMIT 1);
 * ```
 *
 * The following is a workaround,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 NOT IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
 * ```
 */
function notInQuery(builtInExpr, query) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Query must SELECT one item`);
    }
    if (tm.canOutputNull(query.selectClause[0].mapper)) {
        throw new Error(`Query must not SELECT nullable value`);
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr),
    }, ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.NOT_IN_QUERY, [
        built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        built_in_expr_1.BuiltInExprUtil.buildAst(query)
    ], undefined));
}
exports.notInQuery = notInQuery;
//# sourceMappingURL=not-in-query.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/factory/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-any-operator-1 */ "../tsql/dist/expr-library/factory/make-any-operator-1.js"));
__export(__webpack_require__(/*! ./make-chainable-decimal-operator */ "../tsql/dist/expr-library/factory/make-chainable-decimal-operator.js"));
__export(__webpack_require__(/*! ./make-chainable-operator */ "../tsql/dist/expr-library/factory/make-chainable-operator.js"));
__export(__webpack_require__(/*! ./make-comparison-1-to-n */ "../tsql/dist/expr-library/factory/make-comparison-1-to-n.js"));
__export(__webpack_require__(/*! ./make-comparison-2-to-n */ "../tsql/dist/expr-library/factory/make-comparison-2-to-n.js"));
__export(__webpack_require__(/*! ./make-comparison-2 */ "../tsql/dist/expr-library/factory/make-comparison-2.js"));
__export(__webpack_require__(/*! ./make-comparison-3 */ "../tsql/dist/expr-library/factory/make-comparison-3.js"));
__export(__webpack_require__(/*! ./make-comparison-projection-2-to-n */ "../tsql/dist/expr-library/factory/make-comparison-projection-2-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-1-to-n */ "../tsql/dist/expr-library/factory/make-equation-1-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-2-to-n */ "../tsql/dist/expr-library/factory/make-equation-2-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-2 */ "../tsql/dist/expr-library/factory/make-equation-2.js"));
__export(__webpack_require__(/*! ./make-null-safe-comparison-1 */ "../tsql/dist/expr-library/factory/make-null-safe-comparison-1.js"));
__export(__webpack_require__(/*! ./make-null-safe-comparison-2 */ "../tsql/dist/expr-library/factory/make-null-safe-comparison-2.js"));
__export(__webpack_require__(/*! ./make-null-safe-equation-1 */ "../tsql/dist/expr-library/factory/make-null-safe-equation-1.js"));
__export(__webpack_require__(/*! ./make-null-safe-equation-2 */ "../tsql/dist/expr-library/factory/make-null-safe-equation-2.js"));
__export(__webpack_require__(/*! ./make-operator-0 */ "../tsql/dist/expr-library/factory/make-operator-0.js"));
__export(__webpack_require__(/*! ./make-operator-1-double-elimination */ "../tsql/dist/expr-library/factory/make-operator-1-double-elimination.js"));
__export(__webpack_require__(/*! ./make-operator-1-idempotent */ "../tsql/dist/expr-library/factory/make-operator-1-idempotent.js"));
__export(__webpack_require__(/*! ./make-operator-1-to-n */ "../tsql/dist/expr-library/factory/make-operator-1-to-n.js"));
__export(__webpack_require__(/*! ./make-operator-1 */ "../tsql/dist/expr-library/factory/make-operator-1.js"));
__export(__webpack_require__(/*! ./make-operator-2-to-n */ "../tsql/dist/expr-library/factory/make-operator-2-to-n.js"));
__export(__webpack_require__(/*! ./make-operator-2 */ "../tsql/dist/expr-library/factory/make-operator-2.js"));
__export(__webpack_require__(/*! ./make-operator-3 */ "../tsql/dist/expr-library/factory/make-operator-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-any-operator-1.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-any-operator-1.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeAnyOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeAnyOperator1 = makeAnyOperator1;
//# sourceMappingURL=make-any-operator-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-chainable-decimal-operator.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-chainable-decimal-operator.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../decimal/decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
function tryGetFlattenableElements(
/**
 * In this specific instance, we could probably have `BuiltInExpr<Decimal>`.
 * Can't accept arbitrary `Decimal` types because they may have invalid precision/scale.
 */
builtInExpr, operatorType, _identityElement, identityAst, identityParseResult) {
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return ast_1.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
            if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_1.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                /**
                 * Eliminate all identity elements
                 */
                return [];
            }
            else if (ast_1.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                return ast.operands;
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * We should not see any `Decimal` built-ins because JS does not have them.
     */
    const builtInExprParseResult = tm.FixedPointUtil.tryParse(String(builtInExpr));
    if (builtInExprParseResult != undefined &&
        tm.FixedPointUtil.isEqual(builtInExprParseResult, identityParseResult, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL)) {
        /**
         * Eliminate all identity elements
         */
        return [];
    }
    return undefined;
}
function makeChainableDecimalOperator(operatorType, rawIdentityElement, mapper, 
/**
 * For now, the typeHint should always be `DECIMAL`
 */
typeHint) {
    const identityElement = decimal_mapper_1.decimalMapper("rawIdentityElement", rawIdentityElement);
    const identityParseResult = tm.FixedPointUtil.tryParse(rawIdentityElement.toString());
    if (identityParseResult == undefined) {
        throw new Error(`Invalid identity element ${rawIdentityElement}`);
    }
    let identityAst = undefined;
    const result = (...arr) => {
        if (identityAst == undefined) {
            const newIdentityAst = literal_value_node_1.LiteralValueNodeUtil.decimalLiteralNode(identityElement, 65, 30);
            if (!literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                throw new Error(`Invalid identity element`);
            }
            identityAst = newIdentityAst;
        }
        let operands = undefined;
        for (const builtInExpr of arr) {
            const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst, identityParseResult);
            if (flattenableElements != undefined) {
                /**
                 * Looks like we should flatten this `builtInExpr`
                 */
                if (flattenableElements.length == 0) {
                    continue;
                }
                else {
                    if (operands == undefined) {
                        operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                    }
                    else {
                        operands.push(...flattenableElements);
                    }
                }
            }
            else {
                /**
                 * Can't flatten this `builtInExpr`
                 */
                if (operands == undefined) {
                    operands = [built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr)];
                }
                else {
                    operands.push(built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr));
                }
            }
        }
        return expr_1.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
            /**
             * By convention, applying the operator to zero operands gives you the identity element
             */
            identityAst :
            (operands.length == 1) ?
                /**
                 * By convention, applying the operator on one operand does not do anything to the operand
                 */
                operands[0] :
                ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
    };
    return result;
}
exports.makeChainableDecimalOperator = makeChainableDecimalOperator;
//# sourceMappingURL=make-chainable-decimal-operator.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-chainable-operator.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-chainable-operator.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "../tsql/dist/ast/literal-value-node/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
function tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst) {
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return ast_1.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
            if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_1.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                /**
                 * Eliminate all identity elements
                 */
                return [];
            }
            else if (ast_1.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                return ast.operands;
            }
            else {
                return undefined;
            }
        });
    }
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr) &&
        built_in_value_expr_1.BuiltInValueExprUtil.isEqual(builtInExpr, identityElement)) {
        /**
         * Eliminate all identity elements
         */
        return [];
    }
    return undefined;
}
function makeChainableOperator(operatorType, identityElement, mapper, typeHint) {
    let identityAst = undefined;
    const result = (...arr) => {
        if (identityAst == undefined) {
            const newIdentityAst = built_in_expr_1.BuiltInExprUtil.buildAst(identityElement);
            if (!literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                throw new Error(`Invalid identity element`);
            }
            identityAst = newIdentityAst;
        }
        let operands = undefined;
        for (const builtInExpr of arr) {
            const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst);
            if (flattenableElements != undefined) {
                /**
                 * Looks like we should flatten this `builtInExpr`
                 */
                if (flattenableElements.length == 0) {
                    continue;
                }
                else {
                    if (operands == undefined) {
                        operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                    }
                    else {
                        operands.push(...flattenableElements);
                    }
                }
            }
            else {
                /**
                 * Can't flatten this `builtInExpr`
                 */
                if (operands == undefined) {
                    operands = [built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr)];
                }
                else {
                    operands.push(built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr));
                }
            }
        }
        return expr_1.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
            /**
             * By convention, applying the operator to zero operands gives you the identity element
             */
            identityAst :
            (operands.length == 1) ?
                /**
                 * By convention, applying the operator on one operand does not do anything to the operand
                 */
                operands[0] :
                ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
    };
    return result;
}
exports.makeChainableOperator = makeChainableOperator;
//# sourceMappingURL=make-chainable-operator.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-comparison-1-to-n.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-comparison-1-to-n.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const make_operator_1_to_n_1 = __webpack_require__(/*! ./make-operator-1-to-n */ "../tsql/dist/expr-library/factory/make-operator-1-to-n.js");
function makeComparison1ToN(operatorType, typeHint) {
    return make_operator_1_to_n_1.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeComparison1ToN = makeComparison1ToN;
//# sourceMappingURL=make-comparison-1-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-comparison-2-to-n.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-comparison-2-to-n.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const make_operator_2_to_n_1 = __webpack_require__(/*! ./make-operator-2-to-n */ "../tsql/dist/expr-library/factory/make-operator-2-to-n.js");
function makeComparison2ToN(operatorType, typeHint) {
    return make_operator_2_to_n_1.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeComparison2ToN = makeComparison2ToN;
//# sourceMappingURL=make-comparison-2-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-comparison-2.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-comparison-2.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeComparison2(operatorType, typeHint) {
    const result = (left, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeComparison2 = makeComparison2;
//# sourceMappingURL=make-comparison-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-comparison-3.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-comparison-3.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making ternary comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeComparison3(operatorType, typeHint) {
    const result = (left, mid, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("MHS", mid);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeComparison3 = makeComparison3;
//# sourceMappingURL=make-comparison-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-comparison-projection-2-to-n.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-comparison-projection-2-to-n.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * @todo Better name?
 *
 * Called `Projection` because it picks one of its arguments as the return value.
 * Similar to picking columns in a query.
 */
function makeComparisonProjection2ToN(operatorType, typeHint) {
    const result = (arg0, arg1, ...args) => {
        const arr = [arg0, arg1, ...args];
        return expr_1.ExprUtil.intersect(tm.unsafeOr(...arr.map(built_in_expr_1.BuiltInExprUtil.mapper)), arr, ast_1.OperatorNodeUtil.operatorNode2ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeComparisonProjection2ToN = makeComparisonProjection2ToN;
//# sourceMappingURL=make-comparison-projection-2-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-equation-1-to-n.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-equation-1-to-n.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const make_operator_1_to_n_1 = __webpack_require__(/*! ./make-operator-1-to-n */ "../tsql/dist/expr-library/factory/make-operator-1-to-n.js");
function makeEquation1ToN(operatorType, typeHint) {
    return make_operator_1_to_n_1.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeEquation1ToN = makeEquation1ToN;
//# sourceMappingURL=make-equation-1-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-equation-2-to-n.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-equation-2-to-n.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const make_operator_2_to_n_1 = __webpack_require__(/*! ./make-operator-2-to-n */ "../tsql/dist/expr-library/factory/make-operator-2-to-n.js");
function makeEquation2ToN(operatorType, typeHint) {
    return make_operator_2_to_n_1.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeEquation2ToN = makeEquation2ToN;
//# sourceMappingURL=make-equation-2-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-equation-2.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-equation-2.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeEquation2(operatorType, typeHint) {
    const result = (left, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeEquation2 = makeEquation2;
//# sourceMappingURL=make-equation-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-null-safe-comparison-1.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-null-safe-comparison-1.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making null-safe unary comparison operators.
 */
function makeNullSafeComparison1(operatorType, typeHint) {
    const result = (builtInExpr) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeComparison1 = makeNullSafeComparison1;
//# sourceMappingURL=make-null-safe-comparison-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-null-safe-comparison-2.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-null-safe-comparison-2.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making null-safe comparison operators.
 *
 * These allow `null` in comparisons.
 */
function makeNullSafeComparison(operatorType, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeComparison = makeNullSafeComparison;
//# sourceMappingURL=make-null-safe-comparison-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-null-safe-equation-1.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-null-safe-equation-1.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making null-safe unary equation operators.
 */
function makeNullSafeEquation1(operatorType, typeHint) {
    const result = (builtInExpr) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeEquation1 = makeNullSafeEquation1;
//# sourceMappingURL=make-null-safe-equation-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-null-safe-equation-2.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-null-safe-equation-2.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Factory for making null-safe equation operators.
 *
 * These allow `null` in equations.
 */
function makeNullSafeEquation2(operatorType, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeEquation2 = makeNullSafeEquation2;
//# sourceMappingURL=make-null-safe-equation-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-0.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-0.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
function makeOperator0(operatorType, mapper, typeHint) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast_1.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
    };
    return result;
}
exports.makeOperator0 = makeOperator0;
//# sourceMappingURL=make-operator-0.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-1-double-elimination.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-1-double-elimination.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const util_1 = __webpack_require__(/*! ../../ast/util */ "../tsql/dist/ast/util/index.js");
/**
 * Makes a double elimination unary operator.
 *
 * A double elimination function `f` has the following property,
 * `f(f(x)) == x`
 */
function makeOperator1DoubleElimination(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], util_1.tryExtractAstOr(built_in_expr_1.BuiltInExprUtil.buildAst(arg), operand => (ast_1.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType ?
            operand.operands[0] :
            undefined), operand => ast_1.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
    };
    return result;
}
exports.makeOperator1DoubleElimination = makeOperator1DoubleElimination;
//# sourceMappingURL=make-operator-1-double-elimination.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-1-idempotent.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-1-idempotent.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
const util_1 = __webpack_require__(/*! ../../ast/util */ "../tsql/dist/ast/util/index.js");
/**
 * Makes an idempotent unary operator.
 *
 * An idempotent function `f` has the following property,
 * `f(f(x)) == f(x)`
 */
function makeOperator1Idempotent(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], util_1.tryExtractAstOr(built_in_expr_1.BuiltInExprUtil.buildAst(arg), operand => ast_1.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType, operand => ast_1.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
    };
    return result;
}
exports.makeOperator1Idempotent = makeOperator1Idempotent;
//# sourceMappingURL=make-operator-1-idempotent.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-1-to-n.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-1-to-n.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeOperator1ToN(operatorType, mapper, typeHint) {
    const result = (arg0, ...args) => {
        return expr_1.ExprUtil.intersect(mapper, [arg0, ...args], ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeOperator1ToN = makeOperator1ToN;
//# sourceMappingURL=make-operator-1-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-1.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-1.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeOperator1 = makeOperator1;
//# sourceMappingURL=make-operator-1.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-2-to-n.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-2-to-n.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeOperator2ToN(operatorType, mapper, typeHint) {
    const result = (arg0, arg1, ...args) => {
        return expr_1.ExprUtil.intersect(mapper, [arg0, arg1, ...args], ast_1.OperatorNodeUtil.operatorNode2ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeOperator2ToN = makeOperator2ToN;
//# sourceMappingURL=make-operator-2-to-n.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-2.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-2.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeOperator2(operatorType, mapper, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(mapper, [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeOperator2 = makeOperator2;
//# sourceMappingURL=make-operator-2.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/factory/make-operator-3.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/factory/make-operator-3.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
function makeOperator3(operatorType, mapper, typeHint) {
    const result = (left, mid, right) => {
        return expr_1.ExprUtil.intersect(mapper, [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeOperator3 = makeOperator3;
//# sourceMappingURL=make-operator-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/expr-library/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "../tsql/dist/expr-library/aggregate/index.js"));
__export(__webpack_require__(/*! ./aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js"));
__export(__webpack_require__(/*! ./assert */ "../tsql/dist/expr-library/assert/index.js"));
__export(__webpack_require__(/*! ./cast */ "../tsql/dist/expr-library/cast/index.js"));
__export(__webpack_require__(/*! ./comparison */ "../tsql/dist/expr-library/comparison/index.js"));
__export(__webpack_require__(/*! ./control-flow */ "../tsql/dist/expr-library/control-flow/index.js"));
__export(__webpack_require__(/*! ./custom-factory */ "../tsql/dist/expr-library/custom-factory/index.js"));
__export(__webpack_require__(/*! ./date-time */ "../tsql/dist/expr-library/date-time/index.js"));
__export(__webpack_require__(/*! ./equation */ "../tsql/dist/expr-library/equation/index.js"));
__export(__webpack_require__(/*! ./factory */ "../tsql/dist/expr-library/factory/index.js"));
__export(__webpack_require__(/*! ./information */ "../tsql/dist/expr-library/information/index.js"));
__export(__webpack_require__(/*! ./logical */ "../tsql/dist/expr-library/logical/index.js"));
__export(__webpack_require__(/*! ./logical-3 */ "../tsql/dist/expr-library/logical-3/index.js"));
__export(__webpack_require__(/*! ./null-safe-equation */ "../tsql/dist/expr-library/null-safe-equation/index.js"));
__export(__webpack_require__(/*! ./string */ "../tsql/dist/expr-library/string/index.js"));
__export(__webpack_require__(/*! ./subquery */ "../tsql/dist/expr-library/subquery/index.js"));
const decimal = __webpack_require__(/*! ./decimal */ "../tsql/dist/expr-library/decimal/index.js");
exports.decimal = decimal;
const double = __webpack_require__(/*! ./double */ "../tsql/dist/expr-library/double/index.js");
exports.double = double;
const integer = __webpack_require__(/*! ./integer */ "../tsql/dist/expr-library/integer/index.js");
exports.integer = integer;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/information/current-schema.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/information/current-schema.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * Returns the default (current) schema name as a string.
 * If there is no default schema, returns `NULL`.
 *
 * -----
 *
 * MySQL does not make a distinction between "database" and "schema".
 * PostgreSQL does.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
 * + https://www.postgresql.org/docs/9.2/functions-info.html
 * + https://www.sqlite.org/lang_attach.html
 *
 * -----
 *
 * + MySQL      : `DATABASE()`
 * + PostgreSQL : `CURRENT_SCHEMA`
 * + SQLite     : `'main'` should always be the current database.
 *   + There's also `'temp'`, I guess
 */
exports.currentSchema = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_SCHEMA, tm.orNull(tm.string()));
//# sourceMappingURL=current-schema.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/information/current-user.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/information/current-user.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * On MySQL,
 * > Returns the user name and host name combination for the MySQL account
 * > that the server used to authenticate the current client.
 * > This account determines your access privileges.
 *
 * -----
 *
 * On PostgreSQL,
 * > the user identifier that is applicable for permission checking.
 * > The SQL standard draws a distinction between current_role and current_user,
 * > but PostgreSQL does not, since it unifies users and roles into a single kind of entity.
 *
 * -----
 *
 * SQLite does not have the concept of users.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
 * + https://www.postgresql.org/docs/9.2/functions-info.html
 * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
 *
 * -----
 *
 * + MySQL      : `CURRENT_USER`
 *   + MySQL has a `USER()` function that does something different.
 * + PostgreSQL : `CURRENT_USER`
 * + SQLite     : None. It does not make sense to ask what the current user is.
 */
exports.currentUser = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_USER, tm.orNull(tm.string()));
//# sourceMappingURL=current-user.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/information/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/information/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./current-schema */ "../tsql/dist/expr-library/information/current-schema.js"));
__export(__webpack_require__(/*! ./current-user */ "../tsql/dist/expr-library/information/current-user.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/abs.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/integer/abs.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 *
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT ABS(-9223372036854775808)
 * ```
 * The above throws an error on MySQL, PostgreSQL and SQLite.
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/add.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/integer/add.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807+9223372036854775807;
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT -9223372036854775808+-9223372036854775808
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615+18446744073709551615
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is adding two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is adding two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 + -9223372036854775808 + -9223372036854775808
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL` and the result is correctly `-1`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE` and the result is **incorrectly** `0`.
 *
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintAdd()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.add = factory_1.makeChainableOperator(operator_type_1.OperatorType.ADDITION, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/avg.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/avg.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../../decimal/decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
/**
 * The return type being `DECIMAL` is intentional.
 */
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(DISTINCT x)`
 * + PostgreSQL : `AVG(DISTINCT x)`
 * + SQLite     : `AVG(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "../tsql/dist/expr-library/integer/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "../tsql/dist/expr-library/integer/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "../tsql/dist/expr-library/integer/aggregate/min.js"));
__export(__webpack_require__(/*! ./sum-as-bigint */ "../tsql/dist/expr-library/integer/aggregate/sum-as-bigint.js"));
__export(__webpack_require__(/*! ./sum-as-decimal */ "../tsql/dist/expr-library/integer/aggregate/sum-as-decimal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/max.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/max.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/min.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/min.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/sum-as-bigint.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/sum-as-bigint.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const sumAsBigIntSignedImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(DISTINCT x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(DISTINCT x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(DISTINCT x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSignedDistinct = (arg) => {
    return sumAsBigIntSignedImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSignedAll = (arg) => {
    return sumAsBigIntSignedImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSigned = exports.sumAsBigIntSignedAll;
//# sourceMappingURL=sum-as-bigint.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/aggregate/sum-as-decimal.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/aggregate/sum-as-decimal.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../../decimal/decimal-mapper */ "../tsql/dist/expr-library/decimal/decimal-mapper.js");
/**
 * The return type being `DECIMAL` is intentional.
 */
const sumAsDecimalImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM_AS_DECIMAL, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(DISTINCT x)`
 * + PostgreSQL : `SUM(DISTINCT CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(DISTINCT CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimalDistinct = (arg) => {
    return sumAsDecimalImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimalAll = (arg) => {
    return sumAsDecimalImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimal = exports.sumAsDecimalAll;
//# sourceMappingURL=sum-as-decimal.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-and.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-and.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
exports.bitwiseAnd = factory_1.makeChainableOperator(operator_type_1.OperatorType.BITWISE_AND, tm.BigInt(-1), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-and.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-left-shift.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-left-shift.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
/**
 * Performs a **signed** bitwise left-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x << y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `<<`
 * + SQLite       : `<<`
 *
 * -----
 *
 * If the RHS is negative, the behaviour is cannot be unified.
 *
 * + MySQL      : `2 << -1` is `0`
 * + PostgreSQL : `2 << -1` is `0`
 * + SQLite     : `2 << -1` is `1`
 * + JavaScript : `2 << -1` is `0`
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; undefined behaviour if negative
 *
 * @see bitwiseLeftShift
 */
exports.bitwiseLeftShiftUnsafe = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_LEFT_SHIFT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Performs a **signed** bitwise left-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x << y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `<<`
 * + SQLite       : `<<`
 *
 * -----
 *
 * If the RHS is negative, this throws.
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; throws if negative
 *
 * @see bitwiseLeftShiftUnsafe
 */
function bitwiseLeftShift(left, right) {
    tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
    return expr_1.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.BITWISE_LEFT_SHIFT, [
        built_in_expr_1.BuiltInExprUtil.buildAst(left),
        built_in_expr_1.BuiltInExprUtil.buildAst(right),
    ], type_hint_1.TypeHint.BIGINT_SIGNED));
}
exports.bitwiseLeftShift = bitwiseLeftShift;
//# sourceMappingURL=bitwise-left-shift.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-not.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-not.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `~(~(x)) == x`
 */
exports.bitwiseNot = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.BITWISE_NOT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-not.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-or.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-or.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
exports.bitwiseOr = factory_1.makeChainableOperator(operator_type_1.OperatorType.BITWISE_OR, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-or.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-right-shift.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-right-shift.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
/**
 * Performs a **signed** bitwise right-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x >> y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `>>`
 * + SQLite       : `>>`
 *
 * -----
 *
 * If the RHS is negative, the behaviour is cannot be unified.
 *
 * + MySQL      : `2 >> -1` is `0`
 * + PostgreSQL : `2 >> -1` is `0`
 * + SQLite     : `2 >> -1` is `4`
 * + JavaScript : `2 >> -1` is `0`
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; undefined behaviour if negative
 *
 * @see bitwiseRightShift
 */
exports.bitwiseRightShiftUnsafe = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_RIGHT_SHIFT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Performs a **signed** bitwise right-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x >> y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `>>`
 * + SQLite       : `>>`
 *
 * -----
 *
 * If the RHS is negative, this throws.
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; throws if negative
 *
 * @see bitwiseRightShiftUnsafe
 */
function bitwiseRightShift(left, right) {
    tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
    return expr_1.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.BITWISE_RIGHT_SHIFT, [
        built_in_expr_1.BuiltInExprUtil.buildAst(left),
        built_in_expr_1.BuiltInExprUtil.buildAst(right),
    ], type_hint_1.TypeHint.BIGINT_SIGNED));
}
exports.bitwiseRightShift = bitwiseRightShift;
//# sourceMappingURL=bitwise-right-shift.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/bitwise-xor.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/bitwise-xor.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
exports.bitwiseXor = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_XOR, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-xor.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/bitwise/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/integer/bitwise/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bitwise-and */ "../tsql/dist/expr-library/integer/bitwise/bitwise-and.js"));
__export(__webpack_require__(/*! ./bitwise-left-shift */ "../tsql/dist/expr-library/integer/bitwise/bitwise-left-shift.js"));
__export(__webpack_require__(/*! ./bitwise-not */ "../tsql/dist/expr-library/integer/bitwise/bitwise-not.js"));
__export(__webpack_require__(/*! ./bitwise-or */ "../tsql/dist/expr-library/integer/bitwise/bitwise-or.js"));
__export(__webpack_require__(/*! ./bitwise-right-shift */ "../tsql/dist/expr-library/integer/bitwise/bitwise-right-shift.js"));
__export(__webpack_require__(/*! ./bitwise-xor */ "../tsql/dist/expr-library/integer/bitwise/bitwise-xor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/integer/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "../tsql/dist/expr-library/integer/aggregate/index.js"));
__export(__webpack_require__(/*! ./bitwise */ "../tsql/dist/expr-library/integer/bitwise/index.js"));
__export(__webpack_require__(/*! ./abs */ "../tsql/dist/expr-library/integer/abs.js"));
__export(__webpack_require__(/*! ./add */ "../tsql/dist/expr-library/integer/add.js"));
__export(__webpack_require__(/*! ./integer-div */ "../tsql/dist/expr-library/integer/integer-div.js"));
__export(__webpack_require__(/*! ./integer-remainder */ "../tsql/dist/expr-library/integer/integer-remainder.js"));
__export(__webpack_require__(/*! ./mul */ "../tsql/dist/expr-library/integer/mul.js"));
__export(__webpack_require__(/*! ./neg */ "../tsql/dist/expr-library/integer/neg.js"));
__export(__webpack_require__(/*! ./random-bigint-signed */ "../tsql/dist/expr-library/integer/random-bigint-signed.js"));
__export(__webpack_require__(/*! ./sign */ "../tsql/dist/expr-library/integer/sign.js"));
__export(__webpack_require__(/*! ./sub */ "../tsql/dist/expr-library/integer/sub.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/integer-div.js":
/*!********************************************************!*\
  !*** ../tsql/dist/expr-library/integer/integer-div.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * Treats both arguments as integers and performs integer division
 *
 * -----
 *
 * ### Divide by zero
 *
 * ```sql
 *  SELECT 9223372036854775807 DIV 0; -- MySQL
 *  SELECT 9223372036854775807 / 0; -- PostgreSQL, SQLite
 * ```
 * The above gives `NULL` for MySQL and SQLite.
 * The above throws an error for PostgreSQL.
 */
exports.integerDiv = factory_1.makeOperator2(operator_type_1.OperatorType.INTEGER_DIVISION, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=integer-div.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/integer-remainder.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/integer-remainder.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * The remainder after performing integer division.
 *
 * Integer division is defined as,
 * `dividend / divisor`
 *
 * ```ts
 * result = sign(dividend) * abs(remainder)
 * ```
 *
 * If the dividend is positive, the result is positive.
 * If the dividend is negative, the result is negative.
 *
 * ```ts
 * integerRemainder( 5,  3); //2
 * integerRemainder( 5, -3); //2
 * integerRemainder(-5,  3); //-2
 * integerRemainder(-5, -3); //-2
 * ```
 *
 * -----
 *
 * ### Divide by zero
 *
 * ```sql
 *  SELECT 9223372036854775807 % 0
 * ```
 * The above gives `NULL` for MySQL and SQLite.
 * The above throws an error for PostgreSQL.
 */
exports.integerRemainder = factory_1.makeOperator2(operator_type_1.OperatorType.INTEGER_REMAINDER, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=integer-remainder.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/mul.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/integer/mul.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807*9223372036854775807;
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT 9223372036854775807*-9223372036854775808
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615*18446744073709551615
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is multiplying two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is multiplying two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 * -9223372036854775808
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
 *
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintMul()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.mul = factory_1.makeChainableOperator(operator_type_1.OperatorType.MULTIPLICATION, tm.BigInt(1), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/neg.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/integer/neg.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 *
 * -----
 *
 * ### `BIGINT SIGNED` too large (from database)
 *
 * Be careful, however,
 * ```sql
 *  CREATE TABLE a (id BIGINT);
 *  INSERT INTO a (id) VALUES (-9223372036854775808);
 *
 *  SELECT
 *      -- 9223372036854775808 is too big
 *      -- to fit in signed bigint
 *      -id
 *  FROM
 *      a
 * ```
 *
 * The above will throw an error on both MySQL and PostgreSQL
 * because `9223372036854775808` is not a valid signed bigint value.
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * ### Double Unary Minus Elimination on Negative `BIGINT SIGNED` Literal
 *
 * The following will not throw an error but will silently
 * cast the result,
 * ```sql
 *  SELECT -(-9223372036854775808);
 * ```
 * Both **do not** error in MySQL and PostgreSQL.
 * PostgreSQL seems to perform double unary minus elimination and treats the result as a `DECIMAL` literal.
 * MySQL seems to perform double unary minus elimination and treats the result as an `BIGINT UNSIGNED` literal.
 *
 * SQLite casts to `DOUBLE`
 *
 * -----
 *
 * ```sql
 *  SELECT -(
 *      CAST(-9223372036854775808 AS BIGINT)
 *  ); -- PostgreSQL
 *
 *  SELECT -(-9223372036854775808 + 0); -- PostgreSQL
 *
 *  SELECT -(
 *      CAST(-9223372036854775808 AS BIGINT SIGNED)
 *  ); -- MySQL
 * ```
 * The above throws an error on PostgreSQL.
 * The above silently casts to an `BIGINT UNSIGNED` on MySQL.
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * ```sql
 *  SELECT
 *      CAST(-(-9223372036854775808) AS BIGINT); -- PostgreSQL
 *
 *  SELECT
 *      CAST(-(-9223372036854775808) AS BIGINT SIGNED); -- MySQL
 * ```
 * The above throws an error on PostgreSQL.
 * The above silently casts to an `BIGINT UNSIGNED`
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * MySQL seems to treat `BIGINT SIGNED` values from **columns** and **literals** differently!
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small.
 *
 * MySQL-specific,
 * ```sql
 *  CREATE TABLE a (id  BIGINT UNSIGNED);
 *  INSERT INTO a (id) VALUES (9223372036854775809);
 *  SELECT -id FROM a;
 * ```
 *
 * `-9223372036854775809` is too small to fit in `BIGINT SIGNED`. This will throw an error.
 *
 * -----
 *
 * ```sql
 *  SELECT -CAST(9223372036854775809 AS UNSIGNED);
 * ```
 * The above gives you a `DECIMAL` type with value `-9223372036854775809` in MySQL.
 * PostgreSQL and SQLite do not have `BIGINT UNSIGNED`.
 *
 * -----
 *
 * MySQL and PostgreSQL query builders should perform the unary minus on the library
 * level as much as possible. However, it is not always feasible...
 *
 * PostgreSQL should perform bigint unary minus with `-CAST(x AS BIGINT)` to avoid implicit conversions.
 *
 * MySQL should just use `CAST(-x AS SIGNED)`.
 *
 * However, on MySQL,
 * `CAST(-18446744073709551615 AS SIGNED)` === `-9223372036854775808` (signed bigint minimum value)
 *
 * It would be nice if it threw an error instead.
 * It throws an error on PostgreSQL.
 *
 * SQLite should have a special `bigintNeg()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/random-bigint-signed.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-library/integer/random-bigint-signed.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns a random `BIGINT SIGNED` in the range,
 * [-9223372036854775808, 9223372036854775807]
 *
 * -----
 *
 * MySQL,
 * ```sql
 *  CAST(
 *      CAST(RAND() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
 *      AS SIGNED
 *  )
 * ```
 *
 * PostgreSQL,
 * ```sql
 *  CAST(
 *      CAST(RANDOM() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
 *      AS BIGINT
 *  )
 * ```
 *
 * SQLite,
 * ```sql
 *  RANDOM()
 * ```
 */
exports.randomBigIntSigned = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=random-bigint-signed.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/sign.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/integer/sign.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
 *
 * Will return -1, 0, 1
 */
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/integer/sub.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/integer/sub.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807- (-9223372036854775808);
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT -9223372036854775808 - 9223372036854775807
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615 - (-9223372036854775808)
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is subtracting two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is subtracting two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 - 9223372036854775807 - 9223372036854775807 - 9223372036854775807
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintSub()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/and-3.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/and-3.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
 *
 * This version of the `AND` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link and}
 */
exports.and3 = factory_1.makeChainableOperator(operator_type_1.OperatorType.AND, true, tm.mysql.boolean().orNull());
//# sourceMappingURL=and-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./and-3 */ "../tsql/dist/expr-library/logical-3/and-3.js"));
__export(__webpack_require__(/*! ./is-false */ "../tsql/dist/expr-library/logical-3/is-false.js"));
__export(__webpack_require__(/*! ./is-not-false */ "../tsql/dist/expr-library/logical-3/is-not-false.js"));
__export(__webpack_require__(/*! ./is-not-true */ "../tsql/dist/expr-library/logical-3/is-not-true.js"));
__export(__webpack_require__(/*! ./is-not-unknown */ "../tsql/dist/expr-library/logical-3/is-not-unknown.js"));
__export(__webpack_require__(/*! ./is-true */ "../tsql/dist/expr-library/logical-3/is-true.js"));
__export(__webpack_require__(/*! ./is-unknown */ "../tsql/dist/expr-library/logical-3/is-unknown.js"));
__export(__webpack_require__(/*! ./not-3 */ "../tsql/dist/expr-library/logical-3/not-3.js"));
__export(__webpack_require__(/*! ./or-3 */ "../tsql/dist/expr-library/logical-3/or-3.js"));
__export(__webpack_require__(/*! ./xor-3 */ "../tsql/dist/expr-library/logical-3/xor-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-false.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-false.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `FALSE`.
 *
 * ```sql
 * mysql> SELECT (1 IS FALSE), (0 IS FALSE), (NULL IS FALSE);
 *         -> 0, 1, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS FALSE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isFalse = factory_1.makeOperator1(operator_type_1.OperatorType.IS_FALSE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-false.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-not-false.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-not-false.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `FALSE`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT FALSE), (0 IS NOT FALSE), (NULL IS NOT FALSE);
 *         -> 1, 0, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS NOT FALSE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotFalse = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_FALSE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-false.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-not-true.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-not-true.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `TRUE`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT TRUE), (0 IS NOT TRUE), (NULL IS NOT TRUE);
 *         -> 0, 1, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(1 IS NOT TRUE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotTrue = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_TRUE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-true.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-not-unknown.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-not-unknown.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `UNKNOWN`.
 * Basically an alias for `IS NOT NULL`
 *
 * ```sql
 * mysql> SELECT (1 IS NOT UNKNOWN), (0 IS NOT UNKNOWN), (NULL IS NOT UNKNOWN);
 *         -> 1, 1, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS NOT UNKNOWN)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotUnknown = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_UNKNOWN, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-unknown.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-true.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-true.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `TRUE`.
 *
 * ```sql
 * mysql> SELECT (1 IS TRUE), (0 IS TRUE), (NULL IS TRUE);
 *         -> 1, 0, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(1 IS TRUE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isTrue = factory_1.makeOperator1(operator_type_1.OperatorType.IS_TRUE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-true.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/is-unknown.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/is-unknown.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `UNKNOWN`.
 * Basically an alias for `IS NULL`
 *
 * ```sql
 * mysql> SELECT (1 IS UNKNOWN), (0 IS UNKNOWN), (NULL IS UNKNOWN);
 *         -> 0, 0, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS UNKNOWN)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isUnknown = factory_1.makeOperator1(operator_type_1.OperatorType.IS_UNKNOWN, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-unknown.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/not-3.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/not-3.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
 *
 * This version of the `NOT` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link not}
 */
exports.not3 = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.NOT, tm.mysql.boolean().orNull());
//# sourceMappingURL=not-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/or-3.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/or-3.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
 *
 * This version of the `OR` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link or}
 */
exports.or3 = factory_1.makeChainableOperator(operator_type_1.OperatorType.OR, false, tm.mysql.boolean().orNull());
//# sourceMappingURL=or-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical-3/xor-3.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/logical-3/xor-3.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
 *
 * This version of the `XOR` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link xor}
 */
exports.xor3 = factory_1.makeOperator2(operator_type_1.OperatorType.XOR, tm.mysql.boolean().orNull());
//# sourceMappingURL=xor-3.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/and.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/logical/and.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
 *
 * This version of the `AND` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link and3}
 */
exports.and = factory_1.makeChainableOperator(operator_type_1.OperatorType.AND, true, tm.mysql.boolean());
//# sourceMappingURL=and.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/logical/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./and */ "../tsql/dist/expr-library/logical/and.js"));
__export(__webpack_require__(/*! ./is-not-null-and */ "../tsql/dist/expr-library/logical/is-not-null-and.js"));
__export(__webpack_require__(/*! ./is-null-or */ "../tsql/dist/expr-library/logical/is-null-or.js"));
__export(__webpack_require__(/*! ./not */ "../tsql/dist/expr-library/logical/not.js"));
__export(__webpack_require__(/*! ./or */ "../tsql/dist/expr-library/logical/or.js"));
__export(__webpack_require__(/*! ./xor */ "../tsql/dist/expr-library/logical/xor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/is-not-null-and.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/logical/is-not-null-and.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "../tsql/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "../tsql/dist/expr-library/null-safe-equation/index.js");
const and_1 = __webpack_require__(/*! ./and */ "../tsql/dist/expr-library/logical/and.js");
function isNotNullAnd(column, builtInExprDelegate) {
    return and_1.and(null_safe_equation_1.isNotNull(column), builtInExprDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.isNotNullAnd = isNotNullAnd;
//# sourceMappingURL=is-not-null-and.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/is-null-or.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/logical/is-null-or.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "../tsql/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "../tsql/dist/expr-library/null-safe-equation/index.js");
const or_1 = __webpack_require__(/*! ./or */ "../tsql/dist/expr-library/logical/or.js");
function isNullOr(column, builtInExprDelegate) {
    return or_1.or(null_safe_equation_1.isNull(column), builtInExprDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.isNullOr = isNullOr;
//# sourceMappingURL=is-null-or.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/not.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/logical/not.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
 *
 * This version of the `NOT` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link not3}
 */
exports.not = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.NOT, tm.mysql.boolean());
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/or.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/logical/or.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
 *
 * This version of the `OR` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link or3}
 */
exports.or = factory_1.makeChainableOperator(operator_type_1.OperatorType.OR, false, tm.mysql.boolean());
//# sourceMappingURL=or.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/logical/xor.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/logical/xor.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
 *
 * This version of the `XOR` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link xor3}
 */
exports.xor = factory_1.makeOperator2(operator_type_1.OperatorType.XOR, tm.mysql.boolean());
//# sourceMappingURL=xor.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js":
/*!****************************************************************************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns) {
    const candidateKeys = table_1.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
    const srcColumnAliases = srcColumns.map(column => column.columnAlias);
    const dstCandidateKey = candidateKeys.find(candidateKey => key_1.KeyUtil.isEqual(candidateKey, srcColumnAliases));
    if (dstCandidateKey == undefined) {
        throw new Error(`${column_map_1.ColumnMapUtil.tableAlias(src.columns)} (${srcColumnAliases.join(",")}) cannot be used to compare with candidate keys of ${column_map_1.ColumnMapUtil.tableAlias(dst.columns)}`);
    }
    column_map_1.ColumnMapUtil.assertIsNullSafeComparable(column_map_1.ColumnMapUtil.fromColumnArray(srcColumns), type_util_1.pickOwnEnumerable(dst.columns, dstCandidateKey));
    return dstCandidateKey;
}
exports.assertNullSafeComparableToCandidateKeysOfTable = assertNullSafeComparableToCandidateKeysOfTable;
//# sourceMappingURL=assert-null-safe-comparable-to-candidate-keys-of-table.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js":
/*!***********************************************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const logical_1 = __webpack_require__(/*! ../../logical */ "../tsql/dist/expr-library/logical/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const assert_null_safe_comparable_to_candidate_keys_of_table_1 = __webpack_require__(/*! ./assert-null-safe-comparable-to-candidate-keys-of-table */ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js");
const null_safe_eq_1 = __webpack_require__(/*! ../null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js");
exports.eqCandidateKeyOfTable = ((src, dst, eqCandidateKeyOfTableDelegate) => {
    const candidateKeys = table_1.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
    const columnAliases = [];
    for (const key of candidateKeys) {
        columnAliases.push(...key);
    }
    const columns = type_util_1.pickOwnEnumerable(src.columns, columnAliases);
    const srcColumns = eqCandidateKeyOfTableDelegate(columns);
    const dstCandidateKey = assert_null_safe_comparable_to_candidate_keys_of_table_1.assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns);
    /**
     * No need to `.sort()`, just use `candidateKey` and the order
     * the user set.
     */
    const arr = dstCandidateKey.map((columnAlias) => {
        /**
         * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
         */
        const expr = null_safe_eq_1.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-candidate-key-of-table.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-null-safe-comparable-to-candidate-keys-of-table */ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js"));
__export(__webpack_require__(/*! ./eq-candidate-key-of-table */ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-candidate-key.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "../tsql/dist/expr-library/logical/index.js");
const candidate_key_1 = __webpack_require__(/*! ../../candidate-key */ "../tsql/dist/candidate-key/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "../tsql/dist/column-map/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
exports.eqCandidateKey = ((table, candidateKeyInput) => {
    const candidateKey = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.candidateKey`, candidateKeyInput);
    /**
     * We `.sort()` the keys so our resulting SQL is deterministic,
     * regardless of how `candidateKey` was constructed.
     */
    const arr = Object.keys(candidateKey).sort().map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], candidateKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-columns.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-columns.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "../tsql/dist/expr-library/logical/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "../tsql/dist/column-map/index.js");
const partial_row_1 = __webpack_require__(/*! ../../partial-row */ "../tsql/dist/partial-row/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
exports.eqColumns = ((table, columnsInput) => {
    const columns = partial_row_1.PartialRowUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.columns`, columnsInput);
    const arr = Object.keys(columns)
        .filter((columnAlias) => {
        return columns[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `columns` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], columns[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-columns.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../table */ "../tsql/dist/table/index.js");
const logical_1 = __webpack_require__(/*! ../logical */ "../tsql/dist/expr-library/logical/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js");
exports.eqPrimaryKeyOfTable = ((src, dst) => {
    table_1.TableUtil.assertHasNullSafeComparablePrimaryKey(dst, src.columns);
    /**
     * No need to `.sort()`, just use `primaryKey` and the order
     * the user set.
     */
    const arr = dst.primaryKey.map((columnAlias) => {
        /**
         * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
         */
        const expr = null_safe_eq_1.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-primary-key-of-table.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/eq-super-key.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/eq-super-key.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "../tsql/dist/expr-library/logical/index.js");
const super_key_1 = __webpack_require__(/*! ../../super-key */ "../tsql/dist/super-key/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "../tsql/dist/column-map/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
exports.eqSuperKey = ((table, superKeyInput) => {
    const superKey = super_key_1.SuperKeyUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.superKey`, superKeyInput);
    const arr = Object.keys(superKey)
        .filter((columnAlias) => {
        return superKey[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `superKey` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-super-key.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./eq-candidate-key-of-table */ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js"));
__export(__webpack_require__(/*! ./eq-candidate-key */ "../tsql/dist/expr-library/null-safe-equation/eq-candidate-key.js"));
__export(__webpack_require__(/*! ./eq-columns */ "../tsql/dist/expr-library/null-safe-equation/eq-columns.js"));
__export(__webpack_require__(/*! ./eq-primary-key-of-table */ "../tsql/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js"));
__export(__webpack_require__(/*! ./eq-super-key */ "../tsql/dist/expr-library/null-safe-equation/eq-super-key.js"));
__export(__webpack_require__(/*! ./is-not-null */ "../tsql/dist/expr-library/null-safe-equation/is-not-null.js"));
__export(__webpack_require__(/*! ./is-null */ "../tsql/dist/expr-library/null-safe-equation/is-null.js"));
__export(__webpack_require__(/*! ./not-null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/not-null-safe-eq.js"));
__export(__webpack_require__(/*! ./null-safe-eq */ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/is-not-null.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/is-not-null.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
 *
 * Tests whether a value is not `NULL`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT NULL), (0 IS NOT NULL), (NULL IS NOT NULL);
 *         -> 1, 1, 0
 * ```
 */
exports.isNotNull = factory_1.makeNullSafeEquation1(operator_type_1.OperatorType.IS_NOT_NULL);
//# sourceMappingURL=is-not-null.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/is-null.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/is-null.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null
 *
 * Tests whether a value is NULL.
 *
 * ```sql
 * mysql> SELECT (1 IS NULL), (0 IS NULL), (NULL IS NULL);
 *         -> 0, 0, 1
 * ```
 */
exports.isNull = factory_1.makeNullSafeEquation1(operator_type_1.OperatorType.IS_NULL);
//# sourceMappingURL=is-null.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/not-null-safe-eq.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/not-null-safe-eq.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
 *
 * This operator allows `NULL`.
 *
 * This operator performs an equality comparison like the `=` operator,
 * but returns
 * + `false` rather than `NULL` if both operands are `NULL`, and
 * + `true` rather than `NULL` if one operand is `NULL`.
 *
 * For regular equality, @see {@link eq}
 */
exports.notNullSafeEq = factory_1.makeNullSafeEquation2(operator_type_1.OperatorType.NOT_NULL_SAFE_EQUAL);
//# sourceMappingURL=not-null-safe-eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/expr-library/null-safe-equation/null-safe-eq.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
 *
 * This operator allows `NULL`.
 *
 * This operator performs an equality comparison like the `=` operator,
 * but returns
 * + `true` rather than `NULL` if both operands are `NULL`, and
 * + `false` rather than `NULL` if one operand is `NULL`.
 *
 * For regular equality, @see {@link eq}
 */
exports.nullSafeEq = factory_1.makeNullSafeEquation2(operator_type_1.OperatorType.NULL_SAFE_EQUAL);
//# sourceMappingURL=null-safe-eq.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/aggregate/group-concat.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/expr-library/string/aggregate/group-concat.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "../tsql/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "../tsql/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns a string result with the concatenated non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
 *
 * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
 * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
 * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
 *   + The order of the concatenated elements is arbitrary.
 *   + Uses comma as separator
 *
 * -----
 *
 * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
 * for the DB-unified implementation.
 *
 * Unless we modify the SQLite implementation with a user-defined function?
 *
 * -----
 *
 * @param arg - The expression to aggregate
 *
 * @todo Investigate replacing SQLite `GROUP_CONCAT()` with user-defined function
 */
exports.groupConcatDistinct = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string result with the concatenated non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
 *
 * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
 * + PostgreSQL : `STRING_AGG(expr, separator)`
 * + SQLite     : `GROUP_CONCAT(expr, separator)`
 *   + The order of the concatenated elements is arbitrary.
 *
 * @param left  - The expression to aggregate
 * @param right - The separator between expressions
 */
exports.groupConcatAll = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_GROUP_CONCAT_ALL, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=group-concat.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/aggregate/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/expr-library/string/aggregate/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./group-concat */ "../tsql/dist/expr-library/string/aggregate/group-concat.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/ascii.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/ascii.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the numeric value of the leftmost character of the string.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `ASCII(x)`
 * + PostgreSQL     : `ASCII(x)`
 * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  ASCII(CHAR(128 USING latin1))
 *  > 128
 *
 *  ASCII(CHAR(128 USING utf32))
 *  > 0
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/2
 */
exports.ascii = factory_1.makeOperator1(operator_type_1.OperatorType.ASCII, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=ascii.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/bin.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/string/bin.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns a binary string representation of a `bigint` value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
 *
 * -----
 *
 * + MySQL          : `BIN(x)`
 * + PostgreSQL     : None. Implement with,
 * ```sql
 *  REGEXP_REPLACE(
 *      (x)::bit(64)::varchar(64),
 *      '^0+(\d+)$',
 *      '\1'
 *  )
 * ```
 * + SQLite         : None. Implement with,
 * ```ts
 * //x >= 0
 * (x).toString(2)
 * //x < 0
 * (2n**64n + BigInt(x)).toString(2)
 * ```
 */
exports.bin = factory_1.makeOperator1(operator_type_1.OperatorType.BIN, tm.match(/^[01]+$/), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bin.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/bit-length.js":
/*!******************************************************!*\
  !*** ../tsql/dist/expr-library/string/bit-length.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the length of the string in bits.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `BIT_LENGTH(x)`
 * + PostgreSQL     : `BIT_LENGTH(x)`
 * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  BIT_LENGTH(CHAR(128 USING latin1))
 *  > 8
 *
 *  BIT_LENGTH(CHAR(128 USING utf32))
 *  > 32
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/3
 */
exports.bitLength = factory_1.makeOperator1(operator_type_1.OperatorType.BIT_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=bit-length.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/char-length.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/string/char-length.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the length of the string, measured in characters.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#length
 * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
 *
 * -----
 *
 * + MySQL          : `CHAR_LENGTH(x)`
 *   + `CHAR_LENGTH('cafȩ́')` returns 6
 * + PostgreSQL     : `CHAR_LENGTH(x)`
 *   + `CHAR_LENGTH('cafȩ́')` returns 8
 * + SQLite         : `LENGTH(x)`
 *   + `LENGTH('cafȩ́')` returns 6
 *
 * -----
 *
 * Surrogate pairs may cause results to differ across databases.
 */
exports.charLength = factory_1.makeOperator1(operator_type_1.OperatorType.CHAR_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=char-length.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/concat-ws.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/string/concat-ws.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Concatenate With Separator.
 * The first argument is the separator for the rest of the arguments.
 * The separator is added between the strings to be concatenated.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `CONCAT_WS(separator, x, ...)`
 *   + If the separator is `NULL`, the result is `NULL`
 *   + Ignores `NULL` arguments after the separator
 * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
 *   + If the separator is `NULL`, the result is `NULL`
 *   + Ignores `NULL` arguments after the separator
 * + SQLite         : None. Implement with user-defined function.
 */
exports.concatWs = factory_1.makeOperator2ToN(operator_type_1.OperatorType.CONCAT_WS, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=concat-ws.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/concat.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/string/concat.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string that results from concatenating the arguments.
 * May have one or more arguments.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
 *   + MySQL actually treats `||` as the boolean `OR` operator.
 * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
 *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
 *     + This is different from MySQL's `CONCAT()`
 * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
 *   + SQLite uses an operator, not a function, to concatenate strings
 *   + https://www.sqlite.org/lang_expr.html#collateop
 *
 * -----
 *
 * The SQL standard says,
 * > `<concatenation operator>` is an operator, `||`,
 * > that returns the character string made by joining its character string operands in the order given.
 *
 * MySQL actually treats `||` as the boolean `OR` operator.
 *
 * -----
 *
 * @see nullSafeConcat
 */
exports.concat = factory_1.makeOperator1ToN(operator_type_1.OperatorType.CONCAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/escape-like-pattern.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr-library/string/escape-like-pattern.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const like_1 = __webpack_require__(/*! ./like */ "../tsql/dist/expr-library/string/like.js");
//TODO-FEATURE Create a version using MySQL/PostgreSQL/SQLite queries
//REGEXP_REPLACE(pattern, '(\\%|\\_)', '\\$1', 1, 0, 'm') or something
/**
 * With `LIKE` you can use the following two wildcard characters in the pattern:
 *
 * + `%` matches any number of characters, even zero characters.
 * + `_` matches exactly one character.
 *
 * This function just prepends `escapeChar` to each of the above characters.
 * It also prepends `escapeChar` to itself.
 */
function escapeLikePattern(pattern, escapeChar) {
    like_1.assertValidLikeEscapeChar(escapeChar);
    /**
     * Escape occurrences of the `escapeChar`
     */
    pattern = pattern.split(escapeChar).join(escapeChar + escapeChar);
    /**
     * Escape wildcard characters
     */
    return pattern.replace(/(\%|\_)/g, s => escapeChar + s);
}
exports.escapeLikePattern = escapeLikePattern;
//# sourceMappingURL=escape-like-pattern.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/from-base64.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/expr-library/string/from-base64.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Takes a base-64 encoded string,
 * and returns the decoded result as a `BLOB/bytea`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `FROM_BASE64(x)`
 *   + `FROM_BASE64('~')` === `NULL`
 * + PostgreSQL     : `DECODE(x, 'base64')`
 *   + `DECODE('~', 'base64')` throws an error
 * + SQLite         : None, implement with user-defined function `atob()`
 *   + `atob('~')` throws an error
 *
 * -----
 *
 * If the input is not a valid base-64 string, some databases throw an error.
 * Others return `NULL`.
 */
exports.fromBase64 = factory_1.makeOperator1(operator_type_1.OperatorType.FROM_BASE64, tm.orNull(tm.instanceOfUint8Array()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=from-base64.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/hex.js":
/*!***********************************************!*\
  !*** ../tsql/dist/expr-library/string/hex.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Converts each byte of the input to two hexadecimal digits.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#hex
 *
 * -----
 *
 * + MySQL          : `HEX(x)`
 * + PostgreSQL     : `ENCODE(x, 'hex')`
 * + SQLite         : `HEX(x)`
 */
exports.hex = factory_1.makeOperator1(operator_type_1.OperatorType.HEX, tm.string(), type_hint_1.TypeHint.BUFFER);
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/in-str.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/string/in-str.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the position of the first occurrence of the substring in the target.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
 * + https://www.sqlite.org/lang_corefunc.html#instr
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `INSTR(str, substr)`
 * + PostgreSQL     : `STRPOS(str, substr)`
 * + SQLite         : `INSTR(str, substr)`
 *
 * -----
 *
 * @param left - The target of the search
 * @param right - The substring to look for
 *
 * -----
 *
 * If the substring is not found, it returns `0`.
 * Remember that string indices are one-based; not zero-based.
 *
 * @see position
 */
exports.inStr = factory_1.makeOperator2(operator_type_1.OperatorType.IN_STR, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=in-str.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "../tsql/dist/expr-library/string/aggregate/index.js"));
__export(__webpack_require__(/*! ./ascii */ "../tsql/dist/expr-library/string/ascii.js"));
__export(__webpack_require__(/*! ./bin */ "../tsql/dist/expr-library/string/bin.js"));
__export(__webpack_require__(/*! ./bit-length */ "../tsql/dist/expr-library/string/bit-length.js"));
__export(__webpack_require__(/*! ./char-length */ "../tsql/dist/expr-library/string/char-length.js"));
__export(__webpack_require__(/*! ./concat-ws */ "../tsql/dist/expr-library/string/concat-ws.js"));
__export(__webpack_require__(/*! ./concat */ "../tsql/dist/expr-library/string/concat.js"));
__export(__webpack_require__(/*! ./escape-like-pattern */ "../tsql/dist/expr-library/string/escape-like-pattern.js"));
__export(__webpack_require__(/*! ./from-base64 */ "../tsql/dist/expr-library/string/from-base64.js"));
__export(__webpack_require__(/*! ./hex */ "../tsql/dist/expr-library/string/hex.js"));
__export(__webpack_require__(/*! ./in-str */ "../tsql/dist/expr-library/string/in-str.js"));
__export(__webpack_require__(/*! ./l-pad */ "../tsql/dist/expr-library/string/l-pad.js"));
__export(__webpack_require__(/*! ./l-trim */ "../tsql/dist/expr-library/string/l-trim.js"));
__export(__webpack_require__(/*! ./like */ "../tsql/dist/expr-library/string/like.js"));
__export(__webpack_require__(/*! ./lower */ "../tsql/dist/expr-library/string/lower.js"));
__export(__webpack_require__(/*! ./not-like */ "../tsql/dist/expr-library/string/not-like.js"));
__export(__webpack_require__(/*! ./null-safe-concat */ "../tsql/dist/expr-library/string/null-safe-concat.js"));
__export(__webpack_require__(/*! ./octet-length */ "../tsql/dist/expr-library/string/octet-length.js"));
__export(__webpack_require__(/*! ./position */ "../tsql/dist/expr-library/string/position.js"));
//export * from "./quote";
__export(__webpack_require__(/*! ./r-pad */ "../tsql/dist/expr-library/string/r-pad.js"));
__export(__webpack_require__(/*! ./r-trim */ "../tsql/dist/expr-library/string/r-trim.js"));
__export(__webpack_require__(/*! ./repeat */ "../tsql/dist/expr-library/string/repeat.js"));
__export(__webpack_require__(/*! ./replace */ "../tsql/dist/expr-library/string/replace.js"));
__export(__webpack_require__(/*! ./reverse */ "../tsql/dist/expr-library/string/reverse.js"));
__export(__webpack_require__(/*! ./to-base64 */ "../tsql/dist/expr-library/string/to-base64.js"));
__export(__webpack_require__(/*! ./trim */ "../tsql/dist/expr-library/string/trim.js"));
__export(__webpack_require__(/*! ./unhex */ "../tsql/dist/expr-library/string/unhex.js"));
__export(__webpack_require__(/*! ./upper */ "../tsql/dist/expr-library/string/upper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/l-pad.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/l-pad.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Returns a string, left-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 *   + `LPAD('123', 5, '')`   === `NULL`
 *   + `LPAD('123', 2, '')`   === `'12'`
 *   + `LPAD('123', -2, 'a')` === `NULL`
 * + PostgreSQL     : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 *   + `LPAD('123', 5, '')`   === `'123'`
 *   + `LPAD('123', 2, '')`   === `'12'`
 *   + `LPAD('123', -2, 'a')` === `''`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the desired length is negative, or padding string is empty,
 * the behaviour cannot be unified.
 *
 * MySQL seems to return `NULL`.
 *
 * -----
 *
 * @param left  - The string to pad
 * @param mid   - The desired length of the output
 * @param right - The padding
 *
 * @see lPad
 */
exports.lPadUnsafe = factory_1.makeOperator3(operator_type_1.OperatorType.LPAD, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string, left-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 * + PostgreSQL     : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * This function does not allow negative `desiredLength`, or empty `padding`.
 *
 * -----
 *
 * @param str           - The string to pad
 * @param desiredLength - The desired length of the output; must not be negative
 * @param padding       - The padding; must not be empty
 *
 * @see lPadUnsafe
 */
function lPad(str, desiredLength, padding) {
    desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
    padding = tm.stringLength({ min: 1 })(`padding`, padding);
    return expr_1.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.LPAD, [
        built_in_expr_1.BuiltInExprUtil.buildAst(str),
        built_in_expr_1.BuiltInExprUtil.buildAst(desiredLength),
        built_in_expr_1.BuiltInExprUtil.buildAst(padding),
    ], type_hint_1.TypeHint.STRING));
}
exports.lPad = lPad;
//# sourceMappingURL=l-pad.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/l-trim.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/string/l-trim.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with leading **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#ltrim
 *
 * -----
 *
 * + MySQL          : `LTRIM(x)`
 * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
 * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
 *
 * -----
 *
 * Does not remove other leading whitespace. Only removes leading spaces.
 */
exports.lTrim = factory_1.makeOperator1(operator_type_1.OperatorType.LTRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=l-trim.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/like.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/string/like.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const make_operator_3_1 = __webpack_require__(/*! ../factory/make-operator-3 */ "../tsql/dist/expr-library/factory/make-operator-3.js");
function assertValidLikeEscapeChar(escapeChar) {
    tm.stringExactLength(1)("escapeChar", escapeChar);
}
exports.assertValidLikeEscapeChar = assertValidLikeEscapeChar;
const likeEscapeImpl = make_operator_3_1.makeOperator3(operator_type_1.OperatorType.LIKE_ESCAPE, tm.mysql.boolean(), type_hint_1.TypeHint.STRING);
/**
 * + The escape character must always be specified, with this unified library.
 * + The escape character must be of length `1`.
 *
 * -----
 *
 * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
 *
 * -----
 *
 * This library requires the escape character to always be specified
 * because different databases have different defaults.
 *
 * Forcing an explicit escape character helps keep behaviour more consistent
 * across databases.
 *
 * Default escape characters per database,
 * + MySQL      : backslash (`\`)
 * + PostgreSQL : backslash (`\`)
 * + SQLite     : no-escape-character
 *
 * -----
 *
 * This library requires the escape character to have length `1` because
 * specifying the empty string has different behaviour on different databases,
 * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
 * + PostgreSQL : no-escape-character
 * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
 *
 * @param str - The target of the search
 * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
 * @param escapeChar - The escape character to use on the `pattern`
 */
function like(str, pattern, escapeChar) {
    assertValidLikeEscapeChar(escapeChar);
    return likeEscapeImpl(str, pattern, escapeChar);
}
exports.like = like;
//# sourceMappingURL=like.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/lower.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/lower.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with all characters changed to lowercase
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#lower
 *
 * -----
 *
 * + MySQL          : `LOWER(x)`
 * + PostgreSQL     : `LOWER(x)`
 * + SQLite         : `LOWER(x)`
 */
exports.lower = factory_1.makeOperator1(operator_type_1.OperatorType.LOWER, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=lower.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/not-like.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/string/not-like.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const make_operator_3_1 = __webpack_require__(/*! ../factory/make-operator-3 */ "../tsql/dist/expr-library/factory/make-operator-3.js");
const like_1 = __webpack_require__(/*! ./like */ "../tsql/dist/expr-library/string/like.js");
const notLikeEscapeImpl = make_operator_3_1.makeOperator3(operator_type_1.OperatorType.NOT_LIKE_ESCAPE, tm.mysql.boolean(), type_hint_1.TypeHint.STRING);
/**
 * + The escape character must always be specified, with this unified library.
 * + The escape character must be of length `1`.
 *
 * -----
 *
 * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
 *
 * -----
 *
 * This library requires the escape character to always be specified
 * because different databases have different defaults.
 *
 * Forcing an explicit escape character helps keep behaviour more consistent
 * across databases.
 *
 * Default escape characters per database,
 * + MySQL      : backslash (`\`)
 * + PostgreSQL : backslash (`\`)
 * + SQLite     : no-escape-character
 *
 * -----
 *
 * This library requires the escape character to have length `1` because
 * specifying the empty string has different behaviour on different databases,
 * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
 * + PostgreSQL : no-escape-character
 * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
 *
 * @param str - The target of the search
 * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
 * @param escapeChar - The escape character to use on the `pattern`
 */
function notLike(str, pattern, escapeChar) {
    like_1.assertValidLikeEscapeChar(escapeChar);
    return notLikeEscapeImpl(str, pattern, escapeChar);
}
exports.notLike = notLike;
//# sourceMappingURL=not-like.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/null-safe-concat.js":
/*!************************************************************!*\
  !*** ../tsql/dist/expr-library/string/null-safe-concat.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string that results from concatenating the arguments.
 * May have one or more arguments.
 * `NULL` values are treated as empty strings.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
 * + PostgreSQL     : `CONCAT(x, ...)`
 *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
 *     + This is different from MySQL's `CONCAT()`
 * + SQLite         : `COALESCE(x, '') || ... || ...`
 *
 * -----
 *
 * The SQL standard says,
 * > `<concatenation operator>` is an operator, `||`,
 * > that returns the character string made by joining its character string operands in the order given.
 *
 * MySQL actually treats `||` as the boolean `OR` operator.
 *
 * -----
 *
 * @see concat
 */
exports.nullSafeConcat = factory_1.makeOperator1ToN(operator_type_1.OperatorType.NULL_SAFE_CONCAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=null-safe-concat.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/octet-length.js":
/*!********************************************************!*\
  !*** ../tsql/dist/expr-library/string/octet-length.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the length of the string, measured in bytes.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `OCTET_LENGTH(x)`
 * + PostgreSQL     : `OCTET_LENGTH(x)`
 * + SQLite         : `LENGTH(CAST(x AS BLOB))`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  OCTET_LENGTH(CHAR(128 USING latin1))
 *  > 1
 *
 *  OCTET_LENGTH(CHAR(128 USING utf32))
 *  > 4
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/4
 */
exports.octetLength = factory_1.makeOperator1(operator_type_1.OperatorType.OCTET_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=octet-length.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/position.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/string/position.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the position of the first occurrence of the substring in the target.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `POSITION(substr IN str)`
 * + PostgreSQL     : `POSITION(substr IN str)`
 * + SQLite         : `INSTR(str, substr)`
 *
 * -----
 *
 * @param left  - The substring to look for
 * @param right - The target of the search
 *
 * -----
 *
 * If the substring is not found, it returns `0`.
 * Remember that string indices are one-based; not zero-based.
 *
 * @see inStr
 * @todo Remove `inStr()` and keep `position()`?
 */
exports.position = factory_1.makeOperator2(operator_type_1.OperatorType.POSITION, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=position.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/r-pad.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/r-pad.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "../tsql/dist/ast/index.js");
/**
 * Returns a string, right-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 *   + `RPAD('123', 5, '')`   === `NULL`
 *   + `RPAD('123', 2, '')`   === `'12'`
 *   + `RPAD('123', -2, 'a')` === `NULL`
 * + PostgreSQL     : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 *   + `RPAD('123', 5, '')`   === `'123'`
 *   + `RPAD('123', 2, '')`   === `'12'`
 *   + `RPAD('123', -2, 'a')` === `''`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the desired length is negative, or padding string is empty,
 * the behaviour cannot be unified.
 *
 * MySQL seems to return `NULL`.
 *
 * -----
 *
 * @param left  - The string to pad
 * @param mid   - The desired length of the output
 * @param right - The padding
 *
 * @see rPad
 */
exports.rPadUnsafe = factory_1.makeOperator3(operator_type_1.OperatorType.RPAD, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string, right-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 * + PostgreSQL     : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * This function does not allow negative `desiredLength`, or empty `padding`.
 *
 * -----
 *
 * @param str           - The string to pad
 * @param desiredLength - The desired length of the output; must not be negative
 * @param padding       - The padding; must not be empty
 *
 * @see rPadUnsafe
 */
function rPad(str, desiredLength, padding) {
    desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
    padding = tm.stringLength({ min: 1 })(`padding`, padding);
    return expr_1.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.RPAD, [
        built_in_expr_1.BuiltInExprUtil.buildAst(str),
        built_in_expr_1.BuiltInExprUtil.buildAst(desiredLength),
        built_in_expr_1.BuiltInExprUtil.buildAst(padding),
    ], type_hint_1.TypeHint.STRING));
}
exports.rPad = rPad;
//# sourceMappingURL=r-pad.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/r-trim.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/string/r-trim.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with trailing **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#rtrim
 *
 * -----
 *
 * + MySQL          : `RTRIM(x)`
 * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
 * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
 *
 * -----
 *
 * Does not remove other trailing whitespace. Only removes trailing spaces.
 */
exports.rTrim = factory_1.makeOperator1(operator_type_1.OperatorType.RTRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=r-trim.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/repeat.js":
/*!**************************************************!*\
  !*** ../tsql/dist/expr-library/string/repeat.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Repeats a string the specified amount of times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `REPEAT(x, count)`
 * + PostgreSQL     : `REPEAT(x, count)`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the specified amount is zero or less, it returns an empty string.
 *
 * -----
 *
 * @param left  - The string to repeat
 * @param right - The amount of times to repeat the string
 */
exports.repeat = factory_1.makeOperator2(operator_type_1.OperatorType.REPEAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/replace.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/string/replace.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string `str`
 * with all occurrences of the string `from`
 * replaced by the string `to`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#replace
 *
 * -----
 *
 * + MySQL          : `REPLACE(str, from, to)`
 * + PostgreSQL     : `REPLACE(str, from, to)`
 * + SQLite         : `REPLACE(str, from, to)`
 *
 * -----
 *
 * @param left  - The string to transform
 * @param mid   - The string to look for
 * @param right - The replacement string
 */
exports.replace = factory_1.makeOperator3(operator_type_1.OperatorType.REPLACE, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/reverse.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/string/reverse.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with the order of the characters reversed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `REVERSE(x)`
 * + PostgreSQL     : `REVERSE(x)`
 * + SQLite         : None. Implement with user-defined function.
 */
exports.reverse = factory_1.makeOperator1(operator_type_1.OperatorType.REVERSE, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/to-base64.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr-library/string/to-base64.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Converts the argument to base-64 encoded form.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `TO_BASE64(x)`
 * + PostgreSQL     : `ENCODE(x, 'base64')`
 * + SQLite         : None, implement with user-defined function `btoa()`
 */
exports.toBase64 = factory_1.makeOperator1(operator_type_1.OperatorType.TO_BASE64, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=to-base64.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/trim.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr-library/string/trim.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with leading and trailing **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#trim
 *
 * -----
 *
 * + MySQL          : `TRIM(x)`
 * + PostgreSQL     : `TRIM(x)`
 * + SQLite         : `TRIM(x)`
 *
 * -----
 *
 * Does not remove other leading and trailing whitespace.
 * Only removes leading and trailing spaces.
 */
exports.trim = factory_1.makeOperator1(operator_type_1.OperatorType.TRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=trim.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/unhex.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/unhex.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Takes a hex encoded string,
 * and returns the decoded result as a `BLOB/bytea`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `UNHEX(x)`
 *   + `UNHEX('~')` === `NULL`
 * + PostgreSQL     : `DECODE(x, 'hex')`
 *   + `DECODE('~', 'hex')` throws an error
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the input is not a valid hex string, some databases throw an error.
 * Others return `NULL`.
 */
exports.unhex = factory_1.makeOperator1(operator_type_1.OperatorType.UNHEX, tm.orNull(tm.instanceOfUint8Array()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=unhex.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/string/upper.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr-library/string/upper.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "../tsql/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "../tsql/dist/type-hint.js");
/**
 * Returns the string with all characters changed to uppercase
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#upper
 *
 * -----
 *
 * + MySQL          : `UPPER(x)`
 * + PostgreSQL     : `UPPER(x)`
 * + SQLite         : `UPPER(x)`
 */
exports.upper = factory_1.makeOperator1(operator_type_1.OperatorType.UPPER, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=upper.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/subquery/exists.js":
/*!****************************************************!*\
  !*** ../tsql/dist/expr-library/subquery/exists.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "../tsql/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "../tsql/dist/expr/index.js");
const util_1 = __webpack_require__(/*! ../../ast/operator-node/util */ "../tsql/dist/ast/operator-node/util/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "../tsql/dist/operator-type.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "../tsql/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function exists(query) {
    if (!query_base_1.QueryBaseUtil.isAfterFromClause(query) && !query_base_1.QueryBaseUtil.isAfterSelectClause(query)) {
        throw new Error(`Query must be after FROM/SELECT clause`);
    }
    /**
     * Hack for MySQL 5.7 and SQLite < 3.30 thinking the following is `true`,
     * ```sql
     *  EXISTS(SELECT 'hello' LIMIT 0);
     * ```
     */
    if (query.compoundQueryClause == undefined) {
        if ((query.compoundQueryLimitClause != undefined &&
            Number(query.compoundQueryLimitClause.maxRowCount) == 0) ||
            (query.limitClause != undefined &&
                Number(query.limitClause.maxRowCount) == 0)) {
            return expr_1.expr({
                mapper: tm.mysql.boolean(),
                usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
                isAggregate: false,
            }, built_in_expr_1.BuiltInExprUtil.buildAst(false));
        }
    }
    else {
        if (query.compoundQueryLimitClause != undefined &&
            Number(query.compoundQueryLimitClause.maxRowCount) == 0) {
            return expr_1.expr({
                mapper: tm.mysql.boolean(),
                usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
                isAggregate: false,
            }, built_in_expr_1.BuiltInExprUtil.buildAst(false));
        }
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
        isAggregate: false,
    }, util_1.operatorNode1(operator_type_1.OperatorType.EXISTS, [query], undefined));
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "../tsql/dist/expr-library/subquery/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-library/subquery/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "../tsql/dist/expr-library/subquery/exists.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/expr-select-item/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprSelectItemUtil = __webpack_require__(/*! ./util */ "../tsql/dist/expr-select-item/util/index.js");
exports.ExprSelectItemUtil = ExprSelectItemUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/util/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr-select-item/util/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/expr-select-item/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/expr-select-item/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/util/operation/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-select-item/util/operation/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./with-type */ "../tsql/dist/expr-select-item/util/operation/with-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/util/operation/with-type.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/expr-select-item/util/operation/with-type.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function withType({ tableAlias, alias, usedRef, unaliasedAst, isAggregate, }, newMapper) {
    const result = {
        mapper: newMapper,
        tableAlias,
        alias,
        usedRef,
        isAggregate,
        unaliasedAst,
    };
    return result;
}
exports.withType = withType;
//# sourceMappingURL=with-type.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/util/predicate/index.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/expr-select-item/util/predicate/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr-select-item */ "../tsql/dist/expr-select-item/util/predicate/is-expr-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr-select-item/util/predicate/is-expr-select-item.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/expr-select-item/util/predicate/is-expr-select-item.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Does not actually check,
 * + `x.usedRef` is `IUsedRef`
 * + `x.unaliasedAst` is `Ast`
 *
 * @todo Consider adding checks for increased type safety.
 */
function isExprSelectItem(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "mapper",
        "tableAlias",
        "alias",
        "usedRef",
        "isAggregate",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof x.mapper == "function") &&
        (typeof x.tableAlias == "string") &&
        (typeof x.alias == "string") //&&
    //UsedRefUtil.isUsedRef(x.usedRef) &&
    //(typeof x.isAggregate == "boolean") &&
    //AstUtil.isAst(x.ast)
    );
}
exports.isExprSelectItem = isExprSelectItem;
//# sourceMappingURL=is-expr-select-item.js.map

/***/ }),

/***/ "../tsql/dist/expr/expr-impl.js":
/*!**************************************!*\
  !*** ../tsql/dist/expr/expr-impl.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = __webpack_require__(/*! ../ast */ "../tsql/dist/ast/index.js");
const ExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/expr/util/index.js");
/**
 * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
 *
 * This hack should only really be reserved for types that are more likely
 * to trigger max depth/max count errors.
 */
class ExprImpl {
    constructor(data, ast) {
        this.mapper = data.mapper;
        this.usedRef = data.usedRef;
        this.isAggregate = data.isAggregate;
        //Gotta' play it safe.
        //We want to preserve the order of operations.
        this.ast = ast_1.parentheses(ast);
    }
    /**
     * If you are running into "max instantiation depth" errors,
     * consider adding explicit `TableExpr<>` type annotations.
     *
     * If that doesn't help,
     * consider using `ExprUtil.as()` instead.
     *
     * Also, consider reading this to understand my frustration,
     * https://github.com/microsoft/TypeScript/issues/29511
     *
     * @param alias
     */
    as(alias) {
        return ExprUtil.as(this, alias);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() ASC
     * ```
     */
    asc() {
        return ExprUtil.asc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() DESC
     * ```
     */
    desc() {
        return ExprUtil.desc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  (myTable.myColumn IS NOT NULL) ASC,
     *  RAND() DESC
     * ```
     */
    sort(sortDirection) {
        return ExprUtil.sort(this, sortDirection);
    }
}
exports.ExprImpl = ExprImpl;
function expr(data, ast) {
    return new ExprImpl(data, ast);
}
exports.expr = expr;
//# sourceMappingURL=expr-impl.js.map

/***/ }),

/***/ "../tsql/dist/expr/index.js":
/*!**********************************!*\
  !*** ../tsql/dist/expr/index.js ***!
  \**********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./expr-impl */ "../tsql/dist/expr/expr-impl.js"));
const ExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/expr/util/index.js");
exports.ExprUtil = ExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/constructor/from-built-in-expr.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/expr/util/constructor/from-built-in-expr.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "../tsql/dist/expr/expr-impl.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function fromBuiltInExpr(builtInExpr) {
    if (builtInExpr instanceof expr_impl_1.ExprImpl) {
        return builtInExpr;
    }
    const mapper = built_in_expr_1.BuiltInExprUtil.mapper(builtInExpr);
    const usedRef = built_in_expr_1.BuiltInExprUtil.usedRef(builtInExpr);
    const isAggregate = built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr);
    const ast = built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr);
    return expr_impl_1.expr({
        mapper,
        usedRef,
        isAggregate,
    }, ast);
}
exports.fromBuiltInExpr = fromBuiltInExpr;
function fromRawExprNoUsedRefInput(mapper, value) {
    if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(value)) {
        /**
         * Cannot map a `NonValueExpr`
         */
        return fromBuiltInExpr(value);
    }
    else {
        return fromBuiltInExpr(built_in_expr_1.BuiltInExprUtil.fromValueExpr(mapper, value));
    }
}
exports.fromRawExprNoUsedRefInput = fromRawExprNoUsedRefInput;
//# sourceMappingURL=from-built-in-expr.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/constructor/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr/util/constructor/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-built-in-expr */ "../tsql/dist/expr/util/constructor/from-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/expr/util/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/expr/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/expr/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/operation/aggregate-intersect.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/expr/util/operation/aggregate-intersect.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "../tsql/dist/expr/expr-impl.js");
function aggregateIntersect(mapper, args, ast) {
    /**
     * @todo Set the `name` parameter?
     */
    built_in_expr_1.BuiltInExprUtil.assertAllNonAggregate(``, args);
    return expr_impl_1.expr({
        mapper,
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(...args),
        isAggregate: true,
    }, ast);
}
exports.aggregateIntersect = aggregateIntersect;
//# sourceMappingURL=aggregate-intersect.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/operation/as.js":
/*!**********************************************!*\
  !*** ../tsql/dist/expr/util/operation/as.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(/*! ../../../constants */ "../tsql/dist/constants.js");
const aliased_expr_1 = __webpack_require__(/*! ../../../aliased-expr */ "../tsql/dist/aliased-expr/index.js");
function as(expr, alias) {
    const result = new aliased_expr_1.AliasedExpr({
        mapper: expr.mapper,
        tableAlias: constants_1.ALIASED,
        alias,
        usedRef: expr.usedRef,
        isAggregate: expr.isAggregate,
    }, expr.ast);
    return result;
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/operation/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr/util/operation/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate-intersect */ "../tsql/dist/expr/util/operation/aggregate-intersect.js"));
__export(__webpack_require__(/*! ./as */ "../tsql/dist/expr/util/operation/as.js"));
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/expr/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./sort */ "../tsql/dist/expr/util/operation/sort.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/operation/intersect.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/expr/util/operation/intersect.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "../tsql/dist/expr/expr-impl.js");
function intersect(mapper, args, ast) {
    return expr_impl_1.expr({
        mapper,
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(...args),
        isAggregate: args.some(built_in_expr_1.BuiltInExprUtil.isAggregate),
    }, ast);
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/operation/sort.js":
/*!************************************************!*\
  !*** ../tsql/dist/expr/util/operation/sort.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
function asc(expr) {
    return [expr, sort_direction_1.SortDirection.ASC];
}
exports.asc = asc;
function desc(expr) {
    return [expr, sort_direction_1.SortDirection.DESC];
}
exports.desc = desc;
function sort(expr, sortDirection) {
    return [expr, sortDirection];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/predicate/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/expr/util/predicate/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr */ "../tsql/dist/expr/util/predicate/is-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/expr/util/predicate/is-expr.js":
/*!***************************************************!*\
  !*** ../tsql/dist/expr/util/predicate/is-expr.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Does not actually check,
 * + `x.usedRef` is `IUsedRef`
 * + `x.ast` is `Ast`
 *
 * @todo Consider adding checks for increased type safety.
 */
function isExpr(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "mapper",
        "usedRef",
        "isAggregate",
        "ast"
    ])) {
        return false;
    }
    return ((typeof x.mapper == "function") //&&
    //UsedRefUtil.isUsedRef(x.usedRef) &&
    //AstUtil.isAst(x.ast) &&
    //(typeof x.isAggregate == "boolean")
    );
}
exports.isExpr = isExpr;
//# sourceMappingURL=is-expr.js.map

/***/ }),

/***/ "../tsql/dist/formatter/Formatter.js":
/*!*******************************************!*\
  !*** ../tsql/dist/formatter/Formatter.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "../tsql/dist/formatter/TokenType.js");
const Indentation_1 = __webpack_require__(/*! ./Indentation */ "../tsql/dist/formatter/Indentation.js");
const InlineBlock_1 = __webpack_require__(/*! ./InlineBlock */ "../tsql/dist/formatter/InlineBlock.js");
const Params_1 = __webpack_require__(/*! ./Params */ "../tsql/dist/formatter/Params.js");
/* eslint-disable local/no-method */
class Formatter {
    /**
     * @param {Object} cfg
     *   @param {Object} cfg.indent
     *   @param {Object} cfg.params
     * @param {Tokenizer} tokenizer
     */
    constructor(cfg, tokenizer) {
        this.cfg = (cfg == undefined) ?
            {} :
            cfg;
        this.indentation = new Indentation_1.Indentation(this.cfg.indent);
        this.inlineBlock = new InlineBlock_1.InlineBlock();
        this.params = new Params_1.Params(this.cfg.params);
        this.tokenizer = tokenizer;
        this.previousReservedWord = undefined;
        this.tokens = [];
        this.index = 0;
    }
    /**
     * Formats whitespaces in a SQL string to make it easier to read.
     *
     * @param {String} query The SQL query string
     * @return {String} formatted query
     */
    format(query) {
        this.tokens = this.tokenizer.tokenize(query);
        const formattedQuery = this.getFormattedQueryFromTokens();
        return formattedQuery.trim();
    }
    getFormattedQueryFromTokens() {
        let formattedQuery = "";
        this.tokens.forEach((token, index) => {
            this.index = index;
            if (token.type === TokenType_1.TokenType.WHITESPACE) {
                // ignore (we do our own whitespace formatting)
            }
            else if (token.type === TokenType_1.TokenType.LINE_COMMENT) {
                formattedQuery = this.formatLineComment(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.BLOCK_COMMENT) {
                formattedQuery = this.formatBlockComment(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_TOPLEVEL) {
                formattedQuery = this.formatToplevelReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_NEWLINE) {
                formattedQuery = this.formatNewlineReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_PRE_NEWLINE) {
                formattedQuery = this.formatPreNewlineReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED) {
                formattedQuery = this.formatWithSpaces(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.OPEN_PAREN) {
                formattedQuery = this.formatOpeningParentheses(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.CLOSE_PAREN) {
                formattedQuery = this.formatClosingParentheses(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.PLACEHOLDER) {
                formattedQuery = this.formatPlaceholder(token, formattedQuery);
            }
            else if (token.value === ",") {
                formattedQuery = this.formatComma(token, formattedQuery);
            }
            else if (token.value === ":") {
                formattedQuery = this.formatWithSpaceAfter(token, formattedQuery);
            }
            else if (token.value === "." || token.value === ";") {
                formattedQuery = this.formatWithoutSpaces(token, formattedQuery);
            }
            else {
                formattedQuery = this.formatWithSpaces(token, formattedQuery);
            }
        });
        return formattedQuery;
    }
    formatLineComment(token, query) {
        return this.addNewline(query + token.value);
    }
    formatBlockComment(token, query) {
        return this.addNewline(this.addNewline(query) + this.indentComment(token.value));
    }
    indentComment(comment) {
        return comment.replace(/\n/g, "\n" + this.indentation.getIndent());
    }
    formatToplevelReservedWord(token, query) {
        this.indentation.decreaseTopLevel();
        query = this.addNewline(query);
        this.indentation.increaseToplevel();
        query += this.equalizeWhitespace(token.value);
        return this.addNewline(query);
    }
    formatNewlineReservedWord(token, query) {
        //Different from original implementation. I think this looks nicer.
        if (query.length > 0 && !query.endsWith(" ")) {
            query += " ";
        }
        return this.addNewline(query + this.equalizeWhitespace(token.value));
    }
    formatPreNewlineReservedWord(token, query) {
        //The original formatNewlineReservedWord() implementation
        //Useful for WHEN clause of CASE
        return this.addNewline(query) + this.equalizeWhitespace(token.value) + " ";
    }
    // Replace any sequence of whitespace characters with single space
    equalizeWhitespace(string) {
        return string.replace(/\s+/g, " ");
    }
    // Opening parentheses increase the block indent level and start a new line
    formatOpeningParentheses(token, query) {
        // Take out the preceding space unless there was whitespace there in the original query
        // or another opening parens or line comment
        const preserveWhitespaceFor = [
            TokenType_1.TokenType.WHITESPACE,
            TokenType_1.TokenType.OPEN_PAREN,
            TokenType_1.TokenType.LINE_COMMENT,
        ];
        if (!this.hasPreviousToken() || !preserveWhitespaceFor.includes(this.previousToken().type)) {
            query = query.trimRight();
        }
        query += token.value;
        this.inlineBlock.beginIfPossible(this.tokens, this.index);
        if (!this.inlineBlock.isActive()) {
            this.indentation.increaseBlockLevel();
            query = this.addNewline(query);
        }
        return query;
    }
    // Closing parentheses decrease the block indent level
    formatClosingParentheses(token, query) {
        if (this.inlineBlock.isActive()) {
            this.inlineBlock.end();
            return this.formatWithSpaceAfter(token, query);
        }
        else {
            this.indentation.decreaseBlockLevel();
            return this.formatWithSpaces(token, this.addNewline(query));
        }
    }
    formatPlaceholder(token, query) {
        return query + this.params.get(token) + " ";
    }
    // Commas start a new line (unless within inline parentheses or SQL "LIMIT" clause)
    formatComma(token, query) {
        query = this.trimTrailingWhitespace(query) + token.value + " ";
        if (this.inlineBlock.isActive()) {
            return query;
        }
        else if (this.previousReservedWord != undefined && /^LIMIT$/i.test(this.previousReservedWord.value)) {
            return query;
        }
        else {
            return this.addNewline(query);
        }
    }
    formatWithSpaceAfter(token, query) {
        return this.trimTrailingWhitespace(query) + token.value + " ";
    }
    formatWithoutSpaces(token, query) {
        return this.trimTrailingWhitespace(query) + token.value;
    }
    formatWithSpaces(token, query) {
        if (token.value == "HACKED_AND_NO_NEW_LINE") {
            return query + "AND" + " ";
        }
        return query + token.value + " ";
    }
    addNewline(query) {
        return query.trimRight() + "\n" + this.indentation.getIndent();
    }
    trimTrailingWhitespace(query) {
        if (this.hasPreviousNonWhitespaceToken() && this.previousNonWhitespaceToken().type === TokenType_1.TokenType.LINE_COMMENT) {
            return query.trimRight() + "\n";
        }
        else {
            return query.trimRight();
        }
    }
    hasPreviousNonWhitespaceToken() {
        let n = 1;
        while (this.hasPreviousToken(n) && this.previousToken(n).type === TokenType_1.TokenType.WHITESPACE) {
            n++;
        }
        return this.hasPreviousToken(n);
    }
    previousNonWhitespaceToken() {
        let n = 1;
        while (this.previousToken(n).type === TokenType_1.TokenType.WHITESPACE) {
            n++;
        }
        return this.previousToken(n);
    }
    hasPreviousToken(offset = 1) {
        return (this.index - offset) >= 0;
    }
    previousToken(offset = 1) {
        const result = this.tokens[this.index - offset];
        if (result == undefined) {
            throw new Error(`No previous token. index ${this.index}, offset ${offset}`);
        }
        return result;
    }
}
exports.Formatter = Formatter;
//# sourceMappingURL=Formatter.js.map

/***/ }),

/***/ "../tsql/dist/formatter/Indentation.js":
/*!*********************************************!*\
  !*** ../tsql/dist/formatter/Indentation.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function last(arr) {
    if (arr.length == 0) {
        return undefined;
    }
    else {
        return arr[arr.length - 1];
    }
}
//Poor man's enum?
const INDENT_TYPE_TOP_LEVEL = "top-level";
const INDENT_TYPE_BLOCK_LEVEL = "block-level";
/* eslint-disable local/no-method */
/**
 * Manages indentation levels.
 *
 * There are two types of indentation levels:
 *
 * - BLOCK_LEVEL : increased by open-parenthesis
 * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
 */
class Indentation {
    /**
     * @param {String} indent Indent value, default is "  " (2 spaces)
     */
    constructor(indent) {
        this.indent = (indent == undefined) ? "  " : indent;
        this.indentTypes = [];
    }
    /**
     * Returns current indentation string.
     * @return {String}
     */
    getIndent() {
        return this.indent.repeat(this.indentTypes.length);
    }
    /**
     * Increases indentation by one top-level indent.
     */
    increaseToplevel() {
        this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
    }
    /**
     * Increases indentation by one block-level indent.
     */
    increaseBlockLevel() {
        this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
    }
    /**
     * Decreases indentation by one top-level indent.
     * Does nothing when the previous indent is not top-level.
     */
    decreaseTopLevel() {
        if (last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            this.indentTypes.pop();
        }
    }
    /**
     * Decreases indentation by one block-level indent.
     * If there are top-level indents within the block-level indent,
     * throws away these as well.
     */
    decreaseBlockLevel() {
        while (this.indentTypes.length > 0) {
            const type = this.indentTypes.pop();
            if (type !== INDENT_TYPE_TOP_LEVEL) {
                break;
            }
        }
    }
}
exports.Indentation = Indentation;
//# sourceMappingURL=Indentation.js.map

/***/ }),

/***/ "../tsql/dist/formatter/InlineBlock.js":
/*!*********************************************!*\
  !*** ../tsql/dist/formatter/InlineBlock.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "../tsql/dist/formatter/TokenType.js");
const INLINE_MAX_LENGTH = 50;
/* eslint-disable local/no-method */
/**
 * Bookkeeper for inline blocks.
 *
 * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.
 * These blocks are formatted on a single line, unlike longer parenthized
 * expressions where open-parenthesis causes newline and increase of indentation.
 */
class InlineBlock {
    constructor() {
        this.level = 0;
    }
    /**
     * Begins inline block when lookahead through upcoming tokens determines
     * that the block would be smaller than INLINE_MAX_LENGTH.
     * @param  {Object[]} tokens Array of all tokens
     * @param  {Number} index Current token position
     */
    beginIfPossible(tokens, index) {
        if (this.level === 0 && this.isInlineBlock(tokens, index)) {
            this.level = 1;
        }
        else if (this.level > 0) {
            this.level++;
        }
        else {
            this.level = 0;
        }
    }
    /**
     * Finishes current inline block.
     * There might be several nested ones.
     */
    end() {
        this.level--;
    }
    /**
     * True when inside an inline block
     * @return {Boolean}
     */
    isActive() {
        return this.level > 0;
    }
    // Check if this should be an inline parentheses block
    // Examples are "NOW()", "COUNT(*)", "int(10)", key(`somecolumn`), DECIMAL(7,2)
    isInlineBlock(tokens, index) {
        let length = 0;
        let level = 0;
        for (let i = index; i < tokens.length; i++) {
            const token = tokens[i];
            length += token.value.length;
            // Overran max length
            if (length > INLINE_MAX_LENGTH) {
                return false;
            }
            if (token.type === TokenType_1.TokenType.OPEN_PAREN) {
                level++;
            }
            else if (token.type === TokenType_1.TokenType.CLOSE_PAREN) {
                level--;
                if (level === 0) {
                    return true;
                }
            }
            if (this.isForbiddenToken(token)) {
                return false;
            }
        }
        return false;
    }
    // Reserved words that cause newlines, comments and semicolons
    // are not allowed inside inline parentheses block
    isForbiddenToken({ type, value }) {
        return type === TokenType_1.TokenType.RESERVED_TOPLEVEL ||
            type === TokenType_1.TokenType.RESERVED_NEWLINE ||
            type === TokenType_1.TokenType.RESERVED_PRE_NEWLINE ||
            //TokenType.COMMENT does not exist.
            //This is effectively, type === undefined
            //This is why plain JS sucks.
            //type === TokenType.COMMENT ||
            type === TokenType_1.TokenType.BLOCK_COMMENT ||
            value === ";";
    }
}
exports.InlineBlock = InlineBlock;
//# sourceMappingURL=InlineBlock.js.map

/***/ }),

/***/ "../tsql/dist/formatter/Params.js":
/*!****************************************!*\
  !*** ../tsql/dist/formatter/Params.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable local/no-method */
/**
 * Handles placeholder replacement with given params.
 */
class Params {
    /**
     * @param {Object} params
     */
    constructor(params) {
        this.params = params;
        this.index = 0;
    }
    /**
     * Returns param value that matches given placeholder with param key.
     * @param {Object} token
     * @param {String} token.key Placeholder key
     * @param {String} token.value Placeholder value
     * @return {String} param or token.value when params are missing
     */
    get({ key, value }) {
        if (this.params == undefined) {
            return value;
        }
        if (key != undefined) {
            if (Array.isArray(this.params)) {
                throw new Error(`Cannot use array params with named placeholders`);
            }
            else {
                return this.params[key];
            }
        }
        else {
            if (Array.isArray(this.params)) {
                return this.params[this.index++];
            }
            else {
                throw new Error(`Cannot use object params with index placeholders`);
            }
        }
    }
}
exports.Params = Params;
//# sourceMappingURL=Params.js.map

/***/ }),

/***/ "../tsql/dist/formatter/SqlFormatter.js":
/*!**********************************************!*\
  !*** ../tsql/dist/formatter/SqlFormatter.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Formatter_1 = __webpack_require__(/*! ./Formatter */ "../tsql/dist/formatter/Formatter.js");
const Tokenizer_1 = __webpack_require__(/*! ./Tokenizer */ "../tsql/dist/formatter/Tokenizer.js");
const reservedWords = [
    "ACCESSIBLE", "ACTION", "AGAINST", "AGGREGATE", "ALGORITHM", "ALL", "ALTER", "ANALYSE", "ANALYZE", "AS", "ASC", "AUTOCOMMIT",
    "AUTO_INCREMENT",
    "BACKUP", "BEGIN", "BETWEEN", "BINLOG", "BOTH",
    "CASCADE", "CASE", "CHANGE", "CHANGED", "CHARACTER SET", "CHARSET", "CHECK", "CHECKSUM", "COLLATE", "COLLATION", "COLUMN", "COLUMNS",
    "COMMENT", "COMMIT", "COMMITTED", "COMPRESSED", "CONCURRENT", "CONSTRAINT", "CONTAINS", "CONVERT", "CREATE", "CROSS",
    "CURRENT_TIMESTAMP",
    "DATABASE", "DATABASES", "DAY", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "DEFAULT", "DEFINER", "DELAYED", "DELETE", "DESC", "DESCRIBE",
    "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DO", "DROP", "DUMPFILE", "DUPLICATE", "DYNAMIC",
    "ENCLOSED", "END", "ENGINE", "ENGINES", "ENGINE_TYPE", "ESCAPE", "ESCAPED", "EVENTS", "EXEC", "EXECUTE", "EXISTS", "EXPLAIN",
    "EXTENDED",
    "FAST", "FETCH", "FIELDS", "FILE", "FIRST", "FIXED", "FLUSH", "FOR", "FORCE", "FOREIGN", "FULL", "FULLTEXT", "FUNCTION",
    "GLOBAL", "GRANT", "GRANTS", "GROUP_CONCAT",
    "HEAP", "HIGH_PRIORITY", "HOSTS", "HOUR", "HOUR_MINUTE", "HOUR_SECOND",
    "IDENTIFIED", "IF", "IFNULL", "IGNORE", "IN", "INDEX", "INDEXES", "INFILE", "INSERT", "INSERT_ID", "INSERT_METHOD", "INTERVAL",
    "INTO", "INVOKER", "IS", "ISOLATION",
    "KEY", "KEYS", "KILL",
    "LAST_INSERT_ID", "LEADING", "LEVEL", "LIKE", "LINEAR", "LINES", "LOAD", "LOCAL", "LOCK", "LOCKS", "LOGS", "LOW_PRIORITY",
    "MARIA", "MASTER", "MASTER_CONNECT_RETRY", "MASTER_HOST", "MASTER_LOG_FILE", "MATCH", "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", "MERGE", "MINUTE", "MINUTE_SECOND",
    "MIN_ROWS", "MODE", "MODIFY", "MONTH", "MRG_MYISAM", "MYISAM",
    "NAMES", "NATURAL", "NOT", "NOW()", "NULL",
    "ON DELETE", "ON UPDATE", "ONLY", "OPEN", "OPTIMIZE", "OPTION", "OPTIONALLY", "OUTFILE",
    "PACK_KEYS", "PAGE", "PARTIAL", "PARTITION", "PARTITIONS", "PASSWORD", "PRIMARY", "PRIVILEGES", "PROCEDURE", "PROCESS", "PROCESSLIST",
    "PURGE",
    "QUICK",
    "RAID0", "RAID_CHUNKS", "RAID_CHUNKSIZE", "RAID_TYPE", "RANGE", "READ", "READ_ONLY", "READ_WRITE", "REFERENCES", "REGEXP", "RELOAD",
    "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLICATION", "RESET", "RESTORE", "RESTRICT", "RETURN", "RETURNS", "REVOKE", "RLIKE",
    "ROLLBACK", "ROW", "ROWS", "ROW_FORMAT",
    "SECOND", "SECURITY", "SEPARATOR", "SERIALIZABLE", "SESSION", "SHARE", "SHOW", "SHUTDOWN", "SLAVE", "SONAME", "SOUNDS", "SQL",
    "SQL_AUTO_IS_NULL", "SQL_BIG_RESULT", "SQL_BIG_SELECTS", "SQL_BIG_TABLES", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS",
    "SQL_LOG_BIN", "SQL_LOG_OFF", "SQL_LOG_UPDATE", "SQL_LOW_PRIORITY_UPDATES", "SQL_MAX_JOIN_SIZE", "SQL_NO_CACHE",
    "SQL_QUOTE_SHOW_CREATE", "SQL_SAFE_UPDATES", "SQL_SELECT_LIMIT", "SQL_SLAVE_SKIP_COUNTER", "SQL_SMALL_RESULT", "SQL_WARNINGS",
    "START", "STARTING", "STATUS", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRING", "STRIPED", "SUPER",
    "TABLE", "TABLES", "TEMPORARY", "TERMINATED", "THEN", "TO", "TRAILING", "TRANSACTIONAL", "TRUE", "TRUNCATE", "TYPE", "TYPES",
    "UNCOMMITTED", "UNIQUE", "UNLOCK", "UNSIGNED", "USAGE", "USE", "USING",
    "VARIABLES", "VIEW", "WITH", "WORK", "WRITE",
    "YEAR_MONTH",
    //This will be rendered as `AND` but without a new line
    "HACKED_AND_NO_NEW_LINE"
];
const reservedToplevelWords = [
    "ADD", "AFTER", "ALTER COLUMN", "ALTER TABLE",
    "DELETE FROM",
    "EXCEPT",
    "FETCH FIRST", "FROM",
    "GROUP BY", "GO",
    "HAVING",
    "INSERT INTO", "INSERT", "INTERSECT",
    "LIMIT",
    "MODIFY",
    "ORDER BY",
    /*New reserved top-level word*/ "SELECT DISTINCT SQL_CALC_FOUND_ROWS",
    /*New reserved top-level word*/ "SELECT DISTINCT",
    /*New reserved top-level word*/ "SELECT SQL_CALC_FOUND_ROWS",
    "SELECT", "SET CURRENT SCHEMA", "SET SCHEMA", "SET",
    "UNION ALL", /*New reserved top-level word*/ "UNION DISTINCT", "UNION", "UPDATE",
    "VALUES",
    "WHERE",
    //Originally in reservedNewlineWords
    //But I think this is better to me
    "CROSS APPLY", "CROSS JOIN",
    "INNER JOIN",
    "JOIN",
    "LEFT JOIN", "LEFT OUTER JOIN",
    "OUTER APPLY", "OUTER JOIN",
    "RIGHT JOIN", "RIGHT OUTER JOIN",
    //Originally in reservedWords
    //But I think this is better to me
    "ON",
    "OFFSET",
];
const reservedNewlineWords = [
    "AND",
    "OR",
    "XOR"
];
const reservedPreNewlineWords = [
    "WHEN",
    "ELSE",
];
exports.defaultTokenizerConfig = {
    reservedWords,
    reservedToplevelWords,
    reservedNewlineWords,
    reservedPreNewlineWords,
    stringTypes: [/*`""`,*/ "N''", /*"''",*/ "``", "[]", "X''", "pascal-double", "pascal-single"],
    openParens: ["(", "CASE"],
    closeParens: [")", "END"],
    indexedPlaceholderTypes: ["?"],
    namedPlaceholderTypes: ["@", ":"],
    lineCommentTypes: ["#", "--"],
    specialWordChars: undefined,
};
/* eslint-disable local/no-method */
class SqlFormatter {
    /**
     * @param {Object} cfg Different set of configurations
     */
    constructor(cfg, tokenizerConfig) {
        this.cfg = cfg;
        /**
         * @todo Not use this hack.
         * We want to ignore properties set to `undefined`.
         */
        this.tokenizerConfig = { ...tokenizerConfig };
        for (const key of Object.keys(this.tokenizerConfig)) {
            if (this.tokenizerConfig[key] === undefined) {
                delete this.tokenizerConfig[key];
            }
        }
    }
    /**
     * Format the whitespace in a Standard SQL string to make it easier to read
     *
     * @param {String} query The Standard SQL string
     * @return {String} formatted string
     */
    format(query) {
        if (this.tokenizer == undefined) {
            this.tokenizer = new Tokenizer_1.Tokenizer({
                ...exports.defaultTokenizerConfig,
                ...this.tokenizerConfig,
            });
        }
        return new Formatter_1.Formatter(this.cfg, this.tokenizer).format(query);
    }
}
exports.SqlFormatter = SqlFormatter;
//# sourceMappingURL=SqlFormatter.js.map

/***/ }),

/***/ "../tsql/dist/formatter/TokenType.js":
/*!*******************************************!*\
  !*** ../tsql/dist/formatter/TokenType.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TokenType;
(function (TokenType) {
    TokenType["WHITESPACE"] = "whitespace";
    TokenType["WORD"] = "word";
    TokenType["STRING"] = "string";
    TokenType["RESERVED"] = "reserved";
    TokenType["RESERVED_TOPLEVEL"] = "reserved-toplevel";
    TokenType["RESERVED_NEWLINE"] = "reserved-newline";
    TokenType["RESERVED_PRE_NEWLINE"] = "reserved-pre-newline";
    TokenType["OPERATOR"] = "operator";
    TokenType["OPEN_PAREN"] = "open-paren";
    TokenType["CLOSE_PAREN"] = "close-paren";
    TokenType["LINE_COMMENT"] = "line-comment";
    TokenType["BLOCK_COMMENT"] = "block-comment";
    TokenType["NUMBER"] = "number";
    TokenType["PLACEHOLDER"] = "placeholder";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
//# sourceMappingURL=TokenType.js.map

/***/ }),

/***/ "../tsql/dist/formatter/Tokenizer.js":
/*!*******************************************!*\
  !*** ../tsql/dist/formatter/Tokenizer.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "../tsql/dist/formatter/TokenType.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
const reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(str) {
    return (str != "" && reHasRegExpChar.test(str))
        ? str.replace(reRegExpChar, '\\$&')
        : str;
}
/* eslint-disable local/no-method */
class Tokenizer {
    /**
     * @param {Object} cfg
     *  @param {String[]} cfg.reservedWords Reserved words in SQL
     *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately
     *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline
     *  @param {String[]} cfg.stringTypes String types to enable: "", '', ``, [], N''
     *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [
     *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]
     *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?
     *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :
     *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --
     *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #
     */
    constructor(cfg) {
        this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
        this.WHITESPACE_REGEX = /^(\s+)/;
        //The original NUMBER_REGEX was this -> /^((-\s*)?[0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\b/;
        this.NUMBER_REGEX = /^(([-+])?([0-9]*\.?[0-9]+)([eE]([-+])?([0-9]+))?)\b/;
        //Added <=> as the NULL-safe equality operator
        this.OPERATOR_REGEX = /^(<=>|!=|<>|==|<=|>=|!<|!>|\|\||::|->>|->|~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|.)/;
        this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
        this.LINE_COMMENT_REGEX = this.createLineCommentRegex(cfg.lineCommentTypes);
        this.RESERVED_TOPLEVEL_REGEX = this.createReservedWordRegex(cfg.reservedToplevelWords);
        this.RESERVED_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedNewlineWords);
        this.RESERVED_PRE_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedPreNewlineWords);
        this.RESERVED_PLAIN_REGEX = this.createReservedWordRegex(cfg.reservedWords);
        this.WORD_REGEX = this.createWordRegex(cfg.specialWordChars);
        this.STRING_REGEX = this.createStringRegex(cfg.stringTypes);
        this.OPEN_PAREN_REGEX = this.createParenRegex(cfg.openParens);
        this.CLOSE_PAREN_REGEX = this.createParenRegex(cfg.closeParens);
        this.INDEXED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.indexedPlaceholderTypes, "[0-9]*");
        this.IDENT_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, "[a-zA-Z0-9._$]+");
        this.STRING_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, this.createStringPattern(cfg.stringTypes));
    }
    createLineCommentRegex(lineCommentTypes) {
        return new RegExp(`^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join("|")}).*?(?:\n|$))`);
    }
    createReservedWordRegex(reservedWords) {
        const reservedWordsPattern = reservedWords.join("|").replace(/ /g, "\\s+");
        return new RegExp(`^(${reservedWordsPattern})\\b`, "i");
    }
    createWordRegex(specialChars = []) {
        return new RegExp(`^([\\w${specialChars.join("")}]+)`);
    }
    createStringRegex(stringTypes) {
        return new RegExp("^(" + this.createStringPattern(stringTypes) + ")");
    }
    // This enables the following string patterns:
    // 1. backtick quoted string using `` to escape
    // 2. square bracket quoted string (SQL Server) using ]] to escape
    // 3. double quoted string using "" or \" to escape
    // 4. single quoted string using '' or \' to escape
    // 5. national character quoted string using N'' or N\' to escape
    // 6. double quoted string using "" to escape (should not be used with number 3)
    // 7. single quoted string using '' to escape (should not be used with number 4)
    createStringPattern(stringTypes) {
        const patterns = {
            "``": "((`[^`]*($|`))+)",
            "[]": "((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)",
            "\"\"": "((\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*(\"|$))+)",
            "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
            "N''": "((N'[^N'\\\\]*(?:\\\\.[^N'\\\\]*)*('|$))+)",
            "X''": "((X'[^X'\\\\]*(?:\\\\.[^X'\\\\]*)*('|$))+)",
            "pascal-double": `(("[^"]*($|"))+)`,
            "pascal-single": "(('[^']*($|'))+)",
        };
        return stringTypes.map(t => patterns[t]).join("|");
    }
    createParenRegex(parens) {
        return new RegExp("^(" + parens.map(p => this.escapeParen(p)).join("|") + ")", "i");
    }
    escapeParen(paren) {
        if (paren.length === 1) {
            // A single punctuation character
            return escapeRegExp(paren);
        }
        else {
            // longer word
            return "\\b" + paren + "\\b";
        }
    }
    createPlaceholderRegex(types, pattern) {
        if (types.length == 0) {
            return undefined;
        }
        const typesRegex = types.map(escapeRegExp).join("|");
        return new RegExp(`^((?:${typesRegex})(?:${pattern}))`);
    }
    /**
     * Takes a SQL string and breaks it into tokens.
     * Each token is an object with type and value.
     *
     * @param {String} input The SQL string
     * @return {Object[]} tokens An array of tokens.
     *  @return {String} token.type
     *  @return {String} token.value
     */
    tokenize(input) {
        const tokens = [];
        let token;
        // Keep processing the string until it is empty
        while (input.length > 0) {
            // Get the next token and the token type
            token = this.getNextToken(input, token);
            if (token == undefined) {
                throw new Error(`No token found`);
            }
            // Advance the string
            input = input.substring(token.value.length);
            tokens.push(token);
        }
        return tokens;
    }
    getNextToken(input, previousToken) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getWhitespaceToken(input) ||
            this.getCommentToken(input) ||
            this.getStringToken(input) ||
            this.getOpenParenToken(input) ||
            this.getCloseParenToken(input) ||
            this.getPlaceholderToken(input) ||
            this.getNumberToken(input) ||
            this.getReservedWordToken(input, previousToken) ||
            this.getWordToken(input) ||
            this.getOperatorToken(input);
    }
    getWhitespaceToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.WHITESPACE,
            regex: this.WHITESPACE_REGEX
        });
    }
    getCommentToken(input) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getLineCommentToken(input) || this.getBlockCommentToken(input);
    }
    getLineCommentToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.LINE_COMMENT,
            regex: this.LINE_COMMENT_REGEX
        });
    }
    getBlockCommentToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.BLOCK_COMMENT,
            regex: this.BLOCK_COMMENT_REGEX
        });
    }
    getStringToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.STRING,
            regex: this.STRING_REGEX
        });
    }
    getOpenParenToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.OPEN_PAREN,
            regex: this.OPEN_PAREN_REGEX
        });
    }
    getCloseParenToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.CLOSE_PAREN,
            regex: this.CLOSE_PAREN_REGEX
        });
    }
    getPlaceholderToken(input) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getIdentNamedPlaceholderToken(input) ||
            this.getStringNamedPlaceholderToken(input) ||
            this.getIndexedPlaceholderToken(input);
    }
    getIdentNamedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.IDENT_NAMED_PLACEHOLDER_REGEX,
            parseKey: (v) => v.slice(1)
        });
    }
    getStringNamedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.STRING_NAMED_PLACEHOLDER_REGEX,
            parseKey: (v) => this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) })
        });
    }
    getIndexedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.INDEXED_PLACEHOLDER_REGEX,
            parseKey: (v) => v.slice(1)
        });
    }
    getPlaceholderTokenWithKey({ input, regex, parseKey }) {
        const token = this.getTokenOnFirstMatch({ input, regex, type: TokenType_1.TokenType.PLACEHOLDER });
        if (token == undefined) {
            return undefined;
        }
        token.key = parseKey(token.value);
        return token;
    }
    getEscapedPlaceholderKey({ key, quoteChar }) {
        return key.replace(new RegExp(escapeRegExp("\\") + quoteChar, "g"), quoteChar);
    }
    // Decimal, binary, or hex numbers
    getNumberToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.NUMBER,
            regex: this.NUMBER_REGEX
        });
    }
    // Punctuation and symbols
    getOperatorToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.OPERATOR,
            regex: this.OPERATOR_REGEX
        });
    }
    getReservedWordToken(input, previousToken) {
        // A reserved word cannot be preceded by a "."
        // this makes it so in "mytable.from", "from" is not considered a reserved word
        if (previousToken != undefined && previousToken.value === ".") {
            return;
        }
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        this.getToplevelReservedToken(input) ||
            this.getNewlineReservedToken(input) ||
            this.getPreNewlineReservedToken(input) ||
            this.getPlainReservedToken(input));
    }
    getToplevelReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_TOPLEVEL,
            regex: this.RESERVED_TOPLEVEL_REGEX
        });
    }
    getNewlineReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_NEWLINE,
            regex: this.RESERVED_NEWLINE_REGEX
        });
    }
    getPreNewlineReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_PRE_NEWLINE,
            regex: this.RESERVED_PRE_NEWLINE_REGEX
        });
    }
    getPlainReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED,
            regex: this.RESERVED_PLAIN_REGEX
        });
    }
    getWordToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.WORD,
            regex: this.WORD_REGEX
        });
    }
    getTokenOnFirstMatch({ input, type, regex }) {
        const matches = (regex == undefined) ?
            undefined :
            input.match(regex);
        if (matches == undefined) {
            return undefined;
        }
        const value = matches[1];
        if (value == undefined) {
            throw new Error(`No value found; is the regex missing a capture group?`);
        }
        return { type, value };
    }
}
exports.Tokenizer = Tokenizer;
//# sourceMappingURL=Tokenizer.js.map

/***/ }),

/***/ "../tsql/dist/formatter/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/formatter/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./Formatter */ "../tsql/dist/formatter/Formatter.js"));
__export(__webpack_require__(/*! ./Indentation */ "../tsql/dist/formatter/Indentation.js"));
__export(__webpack_require__(/*! ./InlineBlock */ "../tsql/dist/formatter/InlineBlock.js"));
__export(__webpack_require__(/*! ./Params */ "../tsql/dist/formatter/Params.js"));
__export(__webpack_require__(/*! ./SqlFormatter */ "../tsql/dist/formatter/SqlFormatter.js"));
__export(__webpack_require__(/*! ./Tokenizer */ "../tsql/dist/formatter/Tokenizer.js"));
__export(__webpack_require__(/*! ./TokenType */ "../tsql/dist/formatter/TokenType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/from-clause/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FromClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/from-clause/util/index.js");
exports.FromClauseUtil = FromClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/constructor/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/from-clause/util/constructor/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./new-instance */ "../tsql/dist/from-clause/util/constructor/new-instance.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/constructor/new-instance.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/from-clause/util/constructor/new-instance.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function newInstance() {
    const result = {
        outerQueryJoins: undefined,
        currentJoins: undefined,
    };
    return result;
}
exports.newInstance = newInstance;
//# sourceMappingURL=new-instance.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/from-clause/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/from-clause/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/from-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/from-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/from-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/correlate.js":
/*!************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/correlate.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function correlate(fromClause) {
    return {
        outerQueryJoins: (fromClause.outerQueryJoins == undefined && fromClause.currentJoins == undefined ?
            undefined :
            [
                ...(fromClause.outerQueryJoins == undefined ?
                    [] :
                    fromClause.outerQueryJoins),
                ...(fromClause.currentJoins == undefined ?
                    [] :
                    fromClause.currentJoins),
            ]),
        currentJoins: undefined,
    };
}
exports.correlate = correlate;
//# sourceMappingURL=correlate.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/cross-join.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/cross-join.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
function crossJoin(fromClause, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.CROSS, undefined)),
    };
    return result;
}
exports.crossJoin = crossJoin;
//# sourceMappingURL=cross-join.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/from.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/from.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
function from(fromClause, aliasedTable) {
    predicate_1.assertBeforeFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: [
            join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.FROM, undefined)
        ],
    };
    return result;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./correlate */ "../tsql/dist/from-clause/util/operation/correlate.js"));
__export(__webpack_require__(/*! ./cross-join */ "../tsql/dist/from-clause/util/operation/cross-join.js"));
__export(__webpack_require__(/*! ./from */ "../tsql/dist/from-clause/util/operation/from.js"));
__export(__webpack_require__(/*! ./inner-join-using-candidate-key */ "../tsql/dist/from-clause/util/operation/inner-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./inner-join-using-primary-key */ "../tsql/dist/from-clause/util/operation/inner-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./inner-join */ "../tsql/dist/from-clause/util/operation/inner-join.js"));
__export(__webpack_require__(/*! ./left-join-using-candidate-key */ "../tsql/dist/from-clause/util/operation/left-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./left-join-using-primary-key */ "../tsql/dist/from-clause/util/operation/left-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./left-join */ "../tsql/dist/from-clause/util/operation/left-join.js"));
__export(__webpack_require__(/*! ./require-nullable-outer-query-joins */ "../tsql/dist/from-clause/util/operation/require-nullable-outer-query-joins.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins-impl */ "../tsql/dist/from-clause/util/operation/require-outer-query-joins-impl.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins */ "../tsql/dist/from-clause/util/operation/require-outer-query-joins.js"));
__export(__webpack_require__(/*! ./where-eq-candidate-key */ "../tsql/dist/from-clause/util/operation/where-eq-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-columns */ "../tsql/dist/from-clause/util/operation/where-eq-columns.js"));
__export(__webpack_require__(/*! ./where-eq-inner-query-primary-key */ "../tsql/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-candidate-key */ "../tsql/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-primary-key */ "../tsql/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-primary-key */ "../tsql/dist/from-clause/util/operation/where-eq-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-super-key */ "../tsql/dist/from-clause/util/operation/where-eq-super-key.js"));
__export(__webpack_require__(/*! ./where-eq */ "../tsql/dist/from-clause/util/operation/where-eq.js"));
__export(__webpack_require__(/*! ./where-is-not-null */ "../tsql/dist/from-clause/util/operation/where-is-not-null.js"));
__export(__webpack_require__(/*! ./where-is-null */ "../tsql/dist/from-clause/util/operation/where-is-null.js"));
__export(__webpack_require__(/*! ./where-null-safe-eq */ "../tsql/dist/from-clause/util/operation/where-null-safe-eq.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/inner-join-using-candidate-key.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/inner-join-using-candidate-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const inner_join_1 = __webpack_require__(/*! ./inner-join */ "../tsql/dist/from-clause/util/operation/inner-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .innerJoin(
 *      otherTable,
 *      () => tsql.eqCandidateKeyOfTable(
 *          myTable,
 *          otherTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      )
 *  )
 * ```
 *
 * ```sql
 *  INNER JOIN
 *      otherTable
 *  ON
 *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
 *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
 *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
 *      --snip
 * ```
 */
function innerJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = inner_join_1.innerJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
    });
    return result;
}
exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
//# sourceMappingURL=inner-join-using-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/inner-join-using-primary-key.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/inner-join-using-primary-key.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const inner_join_1 = __webpack_require__(/*! ./inner-join */ "../tsql/dist/from-clause/util/operation/inner-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .innerJoin(
 *      otherTable,
 *      () => tsql.eqPrimaryKeyOfTable(
 *          myTable,
 *          otherTable
 *      )
 *  )
 * ```
 *
 * ```sql
 *  INNER JOIN
 *      otherTable
 *  ON
 *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
 *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
 *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
 *      --snip
 * ```
 */
function innerJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = inner_join_1.innerJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
    });
    return result;
}
exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
//# sourceMappingURL=inner-join-using-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/inner-join.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/inner-join.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "../tsql/dist/on-clause/index.js");
/**
 * ```sql
 *  INNER JOIN
 *      myTable
 *  ON
 *      --condition
 * ```
 */
function innerJoin(fromClause, aliasedTable, onDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.INNER, on_clause_1.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
    };
    return result;
}
exports.innerJoin = innerJoin;
//# sourceMappingURL=inner-join.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/left-join-using-candidate-key.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/left-join-using-candidate-key.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const left_join_1 = __webpack_require__(/*! ./left-join */ "../tsql/dist/from-clause/util/operation/left-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .leftJoin(
 *      otherTable,
 *      () => tsql.eqCandidateKeyOfTable(
 *          myTable,
 *          otherTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      )
 *  )
 * ```
 *
 * ```sql
 *  LEFT JOIN
 *      otherTable
 *  ON
 *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
 *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
 *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
 *      --snip
 * ```
 */
function leftJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = left_join_1.leftJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
    });
    return result;
}
exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
//# sourceMappingURL=left-join-using-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/left-join-using-primary-key.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/left-join-using-primary-key.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const left_join_1 = __webpack_require__(/*! ./left-join */ "../tsql/dist/from-clause/util/operation/left-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .leftJoin(
 *      otherTable,
 *      () => tsql.eqPrimaryKeyOfTable(
 *          myTable,
 *          otherTable
 *      )
 *  )
 * ```
 *
 * ```sql
 *  LEFT JOIN
 *      otherTable
 *  ON
 *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
 *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
 *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
 *      --snip
 * ```
 */
function leftJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = left_join_1.leftJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
    });
    return result;
}
exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
//# sourceMappingURL=left-join-using-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/left-join.js":
/*!************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/left-join.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "../tsql/dist/on-clause/index.js");
/**
 * ```sql
 *  LEFT JOIN
 *      myTable
 *  ON
 *      --condition
 * ```
 */
function leftJoin(fromClause, aliasedTable, onDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, true, join_1.JoinType.LEFT, on_clause_1.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
    };
    return result;
}
exports.leftJoin = leftJoin;
//# sourceMappingURL=left-join.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/require-nullable-outer-query-joins.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/require-nullable-outer-query-joins.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const require_outer_query_joins_impl_1 = __webpack_require__(/*! ./require-outer-query-joins-impl */ "../tsql/dist/from-clause/util/operation/require-outer-query-joins-impl.js");
function requireNullableOuterQueryJoins(fromClause, ...aliasedTables) {
    return require_outer_query_joins_impl_1.requireOuterQueryJoinsImpl(fromClause, true, ...aliasedTables);
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
//# sourceMappingURL=require-nullable-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/require-outer-query-joins-impl.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/require-outer-query-joins-impl.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/from-clause/util/predicate/index.js");
function requireOuterQueryJoinsImpl(fromClause, nullable, ...aliasedTables) {
    if (aliasedTables.length == 0) {
        return fromClause;
    }
    predicate_1.assertValidOuterQueryJoins(fromClause, aliasedTables);
    const required = aliasedTables.map(aliasedTable => (join_1.JoinUtil.fromAliasedTable(aliasedTable, nullable, 
    /**
     * The `JoinType` does not matter for outer query joins.
     */
    join_1.JoinType.FROM, 
    /**
     * The `ON` clause doesn't matter, either.
     */
    undefined)));
    const outerQueryJoins = (fromClause.outerQueryJoins == undefined ?
        required :
        join_1.JoinArrayUtil.append(fromClause.outerQueryJoins, ...required));
    const result = {
        outerQueryJoins,
        currentJoins: fromClause.currentJoins,
    };
    return result;
}
exports.requireOuterQueryJoinsImpl = requireOuterQueryJoinsImpl;
//# sourceMappingURL=require-outer-query-joins-impl.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/require-outer-query-joins.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/require-outer-query-joins.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const require_outer_query_joins_impl_1 = __webpack_require__(/*! ./require-outer-query-joins-impl */ "../tsql/dist/from-clause/util/operation/require-outer-query-joins-impl.js");
function requireOuterQueryJoins(fromClause, ...aliasedTables) {
    return require_outer_query_joins_impl_1.requireOuterQueryJoinsImpl(fromClause, false, ...aliasedTables);
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
//# sourceMappingURL=require-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-candidate-key.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-candidate-key.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqCandidateKey(
 *          myTable,
 *          myCandidateKey
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 * -----
 *
 * Excess properties are especially dangerous for this function.
 *
 * If your `candidateKeyInput` is actually a super key of two candidate keys,
 * then the candidate key this function compares against is arbitrary.
 *
 * The extra properties will be discarded.
 *
 * If you want to compare against a super key, use `whereEqSuperKey()` instead.
 *
 */
function whereEqCandidateKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqCandidateKeyDelegate = args[0];
    const candidateKey = args[1];
    const table = whereEqCandidateKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqCandidateKey(table, candidateKey)),
    };
    return result;
}
exports.whereEqCandidateKey = whereEqCandidateKey;
//# sourceMappingURL=where-eq-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-columns.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-columns.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqColumns(
 *          myTable,
 *          myColumns
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqColumns(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqColumnsDelegate = args[0];
    const columns = args[1];
    /**
     * @todo Investigate assignability
     */
    const table = whereEqColumnsDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqColumns(table, 
        /**
         * @todo Investigate assignability
         */
        columns)),
    };
    return result;
}
exports.whereEqColumns = whereEqColumns;
//# sourceMappingURL=where-eq-columns.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKeyOfTable(
 *          outerQueryTable,
 *          currentQueryTable
 *      ));
 * ```
 * -----
 *
 * + The `outerQueryTable` does not need to have keys.
 * + The `currentQueryTable` must have a primary key.
 * + The `outerQueryTable` must have columns comparable to columns of `currentQueryTable`'s primary key.
 */
function whereEqInnerQueryPrimaryKey(fromClause, whereClause, srcDelegate, dstDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.outerQueryJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.currentJoins, src.columns)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
    };
    return result;
}
exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
//# sourceMappingURL=where-eq-inner-query-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqCandidateKeyOfTable(
 *          currentQueryTable,
 *          outerQueryTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      ));
 * ```
 * -----
 *
 * + The `currentQueryTable` does not need to have keys.
 * + The `outerQueryTable` must have at least one candidate key.
 * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s candidate key.
 */
function whereEqOuterQueryCandidateKey(fromClause, whereClause, 
/**
 * @todo Remove this
 */
eqCandidateKeyOfTable, srcDelegate, dstDelegate, eqCandidateKeyOfTableDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.outerQueryJoins)));
    ;
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => eqCandidateKeyOfTable(src, dst, eqCandidateKeyOfTableDelegate)),
    };
    return result;
}
exports.whereEqOuterQueryCandidateKey = whereEqOuterQueryCandidateKey;
//# sourceMappingURL=where-eq-outer-query-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKeyOfTable(
 *          currentQueryTable,
 *          outerQueryTable
 *      ));
 * ```
 * -----
 *
 * + The `currentQueryTable` does not need to have keys.
 * + The `outerQueryTable` must have a primary key.
 * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s primary key.
 */
function whereEqOuterQueryPrimaryKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for
 * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
srcDelegate, dstDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.outerQueryJoins, src.columns)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
    };
    return result;
}
exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
//# sourceMappingURL=where-eq-outer-query-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-primary-key.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-primary-key.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKey(
 *          myTable,
 *          myPrimaryKey
 *      ));
 * ```
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqPrimaryKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqPrimaryKeyDelegate = args[0];
    const primaryKey = args[1];
    const table = whereEqPrimaryKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithPrimaryKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKey(table, 
        /**
         * @todo Investigate assignability
         */
        primaryKey)),
    };
    return result;
}
exports.whereEqPrimaryKey = whereEqPrimaryKey;
//# sourceMappingURL=where-eq-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq-super-key.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq-super-key.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "../tsql/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqSuperKey(
 *          myTable,
 *          mySuperKey
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqSuperKey(fromClause, whereClause, 
/**
 * @todo Remove this
 */
eqSuperKey, 
/**
 * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqSuperKeyDelegate = args[0];
    const superKey = args[1];
    const table = whereEqSuperKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => eqSuperKey(table, superKey)),
    };
    return result;
}
exports.whereEqSuperKey = whereEqSuperKey;
//# sourceMappingURL=where-eq-super-key.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-eq.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-eq.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
/**
 * Narrows a column's type based on equality to a value
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn = 1
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `1`.
 */
function whereEq(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqDelegate = args[0];
    const value = args[1];
    const columns = column_ref_1.ColumnRefUtil.extractNonNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereEqDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
            /**
             * Cast to the type of `ValueT`
             */
            /*
            tm.or(
                BuiltInExprUtil.mapper(value),
                tm.pipe(
                    column.mapper,
                    BuiltInExprUtil.mapper(value)
                )
            )*/
            column.mapper),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eq(column, built_in_expr_1.BuiltInExprUtil.fromValueExpr(column, value))),
    };
    return result;
}
exports.whereEq = whereEq;
//# sourceMappingURL=where-eq.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-is-not-null.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-is-not-null.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
/**
 * Narrows a column's type to **exclude** `null`
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn IS NOT NULL
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set **WILL NOT** be `null`.
 */
function whereIsNotNull(fromClause, whereClause, whereIsNotNullDelegate) {
    const columns = column_ref_1.ColumnRefUtil.extractNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereIsNotNullDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.excludeLiteral(column.mapper, null)),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.isNotNull(column)),
    };
    return result;
}
exports.whereIsNotNull = whereIsNotNull;
//# sourceMappingURL=where-is-not-null.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-is-null.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-is-null.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
/**
 * Narrows a column's type to `null`
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn IS NULL
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `null`.
 */
function whereIsNull(fromClause, whereClause, whereIsNullDelegate) {
    const columns = column_ref_1.ColumnRefUtil.extractNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereIsNullDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.null()),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.isNull(column)),
    };
    return result;
}
exports.whereIsNull = whereIsNull;
//# sourceMappingURL=where-is-null.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/operation/where-null-safe-eq.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/operation/where-null-safe-eq.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
/**
 * Narrows a column's type based on null-safe equality to a value
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn <=> 1
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `1`.
 */
function whereNullSafeEq(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereNullSafeEqDelegate = args[0];
    const value = args[1];
    const columns = column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins));
    const column = whereNullSafeEqDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
            /**
             * Cast to the type of `ValueT`
             */
            /*
            tm.or(
                BuiltInExprUtil.mapper(value),
                tm.pipe(
                    column.mapper,
                    BuiltInExprUtil.mapper(value)
                )
            )*/
            column.mapper),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.nullSafeEq(column, built_in_expr_1.BuiltInExprUtil.fromValueExpr(column_1.ColumnUtil.toNullable(column), value))),
    };
    return result;
}
exports.whereNullSafeEq = whereNullSafeEq;
//# sourceMappingURL=where-null-safe-eq.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/allowed-used-ref.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/allowed-used-ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function allowedJoinArray(fromClause, aliasedTable) {
    return [
        ...((fromClause.outerQueryJoins != undefined) ?
            fromClause.outerQueryJoins :
            []),
        ...((aliasedTable.isLateral && fromClause.currentJoins != undefined) ?
            fromClause.currentJoins :
            []),
    ];
}
exports.allowedJoinArray = allowedJoinArray;
function allowedColumnRef(fromClause, aliasedTable) {
    return column_ref_1.ColumnRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedColumnRef = allowedColumnRef;
function allowedColumnIdentifierRef(fromClause, aliasedTable) {
    return column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
function allowedUsedRef(fromClause, aliasedTable) {
    return used_ref_1.UsedRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-after-from-clause.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-after-from-clause.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertAfterFromClause(fromClause) {
    if (fromClause.currentJoins == undefined) {
        throw new Error(`Must be after FROM clause`);
    }
}
exports.assertAfterFromClause = assertAfterFromClause;
//# sourceMappingURL=assert-after-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-before-from-clause.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-before-from-clause.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertBeforeFromClause(fromClause) {
    if (fromClause.currentJoins != undefined) {
        throw new Error(`Must be before FROM clause`);
    }
}
exports.assertBeforeFromClause = assertBeforeFromClause;
//# sourceMappingURL=assert-before-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-no-used-ref.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-no-used-ref.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNoUsedRef(aliasedTable) {
    if (Object.keys(aliasedTable.usedRef.columns).length > 0) {
        throw new Error(`Derived table ${aliasedTable.alias} must not reference outer query tables or tables in the same FROM/JOIN clause`);
    }
}
exports.assertNoUsedRef = assertNoUsedRef;
//# sourceMappingURL=assert-no-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-not-in-current-joins.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-not-in-current-joins.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotInCurrentJoins(fromClause, aliasedTable) {
    if (fromClause.currentJoins != undefined) {
        if (fromClause.currentJoins.some(j => j.tableAlias == aliasedTable.alias)) {
            throw new Error(`Table alias ${aliasedTable.alias} already used in current query JOINs`);
        }
    }
}
exports.assertNotInCurrentJoins = assertNotInCurrentJoins;
//# sourceMappingURL=assert-not-in-current-joins.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotInOuterQueryJoins(fromClause, aliasedTable) {
    if (fromClause.outerQueryJoins != undefined) {
        if (fromClause.outerQueryJoins.some(j => j.tableAlias == aliasedTable.alias)) {
            throw new Error(`Table alias ${aliasedTable.alias} already used in outer query JOINs`);
        }
    }
}
exports.assertNotInOuterQueryJoins = assertNotInOuterQueryJoins;
//# sourceMappingURL=assert-not-in-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-not-lateral.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-not-lateral.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotLateral(aliasedTable) {
    if (aliasedTable.isLateral) {
        throw new Error(`${aliasedTable.alias} cannot be LATERAL; does your DBMS support it?`);
    }
}
exports.assertNotLateral = assertNotLateral;
//# sourceMappingURL=assert-not-lateral.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-valid-current-join-base.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-valid-current-join-base.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_not_in_current_joins_1 = __webpack_require__(/*! ./assert-not-in-current-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-current-joins.js");
const assert_not_in_outer_query_joins_1 = __webpack_require__(/*! ./assert-not-in-outer-query-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js");
const allowed_used_ref_1 = __webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/from-clause/util/predicate/allowed-used-ref.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function assertValidCurrentJoinBase(fromClause, aliasedTable) {
    assert_not_in_current_joins_1.assertNotInCurrentJoins(fromClause, aliasedTable);
    assert_not_in_outer_query_joins_1.assertNotInOuterQueryJoins(fromClause, aliasedTable);
    used_ref_1.UsedRefUtil.assertAllowed(allowed_used_ref_1.allowedUsedRef(fromClause, aliasedTable), aliasedTable.usedRef);
}
exports.assertValidCurrentJoinBase = assertValidCurrentJoinBase;
//# sourceMappingURL=assert-valid-current-join-base.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_not_in_current_joins_1 = __webpack_require__(/*! ./assert-not-in-current-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-current-joins.js");
const assert_not_in_outer_query_joins_1 = __webpack_require__(/*! ./assert-not-in-outer-query-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js");
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "../tsql/dist/aliased-table/index.js");
function assertValidOuterQueryJoins(fromClause, aliasedTables) {
    for (const aliasedTable of aliasedTables) {
        assert_not_in_current_joins_1.assertNotInCurrentJoins(fromClause, aliasedTable);
        assert_not_in_outer_query_joins_1.assertNotInOuterQueryJoins(fromClause, aliasedTable);
    }
    aliased_table_1.AliasedTableArrayUtil.assertNoDuplicateTableAlias(aliasedTables);
}
exports.assertValidOuterQueryJoins = assertValidOuterQueryJoins;
//# sourceMappingURL=assert-valid-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/from-clause/util/predicate/allowed-used-ref.js"));
__export(__webpack_require__(/*! ./assert-after-from-clause */ "../tsql/dist/from-clause/util/predicate/assert-after-from-clause.js"));
__export(__webpack_require__(/*! ./assert-before-from-clause */ "../tsql/dist/from-clause/util/predicate/assert-before-from-clause.js"));
__export(__webpack_require__(/*! ./assert-no-used-ref */ "../tsql/dist/from-clause/util/predicate/assert-no-used-ref.js"));
__export(__webpack_require__(/*! ./assert-not-in-current-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-current-joins.js"));
__export(__webpack_require__(/*! ./assert-not-in-outer-query-joins */ "../tsql/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js"));
__export(__webpack_require__(/*! ./assert-not-lateral */ "../tsql/dist/from-clause/util/predicate/assert-not-lateral.js"));
__export(__webpack_require__(/*! ./assert-valid-current-join-base */ "../tsql/dist/from-clause/util/predicate/assert-valid-current-join-base.js"));
__export(__webpack_require__(/*! ./assert-valid-outer-query-joins */ "../tsql/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js"));
__export(__webpack_require__(/*! ./is-after-from-clause */ "../tsql/dist/from-clause/util/predicate/is-after-from-clause.js"));
__export(__webpack_require__(/*! ./is-before-from-clause */ "../tsql/dist/from-clause/util/predicate/is-before-from-clause.js"));
__export(__webpack_require__(/*! ./is-from-clause */ "../tsql/dist/from-clause/util/predicate/is-from-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/is-after-from-clause.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/is-after-from-clause.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_from_clause_1 = __webpack_require__(/*! ./is-from-clause */ "../tsql/dist/from-clause/util/predicate/is-from-clause.js");
function isAfterFromClause(x) {
    return is_from_clause_1.isFromClause(x) && (x.currentJoins != undefined);
}
exports.isAfterFromClause = isAfterFromClause;
//# sourceMappingURL=is-after-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/is-before-from-clause.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/is-before-from-clause.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_from_clause_1 = __webpack_require__(/*! ./is-from-clause */ "../tsql/dist/from-clause/util/predicate/is-from-clause.js");
function isBeforeFromClause(x) {
    return is_from_clause_1.isFromClause(x) && (x.currentJoins == undefined);
}
exports.isBeforeFromClause = isBeforeFromClause;
//# sourceMappingURL=is-before-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/predicate/is-from-clause.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/from-clause/util/predicate/is-from-clause.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Only checks that the properties exist.
 * Does not actually check that they are the right data type!
 *
 * @todo Consider adding checks for increased type safety.
 */
function isFromClause(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "outerQueryJoins",
        "currentJoins",
    ])) {
        return false;
    }
    return true;
}
exports.isFromClause = isFromClause;
//# sourceMappingURL=is-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/query/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/from-clause/util/query/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./outer-query-table-alias */ "../tsql/dist/from-clause/util/query/outer-query-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/from-clause/util/query/outer-query-table-alias.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/from-clause/util/query/outer-query-table-alias.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function outerQueryTableAlias(fromClause) {
    if (fromClause.outerQueryJoins == undefined) {
        return [];
    }
    else {
        return fromClause.outerQueryJoins.map(join => join.tableAlias);
    }
}
exports.outerQueryTableAlias = outerQueryTableAlias;
//# sourceMappingURL=outer-query-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/group-by-clause/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupByClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/group-by-clause/util/index.js");
exports.GroupByClauseUtil = GroupByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/group-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/group-by-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/group-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/operation/group-by.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/operation/group-by.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/group-by-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
/**
 * Returns the MySQL equivalent of `...groupByClause, ...groupByDelegate(columns)`
 *
 * -----
 *
 * Consider the following,
 * ```sql
 *  SELECT 1 AS a GROUP BY a
 * ```
 *
 * + The above works on PostgreSQL 9.4
 * + The above **does not** work on MySQL 5.7
 * -----
 *
 * We only allow `GROUP BY` after the `FROM` clause because
 * it isn't very useful without a `FROM` clause.
 *
 * @param fromClause
 * @param selectClause
 * @param groupByClause
 * @param groupByDelegate
 */
function groupBy(fromClause, groupByClause, groupByDelegate) {
    from_clause_1.FromClauseUtil.assertAfterFromClause(fromClause);
    const columns = query_1.allowedColumnIdentifierRef(fromClause);
    const groupBy = groupByDelegate(column_identifier_ref_1.ColumnIdentifierRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(columns, groupBy);
    return (groupByClause == undefined ?
        groupBy :
        [...groupByClause, ...groupBy]);
}
exports.groupBy = groupBy;
//# sourceMappingURL=group-by.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/operation/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/operation/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./group-by */ "../tsql/dist/group-by-clause/util/operation/group-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/predicate/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/predicate/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-non-empty */ "../tsql/dist/group-by-clause/util/predicate/is-non-empty.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/predicate/is-non-empty.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/predicate/is-non-empty.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNonEmpty(groupByClause) {
    if (groupByClause.length == 0) {
        throw new Error(`GROUP BY clause cannot be empty`);
    }
}
exports.assertNonEmpty = assertNonEmpty;
//# sourceMappingURL=is-non-empty.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/query/allowed-used-ref.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/query/allowed-used-ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function allowedColumnIdentifierRef(fromClause) {
    return column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(fromClause.currentJoins);
}
exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/group-by-clause/util/query/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/group-by-clause/util/query/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/group-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/having-clause/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const HavingClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/having-clause/util/index.js");
exports.HavingClauseUtil = HavingClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/having-clause/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/having-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/having-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/operation/having.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/having-clause/util/operation/having.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/having-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const group_by_clause_1 = __webpack_require__(/*! ../../../group-by-clause */ "../tsql/dist/group-by-clause/index.js");
/**
 * Returns the MySQL equivalent of `havingClause AND havingDelegate(columns)`
 *
 * -----
 *
 * For now, this is basically the same as `WhereClauseUtil.where<>()`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 *
 * -----
 *
 * @param fromClause
 * @param havingClause
 * @param havingDelegate
 */
function having(fromClause, groupByClause, havingClause, havingDelegate) {
    group_by_clause_1.GroupByClauseUtil.assertNonEmpty(groupByClause);
    const columns = query_1.allowedColumnRef(fromClause);
    const operand = havingDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    if (built_in_expr_1.BuiltInExprUtil.isAggregate(operand)) {
        used_ref_1.UsedRefUtil.assertAllowed({ columns }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    }
    else {
        used_ref_1.UsedRefUtil.assertAllowed({
            columns: query_1.allowedNonAggregateColumnRef(fromClause, groupByClause),
        }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    }
    return (havingClause == undefined ?
        expr_1.ExprUtil.fromBuiltInExpr(operand) :
        ExprLib.and(havingClause, operand));
}
exports.having = having;
//# sourceMappingURL=having.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/having-clause/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./having */ "../tsql/dist/having-clause/util/operation/having.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause) {
    const outer = column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    return column_ref_1.ColumnRefUtil.intersect(outer, inner);
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause) {
    return used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/query/allowed-used-ref.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/having-clause/util/query/allowed-used-ref.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
/**
 * For now, this is basically the same as `WhereClauseUtil.AllowedColumnRef<>`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 */
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
/**
 * For now, this is basically the same as `WhereClauseUtil.AllowedUsedRef<>`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 */
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/having-clause/util/query/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/having-clause/util/query/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "../tsql/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/having-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/index.js":
/*!*****************************!*\
  !*** ../tsql/dist/index.js ***!
  \*****************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-expr */ "../tsql/dist/aliased-expr/index.js"));
__export(__webpack_require__(/*! ./aliased-table */ "../tsql/dist/aliased-table/index.js"));
__export(__webpack_require__(/*! ./ast */ "../tsql/dist/ast/index.js"));
__export(__webpack_require__(/*! ./built-in-expr */ "../tsql/dist/built-in-expr/index.js"));
__export(__webpack_require__(/*! ./built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js"));
__export(__webpack_require__(/*! ./candidate-key */ "../tsql/dist/candidate-key/index.js"));
__export(__webpack_require__(/*! ./column */ "../tsql/dist/column/index.js"));
__export(__webpack_require__(/*! ./column-identifier */ "../tsql/dist/column-identifier/index.js"));
__export(__webpack_require__(/*! ./column-identifier-map */ "../tsql/dist/column-identifier-map/index.js"));
__export(__webpack_require__(/*! ./column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js"));
__export(__webpack_require__(/*! ./column-map */ "../tsql/dist/column-map/index.js"));
__export(__webpack_require__(/*! ./column-ref */ "../tsql/dist/column-ref/index.js"));
__export(__webpack_require__(/*! ./compound-query */ "../tsql/dist/compound-query/index.js"));
__export(__webpack_require__(/*! ./compound-query-clause */ "../tsql/dist/compound-query-clause/index.js"));
__export(__webpack_require__(/*! ./compound-query-order-by-clause */ "../tsql/dist/compound-query-order-by-clause/index.js"));
__export(__webpack_require__(/*! ./custom-expr */ "../tsql/dist/custom-expr/index.js"));
__export(__webpack_require__(/*! ./data-type */ "../tsql/dist/data-type/index.js"));
__export(__webpack_require__(/*! ./derived-table */ "../tsql/dist/derived-table/index.js"));
__export(__webpack_require__(/*! ./derived-table-select-item */ "../tsql/dist/derived-table-select-item/index.js"));
__export(__webpack_require__(/*! ./design-pattern-log */ "../tsql/dist/design-pattern-log/index.js"));
__export(__webpack_require__(/*! ./design-pattern-table-per-type */ "../tsql/dist/design-pattern-table-per-type/index.js"));
__export(__webpack_require__(/*! ./event */ "../tsql/dist/event/index.js"));
__export(__webpack_require__(/*! ./execution */ "../tsql/dist/execution/index.js"));
__export(__webpack_require__(/*! ./expr */ "../tsql/dist/expr/index.js"));
__export(__webpack_require__(/*! ./expr-column */ "../tsql/dist/expr-column/index.js"));
__export(__webpack_require__(/*! ./expr-library */ "../tsql/dist/expr-library/index.js"));
__export(__webpack_require__(/*! ./expr-select-item */ "../tsql/dist/expr-select-item/index.js"));
__export(__webpack_require__(/*! ./from-clause */ "../tsql/dist/from-clause/index.js"));
__export(__webpack_require__(/*! ./group-by-clause */ "../tsql/dist/group-by-clause/index.js"));
__export(__webpack_require__(/*! ./having-clause */ "../tsql/dist/having-clause/index.js"));
__export(__webpack_require__(/*! ./insert */ "../tsql/dist/insert/index.js"));
__export(__webpack_require__(/*! ./insert-select */ "../tsql/dist/insert-select/index.js"));
__export(__webpack_require__(/*! ./join */ "../tsql/dist/join/index.js"));
__export(__webpack_require__(/*! ./join-map */ "../tsql/dist/join-map/index.js"));
__export(__webpack_require__(/*! ./key */ "../tsql/dist/key/index.js"));
__export(__webpack_require__(/*! ./limit-clause */ "../tsql/dist/limit-clause/index.js"));
__export(__webpack_require__(/*! ./map-delegate */ "../tsql/dist/map-delegate/index.js"));
__export(__webpack_require__(/*! ./mapper-map */ "../tsql/dist/mapper-map/index.js"));
__export(__webpack_require__(/*! ./on-clause */ "../tsql/dist/on-clause/index.js"));
__export(__webpack_require__(/*! ./order */ "../tsql/dist/order/index.js"));
__export(__webpack_require__(/*! ./order-by-clause */ "../tsql/dist/order-by-clause/index.js"));
__export(__webpack_require__(/*! ./partial-row */ "../tsql/dist/partial-row/index.js"));
__export(__webpack_require__(/*! ./primary-key */ "../tsql/dist/primary-key/index.js"));
__export(__webpack_require__(/*! ./query-base */ "../tsql/dist/query-base/index.js"));
__export(__webpack_require__(/*! ./row */ "../tsql/dist/row/index.js"));
__export(__webpack_require__(/*! ./schema-validation */ "../tsql/dist/schema-validation/index.js"));
__export(__webpack_require__(/*! ./select-clause */ "../tsql/dist/select-clause/index.js"));
__export(__webpack_require__(/*! ./select-item */ "../tsql/dist/select-item/index.js"));
__export(__webpack_require__(/*! ./sort-direction */ "../tsql/dist/sort-direction/index.js"));
__export(__webpack_require__(/*! ./super-key */ "../tsql/dist/super-key/index.js"));
__export(__webpack_require__(/*! ./sqlstring */ "../tsql/dist/sqlstring/index.js"));
__export(__webpack_require__(/*! ./table */ "../tsql/dist/table/index.js"));
__export(__webpack_require__(/*! ./table-where */ "../tsql/dist/table-where/index.js"));
__export(__webpack_require__(/*! ./type-map */ "../tsql/dist/type-map/index.js"));
__export(__webpack_require__(/*! ./type-ref */ "../tsql/dist/type-ref/index.js"));
__export(__webpack_require__(/*! ./unified-query */ "../tsql/dist/unified-query/index.js"));
__export(__webpack_require__(/*! ./update */ "../tsql/dist/update/index.js"));
__export(__webpack_require__(/*! ./used-ref */ "../tsql/dist/used-ref/index.js"));
__export(__webpack_require__(/*! ./value-expr */ "../tsql/dist/value-expr/index.js"));
__export(__webpack_require__(/*! ./where-clause */ "../tsql/dist/where-clause/index.js"));
__export(__webpack_require__(/*! ./async-queue */ "../tsql/dist/async-queue.js"));
__export(__webpack_require__(/*! ./constants */ "../tsql/dist/constants.js"));
__export(__webpack_require__(/*! ./error */ "../tsql/dist/error/index.js"));
__export(__webpack_require__(/*! ./isolation-level */ "../tsql/dist/isolation-level.js"));
__export(__webpack_require__(/*! ./operator-type */ "../tsql/dist/operator-type.js"));
__export(__webpack_require__(/*! ./transaction-access-mode */ "../tsql/dist/transaction-access-mode.js"));
__export(__webpack_require__(/*! ./type-hint */ "../tsql/dist/type-hint.js"));
const DateTimeUtil = __webpack_require__(/*! ./date-time-util */ "../tsql/dist/date-time-util/index.js");
exports.DateTimeUtil = DateTimeUtil;
const FormatUtil = __webpack_require__(/*! ./formatter */ "../tsql/dist/formatter/index.js");
exports.FormatUtil = FormatUtil;
const PromiseUtil = __webpack_require__(/*! ./promise-util */ "../tsql/dist/promise-util/index.js");
exports.PromiseUtil = PromiseUtil;
const TupleUtil = __webpack_require__(/*! ./tuple-util */ "../tsql/dist/tuple-util/index.js");
exports.TupleUtil = TupleUtil;
const TypeUtil = __webpack_require__(/*! ./type-util */ "../tsql/dist/type-util/index.js");
exports.TypeUtil = TypeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/insert-select/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InsertSelectUtil = __webpack_require__(/*! ./util */ "../tsql/dist/insert-select/util/index.js");
exports.InsertSelectUtil = InsertSelectUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/constructor/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/insert-select/util/constructor/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-select */ "../tsql/dist/insert-select/util/constructor/insert-select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/constructor/insert-select.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/insert-select/util/constructor/insert-select.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/insert-select/util/operation/index.js");
function insertSelect(query, table, delegate) {
    const columns = column_ref_1.ColumnRefUtil.tryFlatten(column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause));
    const row = delegate(columns);
    return operation_1.cleanInsertSelectRow(query, table, row);
}
exports.insertSelect = insertSelect;
//# sourceMappingURL=insert-select.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/insert-select/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/insert-select/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/insert-select/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/operation/clean-insert-select-column.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/insert-select/util/operation/clean-insert-select-column.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function cleanInsertSelectColumn(allowedColumnRef, table, row, columnAlias, required) {
    const customExpr = (
    /**
     * This is just safer.
     *
     * But how regularly should we access properties of mapped types this way?
     * All the time?
     * If so, why?
     *
     * Sometimes?
     * If so, what's the criteria?
     *
     * @todo Figure this out
     */
    (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
        row[columnAlias] :
        undefined);
    if (customExpr === undefined) {
        if (required) {
            throw new error_1.MissingRequiredInsertColumnError({
                message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                table,
                columnAlias
            });
        }
        else {
            return undefined;
        }
    }
    if (column_1.ColumnUtil.isColumn(customExpr)) {
        if (!column_identifier_ref_1.ColumnIdentifierRefUtil.hasColumnIdentifier(allowedColumnRef, customExpr)) {
            throw new Error(`Invalid SELECT alias ${customExpr.tableAlias}.${customExpr.columnAlias}`);
        }
        return customExpr;
    }
    else if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
        return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
    }
    else if (built_in_expr_1.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
        /**
         * Can't really perform many checks here.
         * We can, however, check for `NULL`s.
         */
        if (query_base_1.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
            !tm.canOutputNull(table.columns[columnAlias].mapper)) {
            throw new error_1.PotentialNullInRequiredInsertColumnError({
                message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                table,
                columnAlias
            });
        }
        return customExpr;
    }
    else {
        /**
         * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
         */
        if (expr_1.ExprUtil.isExpr(customExpr) ||
            expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
            /**
             * @todo Should we validate these?
             * How would one even do that?
             */
            return customExpr;
        }
        /**
         * Maybe a custom data type?
         */
        return built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
    }
}
exports.cleanInsertSelectColumn = cleanInsertSelectColumn;
//# sourceMappingURL=clean-insert-select-column.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/operation/clean-insert-select-row.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/insert-select/util/operation/clean-insert-select-row.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const clean_insert_select_column_1 = __webpack_require__(/*! ./clean-insert-select-column */ "../tsql/dist/insert-select/util/operation/clean-insert-select-column.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
/**
 * + Removes excess properties.
 * + Removes properties with value `undefined`.
 * + Checks required properties are there.
 */
function cleanInsertSelectRow(query, table, row) {
    const allowedColumnRef = column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause);
    const result = {};
    for (const requiredColumnAlias of table_1.TableUtil.requiredColumnAlias(table)) {
        result[requiredColumnAlias] = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, requiredColumnAlias, true);
    }
    for (const optionalColumnAlias of table_1.TableUtil.optionalColumnAlias(table)) {
        const value = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, optionalColumnAlias, false);
        if (value === undefined) {
            continue;
        }
        result[optionalColumnAlias] = value;
    }
    return result;
}
exports.cleanInsertSelectRow = cleanInsertSelectRow;
//# sourceMappingURL=clean-insert-select-row.js.map

/***/ }),

/***/ "../tsql/dist/insert-select/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/insert-select/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-select-column */ "../tsql/dist/insert-select/util/operation/clean-insert-select-column.js"));
__export(__webpack_require__(/*! ./clean-insert-select-row */ "../tsql/dist/insert-select/util/operation/clean-insert-select-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert/index.js":
/*!************************************!*\
  !*** ../tsql/dist/insert/index.js ***!
  \************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InsertUtil = __webpack_require__(/*! ./util */ "../tsql/dist/insert/util/index.js");
exports.InsertUtil = InsertUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert/util/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/insert/util/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/insert/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/insert/util/operation/clean-insert-column.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/insert/util/operation/clean-insert-column.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "../tsql/dist/built-in-value-expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "../tsql/dist/error/index.js");
function cleanInsertColumn(table, row, columnAlias, required) {
    const customExpr = (
    /**
     * This is just safer.
     *
     * But how regularly should we access properties of mapped types this way?
     * All the time?
     * If so, why?
     *
     * Sometimes?
     * If so, what's the criteria?
     *
     * @todo Figure this out
     */
    (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
        row[columnAlias] :
        undefined);
    if (customExpr === undefined) {
        if (required) {
            throw new error_1.MissingRequiredInsertColumnError({
                message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                table,
                columnAlias
            });
        }
        else {
            return undefined;
        }
    }
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
        return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
    }
    else if (built_in_expr_1.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
        /**
         * Can't really perform many checks here.
         * We can, however, check for `NULL`s.
         */
        if (query_base_1.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
            !tm.canOutputNull(table.columns[columnAlias].mapper)) {
            throw new error_1.PotentialNullInRequiredInsertColumnError({
                message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                table,
                columnAlias
            });
        }
        return customExpr;
    }
    else {
        /**
         * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
         */
        if (expr_1.ExprUtil.isExpr(customExpr) ||
            expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
            /**
             * @todo Should we validate these?
             * How would one even do that?
             */
            return customExpr;
        }
        /**
         * Maybe a custom data type?
         */
        return built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
    }
}
exports.cleanInsertColumn = cleanInsertColumn;
//# sourceMappingURL=clean-insert-column.js.map

/***/ }),

/***/ "../tsql/dist/insert/util/operation/clean-insert-row.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/insert/util/operation/clean-insert-row.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
const clean_insert_column_1 = __webpack_require__(/*! ./clean-insert-column */ "../tsql/dist/insert/util/operation/clean-insert-column.js");
/**
 * + Removes excess properties.
 * + Removes properties with value `undefined`.
 * + Checks required properties are there.
 */
function cleanInsertRow(table, row) {
    const result = {};
    for (const requiredColumnAlias of table_1.TableUtil.requiredColumnAlias(table)) {
        result[requiredColumnAlias] = clean_insert_column_1.cleanInsertColumn(table, row, requiredColumnAlias, true);
    }
    for (const optionalColumnAlias of table_1.TableUtil.optionalColumnAlias(table)) {
        const value = clean_insert_column_1.cleanInsertColumn(table, row, optionalColumnAlias, false);
        if (value === undefined) {
            continue;
        }
        result[optionalColumnAlias] = value;
    }
    return result;
}
exports.cleanInsertRow = cleanInsertRow;
//# sourceMappingURL=clean-insert-row.js.map

/***/ }),

/***/ "../tsql/dist/insert/util/operation/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/insert/util/operation/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-column */ "../tsql/dist/insert/util/operation/clean-insert-column.js"));
__export(__webpack_require__(/*! ./clean-insert-row */ "../tsql/dist/insert/util/operation/clean-insert-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/isolation-level.js":
/*!***************************************!*\
  !*** ../tsql/dist/isolation-level.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Isolation levels ranked from weakest to strongest,
 * 1. `READ_UNCOMMITTED`
 * 2. `READ_COMMITTED`
 * 3. `REPEATABLE_READ`
 * 4. `SERIALIZABLE`
 *
 * https://github.com/AnyhowStep/tsql/issues/14
 */
var IsolationLevel;
(function (IsolationLevel) {
    IsolationLevel["READ_UNCOMMITTED"] = "READ_UNCOMMITTED";
    IsolationLevel["READ_COMMITTED"] = "READ_COMMITTED";
    IsolationLevel["REPEATABLE_READ"] = "REPEATABLE_READ";
    IsolationLevel["SERIALIZABLE"] = "SERIALIZABLE";
})(IsolationLevel = exports.IsolationLevel || (exports.IsolationLevel = {}));
var IsolationLevelUtil;
(function (IsolationLevelUtil) {
    const isolationLevelStrengths = {
        [IsolationLevel.READ_UNCOMMITTED]: 0,
        [IsolationLevel.READ_COMMITTED]: 1,
        [IsolationLevel.REPEATABLE_READ]: 2,
        [IsolationLevel.SERIALIZABLE]: 3,
    };
    /**
     * Is isolation level `a` weaker than `b`?
     */
    function isWeakerThan(a, b) {
        return isolationLevelStrengths[a] < isolationLevelStrengths[b];
    }
    IsolationLevelUtil.isWeakerThan = isWeakerThan;
})(IsolationLevelUtil = exports.IsolationLevelUtil || (exports.IsolationLevelUtil = {}));
//# sourceMappingURL=isolation-level.js.map

/***/ }),

/***/ "../tsql/dist/join-map/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/join-map/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const JoinMapUtil = __webpack_require__(/*! ./util */ "../tsql/dist/join-map/util/index.js");
exports.JoinMapUtil = JoinMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join-map/util/constructor/from-join-array.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/join-map/util/constructor/from-join-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromJoinArray(joins) {
    const result = {};
    for (const join of joins) {
        result[join.tableAlias] = join;
    }
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "../tsql/dist/join-map/util/constructor/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/join-map/util/constructor/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-join-array */ "../tsql/dist/join-map/util/constructor/from-join-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join-map/util/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/join-map/util/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/join-map/util/constructor/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/join/array-util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/join/array-util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/join/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/operation/append.js":
/*!********************************************************!*\
  !*** ../tsql/dist/join/array-util/operation/append.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function append(arr, ...join) {
    return [...arr, ...join];
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/operation/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/join/array-util/operation/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "../tsql/dist/join/array-util/operation/append.js"));
__export(__webpack_require__(/*! ./replace-column */ "../tsql/dist/join/array-util/operation/replace-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/operation/replace-column.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/join/array-util/operation/replace-column.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const JoinUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/join/util/index.js");
function replaceColumn(joins, tableAlias, columnAlias, mapper) {
    return joins.map(join => JoinUtil.replaceColumn(join, tableAlias, columnAlias, mapper));
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/query/extract-with-candidate-key.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/join/array-util/query/extract-with-candidate-key.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function extractWithCandidateKey(joins) {
    return joins.filter((join) => (join.candidateKeys.length > 0));
}
exports.extractWithCandidateKey = extractWithCandidateKey;
//# sourceMappingURL=extract-with-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js":
/*!*******************************************************************************************!*\
  !*** ../tsql/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "../tsql/dist/table/index.js");
function extractWithNullSafeComparablePrimaryKey(joins, columnMap) {
    return joins.filter((join) => {
        if (join.primaryKey == undefined) {
            return false;
        }
        return table_1.TableUtil.hasNullSafeComparablePrimaryKey({
            columns: join.columns,
            primaryKey: join.primaryKey,
        }, columnMap);
    });
}
exports.extractWithNullSafeComparablePrimaryKey = extractWithNullSafeComparablePrimaryKey;
//# sourceMappingURL=extract-with-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/query/extract-with-primary-key.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/join/array-util/query/extract-with-primary-key.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function extractWithPrimaryKey(joins) {
    return joins.filter((join) => (join.primaryKey != undefined));
}
exports.extractWithPrimaryKey = extractWithPrimaryKey;
//# sourceMappingURL=extract-with-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/join/array-util/query/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/join/array-util/query/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-with-candidate-key */ "../tsql/dist/join/array-util/query/extract-with-candidate-key.js"));
__export(__webpack_require__(/*! ./extract-with-primary-key */ "../tsql/dist/join/array-util/query/extract-with-primary-key.js"));
__export(__webpack_require__(/*! ./extract-with-null-safe-comparable-primary-key */ "../tsql/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/index.js":
/*!**********************************!*\
  !*** ../tsql/dist/join/index.js ***!
  \**********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./join-impl */ "../tsql/dist/join/join-impl.js"));
__export(__webpack_require__(/*! ./join */ "../tsql/dist/join/join.js"));
const JoinArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/join/array-util/index.js");
exports.JoinArrayUtil = JoinArrayUtil;
const JoinUtil = __webpack_require__(/*! ./util */ "../tsql/dist/join/util/index.js");
exports.JoinUtil = JoinUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/join-impl.js":
/*!**************************************!*\
  !*** ../tsql/dist/join/join-impl.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Join {
    constructor(data, joinType, onClause, tableAst) {
        this.tableAlias = data.tableAlias;
        this.columns = data.columns;
        this.nullable = data.nullable;
        this.originalColumns = data.originalColumns;
        this.primaryKey = data.primaryKey;
        this.candidateKeys = data.candidateKeys;
        this.deleteEnabled = data.deleteEnabled;
        this.mutableColumns = data.mutableColumns;
        this.joinType = joinType;
        this.onClause = onClause;
        this.tableAst = tableAst;
    }
}
exports.Join = Join;
//# sourceMappingURL=join-impl.js.map

/***/ }),

/***/ "../tsql/dist/join/join.js":
/*!*********************************!*\
  !*** ../tsql/dist/join/join.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
var JoinType;
(function (JoinType) {
    JoinType["FROM"] = "FROM";
    JoinType["INNER"] = "INNER";
    JoinType["LEFT"] = "LEFT";
    /**
     * @todo Remove this?
     */
    JoinType["RIGHT"] = "RIGHT";
    JoinType["CROSS"] = "CROSS";
})(JoinType = exports.JoinType || (exports.JoinType = {}));
;
exports.JoinTypeValues = tm.EnumUtil.getValues(JoinType);
//# sourceMappingURL=join.js.map

/***/ }),

/***/ "../tsql/dist/join/util/constructor/from-aliased-table.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/join/util/constructor/from-aliased-table.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_impl_1 = __webpack_require__(/*! ../../join-impl */ "../tsql/dist/join/join-impl.js");
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "../tsql/dist/aliased-table/index.js");
function fromAliasedTable(aliasedTable, nullable, joinType, onClause) {
    const result = new join_impl_1.Join({
        tableAlias: aliasedTable.alias,
        nullable,
        columns: aliasedTable.columns,
        originalColumns: aliasedTable.columns,
        primaryKey: aliased_table_1.AliasedTableUtil.primaryKey(aliasedTable),
        candidateKeys: aliased_table_1.AliasedTableUtil.candidateKeys(aliasedTable),
        deleteEnabled: aliased_table_1.AliasedTableUtil.deleteEnabled(aliasedTable),
        mutableColumns: aliased_table_1.AliasedTableUtil.mutableColumns(aliasedTable),
    }, joinType, onClause, aliasedTable.unaliasedAst);
    return result;
}
exports.fromAliasedTable = fromAliasedTable;
//# sourceMappingURL=from-aliased-table.js.map

/***/ }),

/***/ "../tsql/dist/join/util/constructor/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/join/util/constructor/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-aliased-table */ "../tsql/dist/join/util/constructor/from-aliased-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/util/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/join/util/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/join/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/join/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/util/operation/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/join/util/operation/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./replace-column */ "../tsql/dist/join/util/operation/replace-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/join/util/operation/replace-column.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/join/util/operation/replace-column.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const join_impl_1 = __webpack_require__(/*! ../../join-impl */ "../tsql/dist/join/join-impl.js");
function replaceColumn(join, tableAlias, columnAlias, mapper) {
    if (join.tableAlias == tableAlias &&
        Object.prototype.hasOwnProperty.call(join.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(join.columns, columnAlias)) {
        const { tableAlias, nullable, columns, originalColumns, primaryKey, candidateKeys, deleteEnabled, mutableColumns, } = join;
        const result = new join_impl_1.Join({
            tableAlias,
            nullable,
            columns: column_map_1.ColumnMapUtil.replaceColumn(columns, columnAlias, mapper),
            originalColumns,
            primaryKey,
            candidateKeys,
            deleteEnabled,
            mutableColumns,
        }, join.joinType, join.onClause, join.tableAst);
        return result;
    }
    else {
        return join;
    }
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/key/array-util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/key/array-util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/key/array-util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/key/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/operation/append.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/key/array-util/operation/append.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/array-util/operation/remove-duplicates.js");
function append(arr, key) {
    return remove_duplicates_1.removeDuplicates([...arr, key]);
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/operation/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/key/array-util/operation/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "../tsql/dist/key/array-util/operation/append.js"));
__export(__webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/array-util/operation/remove-duplicates.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/operation/remove-duplicates.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/key/array-util/operation/remove-duplicates.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/key/array-util/predicate/index.js");
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function removeDuplicates(arr) {
    const result = [];
    for (const key of arr) {
        if (!predicate_1.hasKey(result, key)) {
            result.push(KeyUtil.removeDuplicates(key));
        }
    }
    return result;
}
exports.removeDuplicates = removeDuplicates;
//# sourceMappingURL=remove-duplicates.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/has-key.js":
/*!********************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/has-key.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function hasKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isEqual(k, key)) {
            return true;
        }
    }
    return false;
}
exports.hasKey = hasKey;
//# sourceMappingURL=has-key.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/has-sub-key.js":
/*!************************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/has-sub-key.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function hasSubKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isSubKey(k, key)) {
            return true;
        }
    }
    return false;
}
exports.hasSubKey = hasSubKey;
//# sourceMappingURL=has-sub-key.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/has-super-key.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/has-super-key.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function hasSuperKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isSubKey(key, k)) {
            return true;
        }
    }
    return false;
}
exports.hasSuperKey = hasSuperKey;
//# sourceMappingURL=has-super-key.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-key */ "../tsql/dist/key/array-util/predicate/has-key.js"));
__export(__webpack_require__(/*! ./has-sub-key */ "../tsql/dist/key/array-util/predicate/has-sub-key.js"));
__export(__webpack_require__(/*! ./has-super-key */ "../tsql/dist/key/array-util/predicate/has-super-key.js"));
__export(__webpack_require__(/*! ./is-key-array */ "../tsql/dist/key/array-util/predicate/is-key-array.js"));
__export(__webpack_require__(/*! ./is-disjoint */ "../tsql/dist/key/array-util/predicate/is-disjoint.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/is-disjoint.js":
/*!************************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/is-disjoint.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function isDisjoint(arrayA, arrayB) {
    for (const a of arrayA) {
        for (const b of arrayB) {
            if (KeyUtil.isEqual(a, b)) {
                return false;
            }
        }
    }
    return true;
}
exports.isDisjoint = isDisjoint;
//# sourceMappingURL=is-disjoint.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/predicate/is-key-array.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/key/array-util/predicate/is-key-array.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function isKeyArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!KeyUtil.isKey(item)) {
            return false;
        }
    }
    return true;
}
exports.isKeyArray = isKeyArray;
//# sourceMappingURL=is-key-array.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/query/find-sub-key.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/key/array-util/query/find-sub-key.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function findSubKeys(arr, key) {
    const result = [];
    for (const k of arr) {
        if (KeyUtil.isSubKey(k, key)) {
            result.push(k);
        }
    }
    return result;
}
exports.findSubKeys = findSubKeys;
//# sourceMappingURL=find-sub-key.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/query/find-super-key.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/key/array-util/query/find-super-key.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "../tsql/dist/key/util/index.js");
function findSuperKeys(arr, key) {
    const result = [];
    for (const k of arr) {
        if (KeyUtil.isSubKey(key, k)) {
            result.push(k);
        }
    }
    return result;
}
exports.findSuperKeys = findSuperKeys;
//# sourceMappingURL=find-super-key.js.map

/***/ }),

/***/ "../tsql/dist/key/array-util/query/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/key/array-util/query/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./find-sub-key */ "../tsql/dist/key/array-util/query/find-sub-key.js"));
__export(__webpack_require__(/*! ./find-super-key */ "../tsql/dist/key/array-util/query/find-super-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/index.js":
/*!*********************************!*\
  !*** ../tsql/dist/key/index.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyArrayUtil = __webpack_require__(/*! ./array-util */ "../tsql/dist/key/array-util/index.js");
exports.KeyArrayUtil = KeyArrayUtil;
const KeyUtil = __webpack_require__(/*! ./util */ "../tsql/dist/key/util/index.js");
exports.KeyUtil = KeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/util/constructor/from-column-array.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/key/util/constructor/from-column-array.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operation_1 = __webpack_require__(/*! ../operation */ "../tsql/dist/key/util/operation/index.js");
function fromColumnArray(columns) {
    const result = operation_1.removeDuplicates(columns.map(c => c.columnAlias));
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "../tsql/dist/key/util/constructor/from-column.js":
/*!********************************************************!*\
  !*** ../tsql/dist/key/util/constructor/from-column.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = [column.columnAlias];
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/key/util/constructor/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/key/util/constructor/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "../tsql/dist/key/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/key/util/constructor/from-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/util/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/key/util/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/key/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/key/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/key/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/append.js":
/*!*************************************************!*\
  !*** ../tsql/dist/key/util/operation/append.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/util/operation/remove-duplicates.js");
function append(key, str) {
    return remove_duplicates_1.removeDuplicates([...key, str]);
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/concat.js":
/*!*************************************************!*\
  !*** ../tsql/dist/key/util/operation/concat.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/util/operation/remove-duplicates.js");
function concat(a, b) {
    return remove_duplicates_1.removeDuplicates([...a, ...b]);
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/key/util/operation/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "../tsql/dist/key/util/operation/append.js"));
__export(__webpack_require__(/*! ./concat */ "../tsql/dist/key/util/operation/concat.js"));
__export(__webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/util/operation/remove-duplicates.js"));
__export(__webpack_require__(/*! ./remove */ "../tsql/dist/key/util/operation/remove.js"));
__export(__webpack_require__(/*! ./subtract */ "../tsql/dist/key/util/operation/subtract.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/remove-duplicates.js":
/*!************************************************************!*\
  !*** ../tsql/dist/key/util/operation/remove-duplicates.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removeDuplicates(key) {
    const result = [];
    for (const str of key) {
        if (!result.includes(str)) {
            result.push(str);
        }
    }
    return result;
}
exports.removeDuplicates = removeDuplicates;
//# sourceMappingURL=remove-duplicates.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/remove.js":
/*!*************************************************!*\
  !*** ../tsql/dist/key/util/operation/remove.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/util/operation/remove-duplicates.js");
function remove(key, str) {
    const result = remove_duplicates_1.removeDuplicates(key.filter(s => s != str));
    return result;
}
exports.remove = remove;
//# sourceMappingURL=remove.js.map

/***/ }),

/***/ "../tsql/dist/key/util/operation/subtract.js":
/*!***************************************************!*\
  !*** ../tsql/dist/key/util/operation/subtract.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "../tsql/dist/key/util/operation/remove-duplicates.js");
function subtract(a, b) {
    const result = remove_duplicates_1.removeDuplicates(a.filter(s => !b.includes(s)));
    return result;
}
exports.subtract = subtract;
//# sourceMappingURL=subtract.js.map

/***/ }),

/***/ "../tsql/dist/key/util/predicate/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/key/util/predicate/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-key */ "../tsql/dist/key/util/predicate/is-key.js"));
__export(__webpack_require__(/*! ./is-equal */ "../tsql/dist/key/util/predicate/is-equal.js"));
__export(__webpack_require__(/*! ./is-sub-key */ "../tsql/dist/key/util/predicate/is-sub-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/key/util/predicate/is-equal.js":
/*!***************************************************!*\
  !*** ../tsql/dist/key/util/predicate/is-equal.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_sub_key_1 = __webpack_require__(/*! ./is-sub-key */ "../tsql/dist/key/util/predicate/is-sub-key.js");
function isEqual(a, b) {
    return (is_sub_key_1.isSubKey(a, b) &&
        is_sub_key_1.isSubKey(b, a));
}
exports.isEqual = isEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "../tsql/dist/key/util/predicate/is-key.js":
/*!*************************************************!*\
  !*** ../tsql/dist/key/util/predicate/is-key.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isKey(raw) {
    if (!(Array.isArray(raw))) {
        return false;
    }
    for (const item of raw) {
        if (typeof item != "string") {
            return false;
        }
    }
    return true;
}
exports.isKey = isKey;
//# sourceMappingURL=is-key.js.map

/***/ }),

/***/ "../tsql/dist/key/util/predicate/is-sub-key.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/key/util/predicate/is-sub-key.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isSubKey(a, b) {
    return a.every(aKey => b.includes(aKey));
}
exports.isSubKey = isSubKey;
//# sourceMappingURL=is-sub-key.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/limit-clause/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LimitClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/limit-clause/util/index.js");
exports.LimitClauseUtil = LimitClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/limit-clause/util/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/limit-clause/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./limit-bigint */ "../tsql/dist/limit-clause/util/operation/limit-bigint.js"));
__export(__webpack_require__(/*! ./limit-number */ "../tsql/dist/limit-clause/util/operation/limit-number.js"));
__export(__webpack_require__(/*! ./limit */ "../tsql/dist/limit-clause/util/operation/limit.js"));
__export(__webpack_require__(/*! ./offset-bigint */ "../tsql/dist/limit-clause/util/operation/offset-bigint.js"));
__export(__webpack_require__(/*! ./offset-number */ "../tsql/dist/limit-clause/util/operation/offset-number.js"));
__export(__webpack_require__(/*! ./offset */ "../tsql/dist/limit-clause/util/operation/offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/limit-bigint.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/limit-bigint.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "../tsql/dist/limit-clause/util/operation/offset-bigint.js");
function limitBigInt(limitClause, maxRowCount) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    if (tm.BigIntUtil.lessThan(maxRowCount, 0)) {
        throw new Error(`Cannot LIMIT fewer than zero rows`);
    }
    if (tm.BigIntUtil.greaterThan(maxRowCount, offset_bigint_1.ALL_ROW_COUNT)) {
        throw new Error(`Cannot LIMIT more than ${offset_bigint_1.ALL_ROW_COUNT} rows`);
    }
    if (limitClause == undefined) {
        return {
            maxRowCount,
            offset: BigInt(0),
        };
    }
    else {
        return {
            maxRowCount,
            offset: limitClause.offset,
        };
    }
}
exports.limitBigInt = limitBigInt;
//# sourceMappingURL=limit-bigint.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/limit-number.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/limit-number.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const limit_bigint_1 = __webpack_require__(/*! ./limit-bigint */ "../tsql/dist/limit-clause/util/operation/limit-bigint.js");
function limitNumber(limitClause, maxRowCount) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return limit_bigint_1.limitBigInt(limitClause, 
    /**
     * Will throw a run-time error if `maxRowCount` is not an integer.
     */
    BigInt(maxRowCount));
}
exports.limitNumber = limitNumber;
//# sourceMappingURL=limit-number.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/limit.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/limit.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_bigint_1 = __webpack_require__(/*! ./limit-bigint */ "../tsql/dist/limit-clause/util/operation/limit-bigint.js");
const limit_number_1 = __webpack_require__(/*! ./limit-number */ "../tsql/dist/limit-clause/util/operation/limit-number.js");
function limit(limitClause, maxRowCount) {
    if (typeof maxRowCount == "number") {
        return limit_number_1.limitNumber(limitClause, maxRowCount);
    }
    else {
        return limit_bigint_1.limitBigInt(limitClause, maxRowCount);
    }
}
exports.limit = limit;
//# sourceMappingURL=limit.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/offset-bigint.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/offset-bigint.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
exports.ALL_ROW_COUNT = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
exports.MAX_OFFSET = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
function offsetBigInt(limitClause, offset) {
    if (tm.BigIntUtil.lessThan(offset, 0)) {
        throw new Error(`Cannot OFFSET fewer than zero rows`);
    }
    if (tm.BigIntUtil.greaterThan(offset, exports.MAX_OFFSET)) {
        throw new Error(`Cannot OFFSET more than ${exports.MAX_OFFSET} rows`);
    }
    if (limitClause == undefined) {
        return {
            maxRowCount: exports.ALL_ROW_COUNT,
            offset,
        };
    }
    else {
        return {
            maxRowCount: limitClause.maxRowCount,
            offset,
        };
    }
}
exports.offsetBigInt = offsetBigInt;
//# sourceMappingURL=offset-bigint.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/offset-number.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/offset-number.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "../tsql/dist/limit-clause/util/operation/offset-bigint.js");
function offsetNumber(limitClause, offset) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return offset_bigint_1.offsetBigInt(limitClause, 
    /**
     * Will throw a run-time error if `offset` is not an integer.
     */
    BigInt(offset));
}
exports.offsetNumber = offsetNumber;
//# sourceMappingURL=offset-number.js.map

/***/ }),

/***/ "../tsql/dist/limit-clause/util/operation/offset.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/limit-clause/util/operation/offset.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "../tsql/dist/limit-clause/util/operation/offset-bigint.js");
const offset_number_1 = __webpack_require__(/*! ./offset-number */ "../tsql/dist/limit-clause/util/operation/offset-number.js");
function offset(limitClause, offset) {
    if (typeof offset == "number") {
        return offset_number_1.offsetNumber(limitClause, offset);
    }
    else {
        return offset_bigint_1.offsetBigInt(limitClause, offset);
    }
}
exports.offset = offset;
//# sourceMappingURL=offset.js.map

/***/ }),

/***/ "../tsql/dist/map-delegate/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/map-delegate/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MapDelegateUtil = __webpack_require__(/*! ./util */ "../tsql/dist/map-delegate/util/index.js");
exports.MapDelegateUtil = MapDelegateUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/map-delegate/util/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/map-delegate/util/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/map-delegate/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/map-delegate/util/operation/compose.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/map-delegate/util/operation/compose.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function compose(cur, nxt) {
    return async (row, connection, originalRow) => {
        const tmp = await cur(row, connection, originalRow);
        const result = await nxt(tmp, connection, originalRow);
        return result;
    };
}
exports.compose = compose;
//# sourceMappingURL=compose.js.map

/***/ }),

/***/ "../tsql/dist/map-delegate/util/operation/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/map-delegate/util/operation/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compose */ "../tsql/dist/map-delegate/util/operation/compose.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/mapper-map/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/mapper-map/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MapperMapUtil = __webpack_require__(/*! ./util */ "../tsql/dist/mapper-map/util/index.js");
exports.MapperMapUtil = MapperMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/mapper-map/util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/mapper-map/util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/mapper-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/mapper-map/util/query/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/mapper-map/util/query/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./nullable-key */ "../tsql/dist/mapper-map/util/query/nullable-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/mapper-map/util/query/nullable-key.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/mapper-map/util/query/nullable-key.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
function nullableKeys(map) {
    const columnAliases = Object.keys(map);
    return columnAliases.filter(columnAlias => tm.canOutputNull(map[columnAlias]));
}
exports.nullableKeys = nullableKeys;
//# sourceMappingURL=nullable-key.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/on-clause/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OnClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/on-clause/util/index.js");
exports.OnClauseUtil = OnClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/on-clause/util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/on-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/on-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/on-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/operation/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/on-clause/util/operation/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./on */ "../tsql/dist/on-clause/util/operation/on.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/operation/on.js":
/*!***************************************************!*\
  !*** ../tsql/dist/on-clause/util/operation/on.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/on-clause/util/query/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/on-clause/util/predicate/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
function on(fromClause, aliasedTable, onDelegate) {
    const columns = query_1.allowedColumnRef(fromClause, aliasedTable);
    const rawOnClause = onDelegate(columns);
    predicate_1.assertValidUsedRef(fromClause, aliasedTable, rawOnClause);
    return expr_1.ExprUtil.fromBuiltInExpr(rawOnClause);
}
exports.on = on;
//# sourceMappingURL=on.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function assertNoOuterQueryUsedRef(fromClause, rawOnClause) {
    const outerQueryTableAliases = from_clause_1.FromClauseUtil.outerQueryTableAlias(fromClause);
    const usedOuterQueryTableAliases = Object.keys(built_in_expr_1.BuiltInExprUtil.usedRef(rawOnClause).columns)
        .filter(usedTableAlias => {
        return outerQueryTableAliases.includes(usedTableAlias);
    });
    if (usedOuterQueryTableAliases.length > 0) {
        throw new Error(`ON clause must not reference outer query tables ${usedOuterQueryTableAliases.join(",")}`);
    }
}
exports.assertNoOuterQueryUsedRef = assertNoOuterQueryUsedRef;
//# sourceMappingURL=assert-no-outer-query-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/predicate/assert-valid-used-ref.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/on-clause/util/predicate/assert-valid-used-ref.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/on-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function assertValidUsedRef(fromClause, aliasedTable, rawOnClause) {
    used_ref_1.UsedRefUtil.assertAllowed(query_1.allowedUsedRef(fromClause, aliasedTable), built_in_expr_1.BuiltInExprUtil.usedRef(rawOnClause));
}
exports.assertValidUsedRef = assertValidUsedRef;
//# sourceMappingURL=assert-valid-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/predicate/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/on-clause/util/predicate/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-no-outer-query-used-ref */ "../tsql/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref */ "../tsql/dist/on-clause/util/predicate/assert-valid-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/query/allowed-used-ref.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/on-clause/util/query/allowed-used-ref.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "../tsql/dist/join/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function allowedColumnRef(fromClause, aliasedTable) {
    return column_ref_1.ColumnRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
    /**
     * We don't care about the `JoinType` for this temporary array
     */
    join_1.JoinType.FROM, 
    /**
     * We don't care about the `ON` clause either
     */
    undefined)));
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause, aliasedTable) {
    /**
     * @todo Investigate assignability
     */
    return used_ref_1.UsedRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
    /**
     * We don't care about the `JoinType` for this temporary array
     */
    join_1.JoinType.FROM, 
    /**
     * We don't care about the `ON` clause either
     */
    undefined)));
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/on-clause/util/query/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/on-clause/util/query/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/on-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/operator-type.js":
/*!*************************************!*\
  !*** ../tsql/dist/operator-type.js ***!
  \*************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * It's called `OperatorType` but also contains function names.
 * A function is just an operator with different syntax.
 *
 * -----
 *
 * **EVERY** new `OperatorType` added is a **BREAKING CHANGE**.
 * Make sure to bump the **MAJOR** version number.
 */
var OperatorType;
(function (OperatorType) {
    /*
        Comparison Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `BETWEEN ... AND ...`
     * + PostgreSQL   : `BETWEEN ... AND ...`
     * + SQLite       : `BETWEEN ... AND ...`
     */
    OperatorType["BETWEEN_AND"] = "BETWEEN_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
     * + https://www.postgresql.org/docs/9.5/functions-conditional.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `COALESCE(x, ...)`
     * + PostgreSQL   : `COALESCE(x, ...)`
     * + SQLite       : `COALESCE(x, ...)`
     */
    OperatorType["COALESCE"] = "COALESCE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `=`
     * + PostgreSQL   : `=`
     * + SQLite       : `=`
     */
    OperatorType["EQUAL"] = "EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<=>`
     * + PostgreSQL   : `IS NOT DISTINCT FROM`
     * + SQLite       : `IS`
     */
    OperatorType["NULL_SAFE_EQUAL"] = "NULL_SAFE_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `>`
     * + PostgreSQL   : `>`
     * + SQLite       : `>`
     */
    OperatorType["GREATER_THAN"] = "GREATER_THAN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `>=`
     * + PostgreSQL   : `>=`
     * + SQLite       : `>=`
     */
    OperatorType["GREATER_THAN_OR_EQUAL"] = "GREATER_THAN_OR_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL        : `GREATEST(x, y, ...)` //Requires 2 args
     *   + `NULL` values cause return value of `NULL`
     * + PostgreSQL   : `GREATEST(x, ...)`    //Requires 1 arg
     *   + Ignores `NULL` values
     * + SQLite       : `MAX(x, ...)`         //Requires 1 arg
     *   + `NULL` values cause return value of `NULL`
     */
    OperatorType["GREATEST"] = "GREATEST";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `IN`
     * + PostgreSQL   : `IN`
     * + SQLite       : `IN`
     */
    OperatorType["IN_ARRAY"] = "IN_ARRAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `IN`
     * + PostgreSQL   : `IN`
     * + SQLite       : `IN`
     */
    OperatorType["IN_QUERY"] = "IN_QUERY";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_interval
     */
    //INTERVAL = "INTERVAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS TRUE`
     * + PostgreSQL   : `IS TRUE`
     * + SQLite       : `<NULL_SAFE_EQUAL> TRUE`
     */
    OperatorType["IS_TRUE"] = "IS_TRUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS FALSE`
     * + PostgreSQL   : `IS FALSE`
     * + SQLite       : `<NULL_SAFE_EQUAL> FALSE`
     */
    OperatorType["IS_FALSE"] = "IS_FALSE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * This does not refer to the TypeScript `unknown`.
     * It refers to the three-valued logic `unknown`.
     *
     * It generally has a value equivalent to `NULL`.
     *
     * -----
     *
     * + MySQL        : `IS UNKNOWN`
     * + PostgreSQL   : `IS UNKNOWN`
     * + SQLite       : `<NULL_SAFE_EQUAL> UNKNOWN`
     */
    OperatorType["IS_UNKNOWN"] = "IS_UNKNOWN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT TRUE`
     * + PostgreSQL   : `IS NOT TRUE`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> TRUE`
     */
    OperatorType["IS_NOT_TRUE"] = "IS_NOT_TRUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT FALSE`
     * + PostgreSQL   : `IS NOT FALSE`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> FALSE`
     */
    OperatorType["IS_NOT_FALSE"] = "IS_NOT_FALSE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * This does not refer to the TypeScript `unknown`.
     * It refers to the three-valued logic `unknown`.
     *
     * It generally has a value equivalent to `NULL`.
     *
     * -----
     *
     * + MySQL        : `IS NOT UNKNOWN`
     * + PostgreSQL   : `IS NOT UNKNOWN`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> UNKNOWN`
     */
    OperatorType["IS_NOT_UNKNOWN"] = "IS_NOT_UNKNOWN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT NULL`
     * + PostgreSQL   : `IS NOT NULL`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> NULL`
     */
    OperatorType["IS_NOT_NULL"] = "IS_NOT_NULL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NULL`
     * + PostgreSQL   : `IS NULL`
     * + SQLite       : `<NULL_SAFE_EQUAL> NULL`
     */
    OperatorType["IS_NULL"] = "IS_NULL";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_isnull
     */
    //ISNULL = "ISNULL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL        : `LEAST(x, y, ...)` //Requires 2 args
     * + PostgreSQL   : `LEAST(x, ...)`    //Requires 1 arg
     * + SQLite       : `MIN(x, ...)`         //Requires 1 arg
     */
    OperatorType["LEAST"] = "LEAST";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<`
     * + PostgreSQL   : `<`
     * + SQLite       : `<`
     */
    OperatorType["LESS_THAN"] = "LESS_THAN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<=`
     * + PostgreSQL   : `<=`
     * + SQLite       : `<=`
     */
    OperatorType["LESS_THAN_OR_EQUAL"] = "LESS_THAN_OR_EQUAL";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `LIKE`
     * + PostgreSQL   : `LIKE`
     * + SQLite       : `LIKE`
     */
    /*
     * The `LIKE` operator has different default escape behaviours across databases.
     * By default, SQLite does not have an escape character.
     * By default, MySQL's is the backslash.
     */
    //LIKE = "LIKE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `LIKE ... ESCAPE ...`
     * + PostgreSQL   : `LIKE ... ESCAPE ...`
     * + SQLite       : `LIKE ... ESCAPE ...`
     */
    OperatorType["LIKE_ESCAPE"] = "LIKE_ESCAPE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `NOT BETWEEN ... AND ...`
     * + PostgreSQL   : `NOT BETWEEN ... AND ...`
     * + SQLite       : `NOT BETWEEN ... AND ...`
     */
    OperatorType["NOT_BETWEEN_AND"] = "NOT_BETWEEN_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<>`
     * + PostgreSQL   : `<>`
     * + SQLite       : `<>`
     */
    OperatorType["NOT_EQUAL"] = "NOT_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `<NOT> (x <NULL_SAFE_EQUAL>)`
     * + PostgreSQL   : `IS DISTINCT FROM`
     * + SQLite       : `IS NOT`
     */
    OperatorType["NOT_NULL_SAFE_EQUAL"] = "NOT_NULL_SAFE_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `NOT IN`
     * + PostgreSQL   : `NOT IN`
     * + SQLite       : `NOT IN`
     */
    OperatorType["NOT_IN_ARRAY"] = "NOT_IN_ARRAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `NOT IN`
     * + PostgreSQL   : `NOT IN`
     * + SQLite       : `NOT IN`
     */
    OperatorType["NOT_IN_QUERY"] = "NOT_IN_QUERY";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `NOT LIKE`
     * + PostgreSQL   : `NOT LIKE`
     * + SQLite       : `NOT LIKE`
     */
    /*
     * The `LIKE` operator has different default escape behaviours across databases.
     * By default, SQLite does not have an escape character.
     * By default, MySQL's is the backslash.
     */
    //NOT_LIKE = "NOT_LIKE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `NOT LIKE ... ESCAPE ...`
     * + PostgreSQL   : `NOT LIKE ... ESCAPE ...`
     * + SQLite       : `NOT LIKE ... ESCAPE ...`
     */
    OperatorType["NOT_LIKE_ESCAPE"] = "NOT_LIKE_ESCAPE";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#function_strcmp
     */
    //STRCMP = "STRCMP",
    /*
        Logical Operators
        https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `AND`
     * + PostgreSQL   : `AND`
     * + SQLite       : `AND`
     */
    OperatorType["AND"] = "AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `NOT`
     * + PostgreSQL   : `NOT`
     * + SQLite       : `NOT`
     */
    OperatorType["NOT"] = "NOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `OR`
     * + PostgreSQL   : `OR`
     * + SQLite       : `OR`
     */
    OperatorType["OR"] = "OR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * -----
     *
     * + MySQL        : `XOR`
     * + PostgreSQL   : `<NOT_EQUAL>`
     * + SQLite       : `<NOT_EQUAL>`
     */
    OperatorType["XOR"] = "XOR";
    /*
        Control Flow Functions
        https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * -----
     *
     * + MySQL        : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     * + PostgreSQL   : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     * + SQLite       : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     */
    /**
     * This is handled using `CaseValueNode`
     */
    //CASE = "CASE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * -----
     *
     * + MySQL        : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     * + PostgreSQL   : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     * + SQLite       : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     */
    /**
     * This is handled using `CaseConditionNode`
     */
    //CASE_WHEN = "CASE_WHEN",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
     *
     * -----
     *
     * + MySQL        : `IF(x, y, z)`
     * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
     * + SQLite       : `CASE WHEN x THEN y ELSE z END`
     */
    OperatorType["IF"] = "IF";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#ifnull
     *
     * `COALESCE()` is part of the SQL standard.
     * `IFNULL()` is DB-specific.
     *
     * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
     *
     * -----
     *
     * + MySQL        : `IFNULL(x, y)`
     * + PostgreSQL   : `COALESCE(x, y)`
     * + SQLite       : `IFNULL(x, y)`
     */
    OperatorType["IF_NULL"] = "IF_NULL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * -----
     *
     * This is the same as `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`
     */
    OperatorType["NULL_IF_EQUAL"] = "NULL_IF_EQUAL";
    /*
        String Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `ASCII(x)`
     * + PostgreSQL     : `ASCII(x)`
     * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
     */
    OperatorType["ASCII"] = "ASCII";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
     *
     * -----
     *
     * + MySQL          : `BIN(x)`
     * + PostgreSQL     : None. Implement with,
     * ```sql
     *  REGEXP_REPLACE(
     *      (x)::bit(64)::varchar(64),
     *      '^0+(\d+)$',
     *      '\1'
     *  )
     * ```
     * + SQLite         : None. Implement with,
     * ```ts
     * //x >= 0
     * (x).toString(2)
     * //x < 0
     * (2n**64n + BigInt(x)).toString(2)
     * ```
     */
    OperatorType["BIN"] = "BIN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `BIT_LENGTH(x)`
     * + PostgreSQL     : `BIT_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
     */
    OperatorType["BIT_LENGTH"] = "BIT_LENGTH";
    /*
     * Appears to be MySQL and SQLite-specific,
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char
     * + https://www.sqlite.org/lang_corefunc.html#char
     *
     * They have different implementations, however.
     */
    //CHAR = "CHAR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#length
     * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
     *
     * -----
     *
     * + MySQL          : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 6
     * + PostgreSQL     : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 8
     * + SQLite         : `LENGTH(x)`
     *   + `LENGTH('cafȩ́')` returns 6
     */
    OperatorType["CHAR_LENGTH"] = "CHAR_LENGTH";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
     *   + MySQL actually treats `||` as the boolean `OR` operator.
     * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + SQLite uses an operator, not a function, to concatenate strings
     *   + https://www.sqlite.org/lang_expr.html#collateop
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     */
    OperatorType["CONCAT"] = "CONCAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
     * + PostgreSQL     : `CONCAT(x, ...)`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `COALESCE(x, '') || ... || ...`
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     */
    OperatorType["NULL_SAFE_CONCAT"] = "NULL_SAFE_CONCAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["CONCAT_WS"] = "CONCAT_WS";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_elt
     */
    //ELT = "ELT",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_export-set
     */
    //EXPORT_SET = "EXPORT_SET",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_field
     */
    //FIELD = "FIELD",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_find-in-set
     *
     * ```sql
     * FIND_IN_SET(str, strlist)
     * ```
     *
     * There is a way to emulate it with PostgreSQL,
     * https://stackoverflow.com/questions/35169412/mysql-find-in-set-equivalent-to-postgresql
     *
     * ```sql
     *  array_position(
     *      string_to_array(strlist, ','),
     *      str
     *  )
     * ```
     *
     * @todo Decide if we should add this
     */
    //FIND_IN_SET = "FIND_IN_SET",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `FROM_BASE64(x)`
     *   + `FROM_BASE64('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'base64')`
     *   + `DECODE('~', 'base64')` throws an error
     * + SQLite         : None, implement with user-defined function `atob()`
     *   + `atob('~')` throws an error
     */
    OperatorType["FROM_BASE64"] = "FROM_BASE64";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#hex
     *
     * -----
     *
     * + MySQL          : `HEX(x)`
     * + PostgreSQL     : `ENCODE(x, 'hex')`
     * + SQLite         : `HEX(x)`
     */
    OperatorType["HEX"] = "HEX";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_insert
     */
    //INSERT = "INSERT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
     * + https://www.sqlite.org/lang_corefunc.html#instr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `INSTR(str, substr)`
     * + PostgreSQL     : `STRPOS(str, substr)`
     * + SQLite         : `INSTR(str, substr)`
     */
    OperatorType["IN_STR"] = "IN_STR";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_left
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
     */
    //LEFT = "LEFT",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#length
     *
     * -----
     *
     * + MySQL          : `LENGTH(x)`
     * + PostgreSQL     : `LENGTH(x)`
     * + SQLite         : None. The `LENGTH(x)` implementation is incompatible.
     *
     * -----
     *
     * ```sql
     *  SELECT
     *      -- '\u00c7'
     *      LENGTH('Ç') AS one_length,
     *      CHAR_LENGTH('Ç') AS one_char_length,
     *      -- '\u0043\u0327'
     *      LENGTH('Ç') AS two_length,
     *      CHAR_LENGTH('Ç') AS two_char_length
     * ```
     *
     * MySQL        : `2,1,3,2`
     * PostgreSQL   : `2,2,3,3`
     * SQLite       : `1,X,2,X` (`X` because SQLite does not have `CHAR_LENGTH()`)
     *
     * |                            | MySQL `LENGTH()` | MySQL `CHAR_LENGTH()` | PostgreSQL `LENGTH()` | PostgreSQL `CHAR_LENGTH()` | SQLite `LENGTH()` |
     * |----------------------------|------------------|-----------------------|-----------------------|----------------------------|-------------------|
     * | MySQL      `LENGTH()`      | X                |                       | X                     | X                          |                   |
     * | MySQL      `CHAR_LENGTH()` |                  | X                     |                       |                            | X                 |
     * | PostgreSQL `LENGTH()`      | X                |                       | X                     | X                          |                   |
     * | PostgreSQL `CHAR_LENGTH()` | X                |                       | X                     | X                          |                   |
     * | SQLite     `LENGTH()`      |                  | X                     |                       |                            | X                 |
     *
     * https://news.ycombinator.com/item?id=17311196
     *
     * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/3
     * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/4
     *
     * -----
     *
     * TL;DR,
     * We cannot provide `LENGTH` as a DB-unified operator because of the inconsistencies
     *
     * -----
     *
     * See, `OCTET_LENGTH` instead.
     * All three databases can be made to agree on the behaviour of `OCTET_LENGTH`
     */
    //LENGTH = "LENGTH",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file
     */
    //LOAD_FILE = "LOAD_FILE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_locate
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LOCATE(substr, str)/LOCATE(substr, str, pos)`
     * + PostgreSQL     : `STRPOS(str, substr)`, the 3-arg version is more complicated.
     *
     *   Tentatively, `STRPOS(SUBSTR(str, pos), substr) + pos` or something like that.
     *
     * + SQLite         : None. Implement with user-defined function.
     * @todo
     */
    //LOCATE = "LOCATE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#lower
     *
     * -----
     *
     * + MySQL          : `LOWER(x)`
     * + PostgreSQL     : `LOWER(x)`
     * + SQLite         : `LOWER(x)`
     */
    OperatorType["LOWER"] = "LOWER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["LPAD"] = "LPAD";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#ltrim
     *
     * -----
     *
     * + MySQL          : `LTRIM(x)`
     * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
     * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
     */
    OperatorType["LTRIM"] = "LTRIM";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_make-set
     */
    //MAKE_SET = "MAKE_SET",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_oct
     */
    //OCT = "OCT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `OCTET_LENGTH(x)`
     * + PostgreSQL     : `OCTET_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB))`
     */
    OperatorType["OCTET_LENGTH"] = "OCTET_LENGTH";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ord
     */
    //ORD = "ORD",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `POSITION(substr IN str)`
     * + PostgreSQL     : `POSITION(substr IN str)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["POSITION"] = "POSITION";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_quote
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#quote
     *
     * -----
     *
     * + MySQL          : `QUOTE(x)`
     * + PostgreSQL     : `QUOTE_NULLABLE(x)`
     * + SQLite         : `QUOTE(x)`
     *
     * SQLite seems to not return just strings...
     * SQLite can return string|Uint8Array|number|bigint|...
     * So, we can't unify this.
     */
    //QUOTE = "QUOTE",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#function_regexp-like
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax
     *   + http://userguide.icu-project.org/strings/regexp
     * + `~`/`~*`/`!~`/`!~*`
     *   + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-POSIX-REGEXP
     * + TODO: Find out difference between POSIX regex and ICU regex
     */
    //REGEXP = "REGEXP",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REPEAT(x, count)`
     * + PostgreSQL     : `REPEAT(x, count)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["REPEAT"] = "REPEAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#replace
     *
     * -----
     *
     * + MySQL          : `REPLACE(str, from, to)`
     * + PostgreSQL     : `REPLACE(str, from, to)`
     * + SQLite         : `REPLACE(str, from, to)`
     */
    OperatorType["REPLACE"] = "REPLACE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REVERSE(x)`
     * + PostgreSQL     : `REVERSE(x)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["REVERSE"] = "REVERSE";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_right
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
     */
    //RIGHT = "RIGHT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["RPAD"] = "RPAD";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#rtrim
     *
     * -----
     *
     * + MySQL          : `RTRIM(x)`
     * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
     * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
     */
    OperatorType["RTRIM"] = "RTRIM";
    /*
     * Appears to be PostgreSQL-specific,
     * https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP
     */
    //SIMILAR_TO = "SIMILAR_TO",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_soundex
     * + https://www.sqlite.org/lang_corefunc.html#soundex
     * + https://www.postgresql.org/docs/9.1/fuzzystrmatch.html
     *
     * -----
     *
     * + MySQL          : `SOUNDEX(x)`
     * + PostgreSQL     : `SOUNDEX(x)`
     * + SQLite         : `SOUNDEX(x)`
     */
    //SOUNDEX = "SOUNDEX",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#operator_sounds-like
     */
    //SOUNDS_LIKE = "SOUNDS_LIKE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_space
     *
     * -----
     *
     * `SPACE(n)` is the same as `REPEAT(' ', n)`
     */
    //SPACE = "SPACE",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#substr
     *
     * -----
     *
     * + MySQL          : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'o'`
     *   + `SUBSTR('hello', -1, -2)` === `''`
     *   + `SUBSTR('hello', -2, 2)` === `'lo'`
     * + PostgreSQL     : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'hello'`
     *   + `SUBSTR('hello', -1, -2)` throws an error
     *   + `SUBSTR('hello', -2, 2)` === `''`
     * + SQLite         : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'o'`
     *   + `SUBSTR('hello', -1, -2)` === `'ll'`
     *   + `SUBSTR('hello', -2, 2)` === `'lo'`
     *
     * -----
     *
     * Behaviour varies too much.
     */
    //SUBSTR = "SUBSTR",
    /*
     * Appears to be MySQl-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substring-index
     */
    //SUBSTRING_INDEX = "SUBSTRING_INDEX",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `TO_BASE64(x)`
     * + PostgreSQL     : `ENCODE(x, 'base64')`
     * + SQLite         : None, implement with user-defined function `btoa()`
     */
    OperatorType["TO_BASE64"] = "TO_BASE64";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#trim
     *
     * -----
     *
     * + MySQL          : `TRIM(x)`
     * + PostgreSQL     : `TRIM(x)`
     * + SQLite         : `TRIM(x)`
     */
    OperatorType["TRIM"] = "TRIM";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `UNHEX(x)`
     *   + `UNHEX('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'hex')`
     *   + `DECODE('~', 'hex')` throws an error
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["UNHEX"] = "UNHEX";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#upper
     *
     * -----
     *
     * + MySQL          : `UPPER(x)`
     * + PostgreSQL     : `UPPER(x)`
     * + SQLite         : `UPPER(x)`
     */
    OperatorType["UPPER"] = "UPPER";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_weight-string
     */
    //WEIGHT_STIRNG = "WEIGHT_STIRNG",
    /*
        Arithmetic Operators
        https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_div
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS
     *
     * -----
     *
     * Interestingly enough,
     * MySQL uses `SIGNED` and `UNSIGNED` for integer type names when casting.
     * PostgreSQL uses `INTEGER`
     *
     * -----
     *
     * + MySQL        : `DIV`
     * + PostgreSQL   : `CAST(TRUNC(CAST(x AS NUMERIC) / CAST(y AS NUMERIC), 0) AS BIGINT)`
     * + SQLite       : `CAST(x/y AS BIGINT)`
     *   + SQLite does not have `DECIMAL` data type support...
     *
     */
    OperatorType["INTEGER_DIVISION"] = "INTEGER_DIVISION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `/`
     * + PostgreSQL   : `/`
     * + SQLite       : `/`
     */
    OperatorType["FRACTIONAL_DIVISION"] = "FRACTIONAL_DIVISION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     */
    OperatorType["SUBTRACTION"] = "SUBTRACTION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * @todo Find out if they behave the same
     *
     * + MySQL        : `%`
     *   + `1%0` === `NULL`
     * + PostgreSQL   : `mod(x, y)` (The `%` operator does not handle negative values)
     *   + `mod(1, 0)` throws error
     * + SQLite       : `%`
     *   + `1%0` === `NULL`
     */
    OperatorType["INTEGER_REMAINDER"] = "INTEGER_REMAINDER";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * + MySQL        : `%`
     * + PostgreSQL   : Not supported
     * + SQLite       : Not supported
     */
    OperatorType["FRACTIONAL_REMAINDER"] = "FRACTIONAL_REMAINDER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
     *
     * -----
     *
     * + MySQL        : `+`
     * + PostgreSQL   : `+`
     * + SQLite       : `+`
     */
    OperatorType["ADDITION"] = "ADDITION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
     *
     * -----
     *
     * + MySQL        : `*`
     * + PostgreSQL   : `*`
     * + SQLite       : `*`
     */
    OperatorType["MULTIPLICATION"] = "MULTIPLICATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     */
    OperatorType["UNARY_MINUS"] = "UNARY_MINUS";
    /*
        Mathematical Functions
        https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_corefunc.html#abs
     *
     * -----
     *
     * + MySQL        : `ABS(x)`
     * + PostgreSQL   : `@` or `ABS(x)` (Let's not use the ugly `@` operator)
     * + SQLite       : `ABS(x)`
     */
    OperatorType["ABSOLUTE_VALUE"] = "ABSOLUTE_VALUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ACOS(x)`
     * + PostgreSQL     : `ACOS(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_COSINE"] = "ARC_COSINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ASIN(x)`
     * + PostgreSQL     : `ASIN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_SINE"] = "ARC_SINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN(x)`
     * + PostgreSQL     : `ATAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_TANGENT"] = "ARC_TANGENT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN2(y, x)`
     * + PostgreSQL     : `ATAN2(y, x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_TANGENT_2"] = "ARC_TANGENT_2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceil
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL        : `CEIL(x)/CEILING(x)`
     * + PostgreSQL   : `CEIL(x)/CEILING(x)`
     * + SQLite       : None, use the following instead,
     *   + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
     * ```sql
     *  (
     *      CASE
     *          WHEN x = CAST(x AS INT) THEN
     *              CAST(x AS INT)
     *          ELSE
     *              1 + CAST(x AS INT)
     *      END
     *  )
     * ```
     *
     */
    OperatorType["CEILING"] = "CEILING";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_conv
     */
    //CONV = "CONV"
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COS(x)`
     * + PostgreSQL     : `COS(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["COSINE"] = "COSINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COT(x)`
     * + PostgreSQL     : `COT(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["COTANGENT"] = "COTANGENT";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_crc32
     */
    //CRC32 = "CRC32",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `DEGREES(x)`
     * + PostgreSQL     : `DEGREES(x)`
     * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
     */
    OperatorType["DEGREES"] = "DEGREES";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `EXP(x)`
     * + PostgreSQL     : `EXP(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["NATURAL_EXPONENTIATION"] = "NATURAL_EXPONENTIATION";
    /*
     * Appears to be PostgreSQL-specific,
     * + Factorial; `x !` / `!! x`
     * + https://www.postgresql.org/docs/8.2/functions-math.html
     */
    //FACTORIAL = "FACTORIAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL        : `FLOOR(x)`
     * + PostgreSQL   : `FLOOR(x)`
     * + SQLite       : None, use the following instead,
     *   + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
     * ```sql
     *  (
     *      CASE
     *          WHEN x >= 0 THEN
     *              CAST(x AS INT)
     *          WHEN x = CAST(x AS INT) THEN
     *              CAST(x AS INT)
     *          ELSE
     *              CAST(x - 1.0 AS INT)
     *      END
     *  )
     * ```
     */
    OperatorType["FLOOR"] = "FLOOR";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_format
     */
    //FORMAT = "FORMAT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LN(x)`
     * + PostgreSQL     : `LN(x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LN"] = "LN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LOG(base, x)`
     * + PostgreSQL     : `LOG(base, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG"] = "LOG";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
     *
     * -----
     *
     * + MySQL          : `LOG2(x)`
     * + PostgreSQL     : `LOG(2.0, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG2"] = "LOG2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
     *
     * -----
     *
     * + MySQL          : `LOG10(x)`
     * + PostgreSQL     : `LOG(10.0, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG10"] = "LOG10";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `PI()` Returns `3.141592653589793`
     * + PostgreSQL     : `PI()` Returns `3.14159265358979`
     * + SQLite         : None, implement using `3.141592653589793`
     *
     * -----
     *
     * In JS, `Math.PI` is `3.141592653589793`
     */
    OperatorType["PI"] = "PI";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * + MySQL        : `POWER(x, y)`
     * + PostgreSQL   : `^` or `POWER(x, y)` (Let's not use the ugly `^` operator)
     * + SQLite       : Requres creating a `POWER(x, y)` user-defined function
     */
    OperatorType["POWER"] = "POWER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `RADIANS(x)`
     * + PostgreSQL     : `RADIANS(x)`
     * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
     */
    OperatorType["RADIANS"] = "RADIANS";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#random
     *
     * -----
     *
     * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
     * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
     * + SQLite         : Incompatible.
     *
     *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
     *
     *   Therefore, one should use, `ABS(RANDOM()) / 9223372036854775808`
     */
    OperatorType["RANDOM"] = "RANDOM";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_round
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#round
     *
     * -----
     *
     * + MySQL          : `ROUND(x)` or `ROUND(x, y)`
     * + PostgreSQL     : `ROUND(x)` or `ROUND(x, y)`
     * + SQLite         : `ROUND(x)` or `ROUND(x, y)`
     */
    //ROUND = "ROUND",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `SIGN(x)`
     * + PostgreSQL     : `SIGN(x)`
     * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
     */
    OperatorType["SIGN"] = "SIGN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `SIN(x)`
     * + PostgreSQL     : `SIN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["SINE"] = "SINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `SQRT(x)`
     * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
     * + SQLite       : Requres creating a `SQRT(x)` user-defined function
     */
    OperatorType["SQUARE_ROOT"] = "SQUARE_ROOT";
    /**
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `POWER(x, 1.0/3.0)` The `.0` parts are important!
     * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
     * + SQLite       : Requres creating a `CBRT(x)` user-defined function
     *
     * -----
     *
     * MySQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 3
     * ```
     *
     * PostgreSQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 2.99999999999999999997
     * ```
     */
    OperatorType["CUBE_ROOT"] = "CUBE_ROOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `TAN(x)`
     * + PostgreSQL     : `TAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["TANGENT"] = "TANGENT";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_truncate
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     *
     * -----
     *
     * + MySQL          : `TRUNCATE(x, d)`
     * + PostgreSQL     : `TRUNC(x, d)`
     * + SQLite         : None, implement with `Math.trunc(x * Math.pow(10, d)) / Math.pow(10, d)`
     */
    //TRUNCATE = "TRUNCATE",
    /*
        Date and Time Functions
        https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
    */
    /**
     * @todo
     */
    /*
     * + MySQL          :
     * ```sql
     *  SELECT
     *      adddate(date('2010-01-01'), interval 1 hour),
     *      adddate(date('2010-01-01'), interval 1 day);
     *  > 2010-01-01 01:00:00
     *  > 2010-01-02
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      date '2010-01-01' + interval '1 hour',
     *      date '2010-01-01' + interval '1 day',
     *      time '10:23:45.123' + interval '1 hour',
     *      time '10:23:45.123' + interval '1 day'
     *  > 2010-01-01T01:00:00.000Z
     *  > 2010-01-02T00:00:00.000Z
     *  > 11:23:45.123
     *  > 10:23:45.123
     * ```
     */
    //ADDDATE = "ADDDATE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_addtime
     *
     * It has... Weird behaviour.
     */
    //ADDTIME = "ADDTIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_DATE()`
     * + PostgreSQL     : `CURRENT_DATE()`
     * + SQLite         : `strftime('%Y-%m-%d', 'now')`
     */
    OperatorType["CURRENT_DATE"] = "CURRENT_DATE";
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(0)`
     * + PostgreSQL     : `CURRENT_TIME(0)`
     * + SQLite         : `strftime('%H:%M:%S', 'now')`
     */
    //CURRENT_TIME_0 = "CURRENT_TIME_0",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(1)`
     * + PostgreSQL     : `CURRENT_TIME(1)`
     * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 10)`
     */
    //CURRENT_TIME_1 = "CURRENT_TIME_1",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(2)`
     * + PostgreSQL     : `CURRENT_TIME(2)`
     * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 11)`
     */
    //CURRENT_TIME_2 = "CURRENT_TIME_2",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(3)`
     * + PostgreSQL     : `CURRENT_TIME(3)`
     * + SQLite         : `strftime('%H:%M:%f', 'now')`
     */
    //CURRENT_TIME_3 = "CURRENT_TIME_3",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(0)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(0),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(0))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(0),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(0)
     *      ))
     *  > 2019-09-07T23:58:20.000Z
     *  > 1567900700
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%S', 'now'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%S', 'now'));
     *  > 2019-09-07 23:59:35
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_0"] = "CURRENT_TIMESTAMP_0";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(1)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(1),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(1))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.8
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(1),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(1)
     *      ))
     *  > 2019-09-07T23:58:20.400Z
     *  > 1567900700
     * ```
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
     * ```sql
     *  SELECT
     *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21),
     *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21));
     *  > 2019-09-07 23:59:35.3
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_1"] = "CURRENT_TIMESTAMP_1";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(2)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(2),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(2))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.83
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(2),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(2)
     *      ))
     *  > 2019-09-07T23:58:20.470Z
     *  > 1567900700
     * ```
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
     * ```sql
     *  SELECT
     *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22),
     *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22));
     *  > 2019-09-07 23:59:35.32
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_2"] = "CURRENT_TIMESTAMP_2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(3)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(3),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.836
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(3),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(3)
     *      ))
     *  > 2019-09-07T23:58:20.477Z
     *  > 1567900700
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', 'now'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', 'now'));
     *  > 2019-09-07 23:59:35.327
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_3"] = "CURRENT_TIMESTAMP_3";
    /**
     *
     * -----
     *
     * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
     *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
     *  > 1969-12-31 22:00:00.123
     *  > 10800
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
     *          )
     *      ))
     *  > 1970-01-01T03:00:00.123Z
     *  > 10800
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
     *  > 1970-01-01 03:00:00.123
     *  > 10800
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `UTC` timestamp.
     *
     */
    OperatorType["UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR"] = "UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR";
    /*
     *
     * -----
     *
     * + MySQL          : `TIMESTAMP(x)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      TIMESTAMP('1970-01-01 00:00:00.123'),
     *      FLOOR(UNIX_TIMESTAMP(TIMESTAMP('1970-01-01 00:00:00.123')));
     *  > 1970-01-01 00:00:00.123
     *  > 18000
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE current_setting('TIMEZONE')`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE'),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE')
     *          )
     *      ))
     *  > 1970-01-01T05:00:00.123Z
     *  > 18000
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x, 'utc')`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'));
     *  > 1970-01-01 05:00:00.123
     *  > 18000
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `local` timestamp.
     *
     */
    //LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR = "LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000.0) / 1000.0`
     * ```sql
     *  SELECT
     *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
     *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
     *  > 32.4560
     * ```
     * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
     * + SQLite         : `strftime('%f', datetime)`
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 14:45:32.456789')
     *  > 32.457
     *  -- The result is rounded, not truncated.
     *  -- If it were truncated, we would get 32.456
     * ```
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 23:59:59.999999')
     *  > 59.999
     *  -- The result is truncated, not rounded.
     *  -- If it were rounded, we would get 60
     * ```
     *
     * @todo Make behaviour consistent?
     */
    OperatorType["EXTRACT_FRACTIONAL_SECOND_3"] = "EXTRACT_FRACTIONAL_SECOND_3";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime)`
     * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_INTEGER_SECOND"] = "EXTRACT_INTEGER_SECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_MINUTE"] = "EXTRACT_MINUTE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(HOUR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_HOUR"] = "EXTRACT_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(DAY FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_DAY"] = "EXTRACT_DAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MONTH FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_MONTH"] = "EXTRACT_MONTH";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(YEAR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_YEAR"] = "EXTRACT_YEAR";
    /**
     * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
     *
     * -----
     *
     * + MySQL          : `LAST_DAY(datetime)`
     * ```sql
     *  SELECT
     *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
     *  > 2010-03-31
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SELECT
     *      (
     *          datetime +
     *          interval '1 month' -
     *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
     *      )::date
     * > 2010-03-31T00:00:00.000Z
     * ```
     * + SQLite         :
     * ```sql
     *  SELECT
     *      strftime(
     *          '%Y-%m-%d',
     *          '2010-03-27 14:45:32.456789',
     *          '+1 month',
     *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
     *      )
     *  > 2010-03-31
     * ```
     */
    OperatorType["LAST_DAY"] = "LAST_DAY";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MICROSECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x/1000.0, ' millisecond')::interval`
     *
     *   1 millisecond is 1000 microseconds
     *
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      -- 1 second is 1,000,000 microseconds
     *      (x/1000000.0) || ' second'
     *  );
     * ```
     *
     * However, SQLite only displays up to millisecond precision (3 decimal places for seconds).
     * JS' `Date` also only has up to millisecond precision.
     */
    //TIMESTAMPADD_MICROSECOND = "TIMESTAMPADD_MICROSECOND",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x/1000.0, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      (x/1000e0) || ' second'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MILLISECOND"] = "TIMESTAMPADD_MILLISECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' second'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_SECOND"] = "TIMESTAMPADD_SECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0, datetime)`
     *   + `TIMESTAMPADD(MINUTE, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' minute'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MINUTE"] = "TIMESTAMPADD_MINUTE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0*60.0, datetime)`
     *   + `TIMESTAMPADD(HOUR, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' hour'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_HOUR"] = "TIMESTAMPADD_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*24.0*60.0*60.0, datetime)`
     *   + `TIMESTAMPADD(DAY, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' day'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_DAY"] = "TIMESTAMPADD_DAY";
    /**
     * Seems to be a MySQL and PostgreSQL thing.
     * SQLite does not have `week` intervals.
     *
     * Could probably be emulated with `7 day` being `1 week`
     */
    //TIMESTAMPADD_WEEK = "TIMESTAMPADD_WEEK",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' month'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MONTH"] = "TIMESTAMPADD_MONTH";
    /**
     * Seems to be a MySQL thing.
     * PostgreSQL and SQLite do not have `quarter` intervals.
     *
     * Could probably be emulated with `3 month` being `1 quarter`
     */
    //TIMESTAMPADD_QUARTER = "TIMESTAMPADD_QUARTER",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' year'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_YEAR"] = "TIMESTAMPADD_YEAR";
    /*
     * SQLite does not have microsecond precision.
     */
    //TIMESTAMPDIFF_MICROSECOND = "TIMESTAMPDIFF_MICROSECOND",
    /**
     * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_MILLISECOND"] = "TIMESTAMPDIFF_MILLISECOND";
    /**
     * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_SECOND"] = "TIMESTAMPDIFF_SECOND";
    /**
     * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_MINUTE"] = "TIMESTAMPDIFF_MINUTE";
    /**
     * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_HOUR"] = "TIMESTAMPDIFF_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
     * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_DAY"] = "TIMESTAMPDIFF_DAY";
    /*
     * Seems to be MySQL-specific
     */
    //TIMESTAMPDIFF_WEEK = "TIMESTAMPDIFF_WEEK",
    /*
     * + MySQL          : `TIMESTAMPDIFF(MONTH, from, to)`
     * + PostgreSQL     :
     * ```sql
     * EXTRACT(YEAR FROM AGE(to, from))*12 +
     * EXTRACT(MONTH FROM AGE(to, from))
     * ```
     * + SQLite         : @todo? Doesn't seem possible to compute properly
     */
    //TIMESTAMPDIFF_MONTH = "TIMESTAMPDIFF_MONTH",
    /*
     * Seems to be MySQL-specific
     */
    //TIMESTAMPDIFF_QUARTER = "TIMESTAMPDIFF_QUARTER",
    /*
     * + MySQL          : `TIMESTAMPDIFF(YEAR, from, to)`
     * + PostgreSQL     :
     * ```sql
     * EXTRACT(YEAR FROM AGE(to, from))
     * ```
     * + SQLite         : @todo? Doesn't seem possible to compute properly
     */
    //TIMESTAMPDIFF_YEAR = "TIMESTAMPDIFF_YEAR",
    /*
     * The different databases implement this differently,
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-format
     * + https://www.postgresql.org/docs/9.4/functions-formatting.html
     * + https://www.sqlite.org/lang_datefunc.html
     */
    //TIME_FORMAT = "TIME_FORMAT",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-to-sec
     */
    //TIME_TO_SEC = "TIME_TO_SEC",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days
     */
    //TO_DAYS = "TO_DAYS",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-seconds
     */
    //TO_SECONDS = "TO_SECONDS",
    /*
     * @todo
     *
     * I don't think this can easily be made portable across different database systems
     * **AND** made to behave consistently across different session time zone settings.
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP(datetime)`
     *   + The return value is an integer if no argument is given or the argument does not include a fractional seconds part,
     *   + or `DECIMAL` if an argument is given that includes a fractional seconds part.
     *   + returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
     *   + The server interprets date as a value in the session time zone and converts it to an internal Unix timestamp value in UTC.
     * +
     */
    //UNIX_TIMESTAMP_AT_DATETIME = "UNIX_TIMESTAMP_AT_DATETIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP()`
     * + PostgreSQL     :
     * ```sql
     *  FLOOR(
     *      EXTRACT(EPOCH FROM (
     *          CURRENT_TIMESTAMP -
     *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
     *      ))
     *  )
     * ```
     * + SQLite         : `strftime('%s', 'now')`
     */
    OperatorType["UNIX_TIMESTAMP_NOW"] = "UNIX_TIMESTAMP_NOW";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-date
     */
    //UTC_DATE = "UTC_DATE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-time
     */
    //UTC_TIME = "UTC_TIME",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     *
     * Also, it does not play well with the other MySQL date-time functions.
     * Do not implement in base package unless a **VERY** good reason exists.
     */
    //UTC_TIMESTAMP = "UTC_TIMESTAMP",
    /*
     * Wtf is this, even?
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_week
     */
    //WEEK = "WEEK",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekday
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `WEEKDAY(date)`           ; `0=Monday, 1=Tuesday, ..., 6=Sunday`
     * + PostgreSQL     : `EXTRACT(DOW FROM date)`  ; `0=Sunday, 1=Monday , ..., 6=Saturday`
     * + SQLite         : `strftime('%w', date)`    ; `0=Sunday, 1=Monday , ..., 6=Saturday`
     *
     * -----
     *
     * Implementations are incompatible.
     * Can possibly use a different name and unify their implementations, however.
     */
    //WEEKDAY = "WEEKDAY",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekofyear
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `WEEKOFYEAR(date)`        ; `1-53`
     * + PostgreSQL     : `EXTRACT(WEEK FROM date)` ; `@todo`
     * + SQLite         : `strftime('%W', date)`    ; `0-53`
     *
     * -----
     *
     * Implementations are incompatible.
     * Can possibly use a different name and unify their implementations, however.
     */
    //WEEKOFYEAR = "WEEKOFYEAR",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_year
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `YEAR(date)`
     * + PostgreSQL     : `EXTRACT(YEAR FROM date)`
     * + SQLite         : `strftime('%Y', date)`
     *
     * @todo How is this different from `EXTRACT(YEAR FROM date)`?
     */
    //YEAR = "YEAR",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_yearweek
     */
    //YEARWEEK = "YEARWEEK",
    /*
        Cast Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html
    */
    /**
     * @todo
     */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS BINARY)`
     * + PostgreSQL     : `CAST(x AS bytea)`
     * + SQLite         : `CAST(x AS BLOB)`
     */
    OperatorType["CAST_AS_BINARY"] = "CAST_AS_BINARY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS CHAR) [charset_info]`
     * + PostgreSQL     : `CAST(x AS VARCHAR) [charset_info]`
     * + SQLite         : `CAST(x AS VARCHAR) [charset_info]`
     */
    OperatorType["CAST_AS_VARCHAR"] = "CAST_AS_VARCHAR";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS DATE)`
     * + PostgreSQL     : `CAST(x AS DATE)`
     * + SQLite         :
     *   **DO NOT** use `CAST(x AS DATE)`!
     * ```sql
     * SELECT CAST('2010-10-27 12:00:00' AS DATE)
     * > 2019
     * ```
     *
     * The above happens because `DATE` has `NUMERIC` affinity.
     * And so, the cast is the same as saying `CAST(x AS DECIMAL)`
     *
     * -----
     *
     * Actually, don't even use `CAST_AS_DATE`.
     * Just use one of the two `TIMESTAMP` constructors.
     */
    //CAST_AS_DATE = "CAST_AS_DATE",
    /*
     * Actually, don't even use `CAST_AS_DATETIME`.
     * Just use one of the two `TIMESTAMP` constructors.
     */
    //CAST_AS_DATETIME = "CAST_AS_DATETIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS DECIMAL(precision, scale))`
     *   + Max precision : 65
     *   + Max scale     : 30
     * + PostgreSQL     : `CAST(x AS DECIMAL(precision, scale))`
     *   + Max precision : 1000
     *   + Max scale     : 1000
     * + SQLite         : `CAST(x AS DECIMAL(precision, scale))`
     * ```sql
     * SELECT CAST('1e308' AS DECIMAL)
     * > 1e+308
     * ```
     *
     * For SQLite, this doesn't even cast to an arbitrary precision number.
     * SQLite does not support arbitrary precision numbers.
     * You will get a `double` instead.
     *
     * -----
     *
     * Precision and scale cannot be omitted.
     *
     * When omitted, MySQL defaults to `DECIMAL(10, 0)`
     * When omitted, PostgreSQL defaults to a precision and scale that will contain `x`
     *
     * -----
     *
     * ### Notes about MySQL's `DECIMAL`
     *
     * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1253-L1313
     * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1576-L1598
     *
     * ```js
     * DIG_PER_DEC1 = 9
     * dig2bytes = [0,1,1,2,2,3,3,4,4,4]
     * precision = 65
     * scale = 30
     * //typedef int32 decimal_digit_t;
     * //typedef decimal_digit_t dec1;
     * dec1 = 4
     * function sizeof (arg) { return arg }
     * var
     *      intg = precision - scale,
     *      intg0  = Math.floor(intg / DIG_PER_DEC1),
     *      frac0  = Math.floor(scale / DIG_PER_DEC1),
     *      intg0x = intg - intg0 * DIG_PER_DEC1,
     *      frac0x = scale - frac0 * DIG_PER_DEC1;
     * result = intg0 * sizeof(dec1) + dig2bytes[intg0x] + frac0 * sizeof(dec1) + dig2bytes[frac0x]
     * ```
     *
     * http://ftp.nchu.edu.tw/MySQL/doc/refman/5.0/en/precision-math-decimal-changes.html
     *
     * -----
     *
     * ```js
     * DIG_PER_DEC1 = 9;
     * dig2bytes = [0, 1, 1, 2, 2, 3, 3, 4, 4, 4];
     *
     * res = {};
     *
     * for (let precision = 1; precision < 73; precision++) {
     *      for (let scale = 0; scale <= precision; scale++) {
     *          const intg = precision - scale;
     *          const intg0 = Math.floor(intg / DIG_PER_DEC1);
     *          const frac0 = Math.floor(scale / DIG_PER_DEC1);
     *          const intg0x = intg - intg0 * DIG_PER_DEC1;
     *          const frac0x = scale - frac0 * DIG_PER_DEC1;
     *          const result = (
     *              intg0 * 4 + dig2bytes[intg0x] + frac0 * 4 + dig2bytes[frac0x]
     *          );
     *          res[`${precision}.${scale}`] = result;
     *      }
     * }
     * console.log(res);
     * ```
     *
     * -----
     *
     * ### Notes about PostgreSQL's `DECIMAL`
     *
     * https://doxygen.postgresql.org/numeric_8h.html#a12ab0e498cc609664248b5c9bb6c0a43
     *
     * @karanlyons said,
     * > 511 bytes for 1000 digits in postgres.
     * >
     * > And I think they use the extra byte for some additional bookeeping of the sign, etc.
     * >
     * > So 512, which makes sense!
     * >
     * > <3 u pg.
     * >
     * > Postgres’ source code is way better to read.
     * >
     * > It helps that they’re not insane.
     * >
     * > ~~That extra byte is actually for the type header I think, not internal bookkeeping of the number itself.~~
     * >
     * > The extra byte is for the `typmod` I think, which is 32 bits encoding the precision and scale in the upper 16 and lower 16.
     * >
     * > https://doxygen.postgresql.org/backend_2utils_2adt_2numeric_8c_source.html#l00703
     * >
     * > https://doxygen.postgresql.org/structNumericVar.html
     */
    OperatorType["CAST_AS_DECIMAL"] = "CAST_AS_DECIMAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL 5.7      : `x + 0e0`
     * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
     * + SQLite         : `CAST(x AS DOUBLE)`
     */
    OperatorType["CAST_AS_DOUBLE"] = "CAST_AS_DOUBLE";
    /*
     * Can't do it in MySQL 5.7.
     */
    //CAST_AS_FLOAT = "CAST_AS_FLOAT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS JSON)`
     * + PostgreSQL     : `CAST(x AS JSON)`
     * + SQLite         : `CAST(x AS TEXT)`; Or implement with user-defined function.
     *
     *   SQLite does not have a `JSON` data type
     */
    OperatorType["CAST_AS_JSON"] = "CAST_AS_JSON";
    /* *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     * + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS NCHAR)`
     * + PostgreSQL     : `CAST(x AS VARCHAR) utf8`
     *   + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
     *   + `utf8` is the charset of MySQL's `NCHAR`
     * + SQLite         : `CAST(x AS TEXT)`
     *   + SQLite does not have character sets
     */
    //CAST_AS_N_CHAR = "CAST_AS_N_CHAR",
    /*
     * The behaviour is too unpredictable on MySQL.
     * > Produces a result of type REAL.
     * This is actually FLOAT if REAL_AS_FLOAT SQL mode is enabled; otherwise the result is of type DOUBLE.
     */
    //CAST_AS_REAL = "CAST_AS_REAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS SIGNED INTEGER)`
     *   + Actually gives a signed `bigint`
     *   + Trying to cast `'123e2'` gives `123`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + Trying to cast `'123e2'` throws an error
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + Trying to cast `'123e2'` gives `123`
     */
    OperatorType["CAST_AS_BIGINT_SIGNED"] = "CAST_AS_BIGINT_SIGNED";
    /*
     * Use one of the `TIMESTAMP` constructors instead
     */
    //CAST_AS_TIME = "CAST_AS_TIME",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS UNSIGNED INTEGER)`
     *   + Actually gives an unsigned `bigint`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + PostgreSQL does not have unsigned types!
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + SQLite does not have unsigned types!
     *
     * -----
     *
     * ~~Even though **ONLY** MySQL supports `UNSIGNED` types,~~
     * ~~we're still adding this because it's too useful to give up.~~
     * Support for `BIGINT UNSIGNED` has been dropped.
     *
     * It means that trying to use `BIGINT UNSIGNED` with other databases
     * will produce varying behaviours, though...
     *
     * For example, the range of `BIGINT SIGNED` is much smaller than
     * `BIGINT UNSIGNED` if we are only looking at the non-negative range.
     *
     * Math with `BIGINT UNSIGNED` fails if the result becomes negative.
     * `BIGINT SIGNED` has no such inhibitions.
     */
    //CAST_AS_UNSIGNED_BIG_INTEGER = "CAST_AS_UNSIGNED_BIG_INTEGER",
    /*
        Bit Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x & y AS SIGNED)`
     * + PostgreSQL   : `&`
     * + SQLite       : `&`
     */
    OperatorType["BITWISE_AND"] = "BITWISE_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(~x AS SIGNED)`
     *   + `~1337` === `18446744073709550278`
     *   + `CAST(~1337 AS SIGNED)` === `-1338`
     * + PostgreSQL   : `~x`
     *   + `~1337` === `-1338`
     * + SQLite       : `~x`
     *   + `~1337` === `-1338`
     */
    OperatorType["BITWISE_NOT"] = "BITWISE_NOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x | y AS SIGNED)`
     * + PostgreSQL   : `|`
     * + SQLite       : `|`
     */
    OperatorType["BITWISE_OR"] = "BITWISE_OR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x ^ y AS SIGNED)`
     * + PostgreSQL   : `#`
     * + SQLite       : None, use `(~(a&b))&(a|b)` instead
     *   + https://stackoverflow.com/questions/16440831/bitwise-xor-in-sqlite-bitwise-not-not-working-as-i-expect
     *   + https://www.mail-archive.com/sqlite-users@mailinglists.sqlite.org/msg02250.html
     */
    OperatorType["BITWISE_XOR"] = "BITWISE_XOR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     */
    OperatorType["BITWISE_LEFT_SHIFT"] = "BITWISE_LEFT_SHIFT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     */
    OperatorType["BITWISE_RIGHT_SHIFT"] = "BITWISE_RIGHT_SHIFT";
    /*
        Functions That Create JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-creation-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Search JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Modify JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Return JSON Value Attributes
        https://dev.mysql.com/doc/refman/8.0/en/json-attribute-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Table Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Schema Validation Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-validation-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Utility Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-utility-functions.html
    */
    /**
     * @todo
     */
    /*
        Spatial Analysis Functions
        https://dev.mysql.com/doc/refman/8.0/en/spatial-analysis-functions.html

        @todo Split into subchapters
    */
    /*
        Aggregate (GROUP BY) Function Descriptions
        https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     * + PostgreSQL : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     * + SQLite     : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     */
    OperatorType["AGGREGATE_AVERAGE"] = "AGGREGATE_AVERAGE";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-and
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `BIT_AND(x)/BIT_AND(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `18446744073709551615`
     * + PostgreSQL : `BIT_AND(x)/BIT_AND(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `NULL`
     * + SQLite     : None. Implement with user-defined function.
     */
    //AGGREGATE_BITWISE_AND = "AGGREGATE_BITWISE_AND",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-or
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `BIT_OR(x)/BIT_OR(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `0`
     * + PostgreSQL : `BIT_OR(x)/BIT_OR(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `NULL`
     * + SQLite     : None. Implement with user-defined function.
     */
    //AGGREGATE_BITWISE_OR = "AGGREGATE_BITWISE_OR",
    /**
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-xor
     */
    //BIT_XOR = "BIT_XOR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` always returns one row
     * + PostgreSQL : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` can return zero rows
     * + SQLite     : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` can return zero rows
     */
    OperatorType["AGGREGATE_COUNT_EXPR"] = "AGGREGATE_COUNT_EXPR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     * + PostgreSQL : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     * + SQLite     : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     */
    OperatorType["AGGREGATE_COUNT_ALL"] = "AGGREGATE_COUNT_ALL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
     * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
     *   + The order of the concatenated elements is arbitrary.
     *   + Uses comma as separator
     *
     * -----
     *
     * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
     * for the DB-unified implementation.
     *
     * Unless we modify the SQLite implementation with a user-defined function?
     * @todo Investigate
     */
    OperatorType["AGGREGATE_GROUP_CONCAT_DISTINCT"] = "AGGREGATE_GROUP_CONCAT_DISTINCT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(expr, separator)`
     * + SQLite     : `GROUP_CONCAT(expr, separator)`
     *   + The order of the concatenated elements is arbitrary.
     */
    OperatorType["AGGREGATE_GROUP_CONCAT_ALL"] = "AGGREGATE_GROUP_CONCAT_ALL";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-arrayagg
     * @todo?
     *
     * Could also be related to `ARRAY_AGG()` from PostgreSQL,
     */
    //JSON_ARRAYAGG = "JSON_ARRAYAGG",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-objectagg
     */
    //JSON_OBJECTAGG = "JSON_OBJECTAGG",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     * + PostgreSQL : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     * + SQLite     : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     */
    OperatorType["AGGREGATE_MAX"] = "AGGREGATE_MAX";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(DISTINCT x)/MIN(x) OVER()`
     * + PostgreSQL : `MIN(DISTINCT x)/MIN(x) OVER()`
     * + SQLite     : `MIN(DISTINCT x)/MIN(x)/MIN(x) OVER()`
     */
    OperatorType["AGGREGATE_MIN"] = "AGGREGATE_MIN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
     * + PostgreSQL : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_POPULATION_STANDARD_DEVIATION"] = "AGGREGATE_POPULATION_STANDARD_DEVIATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
     * + PostgreSQL : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_SAMPLE_STANDARD_DEVIATION"] = "AGGREGATE_SAMPLE_STANDARD_DEVIATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM"] = "AGGREGATE_SUM";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM_AS_DECIMAL"] = "AGGREGATE_SUM_AS_DECIMAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM_AS_BIGINT_SIGNED"] = "AGGREGATE_SUM_AS_BIGINT_SIGNED";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_POP(x)/VAR_POP(x) OVER()`
     * + PostgreSQL : `VAR_POP(x)/VAR_POP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_POPULATION_VARIANCE"] = "AGGREGATE_POPULATION_VARIANCE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
     * + PostgreSQL : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_SAMPLE_VARIANCE"] = "AGGREGATE_SAMPLE_VARIANCE";
    /*
        https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html

        Subqueries with `EXISTS` or `NOT EXISTS`
    */
    /**
     * + https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html
     * + https://www.postgresql.org/docs/8.1/functions-subquery.html#AEN13171
     * + https://www.sqlite.org/lang_expr.html#exists_op
     *
     * -----
     *
     * + MySQL      : `EXISTS(query)`
     * + PostgreSQL : `EXISTS(query)`
     * + SQLite     : `EXISTS(query)`
     */
    OperatorType["EXISTS"] = "EXISTS";
    /*
        https://dev.mysql.com/doc/refman/5.7/en/information-functions.html

        Information Functions
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://www.sqlite.org/lang_attach.html
     *
     * -----
     *
     * + MySQL      : `DATABASE()`
     * + PostgreSQL : `CURRENT_SCHEMA`
     * + SQLite     : `'main'` should always be the current database.
     *   + There's also `'temp'`, I guess
     */
    OperatorType["CURRENT_SCHEMA"] = "CURRENT_SCHEMA";
    /**
     * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
     *
     * -----
     *
     * + MySQL      : `CURRENT_USER`
     * + PostgreSQL : `CURRENT_USER`
     * + SQLite     : None. It does not make sense to ask what the current user is.
     */
    OperatorType["CURRENT_USER"] = "CURRENT_USER";
    /*
        Custom library functions

        These functions are not standard SQL,
        but can be implemented using standard SQL.
    */
    /*
     * An invalid expression that is syntactically valid.
     * So, it will run.
     * But evaluating it will throw a run-time error.
     *
     * Good for stuff like,
     * ```sql
     *  -- Throw if the condition is false
     *  -- Otherwise, return the expression
     *  IF(
     *      -- condition,
     *      -- expression,
     *      THROW()
     *  )
     * ```
     *
     * Or,
     * ```sql
     *  -- Throw if expression is null
     *  -- Otherwise, return the expression
     *  COALESCE(
     *      -- possibly null expression,
     *      throw()
     *  )
     * ```
     *
     * A good example of such a throwing expression is,
     * ```sql
     *  -- Returns two rows,
     *  (SELECT NULL UNION ALL SELECT NULL)
     * ```
     *
     * @todo Find other such throwing expressions?
     *
     * This cannot be done in PostgreSQL.
     * PostgeSQL's type system does not allow mixing types like,
     * ```sql
     *  COALESCE(true, (SELECT NULL UNION ALL SELECT NULL))
     * ```
     */
    //THROW = "THROW",
    /**
     * + MySQL      - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
     * + PostgreSQL - `COALESCE(x, (SELECT NULL UNION ALL SELECT x))`
     *   Unfortunately, with PostgreSQL, we need to duplicate the expression...
     *   But this is a debug expression, anyway, and should not be used often.
     * + SQLite     - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
     */
    OperatorType["THROW_IF_NULL"] = "THROW_IF_NULL";
})(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
//# sourceMappingURL=operator-type.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/order-by-clause/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OrderByClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/order-by-clause/util/index.js");
exports.OrderByClauseUtil = OrderByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/order-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/order-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/operation/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/operation/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./order-by */ "../tsql/dist/order-by-clause/util/operation/order-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/operation/order-by.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/operation/order-by.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/order-by-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const order_1 = __webpack_require__(/*! ../../../order */ "../tsql/dist/order/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
/**
 * Returns the MySQL equivalent of `...orderBy, orderByDelegate(columns)`
 *
 * This will change when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 *
 * -----
 *
 * @param fromClause
 * @param orderByClause
 * @param orderByDelegate
 */
function orderBy(fromClause, groupByClause, selectClause, orderByClause, orderByDelegate) {
    const columns = query_1.allowedColumnRef(fromClause, selectClause);
    const orderBy = orderByDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    if (groupByClause == undefined) {
        for (const rawOrder of orderBy) {
            const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
            if (built_in_expr_1.BuiltInExprUtil.isAggregate(sortExpr)) {
                throw new Error(`Aggregate expressions in ORDER BY clause not allowed without GROUP BY clause`);
            }
            if (column_1.ColumnUtil.isColumn(sortExpr)) {
                column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
            }
            else {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
            }
        }
    }
    else {
        const nonAggregateColumns = query_1.allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause);
        for (const rawOrder of orderBy) {
            const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
            if (column_1.ColumnUtil.isColumn(sortExpr)) {
                column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(nonAggregateColumns, sortExpr);
            }
            else {
                if (built_in_expr_1.BuiltInExprUtil.isAggregate(sortExpr)) {
                    used_ref_1.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
                }
                else {
                    used_ref_1.UsedRefUtil.assertAllowed({ columns: nonAggregateColumns }, sortExpr.usedRef);
                }
            }
        }
    }
    return (orderByClause == undefined ?
        orderBy.map(order_1.OrderUtil.fromRawOrder) :
        [...orderByClause, ...orderBy.map(order_1.OrderUtil.fromRawOrder)]);
}
exports.orderBy = orderBy;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause) {
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    const selectClauseColumns = (selectClause == undefined ?
        {} :
        column_ref_1.ColumnRefUtil.fromSelectClause(selectClause));
    const result = column_ref_1.ColumnRefUtil.intersect(inner, selectClauseColumns);
    return result;
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause, selectClause) {
    const usedRef = used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause));
    return usedRef;
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/query/allowed-used-ref.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/query/allowed-used-ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
/**
 * For now, this is basically the same as `HavingClauseUtil.AllowedColumnRef<>`.
 *
 * They will diverge when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 */
function allowedColumnRef(fromClause, selectClause) {
    const fromClauseColumns = column_ref_1.ColumnRefUtil.fromJoinArray((fromClause.currentJoins != undefined) ?
        fromClause.currentJoins :
        []);
    const selectClauseColumns = (selectClause == undefined ?
        {} :
        column_ref_1.ColumnRefUtil.fromSelectClause(selectClause));
    const result = column_ref_1.ColumnRefUtil.intersect(fromClauseColumns, selectClauseColumns);
    return result;
}
exports.allowedColumnRef = allowedColumnRef;
/**
 * For now, this is basically the same as `HavingClauseUtil.AllowedUsedRef<>`.
 *
 * They will diverge when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 */
function allowedUsedRef(fromClause, selectClause) {
    const usedRef = used_ref_1.UsedRefUtil.fromColumnRef(allowedColumnRef(fromClause, selectClause));
    return usedRef;
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/order-by-clause/util/query/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/order-by-clause/util/query/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "../tsql/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/order-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order/index.js":
/*!***********************************!*\
  !*** ../tsql/dist/order/index.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OrderUtil = __webpack_require__(/*! ./util */ "../tsql/dist/order/util/index.js");
exports.OrderUtil = OrderUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order/util/constructor/from-raw-order.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/order/util/constructor/from-raw-order.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/order/util/predicate/index.js");
function fromRawOrder(rawOrder) {
    if (predicate_1.isOrder(rawOrder)) {
        return rawOrder;
    }
    else {
        return [rawOrder, sort_direction_1.SortDirection.ASC];
    }
}
exports.fromRawOrder = fromRawOrder;
//# sourceMappingURL=from-raw-order.js.map

/***/ }),

/***/ "../tsql/dist/order/util/constructor/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/order/util/constructor/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-raw-order */ "../tsql/dist/order/util/constructor/from-raw-order.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order/util/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/order/util/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/order/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/order/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/order/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order/util/predicate/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/order/util/predicate/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-order */ "../tsql/dist/order/util/predicate/is-order.js"));
__export(__webpack_require__(/*! ./is-sort-expr */ "../tsql/dist/order/util/predicate/is-sort-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/order/util/predicate/is-order.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/order/util/predicate/is-order.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
/**
 * Checks,
 * + If it is an 2-tuple
 * + If the second element is a `SortDirection`
 *
 * Does not check,
 * + If the first element is a `SortExpr` (for run-time performance)
 *
 * @param mixed
 */
function isOrder(mixed) {
    return (Array.isArray(mixed) &&
        mixed.length == 2 &&
        sort_direction_1.SortDirectionUtil.isSortDirection(mixed[1]));
}
exports.isOrder = isOrder;
//# sourceMappingURL=is-order.js.map

/***/ }),

/***/ "../tsql/dist/order/util/predicate/is-sort-expr.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/order/util/predicate/is-sort-expr.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
function isSortExpr(mixed) {
    return (column_1.ColumnUtil.isColumn(mixed) ||
        expr_1.ExprUtil.isExpr(mixed) ||
        expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(mixed));
}
exports.isSortExpr = isSortExpr;
//# sourceMappingURL=is-sort-expr.js.map

/***/ }),

/***/ "../tsql/dist/order/util/query/extract-sort-expr.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/order/util/query/extract-sort-expr.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/order/util/predicate/index.js");
function extractSortExpr(rawOrder) {
    if (predicate_1.isOrder(rawOrder)) {
        return rawOrder[0];
    }
    else {
        return rawOrder;
    }
}
exports.extractSortExpr = extractSortExpr;
//# sourceMappingURL=extract-sort-expr.js.map

/***/ }),

/***/ "../tsql/dist/order/util/query/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/order/util/query/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-sort-expr */ "../tsql/dist/order/util/query/extract-sort-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/partial-row/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/partial-row/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const PartialRowUtil = __webpack_require__(/*! ./util */ "../tsql/dist/partial-row/util/index.js");
exports.PartialRowUtil = PartialRowUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/partial-row/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/partial-row/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/partial-row/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/partial-row/util/query/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/partial-row/util/query/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/partial-row/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/partial-row/util/query/mapper.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/partial-row/util/query/mapper.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.partialMapper(table.columns);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/primary-key/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/primary-key/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const PrimaryKeyUtil = __webpack_require__(/*! ./util */ "../tsql/dist/primary-key/util/index.js");
exports.PrimaryKeyUtil = PrimaryKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/primary-key/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/primary-key/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/primary-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/primary-key/util/query/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/primary-key/util/query/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/primary-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/primary-key/util/query/mapper.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/primary-key/util/query/mapper.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, table.primaryKey));
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/promise-util/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/promise-util/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./invoke-async-callback-safely */ "../tsql/dist/promise-util/invoke-async-callback-safely.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/promise-util/invoke-async-callback-safely.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/promise-util/invoke-async-callback-safely.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
async function invokeAsyncCallbackSafely(asyncCallback, thenCallback, catchCallback) {
    try {
        return asyncCallback()
            .then(thenCallback, catchCallback);
    }
    catch (syncErr) {
        return catchCallback(syncErr);
    }
}
exports.invokeAsyncCallbackSafely = invokeAsyncCallbackSafely;
//# sourceMappingURL=invoke-async-callback-safely.js.map

/***/ }),

/***/ "../tsql/dist/query-base/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/query-base/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const QueryBaseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/query-base/util/index.js");
exports.QueryBaseUtil = QueryBaseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/query-base/util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/query-base/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/query-base/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/query-base/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/as.js":
/*!****************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/as.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_1 = __webpack_require__(/*! ../../../derived-table */ "../tsql/dist/derived-table/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/query-base/util/query/index.js");
const constants_1 = __webpack_require__(/*! ../../../constants */ "../tsql/dist/constants.js");
const derived_table_select_item_1 = __webpack_require__(/*! ../../../derived-table-select-item */ "../tsql/dist/derived-table-select-item/index.js");
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/query-base/util/predicate/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
function assertAliasable(query) {
    const duplicateColumnAlias = select_clause_1.SelectClauseUtil.duplicateColumnAlias(query.selectClause);
    if (duplicateColumnAlias.length > 0) {
        throw new Error(`Cannot alias query with duplicate names in SELECT clause; ${duplicateColumnAlias.join(", ")}`);
    }
}
function as(query, alias) {
    assertAliasable(query);
    if (predicate_1.isOneSelectItem(query) && predicate_1.isZeroOrOneRow(query)) {
        const result = new derived_table_select_item_1.DerivedTableSelectItem({
            mapper: query_1.mapper(query),
            isLateral: false,
            tableAlias: constants_1.ALIASED,
            alias,
            columns: (column_map_1.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
            usedRef: used_ref_1.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                [] :
                query.fromClause.outerQueryJoins),
            isAggregate: false,
        }, ast_1.parentheses(query, false));
        /**
         * @todo Investigate why we can't cast to `As<>` directly
         */
        return result;
    }
    else {
        const result = new derived_table_1.DerivedTable({
            isLateral: false,
            alias,
            columns: (column_map_1.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
            usedRef: used_ref_1.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                [] :
                query.fromClause.outerQueryJoins),
        }, query);
        /**
         * @todo Investigate why we can't cast to `As<>` directly
         */
        return result;
    }
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/asc.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/asc.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "../tsql/dist/query-base/util/operation/coalesce.js");
function asc(query) {
    return [
        coalesce_1.coalesce(query, null),
        sort_direction_1.SortDirection.ASC
    ];
}
exports.asc = asc;
//# sourceMappingURL=asc.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/coalesce.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/coalesce.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function coalesce(query, defaultValue) {
    return ExprLib.coalesce(query, defaultValue);
}
exports.coalesce = coalesce;
//# sourceMappingURL=coalesce.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/desc.js":
/*!******************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/desc.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "../tsql/dist/sort-direction/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "../tsql/dist/query-base/util/operation/coalesce.js");
function desc(query) {
    return [
        coalesce_1.coalesce(query, null),
        sort_direction_1.SortDirection.DESC
    ];
}
exports.desc = desc;
//# sourceMappingURL=desc.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./as */ "../tsql/dist/query-base/util/operation/as.js"));
__export(__webpack_require__(/*! ./asc */ "../tsql/dist/query-base/util/operation/asc.js"));
__export(__webpack_require__(/*! ./coalesce */ "../tsql/dist/query-base/util/operation/coalesce.js"));
__export(__webpack_require__(/*! ./desc */ "../tsql/dist/query-base/util/operation/desc.js"));
__export(__webpack_require__(/*! ./sort */ "../tsql/dist/query-base/util/operation/sort.js"));
__export(__webpack_require__(/*! ./throw-if-null */ "../tsql/dist/query-base/util/operation/throw-if-null.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/sort.js":
/*!******************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/sort.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "../tsql/dist/query-base/util/operation/coalesce.js");
function sort(query, sortDirection) {
    return [
        coalesce_1.coalesce(query, null),
        sortDirection
    ];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/operation/throw-if-null.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/query-base/util/operation/throw-if-null.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function throwIfNull(query) {
    return ExprLib.throwIfNull(query);
}
exports.throwIfNull = throwIfNull;
//# sourceMappingURL=throw-if-null.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-after-from-clause */ "../tsql/dist/query-base/util/predicate/is-after-from-clause.js"));
__export(__webpack_require__(/*! ./is-after-select-clause */ "../tsql/dist/query-base/util/predicate/is-after-select-clause.js"));
__export(__webpack_require__(/*! ./is-before-compound-query-clause */ "../tsql/dist/query-base/util/predicate/is-before-compound-query-clause.js"));
__export(__webpack_require__(/*! ./is-before-select-clause */ "../tsql/dist/query-base/util/predicate/is-before-select-clause.js"));
__export(__webpack_require__(/*! ./is-one-row */ "../tsql/dist/query-base/util/predicate/is-one-row.js"));
__export(__webpack_require__(/*! ./is-one-select-item */ "../tsql/dist/query-base/util/predicate/is-one-select-item.js"));
__export(__webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row-using-limit */ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row-using-compound-query-limit */ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row */ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-after-from-clause.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-after-from-clause.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
function isAfterFromClause(x) {
    return is_query_1.isQuery(x) && from_clause_1.FromClauseUtil.isAfterFromClause(x.fromClause);
}
exports.isAfterFromClause = isAfterFromClause;
//# sourceMappingURL=is-after-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-after-select-clause.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-after-select-clause.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
function isAfterSelectClause(x) {
    return is_query_1.isQuery(x) && (x.selectClause != undefined);
}
exports.isAfterSelectClause = isAfterSelectClause;
//# sourceMappingURL=is-after-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-before-compound-query-clause.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-before-compound-query-clause.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
function isBeforeCompoundQueryClause(x) {
    return is_query_1.isQuery(x) && (x.compoundQueryClause == undefined);
}
exports.isBeforeCompoundQueryClause = isBeforeCompoundQueryClause;
//# sourceMappingURL=is-before-compound-query-clause.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-before-select-clause.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-before-select-clause.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
function isBeforeSelectClause(x) {
    return is_query_1.isQuery(x) && (x.selectClause == undefined);
}
exports.isBeforeSelectClause = isBeforeSelectClause;
//# sourceMappingURL=is-before-select-clause.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-one-row.js":
/*!************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-one-row.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
function isOneRow(x) {
    return (is_query_1.isQuery(x) &&
        ((from_clause_1.FromClauseUtil.isBeforeFromClause(x.fromClause) &&
            x.compoundQueryClause == undefined) ||
            (x.groupByClause != undefined &&
                x.groupByClause.length == 0 &&
                x.compoundQueryClause == undefined)));
}
exports.isOneRow = isOneRow;
//# sourceMappingURL=is-one-row.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-one-select-item.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-one-select-item.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_after_select_clause_1 = __webpack_require__(/*! ./is-after-select-clause */ "../tsql/dist/query-base/util/predicate/is-after-select-clause.js");
const select_item_1 = __webpack_require__(/*! ../../../select-item */ "../tsql/dist/select-item/index.js");
function isOneSelectItem(x) {
    return (is_after_select_clause_1.isAfterSelectClause(x) &&
        x.selectClause.length == 1 &&
        select_item_1.SelectItemUtil.isSingleValueSelectItem(x.selectClause[0]));
}
exports.isOneSelectItem = isOneSelectItem;
//# sourceMappingURL=is-one-select-item.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-query.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-query.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Only checks that the properties exist.
 * Does not actually check that they are the right data type!
 *
 * @todo Consider adding checks for increased type safety.
 */
function isQuery(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "fromClause",
        "selectClause",
        "limitClause",
        "compoundQueryClause",
        "compoundQueryLimitClause",
        "mapDelegate",
        "whereClause",
        "groupByClause",
        "havingClause",
        "orderByClause",
        "compoundQueryOrderByClause",
        "isDistinct",
    ])) {
        return false;
    }
    return true;
}
exports.isQuery = isQuery;
//# sourceMappingURL=is-query.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js":
/*!***********************************************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
function isZeroOrOneRowUsingCompoundQueryLimit(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (is_query_1.isQuery(x) &&
        x.compoundQueryLimitClause != undefined &&
        (tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(0)) ||
            tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(1))));
}
exports.isZeroOrOneRowUsingCompoundQueryLimit = isZeroOrOneRowUsingCompoundQueryLimit;
//# sourceMappingURL=is-zero-or-one-row-using-compound-query-limit.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const is_query_1 = __webpack_require__(/*! ./is-query */ "../tsql/dist/query-base/util/predicate/is-query.js");
function isZeroOrOneRowUsingLimit(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (is_query_1.isQuery(x) &&
        x.limitClause != undefined &&
        (tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(0)) ||
            tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(1))) &&
        x.compoundQueryClause == undefined &&
        x.compoundQueryLimitClause == undefined);
}
exports.isZeroOrOneRowUsingLimit = isZeroOrOneRowUsingLimit;
//# sourceMappingURL=is-zero-or-one-row-using-limit.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/query-base/util/predicate/is-zero-or-one-row.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_one_row_1 = __webpack_require__(/*! ./is-one-row */ "../tsql/dist/query-base/util/predicate/is-one-row.js");
const is_zero_or_one_row_using_limit_1 = __webpack_require__(/*! ./is-zero-or-one-row-using-limit */ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js");
const is_zero_or_one_row_using_compound_query_limit_1 = __webpack_require__(/*! ./is-zero-or-one-row-using-compound-query-limit */ "../tsql/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js");
function isZeroOrOneRow(x) {
    return (
    /**
     * This `OR` expression is sorted from most likely to least likely.
     * Do not change the order unless you have a good reason!
     */
    is_zero_or_one_row_using_limit_1.isZeroOrOneRowUsingLimit(x) ||
        is_zero_or_one_row_using_compound_query_limit_1.isZeroOrOneRowUsingCompoundQueryLimit(x) ||
        is_one_row_1.isOneRow(x));
}
exports.isZeroOrOneRow = isZeroOrOneRow;
//# sourceMappingURL=is-zero-or-one-row.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/query/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/query-base/util/query/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/query-base/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/query-base/util/query/mapper.js":
/*!****************************************************!*\
  !*** ../tsql/dist/query-base/util/query/mapper.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/query-base/util/predicate/index.js");
function mapper(query) {
    if (predicate_1.isOneRow(query)) {
        return query.selectClause[0].mapper;
    }
    else {
        return tm.orNull(query.selectClause[0].mapper);
    }
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/row/index.js":
/*!*********************************!*\
  !*** ../tsql/dist/row/index.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RowUtil = __webpack_require__(/*! ./util */ "../tsql/dist/row/util/index.js");
exports.RowUtil = RowUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/row/util/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/row/util/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/row/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/row/util/query/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/row/util/query/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/row/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/row/util/query/mapper.js":
/*!*********************************************!*\
  !*** ../tsql/dist/row/util/query/mapper.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.mapper(table.columns);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/schema-validation/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./schema-validation-error */ "../tsql/dist/schema-validation/schema-validation-error.js"));
__export(__webpack_require__(/*! ./schema-validation-warning */ "../tsql/dist/schema-validation/schema-validation-warning.js"));
const SchemaValidationUtil = __webpack_require__(/*! ./util */ "../tsql/dist/schema-validation/util/index.js");
exports.SchemaValidationUtil = SchemaValidationUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/schema-validation-error.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/schema-validation/schema-validation-error.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SchemaValidationErrorType;
(function (SchemaValidationErrorType) {
    SchemaValidationErrorType["TABLE_ON_APPLICATION_ONLY"] = "TABLE_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["TABLE_ALIAS_MISMATCH"] = "TABLE_ALIAS_MISMATCH";
    SchemaValidationErrorType["PRIMARY_KEY_ON_APPLICATION_ONLY"] = "PRIMARY_KEY_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["PRIMARY_KEY_MISMATCH"] = "PRIMARY_KEY_MISMATCH";
    SchemaValidationErrorType["CANDIDATE_KEY_ON_APPLICATION_ONLY"] = "CANDIDATE_KEY_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY"] = "DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY";
    SchemaValidationErrorType["COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_ON_APPLICATION_ONLY"] = "COLUMN_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["COLUMN_ALIAS_MISMATCH"] = "COLUMN_ALIAS_MISMATCH";
    SchemaValidationErrorType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_DATABASE_ONLY"] = "COLUMN_NULLABLE_ON_DATABASE_ONLY";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION"] = "COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
})(SchemaValidationErrorType = exports.SchemaValidationErrorType || (exports.SchemaValidationErrorType = {}));
//# sourceMappingURL=schema-validation-error.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/schema-validation-warning.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/schema-validation/schema-validation-warning.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SchemaValidationWarningType;
(function (SchemaValidationWarningType) {
    SchemaValidationWarningType["TABLE_ON_DATABASE_ONLY"] = "TABLE_ON_DATABASE_ONLY";
    SchemaValidationWarningType["TABLE_HAS_NO_PRIMARY_KEY"] = "TABLE_HAS_NO_PRIMARY_KEY";
    SchemaValidationWarningType["PRIMARY_KEY_ON_DATABASE_ONLY"] = "PRIMARY_KEY_ON_DATABASE_ONLY";
    SchemaValidationWarningType["CANDIDATE_KEY_ON_DATABASE_ONLY"] = "CANDIDATE_KEY_ON_DATABASE_ONLY";
    SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE"] = "COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE";
    SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED"] = "COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["AUTO_INCREMENT_ON_DATABASE_ONLY"] = "AUTO_INCREMENT_ON_DATABASE_ONLY";
    SchemaValidationWarningType["AUTO_INCREMENT_MISMATCH_INSERT_DISABLED"] = "AUTO_INCREMENT_MISMATCH_INSERT_DISABLED";
    SchemaValidationWarningType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED";
})(SchemaValidationWarningType = exports.SchemaValidationWarningType || (exports.SchemaValidationWarningType = {}));
//# sourceMappingURL=schema-validation-warning.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/util/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/schema-validation/util/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/schema-validation/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/util/operation/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/schema-validation/util/operation/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./validate-column */ "../tsql/dist/schema-validation/util/operation/validate-column.js"));
__export(__webpack_require__(/*! ./validate-schema */ "../tsql/dist/schema-validation/util/operation/validate-schema.js"));
__export(__webpack_require__(/*! ./validate-table */ "../tsql/dist/schema-validation/util/operation/validate-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/util/operation/validate-column.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/schema-validation/util/operation/validate-column.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "../tsql/dist/schema-validation/schema-validation-error.js");
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "../tsql/dist/schema-validation/schema-validation-warning.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "../tsql/dist/sqlstring/index.js");
function validateColumn(applicationTable, applicationColumn, columnMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    /**
     * Sanity check...
     */
    if (applicationColumn.columnAlias != columnMeta.columnAlias) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ALIAS_MISMATCH,
            description: `Application column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)}, database column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)}`,
            tableAlias: applicationTable.alias,
            applicationColumnAlias: applicationColumn.columnAlias,
            databaseColumnAlias: columnMeta.columnAlias,
        });
        return result;
    }
    const applicationNullable = applicationTable.nullableColumns.includes(columnMeta.columnAlias);
    const applicationMutable = applicationTable.mutableColumns.includes(applicationColumn.columnAlias);
    /*const applicationAutoIncrement = (
        applicationTable.autoIncrement != undefined &&
        applicationTable.autoIncrement == applicationColumn.columnAlias
    );*/
    const applicationGenerated = applicationTable.generatedColumns.includes(applicationColumn.columnAlias);
    const applicationExplicitDefaultValue = applicationTable.explicitDefaultValueColumns.includes(applicationColumn.columnAlias);
    if (columnMeta.isNullable) {
        if (applicationNullable) {
            /**
             * OK
             */
        }
        else {
            /**
             * + Database is nullable.
             * + Application is **not** nullable.
             *
             * -----
             *
             * + Attempts to `SELECT` the `NULL` value will fail.
             * + Attempts to `INSERT` are fine.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression expecting non-`NULL` will fail.
             *
             */
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on database only; SELECTs will fail`,
                tableAlias: applicationTable.alias,
                columnAlias: applicationColumn.columnAlias,
            });
        }
    }
    else {
        if (applicationNullable) {
            /**
             * + Database is **not** nullable.
             * + Application is nullable.
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` the `NULL` value will fail.
             * + Attempts to `UPDATE` to the `NULL` value will fail.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression expecting nullable are fine.
             *
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs using NULL value will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else if (applicationMutable) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; UPDATEs using NULL value will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs and UPDATEs using NULL value will fail but both are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    if (columnMeta.generationExpression != undefined) {
        if (applicationGenerated) {
            /**
             * OK
             */
        }
        else {
            /**
             * + This column is generated on the database
             * + This column is **not** generated on the application
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` will fail because you cannot set values for generated columns.
             * + Attsmpts to `UPDATE` will fail because you cannot set values for generated columns.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else if (applicationMutable) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; UPDATEs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs and UPDATEs will fail but both are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
        }
    }
    else {
        if (applicationGenerated) {
            if (applicationTable.autoIncrement != undefined &&
                applicationTable.autoIncrement == applicationColumn.columnAlias) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} cannot be generated and auto-increment at the same time`,
                    tableAlias: applicationTable.alias,
                    applicationColumnAlias: applicationTable.autoIncrement,
                });
            }
            else {
                if (columnMeta.isNullable ||
                    columnMeta.isAutoIncrement ||
                    columnMeta.explicitDefaultValue != undefined) {
                    /**
                     * + This column has an implicit/explicit default/generated value on the database
                     *
                     * So, we can kind of pretend it's generated on application code, anyway.
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` won't set the value because we say it is generated.
                     * + Attempts to `UPDATE` won't set the value because we say it is generated.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will use database default value`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    /**
                     * We say it is generated on application code.
                     * But it has **no** default/generated value on the database.
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail because we cannot set the value on application code,
                     *   and there is no default/generated value on the database.
                     * + Attempts to `UPDATE` won't set the value because we say it is generated.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    if (applicationTable.insertEnabled) {
                        result.errors.push({
                            type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                    else {
                        result.warnings.push({
                            type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail but INSERTs are disabled`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                }
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    if (columnMeta.explicitDefaultValue != undefined) {
        if (applicationExplicitDefaultValue) {
            /**
             * OK
             */
        }
        else {
            /**
             * It has an explicit default value on the database.
             * But not on application code.
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` are fine; they just cannot use the default value.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on database only`,
                tableAlias: applicationTable.alias,
                columnAlias: applicationColumn.columnAlias,
                explicitDefaultValue: columnMeta.explicitDefaultValue,
            });
        }
    }
    else {
        if (applicationExplicitDefaultValue) {
            if (columnMeta.isNullable ||
                columnMeta.isAutoIncrement ||
                columnMeta.generationExpression != undefined) {
                /**
                 * It **does not** have an explicit default value on the database.
                 * But it does, on application code.
                 *
                 * However, it does have other default/generated values on the database...
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` are fine; they will just use the other default/generated values on the database.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will use database generated or NULL value`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                    isNullable: columnMeta.isNullable,
                    isAutoIncrement: columnMeta.isAutoIncrement,
                    generationExpression: columnMeta.generationExpression,
                    explicitDefaultValue: columnMeta.explicitDefaultValue,
                });
            }
            else {
                /**
                 * It **does not** have an explicit default value on the database.
                 * But it does, on application code.
                 *
                 * There are also no other default/generated values on the database...
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail; there is no default/generated value on the database to use.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail but INSERTs are disabled`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    return result;
}
exports.validateColumn = validateColumn;
//# sourceMappingURL=validate-column.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/util/operation/validate-schema.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/schema-validation/util/operation/validate-schema.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "../tsql/dist/schema-validation/schema-validation-warning.js");
const validate_table_1 = __webpack_require__(/*! ./validate-table */ "../tsql/dist/schema-validation/util/operation/validate-table.js");
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "../tsql/dist/schema-validation/schema-validation-error.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "../tsql/dist/sqlstring/index.js");
function validateSchema(applicationTables, schemaMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    const tablesOnDatabaseOnly = schemaMeta.tables.filter(tableMeta => {
        const applicationTable = applicationTables.find(applicationTable => applicationTable.alias == tableMeta.tableAlias);
        return (applicationTable == undefined);
    });
    for (const tableMeta of tablesOnDatabaseOnly) {
        result.warnings.push({
            type: schema_validation_warning_1.SchemaValidationWarningType.TABLE_ON_DATABASE_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)} exists on database only`,
            databaseTableAlias: tableMeta.tableAlias,
        });
    }
    const tablesOnApplicationOnly = applicationTables.filter(applicationTable => {
        const tableMeta = schemaMeta.tables.find(tableMeta => applicationTable.alias == tableMeta.tableAlias);
        return (tableMeta == undefined);
    });
    for (const applicationTable of tablesOnApplicationOnly) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.TABLE_ON_APPLICATION_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} exists on application only; not found on schema ${sqlstring_1.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}`,
            applicationTableAlias: applicationTable.alias,
            databaseSchemaAlias: schemaMeta.schemaAlias,
        });
    }
    for (const applicationTable of applicationTables) {
        const tableMeta = schemaMeta.tables.find(tableMeta => tableMeta.tableAlias == applicationTable.alias);
        if (tableMeta == undefined) {
            continue;
        }
        const validateTableResult = validate_table_1.validateTable(applicationTable, tableMeta);
        result.errors.push(...validateTableResult.errors);
        result.warnings.push(...validateTableResult.warnings);
    }
    return result;
}
exports.validateSchema = validateSchema;
//# sourceMappingURL=validate-schema.js.map

/***/ }),

/***/ "../tsql/dist/schema-validation/util/operation/validate-table.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/schema-validation/util/operation/validate-table.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "../tsql/dist/schema-validation/schema-validation-error.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "../tsql/dist/schema-validation/schema-validation-warning.js");
const validate_column_1 = __webpack_require__(/*! ./validate-column */ "../tsql/dist/schema-validation/util/operation/validate-column.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "../tsql/dist/sqlstring/index.js");
function validateTable(applicationTable, tableMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    /**
     * Sanity check...
     */
    if (applicationTable.alias != tableMeta.tableAlias) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.TABLE_ALIAS_MISMATCH,
            description: `Application table is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}, database table is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}`,
            applicationTableAlias: applicationTable.alias,
            databaseTableAlias: tableMeta.tableAlias,
        });
        return result;
    }
    /**
     * Primary key check
     */
    if (tableMeta.primaryKey == undefined) {
        if (applicationTable.primaryKey == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.TABLE_HAS_NO_PRIMARY_KEY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY`,
                tableAlias: applicationTable.alias,
            });
        }
        else {
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.PRIMARY_KEY_ON_APPLICATION_ONLY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
                tableAlias: applicationTable.alias,
                primaryKey: [...applicationTable.primaryKey],
            });
        }
    }
    else {
        if (applicationTable.primaryKey == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.PRIMARY_KEY_ON_DATABASE_ONLY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
                tableAlias: applicationTable.alias,
                primaryKey: [...tableMeta.primaryKey.columnAliases],
            });
        }
        else {
            if (key_1.KeyUtil.isEqual(applicationTable.primaryKey, tableMeta.primaryKey.columnAliases)) {
                //OK, no problems here
            }
            else {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.PRIMARY_KEY_MISMATCH,
                    description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application, PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database`,
                    tableAlias: applicationTable.alias,
                    applicationPrimaryKey: [...applicationTable.primaryKey],
                    databasePrimaryKey: [...tableMeta.primaryKey.columnAliases],
                });
            }
        }
    }
    /**
     * Candidate keys check
     */
    const candidateKeysOnDatabaseOnly = tableMeta.candidateKeys.filter(candidateKeyMeta => {
        if (applicationTable.primaryKey != undefined &&
            key_1.KeyUtil.isEqual(applicationTable.primaryKey, candidateKeyMeta.columnAliases)) {
            return false;
        }
        const applicationCandidateKey = applicationTable.candidateKeys.find(applicationCandidateKey => {
            return key_1.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
        });
        return (applicationCandidateKey == undefined);
    });
    for (const candidateKey of candidateKeysOnDatabaseOnly) {
        result.warnings.push({
            type: schema_validation_warning_1.SchemaValidationWarningType.CANDIDATE_KEY_ON_DATABASE_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
            tableAlias: applicationTable.alias,
            databaseCandidateKey: [...candidateKey.columnAliases],
        });
    }
    const candidateKeysOnApplicationOnly = applicationTable.candidateKeys.filter(applicationCandidateKey => {
        if (tableMeta.primaryKey != undefined &&
            key_1.KeyUtil.isEqual(tableMeta.primaryKey.columnAliases, applicationCandidateKey)) {
            return false;
        }
        const candidateKeyMeta = tableMeta.candidateKeys.find(candidateKeyMeta => {
            return key_1.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
        });
        return (candidateKeyMeta == undefined);
    });
    for (const candidateKey of candidateKeysOnApplicationOnly) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.CANDIDATE_KEY_ON_APPLICATION_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
            tableAlias: applicationTable.alias,
            applicationCandidateKey: [...candidateKey],
        });
    }
    /**
     * Tables should really have a candidate key...
     */
    if (tableMeta.primaryKey == undefined && tableMeta.candidateKeys.length == 0) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY or CANDIDATE KEY on database`,
            tableAlias: applicationTable.alias,
        });
    }
    /**
     * There should only be zero or one auto-increment column on tables.
     * We validate them here.
     */
    const autoIncrementColumnMeta = tableMeta.columns.find(columnMeta => columnMeta.isAutoIncrement);
    if (autoIncrementColumnMeta == undefined) {
        if (applicationTable.autoIncrement == undefined) {
            /**
             * OK!
             */
        }
        else {
            /**
             * + The database has **no** auto-increment column.
             * + The application has an auto-increment column.
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationTable.autoIncrement,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail but INSERTs are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationTable.autoIncrement,
                });
            }
        }
    }
    else {
        if (applicationTable.autoIncrement == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} is auto-increment on database only`,
                tableAlias: tableMeta.tableAlias,
                columnAlias: autoIncrementColumnMeta.columnAlias,
            });
        }
        else {
            if (autoIncrementColumnMeta.columnAlias == applicationTable.autoIncrement) {
                /**
                 * OK!
                 */
            }
            else {
                /**
                 * The database and application disagree what the auto-increment column is.
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                        applicationColumnAlias: applicationTable.autoIncrement,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_MISMATCH_INSERT_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail but INSERTs are disabled`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                        applicationColumnAlias: applicationTable.autoIncrement,
                    });
                }
            }
        }
    }
    /**
     * Validate columns
     */
    for (const columnMeta of tableMeta.columns) {
        const applicationColumn = applicationTable.columns[columnMeta.columnAlias];
        if (applicationColumn == undefined) {
            if (applicationTable.insertEnabled) {
                if (
                /**
                 * There's an implicit default/generated value
                 */
                columnMeta.isNullable ||
                    columnMeta.isAutoIncrement ||
                    /**
                     * There's an explicit default/generated value
                     */
                    columnMeta.generationExpression != undefined ||
                    columnMeta.explicitDefaultValue != undefined) {
                    /**
                     * + Database has column
                     * + Application **does not** have column
                     * + Database column has default/generated value
                     * + `INSERT` is enabled
                     *
                     * -----
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` are fine; will just use default/generated value on database.
                     * + Attempts to `UPDATE` will never happen; does not exist on application.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression will never happen; does not exist on application.
                     *
                     */
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; but has a default or generated value`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: columnMeta.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                        insertEnabled: applicationTable.insertEnabled,
                    });
                }
                else {
                    /**
                     * + Database has column
                     * + Application **does not** have column
                     * + Database column **does not** have default/generated value
                     * + `INSERT` is enabled
                     *
                     * -----
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail; does not exist on application, and no default/generated value on database.
                     * + Attempts to `UPDATE` will never happen; does not exist on application.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression will never happen; does not exist on application.
                     *
                     */
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs will fail`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: columnMeta.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                        insertEnabled: applicationTable.insertEnabled,
                    });
                }
            }
            else {
                /**
                 * + Database has column
                 * + Application **does not** have column
                 * + `INSERT` is disabled
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will never happen; it is disabled.
                 * + Attempts to `UPDATE` will never happen; does not exist on application.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression will never happen; does not exist on application.
                 *
                 */
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs may fail but INSERTs are disabled`,
                    tableAlias: tableMeta.tableAlias,
                    databaseColumnAlias: columnMeta.columnAlias,
                    isNullable: columnMeta.isNullable,
                    isAutoIncrement: columnMeta.isAutoIncrement,
                    generationExpression: columnMeta.generationExpression,
                    explicitDefaultValue: columnMeta.explicitDefaultValue,
                    insertEnabled: applicationTable.insertEnabled,
                });
            }
        }
        else {
            const validateColumnResult = validate_column_1.validateColumn(applicationTable, applicationColumn, columnMeta);
            result.errors.push(...validateColumnResult.errors);
            result.warnings.push(...validateColumnResult.warnings);
        }
    }
    for (const columnAlias of Object.keys(applicationTable.columns)) {
        const applicationColumn = applicationTable.columns[columnAlias];
        const columnMeta = tableMeta.columns.find(columnMeta => columnMeta.columnAlias == columnAlias);
        if (columnMeta == undefined) {
            /**
             *
             * + Attempts to `SELECT` will fail.
             * + Attempts to `INSERT` will fail.
             * + Attempts to `UPDATE` will fail.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression will fail.
             *
             */
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ON_APPLICATION_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} exists on application only`,
                tableAlias: applicationTable.alias,
                applicationColumnAlias: applicationColumn.columnAlias,
            });
        }
    }
    return result;
}
exports.validateTable = validateTable;
//# sourceMappingURL=validate-table.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/select-clause/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SelectClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/select-clause/util/index.js");
exports.SelectClauseUtil = SelectClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/constructor/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/select-clause/util/constructor/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./value-from-built-in-expr */ "../tsql/dist/select-clause/util/constructor/value-from-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/constructor/value-from-built-in-expr.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/constructor/value-from-built-in-expr.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
exports.SELECT_VALUE_ALIAS = "value";
function valueFromBuiltInExpr(builtInExpr) {
    if (column_1.ColumnUtil.isColumn(builtInExpr) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return [builtInExpr];
    }
    else {
        return [
            expr_1.ExprUtil.as(expr_1.ExprUtil.fromBuiltInExpr(builtInExpr), exports.SELECT_VALUE_ALIAS)
        ];
    }
}
exports.valueFromBuiltInExpr = valueFromBuiltInExpr;
//# sourceMappingURL=value-from-built-in-expr.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/select-clause/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/select-clause/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/select-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/select-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/select-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/select-clause/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./left-compound */ "../tsql/dist/select-clause/util/operation/left-compound.js"));
__export(__webpack_require__(/*! ./select-value */ "../tsql/dist/select-clause/util/operation/select-value.js"));
__export(__webpack_require__(/*! ./select */ "../tsql/dist/select-clause/util/operation/select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/operation/left-compound.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/select-clause/util/operation/left-compound.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
/**
 * Assumes `A` is shorter than, or the same length as `B`
 */
function leftCompound(a, b) {
    const result = [];
    for (let i = 0; i < a.length; ++i) {
        const itemA = a[i];
        const itemB = b[i];
        if (column_1.ColumnUtil.isColumn(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                result.push(column_1.ColumnUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
            }
            else {
                throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
            }
        }
        else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                result.push(expr_select_item_1.ExprSelectItemUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
            }
            else {
                throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
            }
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(itemA)) {
            if (column_map_1.ColumnMapUtil.isColumnMap(itemB)) {
                result.push(column_map_1.ColumnMapUtil.compound(itemA, itemB));
            }
            else {
                throw new Error(`Expected index ${i} to be ColumnMap`);
            }
        }
        else if (column_ref_1.ColumnRefUtil.isColumnRef(itemA)) {
            if (column_ref_1.ColumnRefUtil.isColumnRef(itemB)) {
                result.push(column_ref_1.ColumnRefUtil.compound(itemA, itemB));
            }
            else {
                throw new Error(`Expected index ${i} to be ColumnMap`);
            }
        }
        else {
            throw new Error(`Unknown SELECT item at index ${i}`);
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/operation/select-value.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/select-clause/util/operation/select-value.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_1 = __webpack_require__(/*! ./select */ "../tsql/dist/select-clause/util/operation/select.js");
const constructor_1 = __webpack_require__(/*! ../constructor */ "../tsql/dist/select-clause/util/constructor/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .select(() => [myExpr.as("value")])
 * ```
 *
 * Intended usage,
 * ```ts
 *  myQuery
 *      .selectValue(() => myExpr)
 * ```
 */
function selectValue(fromClause, groupByClause, selectClause, selectValueDelegate) {
    return select_1.select(fromClause, groupByClause, selectClause, columns => constructor_1.valueFromBuiltInExpr(selectValueDelegate(columns)));
}
exports.selectValue = selectValue;
//# sourceMappingURL=select-value.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/operation/select.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/select-clause/util/operation/select.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/select-clause/util/query/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/select-clause/util/predicate/index.js");
/**
 * Returns the MySQL equivalent of `...selectClause, ...selectClauseDelegate(fromClause)`
 *
 * @param fromClause
 * @param selectClause
 * @param selectDelegate
 *
 * @todo This should only be allowed **BEFORE** the `COMPOUND QUERY` clause.
 * If we `SELECT` after the `COMPOUND QUERY` clause, it'll change the number of columns, leading to bugs.
 */
function select(fromClause, groupByClause, selectClause, selectDelegate) {
    const columns = query_1.allowedColumnRef(fromClause);
    const selects = selectDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    predicate_1.assertValidColumnIdentifier(selectClause, selects);
    if (groupByClause == undefined) {
        if (selects.some(selectItem => expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate) ||
            (selectClause != undefined &&
                selectClause.some(selectItem => expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate))) {
            predicate_1.assertValidUsedRef_Aggregate(fromClause, selects);
            predicate_1.assertValidUsedRef_NonAggregate(fromClause, [], selects);
        }
        else {
            predicate_1.assertValidUsedRef(fromClause, selects);
        }
    }
    else {
        predicate_1.assertValidUsedRef_Aggregate(fromClause, selects);
        predicate_1.assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects);
    }
    return (selectClause == undefined ?
        selects :
        [...selectClause, ...selects]);
}
exports.select = select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/predicate/assert-valid-column-identifier.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/predicate/assert-valid-column-identifier.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
function assertValidColumnIdentifier(selectClause, selects) {
    const selectsIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selects);
    column_identifier_1.ColumnIdentifierArrayUtil.assertNoDuplicate(selectsIdentifiers);
    if (selectClause != undefined) {
        const selectClauseIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selectClause);
        column_identifier_1.ColumnIdentifierArrayUtil.assertDisjoint(selectClauseIdentifiers, selectsIdentifiers);
    }
}
exports.assertValidColumnIdentifier = assertValidColumnIdentifier;
//# sourceMappingURL=assert-valid-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js":
/*!************************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/select-clause/util/query/index.js");
function assertValidUsedRef_Aggregate(fromClause, selects) {
    const columns = query_1.allowedColumnRef(fromClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            if (selectItem.isAggregate) {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
            }
        }
    }
}
exports.assertValidUsedRef_Aggregate = assertValidUsedRef_Aggregate;
//# sourceMappingURL=assert-valid-used-ref-aggregate.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js":
/*!****************************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/select-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects) {
    const columns = query_1.allowedNonAggregateColumnRef(fromClause, groupByClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            if (!selectItem.isAggregate) {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
            }
        }
        else if (column_1.ColumnUtil.isColumn(selectItem)) {
            column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnMap(selectItem));
        }
        else {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnRef(selectItem));
        }
    }
}
exports.assertValidUsedRef_NonAggregate = assertValidUsedRef_NonAggregate;
//# sourceMappingURL=assert-valid-used-ref-non-aggregate.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/predicate/assert-valid-used-ref.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/select-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function assertValidUsedRef(fromClause, selects) {
    const columns = query_1.allowedColumnRef(fromClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
        }
        else if (column_1.ColumnUtil.isColumn(selectItem)) {
            column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnMap(selectItem));
        }
        else {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnRef(selectItem));
        }
    }
}
exports.assertValidUsedRef = assertValidUsedRef;
//# sourceMappingURL=assert-valid-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/predicate/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/select-clause/util/predicate/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-valid-column-identifier */ "../tsql/dist/select-clause/util/predicate/assert-valid-column-identifier.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref-aggregate */ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref-non-aggregate */ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref */ "../tsql/dist/select-clause/util/predicate/assert-valid-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause) {
    const outer = column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    return column_ref_1.ColumnRefUtil.intersect(outer, inner);
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause) {
    return used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/query/allowed-used-ref.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/select-clause/util/query/allowed-used-ref.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/query/duplicate-column-alias.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/select-clause/util/query/duplicate-column-alias.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_item_1 = __webpack_require__(/*! ../../../select-item */ "../tsql/dist/select-item/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
function duplicateColumnAlias(selectClause) {
    const duplicateTracker = {};
    const result = [];
    for (const item of selectClause) {
        for (const columnAlias of select_item_1.SelectItemUtil.columnAlias(item)) {
            const isDuplicate = duplicateTracker[columnAlias];
            if (isDuplicate === undefined) {
                /**
                 * We had never encountered it, and now we have.
                 * But it isn't a duplicate.
                 */
                duplicateTracker[columnAlias] = false;
            }
            else if (!isDuplicate) {
                /**
                 * We had encountered it when it wasn't a duplicate.
                 * Now, it is a duplicate.
                 */
                duplicateTracker[columnAlias] = true;
                result.push(columnAlias);
            }
        }
        if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
            for (const columnAlias of column_ref_1.ColumnRefUtil.duplicateColumnAlias(item)) {
                const isDuplicate = duplicateTracker[columnAlias];
                if (isDuplicate === undefined) {
                    /**
                     * We had never encountered it, and now we have.
                     * But it isn't a duplicate.
                     */
                    duplicateTracker[columnAlias] = false;
                }
                else if (!isDuplicate) {
                    /**
                     * We had encountered it when it wasn't a duplicate.
                     * Now, it is a duplicate.
                     */
                    duplicateTracker[columnAlias] = true;
                    result.push(columnAlias);
                }
            }
        }
    }
    return result;
}
exports.duplicateColumnAlias = duplicateColumnAlias;
//# sourceMappingURL=duplicate-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/select-clause/util/query/index.js":
/*!******************************************************!*\
  !*** ../tsql/dist/select-clause/util/query/index.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "../tsql/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/select-clause/util/query/allowed-used-ref.js"));
__export(__webpack_require__(/*! ./duplicate-column-alias */ "../tsql/dist/select-clause/util/query/duplicate-column-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-item/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/select-item/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SelectItemUtil = __webpack_require__(/*! ./util */ "../tsql/dist/select-item/util/index.js");
exports.SelectItemUtil = SelectItemUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-item/util/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/select-item/util/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/select-item/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/select-item/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-item/util/predicate/index.js":
/*!********************************************************!*\
  !*** ../tsql/dist/select-item/util/predicate/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-single-value-select-item */ "../tsql/dist/select-item/util/predicate/is-single-value-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/select-item/util/predicate/is-single-value-select-item.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/select-item/util/predicate/is-single-value-select-item.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
function isSingleValueSelectItem(x) {
    return (column_1.ColumnUtil.isColumn(x) ||
        expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(x));
}
exports.isSingleValueSelectItem = isSingleValueSelectItem;
//# sourceMappingURL=is-single-value-select-item.js.map

/***/ }),

/***/ "../tsql/dist/select-item/util/query/column-alias.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/select-item/util/query/column-alias.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "../tsql/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
function columnAlias(item) {
    if (column_1.ColumnUtil.isColumn(item)) {
        return [item.columnAlias];
    }
    else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(item)) {
        return [item.alias];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(item)) {
        return column_map_1.ColumnMapUtil.columnAlias(item);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
        return column_ref_1.ColumnRefUtil.columnAlias(item);
    }
    else {
        throw new Error("Unknown select item");
    }
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "../tsql/dist/select-item/util/query/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/select-item/util/query/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "../tsql/dist/select-item/util/query/column-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/sort-direction/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/sort-direction/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./sort-direction */ "../tsql/dist/sort-direction/sort-direction.js"));
const SortDirectionUtil = __webpack_require__(/*! ./util */ "../tsql/dist/sort-direction/util/index.js");
exports.SortDirectionUtil = SortDirectionUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/sort-direction/sort-direction.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/sort-direction/sort-direction.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The direction to sort the result set
 */
var SortDirection;
(function (SortDirection) {
    /**
     * Sorts the result set in ascending order
     */
    SortDirection.ASC = "ASC";
    /**
     * Sorts the result set in descending order
     */
    SortDirection.DESC = "DESC";
})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
;
//# sourceMappingURL=sort-direction.js.map

/***/ }),

/***/ "../tsql/dist/sort-direction/util/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/sort-direction/util/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/sort-direction/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/sort-direction/util/predicate/index.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/sort-direction/util/predicate/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-sort-direction */ "../tsql/dist/sort-direction/util/predicate/is-sort-direction.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/sort-direction/util/predicate/is-sort-direction.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/sort-direction/util/predicate/is-sort-direction.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../sort-direction */ "../tsql/dist/sort-direction/sort-direction.js");
function isSortDirection(mixed) {
    return (mixed == sort_direction_1.SortDirection.ASC ||
        mixed == sort_direction_1.SortDirection.DESC);
}
exports.isSortDirection = isSortDirection;
//# sourceMappingURL=is-sort-direction.js.map

/***/ }),

/***/ "../tsql/dist/sqlstring/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/sqlstring/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const ID_BACKTICK_GLOBAL_REGEXP = /`/g;
const ID_DOUBLE_QUOTE_GLOBAL_REGEXP = /"/g;
const CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
const CHARS_ESCAPE_MAP = {
    "\0": "\\0",
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\x1a": "\\Z",
    "\"": "\\\"",
    "\'": "\\\'",
    "\\": "\\\\",
};
/**
 * Escapes a MySQL identifier.
 *
 * For example,
 * + Database name
 * + Table name
 * + Column name
 * + Alias
 *
 * -----
 *
 * ```ts
 * escapeIdentifier("x") == "`x`"
 * escapeIdentifier("x.y") == "`x.y`"
 * escapeIdentifier("x`x.y") == "`x``x.y`"
 * ```
 *
 * @param rawIdentifier - The identifier to escape
 *
 * @todo Refactor this.
 * + MySQL uses backticks.
 * + PostgreSQL uses double quotes. (Following the same rules as MySQL)
 * + MySQL can be made to use double quotes by enabling `ANSI_QUOTES` but this is disabled by default
 *
 * Each database adapter will need to create their own `escaoeIdentifier` function
 * and pass it around.
 *
 * A pain in the butt. Necessary, however.
 *
 * -----
 *
 * Another option would be forcing the MySQL adapter to always run a SQL query
 * to enable `ANSI_QUOTES`...
 *
 * Definitely less of a hassle there.
 *
 * @deprecated Use the `Identifier` AST Node instead
 */
function escapeIdentifierWithBackticks(rawIdentifier) {
    return ("`" +
        String(rawIdentifier).replace(ID_BACKTICK_GLOBAL_REGEXP, "``") +
        "`");
}
exports.escapeIdentifierWithBackticks = escapeIdentifierWithBackticks;
function escapeIdentifierWithDoubleQuotes(rawIdentifier) {
    return ("\"" +
        String(rawIdentifier).replace(ID_DOUBLE_QUOTE_GLOBAL_REGEXP, "\"\"") +
        "\"");
}
exports.escapeIdentifierWithDoubleQuotes = escapeIdentifierWithDoubleQuotes;
function tryUnescapeIdentifierWithDoubleQuotes(rawIdentifier) {
    rawIdentifier = rawIdentifier.trim();
    if (rawIdentifier.startsWith(`"`) && rawIdentifier.endsWith(`"`)) {
        rawIdentifier = rawIdentifier.substr(1, rawIdentifier.length - 2);
        return rawIdentifier.replace(/""/g, `"`);
    }
    else {
        return rawIdentifier;
    }
}
exports.tryUnescapeIdentifierWithDoubleQuotes = tryUnescapeIdentifierWithDoubleQuotes;
/**
 * Escapes a MySQL value.
 *
 * Does not handle `Date` as timezones are a pain.
 *
 * @param rawValue - The value to escape
 */
function escapeValue(rawValue) {
    if (rawValue === null) {
        return "NULL";
    }
    if (tm.TypeUtil.isBigInt(rawValue)) {
        /**
         * Max `BIGINT SIGNED` value: `SELECT 9223372036854775807+9223372036854775807`
         *
         * + MySQL      : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
         * + PostgreSQL : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
         * + SQLite     : `SELECT 9223372036854775807+9223372036854775807`; `18446744073709552000` (incorrect value)
         * + Expected   : `18446744073709551614`
         *
         * -----
         *
         * + MySQL      : `SELECT 18446744073709551615+18446744073709551615`; Error, out of range of bigint unsigned value
         * + PostgreSQL : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103230` (DECIMAL, not bigint unsigned)
         * + SQLite     : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103000` (incorrect value)
         * + Expected   : `36893488147419103230`
         *
         * PostgreSQL and SQLite do not support `BIGINT UNSIGNED`.
         * Selecting an integer larger than bigint signed in PostgreSQL will give you a `DECIMAL` value.
         *
         * @todo Fix this
         */
        return String(rawValue);
    }
    switch (typeof rawValue) {
        case "boolean": {
            return rawValue ?
                "TRUE" :
                "FALSE";
        }
        case "number": {
            if (!isFinite(rawValue)) {
                return "NULL";
            }
            const result = String(rawValue);
            if (result.indexOf("e") < 0) {
                /**
                 * We add `e0` at the end to signal to the DBMS that this is a double value.
                 * Not a `DECIMAL` value.
                 */
                /**
                 * + MySQL      : `SELECT 1e300`; `1e300`
                 * + PostgreSQL : `SELECT 1e300`; `1000000000...` (total 300 zeroes) (DECIMAL)
                 * + SQLite     : `SELECT 1e300`; `1e300`
                 *
                 * -----
                 *
                 * PostgreSQL:
                 * ```sql
                 *  SELECT
                 *      pg_typeof(1e19), -- numeric
                 *      pg_typeof(1e1),  -- numeric
                 *      pg_typeof(10)    -- integer
                 * ```
                 *
                 * SQLite:
                 * ```sql
                 *  SELECT
                 *      typeof(1e19), -- real
                 *      typeof(1e1),  -- real
                 *      typeof(10)    -- integer
                 * ```
                 */
                return result + "e0";
            }
            else {
                return result;
            }
        }
        case "object": {
            if (rawValue instanceof Uint8Array) {
                return uint8ArrayToString(rawValue);
            }
            else {
                throw new Error(`Don't know how to escape non-Uint8Array object`);
            }
        }
        default: {
            throw new Error(`Don't know how to escape ${typeof rawValue}`);
        }
    }
}
exports.escapeValue = escapeValue;
;
//https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
function buf2hex(buffer) {
    return Array.prototype.map
        .call(new Uint8Array(buffer), 
    //Should always return a string of length 2
    x => ("0" + x.toString(16)).slice(-2))
        .join("");
}
function uint8ArrayToString(buffer) {
    return "X" + cStyleEscapeString(buf2hex(buffer));
}
;
/**
 * Only MySQL supports C-style escapes (using the backslash character).
 */
function cStyleEscapeString(rawString) {
    let result = "";
    let chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    let match = CHARS_GLOBAL_REGEXP.exec(rawString);
    while (match != undefined) {
        const escapedChar = CHARS_ESCAPE_MAP[match[0]];
        if (escapedChar == undefined) {
            throw new Error(`Unknown escapable character ${match[0]}`);
        }
        result += rawString.slice(chunkIndex, match.index) + escapedChar;
        chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
        match = CHARS_GLOBAL_REGEXP.exec(rawString);
    }
    if (chunkIndex === 0) {
        //Nothing was escaped
        return "'" + rawString + "'";
    }
    if (chunkIndex < rawString.length) {
        return "'" + result + rawString.slice(chunkIndex) + "'";
    }
    return "'" + result + "'";
}
exports.cStyleEscapeString = cStyleEscapeString;
/**
 * PostgreSQL and SQLite use Pascal-style escapes
 */
function pascalStyleEscapeString(rawString) {
    const result = rawString.replace(/\'/g, `''`);
    return "'" + result + "'";
}
exports.pascalStyleEscapeString = pascalStyleEscapeString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/string-util/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/string-util/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./zero-pad */ "../tsql/dist/string-util/zero-pad.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/string-util/zero-pad.js":
/*!********************************************!*\
  !*** ../tsql/dist/string-util/zero-pad.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
    zeroPad(1, 4)     === "0001"
    zeroPad(34, 4)    === "0034"
    zeroPad(678, 4)   === "0678"
    zeroPad(1337, 4)  === "1337"
    zeroPad(92678, 4) === "92678"
*/
function zeroPad(num, length) {
    const str = num.toString();
    if (str.length < length) {
        return "0".repeat(length - str.length) + str;
    }
    else {
        return str;
    }
}
exports.zeroPad = zeroPad;
function trailingZeroPad(num, length) {
    const str = num.toString();
    if (str.length < length) {
        return str + "0".repeat(length - str.length);
    }
    else {
        return str;
    }
}
exports.trailingZeroPad = trailingZeroPad;
//# sourceMappingURL=zero-pad.js.map

/***/ }),

/***/ "../tsql/dist/super-key/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/super-key/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SuperKeyUtil = __webpack_require__(/*! ./util */ "../tsql/dist/super-key/util/index.js");
exports.SuperKeyUtil = SuperKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/super-key/util/index.js":
/*!********************************************!*\
  !*** ../tsql/dist/super-key/util/index.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "../tsql/dist/super-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/super-key/util/query/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/super-key/util/query/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "../tsql/dist/super-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/super-key/util/query/mapper.js":
/*!***************************************************!*\
  !*** ../tsql/dist/super-key/util/query/mapper.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function mapper(table) {
    return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
        /**
         * This usage of `tm.deepMerge()` is safe.
         * This is not true, in general.
         *
         * The two objects we'll be deep merging do not share any
         * properties.
         */
        return tm.deepMerge(column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, candidateKey)), column_map_1.ColumnMapUtil.partialMapper(type_util_1.omitOwnEnumerable(table.columns, candidateKey)));
    }));
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "../tsql/dist/table-where/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/table-where/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-where */ "../tsql/dist/table-where/table-where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table-where/table-where.js":
/*!***********************************************!*\
  !*** ../tsql/dist/table-where/table-where.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../execution */ "../tsql/dist/execution/index.js");
const table_1 = __webpack_require__(/*! ../table */ "../tsql/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
/**
 * @todo Implement something like `TableWhereOrderBy`?
 *
 * `.fetchAll()` is not provided here
 * because "proper" usage would minimally require,
 * + `ORDER BY` clause - For deterministic ordering
 * + `LIMIT` clause - To prevent accidental OOMs
 *
 * `.paginate()`, `.emulatedCursor()` are not provided here
 * because "proper" usage of them would minimally require,
 * + `ORDER BY` clause - For deterministic ordering
 *
 */
/**
 * @todo Better name
 * This is basically a `table` + `WHERE` clause.
 */
class TableWhere {
    constructor(table, whereDelegate) {
        this.table = table;
        this.whereDelegate = whereDelegate;
    }
    where(whereDelegate) {
        return new TableWhere(this.table, (columns) => {
            return ExprLib.and(this.whereDelegate(columns), whereDelegate(columns));
        });
    }
    assertExists(connection) {
        return table_1.TableUtil.assertExists(this.table, connection, this.whereDelegate);
    }
    exists(connection) {
        return table_1.TableUtil.exists(this.table, connection, this.whereDelegate);
    }
    fetchOne(connection, selectDelegate) {
        return table_1.TableUtil.__fetchOneHelper(this.table, connection, this.whereDelegate, selectDelegate);
    }
    fetchValue(connection, selectValueDelegate) {
        return table_1.TableUtil.fetchValue(this.table, connection, this.whereDelegate, selectValueDelegate);
    }
    delete(connection) {
        return execution_1.ExecutionUtil.delete(this.table, connection, this.whereDelegate);
    }
    deleteOne(connection) {
        return execution_1.ExecutionUtil.deleteOne(this.table, connection, this.whereDelegate);
    }
    deleteZeroOrOne(connection) {
        return execution_1.ExecutionUtil.deleteZeroOrOne(this.table, connection, this.whereDelegate);
    }
    update(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.update(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    updateOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    updateZeroOrOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    /**
     * The `table` must have at least one `candidateKey` to use this method.
     *
     * Internally,
     * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
     * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
     *    (if the candidate key will not be updated, this step is skipped)
     * 3. Run the `UPDATE` statement.
     * 4. Fetch the row using the new candidate key.
     *
     * This algorithm will probably fail if you have triggers that modify the candidate key
     * `ON UPDATE`.
     */
    updateAndFetchOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateAndFetchOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    /**
     * The `table` must have at least one `candidateKey` to use this method.
     *
     * Internally,
     * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
     * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
     *    (if the candidate key will not be updated, this step is skipped)
     * 3. Run the `UPDATE` statement.
     * 4. Fetch the row using the new candidate key (if any were found during the `UPDATE`)
     *
     * This algorithm will probably fail if you have triggers that modify the candidate key
     * `ON UPDATE`.
     */
    updateAndFetchZeroOrOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateAndFetchZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
}
exports.TableWhere = TableWhere;
//# sourceMappingURL=table-where.js.map

/***/ }),

/***/ "../tsql/dist/table/index.js":
/*!***********************************!*\
  !*** ../tsql/dist/table/index.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-impl */ "../tsql/dist/table/table-impl.js"));
const TableUtil = __webpack_require__(/*! ./util */ "../tsql/dist/table/util/index.js");
exports.TableUtil = TableUtil;
const util_1 = __webpack_require__(/*! ./util */ "../tsql/dist/table/util/index.js");
exports.table = util_1.fromTableAlias;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/table-impl.js":
/*!****************************************!*\
  !*** ../tsql/dist/table/table-impl.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TableUtil = __webpack_require__(/*! ./util */ "../tsql/dist/table/util/index.js");
const execution_1 = __webpack_require__(/*! ../execution */ "../tsql/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "../tsql/dist/expr-library/index.js");
const table_where_1 = __webpack_require__(/*! ../table-where */ "../tsql/dist/table-where/index.js");
class Table {
    /**
     * You should never need to explicitly instantiate a `Table`.
     * Use `table()` instead.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
        this.insertEnabled = data.insertEnabled;
        this.deleteEnabled = data.deleteEnabled;
        this.autoIncrement = data.autoIncrement;
        this.id = data.id;
        this.primaryKey = data.primaryKey;
        this.candidateKeys = data.candidateKeys;
        this.generatedColumns = data.generatedColumns;
        this.nullableColumns = data.nullableColumns;
        this.explicitDefaultValueColumns = data.explicitDefaultValueColumns;
        this.mutableColumns = data.mutableColumns;
        this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
    }
    /**
     * Makes all non-generated columns mutable.
     *
     * + Mutable columns may be modified with `UPDATE` statements using this library.
     * + Immutable columns may not be modified with this library
     *   (but could still be modified outside of this library)
     */
    addAllMutable() {
        return TableUtil.addAllMutable(this);
    }
    /**
     * Adds a candidate key to the table.
     *
     * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
     *
     * + A table may have zero-to-many candidate keys. (recommended to have at least one)
     * + A candidate key cannot be a subset of other candidate keys.
     * + A candidate key cannot be a superset of other candidate keys.
     * + A candidate key can intersect other candidate keys.
     * + A candidate key can be disjoint from other candidate keys.
     */
    addCandidateKey(delegate) {
        return TableUtil.addCandidateKey(this, delegate);
    }
    addColumns(rawColumns) {
        return TableUtil.addColumns(this, rawColumns);
    }
    /**
     * Tells the library that these columns have explicit `DEFAULT` values.
     *
     * An example of an "explicit" default value,
     * ```sql
     * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
     * ```
     *
     * + Columns with server default values are optional with `INSERT` statements.
     * + Generated columns have implicit default values.
     * + Nullable columns have implicit default values.
     * + `AUTO_INCREMENT` columns have implicit default values
     */
    addExplicitDefaultValue(delegate) {
        return TableUtil.addExplicitDefaultValue(this, delegate);
    }
    /**
     * Adds a `GENERATED` column to the table.
     *
     * + Setting generated column values will not be allowed with `INSERT` statements.
     * + Updating generated column values will also not be allowed with `UPDATE` statements.
     */
    addGenerated(delegate) {
        return TableUtil.addGenerated(this, delegate);
    }
    /**
     * Lets these columns be updated through this library.
     */
    addMutable(delegate) {
        return TableUtil.addMutable(this, delegate);
    }
    /**
     * Aliases a table reference in a query.
     *
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable AS aliasedTable
     * ```
     */
    as(newTableAlias) {
        return TableUtil.as(this, newTableAlias);
    }
    /**
     * Prevents rows of this table from being deleted through this library.
     *
     * Good for look-up tables, or append-only tables.
     */
    disableDelete() {
        return TableUtil.disableDelete(this);
    }
    /**
     * Prevents rows from being inserted through this library.
     *
     * Good for look-up tables.
     */
    disableInsert() {
        return TableUtil.disableInsert(this);
    }
    /**
     * The opposite of `disableInsert()`.
     * You really shouldn't need to use this as tables allow insert by default.
     */
    enableInsert() {
        return TableUtil.enableInsert(this);
    }
    /**
     * Makes all columns immutable.
     */
    removeAllMutable() {
        return TableUtil.removeAllMutable(this);
    }
    /**
     * Removes columns from the set of columns with explicit `DEFAULT` values
     *
     */
    removeExplicitDefaultValue(delegate) {
        return TableUtil.removeExplicitDefaultValue(this, delegate);
    }
    /**
     * Removes columns from the set of `GENERATED` columns.
     *
     */
    removeGenerated(delegate) {
        return TableUtil.removeGenerated(this, delegate);
    }
    /**
     * Removes columns from the set of mutable columns.
     *
     * You will not be able to update them through this library.
     *
     */
    removeMutable(delegate) {
        return TableUtil.removeMutable(this, delegate);
    }
    /**
     * Designates one column as the `AUTO_INCREMENT` column.
     *
     * -----
     *
     * + `AUTO_INCREMENT` columns cannot be nullable
     * + `AUTO_INCREMENT` columns must be a candidate key
     * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
     * + The `number|string|bigint` requirement is only a compile-time constraint
     */
    setAutoIncrement(delegate) {
        return TableUtil.setAutoIncrement(this, delegate);
    }
    enableExplicitAutoIncrementValue() {
        return TableUtil.enableExplicitAutoIncrementValue(this);
    }
    /**
     * Sets a column as the single-column identifier for this table.
     *
     * -----
     *
     * + `id-column`s cannot be nullable
     * + `id-column`s must be a candidate key
     * + `id-column`s must be a `PRIMARY KEY`
     *
     */
    setId(delegate) {
        return TableUtil.setId(this, delegate);
    }
    /**
     * Sets the `PRIMARY KEY` of the table.
     *
     * In MySQL, a `PRIMARY KEY` is just a candidate key
     * where all its columns are non-nullable.
     *
     * -----
     *
     * + `PRIMARY KEY` columns cannot be nullable
     * + `PRIMARY KEY` columns must be a candidate key
     */
    setPrimaryKey(delegate) {
        return TableUtil.setPrimaryKey(this, delegate);
    }
    /**
     * Sets the `schema` that this table belongs to.
     *
     * This is usually not required because the schema used
     * will be the one your database connection session is using.
     *
     * -----
     *
     * This library does not support cross-schema compile-time safe queries.
     *
     * However, if you **do** need cross-schema support,
     * this library can support it somewhat.
     */
    setSchemaName(newSchemaName) {
        return TableUtil.setSchemaName(this, newSchemaName);
    }
    /**
     * Changes the alias of the table.
     *
     * Useful if you have multiple tables with exactly the same structure.
     *
     * This is different from `.as()`!
     *
     * -----
     *
     * You will have to call `.setSchemaName()` again if you called it before.
     */
    setTableAlias(newTableAlias) {
        return TableUtil.setTableAlias(this, newTableAlias);
    }
    ;
    /*
    addParent<
        ParentT extends ITable
    > (
        parent : TableUtil.Parent<this, ParentT>
    ) : (
        TableUtil.AddParent<this, ParentT>
    ) {
        return TableUtil.addParent<this, ParentT>(this, parent);
    }

    /*
    validate (connection : IConnection, result : TableUtil.ValidateTableResult) {
        return TableUtil.validate(this, connection, result);
    }*/
    pickColumns(delegate) {
        return TableUtil.pickColumns(this, delegate);
    }
    insertOne(connection, row) {
        return execution_1.ExecutionUtil.insertOne(this, connection, row);
    }
    insertMany(connection, rows) {
        return execution_1.ExecutionUtil.insertMany(this, connection, rows);
    }
    insertIgnoreOne(connection, row) {
        return execution_1.ExecutionUtil.insertIgnoreOne(this, connection, row);
    }
    insertIgnoreMany(connection, rows) {
        return execution_1.ExecutionUtil.insertIgnoreMany(this, connection, rows);
    }
    replaceOne(connection, row) {
        return execution_1.ExecutionUtil.replaceOne(this, connection, row);
    }
    replaceMany(connection, rows) {
        return execution_1.ExecutionUtil.replaceMany(this, connection, rows);
    }
    insertAndFetch(connection, row) {
        return execution_1.ExecutionUtil.insertAndFetch(this, connection, row);
    }
    where(whereDelegate) {
        return new table_where_1.TableWhere(this, whereDelegate);
    }
    whereEqCandidateKey(candidateKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqCandidateKey(this, candidateKey));
    }
    whereEqPrimaryKey(primaryKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqPrimaryKey(this, primaryKey));
    }
    whereEqSuperKey(superKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqSuperKey(this, superKey));
    }
}
exports.Table = Table;
//# sourceMappingURL=table-impl.js.map

/***/ }),

/***/ "../tsql/dist/table/util/constructor/from-table-alias.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/table/util/constructor/from-table-alias.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
/**
 * Creates a table with the given alias
 *
 * @param tableAlias
 */
function fromTableAlias(tableAlias) {
    const result = new table_impl_1.Table({
        isLateral: false,
        alias: tableAlias,
        columns: {},
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        autoIncrement: undefined,
        id: undefined,
        primaryKey: undefined,
        candidateKeys: [],
        insertEnabled: true,
        deleteEnabled: true,
        generatedColumns: [],
        nullableColumns: [],
        explicitDefaultValueColumns: [],
        mutableColumns: [],
        explicitAutoIncrementValueEnabled: false,
    }, ast_1.identifierNode(tableAlias));
    return result;
}
exports.fromTableAlias = fromTableAlias;
//# sourceMappingURL=from-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/constructor/from-table.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/table/util/constructor/from-table.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Creates a copy of the `table`
 *
 * @param table
 */
function fromTable(table) {
    const result = new table_impl_1.Table(table, table.unaliasedAst);
    return result;
}
exports.fromTable = fromTable;
//# sourceMappingURL=from-table.js.map

/***/ }),

/***/ "../tsql/dist/table/util/constructor/index.js":
/*!****************************************************!*\
  !*** ../tsql/dist/table/util/constructor/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-table-alias */ "../tsql/dist/table/util/constructor/from-table-alias.js"));
__export(__webpack_require__(/*! ./from-table */ "../tsql/dist/table/util/constructor/from-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/execution/assert-exists.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/table/util/execution/assert-exists.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
async function assertExists(table, connection, whereDelegate) {
    return unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .assertExists(connection);
}
exports.assertExists = assertExists;
//# sourceMappingURL=assert-exists.js.map

/***/ }),

/***/ "../tsql/dist/table/util/execution/exists.js":
/*!***************************************************!*\
  !*** ../tsql/dist/table/util/execution/exists.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
async function exists(table, connection, whereDelegate) {
    return unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .exists(connection);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "../tsql/dist/table/util/execution/fetch-one.js":
/*!******************************************************!*\
  !*** ../tsql/dist/table/util/execution/fetch-one.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
function fetchOne(table, connection, whereDelegate, selectDelegate) {
    try {
        const query = unified_query_1.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate);
        if (selectDelegate == undefined) {
            return query
                .select(((columns) => [columns]))
                .fetchOne(connection);
        }
        else {
            return query
                .select(selectDelegate)
                .fetchOne(connection);
        }
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
/**
 * Not meant to be invoked directly
 */
function __fetchOneHelper(table, connection, whereDelegate, selectDelegate) {
    if (selectDelegate == undefined) {
        return fetchOne(table, connection, whereDelegate);
    }
    else {
        return fetchOne(table, connection, whereDelegate, selectDelegate);
    }
}
exports.__fetchOneHelper = __fetchOneHelper;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "../tsql/dist/table/util/execution/fetch-value.js":
/*!********************************************************!*\
  !*** ../tsql/dist/table/util/execution/fetch-value.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "../tsql/dist/unified-query/index.js");
function fetchValue(table, connection, whereDelegate, selectValueDelegate) {
    try {
        return unified_query_1.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate)
            .selectValue(selectValueDelegate)
            .fetchValue(connection);
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValue = fetchValue;
//# sourceMappingURL=fetch-value.js.map

/***/ }),

/***/ "../tsql/dist/table/util/execution/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/table/util/execution/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-exists */ "../tsql/dist/table/util/execution/assert-exists.js"));
__export(__webpack_require__(/*! ./exists */ "../tsql/dist/table/util/execution/exists.js"));
__export(__webpack_require__(/*! ./fetch-one */ "../tsql/dist/table/util/execution/fetch-one.js"));
__export(__webpack_require__(/*! ./fetch-value */ "../tsql/dist/table/util/execution/fetch-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/table/util/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/table/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "../tsql/dist/table/util/execution/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/table/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/table/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/table/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-all-mutable.js":
/*!************************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-all-mutable.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/table/util/query/index.js");
/**
 * Makes all non-generated columns, and non-implicit auto-increment mutable.
 *
 * + Mutable columns may be modified with `UPDATE` statements using this library.
 * + Immutable columns may not be modified with this library
 *   (but could still be modified outside of this library)
 *
 * @param table
 */
function addAllMutable(table) {
    const mutableColumns = (key_1.KeyUtil.fromColumnArray(column_1.ColumnArrayUtil
        .fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            !query_1.isImplicitAutoIncrement(table, column.columnAlias));
    })));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addAllMutable = addAllMutable;
//# sourceMappingURL=add-all-mutable.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-candidate-key.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-candidate-key.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/table/util/predicate/index.js");
function assertNotEmptyKey(columns) {
    if (columns.length == 0) {
        throw new Error(`Key cannot be empty`);
    }
}
exports.assertNotEmptyKey = assertNotEmptyKey;
function assertNotSubKey(table, columns) {
    const key = key_1.KeyUtil.fromColumnArray(columns);
    const superKeys = key_1.KeyArrayUtil.findSuperKeys(table.candidateKeys, key);
    if (superKeys.length > 0) {
        throw new Error(`${key.join("|")} is a sub key of ${superKeys[0].join("|")}`);
    }
}
exports.assertNotSubKey = assertNotSubKey;
function assertNotSuperKey(table, columns) {
    const key = key_1.KeyUtil.fromColumnArray(columns);
    const subKeys = key_1.KeyArrayUtil.findSubKeys(table.candidateKeys, key);
    if (subKeys.length > 0) {
        throw new Error(`${key.join("|")} is a super key of ${subKeys[0].join("|")}`);
    }
}
exports.assertNotSuperKey = assertNotSuperKey;
function assertValidCandidateKey(table, columns) {
    predicate_1.assertHasColumnIdentifiers(table, columns);
    assertNotEmptyKey(columns);
    assertNotSubKey(table, columns);
    assertNotSuperKey(table, columns);
}
exports.assertValidCandidateKey = assertValidCandidateKey;
/**
 * Adds a candidate key to the table.
 *
 * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
 *
 * + A table may have zero-to-many candidate keys. (recommended to have at least one)
 * + A candidate key cannot be a subset of other candidate keys.
 * + A candidate key cannot be a superset of other candidate keys.
 * + A candidate key can intersect other candidate keys.
 * + A candidate key can be disjoint from other candidate keys.
 *
 * @param table
 * @param delegate
 */
function addCandidateKey(table, delegate) {
    const newCandidateKey = delegate(table.columns);
    assertValidCandidateKey(table, newCandidateKey);
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, key_1.KeyUtil.fromColumnArray(newCandidateKey));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, 
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addCandidateKey = addCandidateKey;
//# sourceMappingURL=add-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-columns-from-field-array.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-columns-from-field-array.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
/**
 * Converts an array of fields to columns of the table
 *
 * @param table
 * @param fields
 *
 * @deprecated
 */
function addColumnsFromFieldArray(table, fields) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const tableColumns = table.columns;
    //https://github.com/Microsoft/TypeScript/issues/28592
    const columnMapFromFieldArray = column_map_1.ColumnMapUtil.fromFieldArray(table.alias, fields);
    const columns = column_map_1.ColumnMapUtil.intersect(tableColumns, columnMapFromFieldArray);
    const nullableColumns = column_map_1.ColumnMapUtil.nullableColumnAliases(columns);
    const result = new table_impl_1.Table({
        /**
         * This fails,
         * ```ts
         * ...table
         * ```
         *
         * This fails,
         * ```ts
         * ...(table as ITable)
         * ```
         *
         * This succeeds,
         * ```ts
         * ...(table as TableData)
         * ```
         *
         * @todo Investigate and possibly file issue
         */
        ...table,
        columns,
        nullableColumns,
    }, table.unaliasedAst);
    return result;
}
exports.addColumnsFromFieldArray = addColumnsFromFieldArray;
//# sourceMappingURL=add-columns-from-field-array.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-columns-from-mapper-map.js":
/*!************************************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-columns-from-mapper-map.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
/**
 * Converts a map of `columnAlias -> mapper` to columns of the table
 *
 * @param table
 * @param mapperMap
 */
function addColumnsFromMapperMap(table, mapperMap) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const tableColumns = table.columns;
    const columns = column_map_1.ColumnMapUtil.intersect(tableColumns, column_map_1.ColumnMapUtil.fromMapperMap(table.alias, mapperMap));
    const nullableColumns = column_map_1.ColumnMapUtil.nullableColumnAliases(columns);
    const result = new table_impl_1.Table({
        ...table,
        columns,
        nullableColumns,
    }, table.unaliasedAst);
    return result;
}
exports.addColumnsFromMapperMap = addColumnsFromMapperMap;
//# sourceMappingURL=add-columns-from-mapper-map.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-columns.js":
/*!********************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-columns.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const add_columns_from_field_array_1 = __webpack_require__(/*! ./add-columns-from-field-array */ "../tsql/dist/table/util/operation/add-columns-from-field-array.js");
const add_columns_from_mapper_map_1 = __webpack_require__(/*! ./add-columns-from-mapper-map */ "../tsql/dist/table/util/operation/add-columns-from-mapper-map.js");
function addColumns(table, rawColumns) {
    if (Array.isArray(rawColumns)) {
        return add_columns_from_field_array_1.addColumnsFromFieldArray(table, rawColumns);
    }
    else {
        return add_columns_from_mapper_map_1.addColumnsFromMapperMap(table, rawColumns);
    }
}
exports.addColumns = addColumns;
//# sourceMappingURL=add-columns.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-explicit-default-value.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-explicit-default-value.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function addExplicitDefaultValueColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            //!table.nullableColumns.includes(column.columnAlias) &&
            (table.autoIncrement != column.columnAlias) &&
            !table.explicitDefaultValueColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addExplicitDefaultValueColumnMap = addExplicitDefaultValueColumnMap;
/**
 * Tells the library that these columns have explicit `DEFAULT` values.
 *
 * An example of an "explicit" default value,
 * ```sql
 * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
 * ```
 *
 * + Columns with server default values are optional with `INSERT` statements.
 * + Generated columns have implicit default values.
 * + Nullable columns have implicit default values.
 * + `AUTO_INCREMENT` columns have implicit default values
 *
 * -----
 *
 * @param table
 * @param delegate
 */
function addExplicitDefaultValue(table, delegate) {
    const columnMap = addExplicitDefaultValueColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const explicitDefaultValueColumns = key_1.KeyUtil.concat(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
    //explicitDefaultValueColumns,
    mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addExplicitDefaultValue = addExplicitDefaultValue;
//# sourceMappingURL=add-explicit-default-value.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-generated.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-generated.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function addGeneratedColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            column.columnAlias != table.autoIncrement);
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addGeneratedColumnMap = addGeneratedColumnMap;
/**
 * Adds a `GENERATED` column to the table.
 *
 * + Setting generated column values will not be allowed with `INSERT` statements.
 * + Updating generated column values will also not be allowed with `UPDATE` statements.
 *
 * @param table
 * @param delegate
 */
function addGenerated(table, delegate) {
    const columnMap = addGeneratedColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const generatedColumns = key_1.KeyUtil.concat(table.generatedColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const explicitDefaultValueColumns = key_1.KeyUtil.subtract(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const mutableColumns = key_1.KeyUtil.subtract(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, 
    //explicitDefaultValueColumns,
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addGenerated = addGenerated;
//# sourceMappingURL=add-generated.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/add-mutable.js":
/*!********************************************************!*\
  !*** ../tsql/dist/table/util/operation/add-mutable.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/table/util/query/index.js");
function addMutableColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            !table.mutableColumns.includes(column.columnAlias) &&
            !query_1.isImplicitAutoIncrement(table, column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addMutableColumnMap = addMutableColumnMap;
/**
 * Lets these columns be updated through this library.
 *
 * @param table
 * @param delegate
 */
function addMutable(table, delegate) {
    const columnMap = addMutableColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const mutableColumns = key_1.KeyUtil.concat(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addMutable = addMutable;
//# sourceMappingURL=add-mutable.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/as.js":
/*!***********************************************!*\
  !*** ../tsql/dist/table/util/operation/as.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Aliases a table reference in a query.
 *
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable AS aliasedTable
 * ```
 */
function as(table, newTableAlias) {
    const { isLateral, 
    //alias,
    columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias: newTableAlias,
        columns: column_map_1.ColumnMapUtil.withTableAlias(columns, newTableAlias),
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/disable-delete.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/table/util/operation/disable-delete.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Prevents rows of this table from being deleted through this library.
 *
 * Good for look-up tables, or append-only tables.
 *
 * @param table
 */
function disableDelete(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, 
    //deleteEnabled,
    generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled: false,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.disableDelete = disableDelete;
//# sourceMappingURL=disable-delete.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/disable-insert.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/table/util/operation/disable-insert.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Prevents rows from being inserted through this library.
 *
 * Good for look-up tables.
 *
 * @param table
 */
function disableInsert(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
    //insertEnabled,
    deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled: false,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.disableInsert = disableInsert;
//# sourceMappingURL=disable-insert.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/enable-explicit-auto-increment-value.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/table/util/operation/enable-explicit-auto-increment-value.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Allows explicit values for auto-increment columns.
 */
function enableExplicitAutoIncrementValue(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled: true,
    }, table.unaliasedAst);
    return result;
}
exports.enableExplicitAutoIncrementValue = enableExplicitAutoIncrementValue;
//# sourceMappingURL=enable-explicit-auto-increment-value.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/enable-insert.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/table/util/operation/enable-insert.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
function enableInsert(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
    //insertEnabled,
    deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled: true,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.enableInsert = enableInsert;
//# sourceMappingURL=enable-insert.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/table/util/operation/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./add-all-mutable */ "../tsql/dist/table/util/operation/add-all-mutable.js"));
__export(__webpack_require__(/*! ./add-candidate-key */ "../tsql/dist/table/util/operation/add-candidate-key.js"));
__export(__webpack_require__(/*! ./add-columns-from-field-array */ "../tsql/dist/table/util/operation/add-columns-from-field-array.js"));
__export(__webpack_require__(/*! ./add-columns-from-mapper-map */ "../tsql/dist/table/util/operation/add-columns-from-mapper-map.js"));
__export(__webpack_require__(/*! ./add-columns */ "../tsql/dist/table/util/operation/add-columns.js"));
__export(__webpack_require__(/*! ./add-explicit-default-value */ "../tsql/dist/table/util/operation/add-explicit-default-value.js"));
__export(__webpack_require__(/*! ./add-generated */ "../tsql/dist/table/util/operation/add-generated.js"));
__export(__webpack_require__(/*! ./add-mutable */ "../tsql/dist/table/util/operation/add-mutable.js"));
__export(__webpack_require__(/*! ./as */ "../tsql/dist/table/util/operation/as.js"));
__export(__webpack_require__(/*! ./disable-delete */ "../tsql/dist/table/util/operation/disable-delete.js"));
__export(__webpack_require__(/*! ./disable-insert */ "../tsql/dist/table/util/operation/disable-insert.js"));
__export(__webpack_require__(/*! ./enable-explicit-auto-increment-value */ "../tsql/dist/table/util/operation/enable-explicit-auto-increment-value.js"));
__export(__webpack_require__(/*! ./enable-insert */ "../tsql/dist/table/util/operation/enable-insert.js"));
__export(__webpack_require__(/*! ./pick-columns */ "../tsql/dist/table/util/operation/pick-columns.js"));
__export(__webpack_require__(/*! ./remove-all-mutable */ "../tsql/dist/table/util/operation/remove-all-mutable.js"));
__export(__webpack_require__(/*! ./remove-explicit-default-value */ "../tsql/dist/table/util/operation/remove-explicit-default-value.js"));
__export(__webpack_require__(/*! ./remove-generated */ "../tsql/dist/table/util/operation/remove-generated.js"));
__export(__webpack_require__(/*! ./remove-mutable */ "../tsql/dist/table/util/operation/remove-mutable.js"));
__export(__webpack_require__(/*! ./set-auto-increment */ "../tsql/dist/table/util/operation/set-auto-increment.js"));
__export(__webpack_require__(/*! ./set-id */ "../tsql/dist/table/util/operation/set-id.js"));
__export(__webpack_require__(/*! ./set-primary-key */ "../tsql/dist/table/util/operation/set-primary-key.js"));
__export(__webpack_require__(/*! ./set-schema-name */ "../tsql/dist/table/util/operation/set-schema-name.js"));
__export(__webpack_require__(/*! ./set-table-alias */ "../tsql/dist/table/util/operation/set-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/pick-columns.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/table/util/operation/pick-columns.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "../tsql/dist/aliased-table/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function pickColumns(table, delegate) {
    const newColumns = delegate(table.columns);
    const { isLateral, alias, columns, usedRef, } = table;
    const result = new aliased_table_1.AliasedTable({
        isLateral,
        alias,
        columns: type_util_1.pickOwnEnumerable(columns, newColumns.map(column => column.columnAlias)),
        usedRef,
    }, table.unaliasedAst);
    return result;
}
exports.pickColumns = pickColumns;
//# sourceMappingURL=pick-columns.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/remove-all-mutable.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/table/util/operation/remove-all-mutable.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
/**
 * Makes all columns immutable.
 *
 * @param table
 */
function removeAllMutable(table) {
    const mutableColumns = [];
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeAllMutable = removeAllMutable;
//# sourceMappingURL=remove-all-mutable.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/remove-explicit-default-value.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/table/util/operation/remove-explicit-default-value.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function removeExplicitDefaultValueColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.explicitDefaultValueColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeExplicitDefaultValueColumnMap = removeExplicitDefaultValueColumnMap;
/**
 * Removes columns from the set of columns with explicit `DEFAULT` values
 *
 * @param table
 * @param delegate
 */
function removeExplicitDefaultValue(table, delegate) {
    const columnMap = removeExplicitDefaultValueColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const explicitDefaultValueColumns = key_1.KeyUtil.subtract(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
    //explicitDefaultValueColumns,
    mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeExplicitDefaultValue = removeExplicitDefaultValue;
//# sourceMappingURL=remove-explicit-default-value.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/remove-generated.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/table/util/operation/remove-generated.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function removeGeneratedColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.generatedColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeGeneratedColumnMap = removeGeneratedColumnMap;
/**
 * Removes columns from the set of `GENERATED` columns.
 *
 * @param table
 * @param delegate
 */
function removeGenerated(table, delegate) {
    const columnMap = removeGeneratedColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const generatedColumns = key_1.KeyUtil.subtract(table.generatedColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeGenerated = removeGenerated;
//# sourceMappingURL=remove-generated.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/remove-mutable.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/table/util/operation/remove-mutable.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function removeMutableColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.mutableColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeMutableColumnMap = removeMutableColumnMap;
/**
 * Removes columns from the set of mutable columns.
 *
 * You will not be able to update them through this library.
 *
 * @param table
 * @param delegate
 */
function removeMutable(table, delegate) {
    const columnMap = removeMutableColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const mutableColumns = key_1.KeyUtil.subtract(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeMutable = removeMutable;
//# sourceMappingURL=remove-mutable.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/set-auto-increment.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/table/util/operation/set-auto-increment.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const set_primary_key_1 = __webpack_require__(/*! ./set-primary-key */ "../tsql/dist/table/util/operation/set-primary-key.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function setAutoIncrementColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!tm.canOutputNull(column.mapper) &&
            !key_1.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.setAutoIncrementColumnMap = setAutoIncrementColumnMap;
function assertValidAutoIncrement(table, autoIncrement) {
    const columnMap = setAutoIncrementColumnMap(table);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, autoIncrement);
    set_primary_key_1.assertValidPrimaryKey(table, [autoIncrement]);
}
exports.assertValidAutoIncrement = assertValidAutoIncrement;
/**
 * Designates one column as the `AUTO_INCREMENT` column.
 *
 * -----
 *
 * + `AUTO_INCREMENT` columns cannot be nullable
 * + `AUTO_INCREMENT` columns must be a candidate key
 * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
 * + The `number|string|bigint` requirement is only a compile-time constraint
 *
 * @todo Consider having run-time checks to see if it allows 1,2,3,4,5,... ?
 */
function setAutoIncrement(table, delegate) {
    const newAutoIncrement = delegate(setAutoIncrementColumnMap(table));
    assertValidAutoIncrement(table, newAutoIncrement);
    const primaryKey = (key_1.KeyUtil.fromColumn(newAutoIncrement));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const generatedColumns = key_1.KeyUtil.remove(table.generatedColumns, newAutoIncrement.columnAlias);
    const explicitDefaultValueColumns = key_1.KeyUtil.remove(table.explicitDefaultValueColumns, newAutoIncrement.columnAlias);
    const mutableColumns = key_1.KeyUtil.remove(table.mutableColumns, newAutoIncrement.columnAlias);
    const { isLateral, alias, columns, usedRef, 
    //autoIncrement,
    //id,
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, 
    //explicitDefaultValueColumns,
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement: newAutoIncrement.columnAlias,
        id: newAutoIncrement.columnAlias,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setAutoIncrement = setAutoIncrement;
//# sourceMappingURL=set-auto-increment.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/set-id.js":
/*!***************************************************!*\
  !*** ../tsql/dist/table/util/operation/set-id.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const set_primary_key_1 = __webpack_require__(/*! ./set-primary-key */ "../tsql/dist/table/util/operation/set-primary-key.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
function setIdColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!tm.canOutputNull(column.mapper) &&
            !key_1.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.setIdColumnMap = setIdColumnMap;
function assertValidId(table, id) {
    const columnMap = setIdColumnMap(table);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, id);
    set_primary_key_1.assertValidPrimaryKey(table, [id]);
}
exports.assertValidId = assertValidId;
/**
 * Sets a column as the single-column identifier for this table.
 *
 * -----
 *
 * + `id-column`s cannot be nullable
 * + `id-column`s must be a candidate key
 * + `id-column`s must be a `PRIMARY KEY`
 *
 */
function setId(table, delegate) {
    const newId = delegate(setIdColumnMap(table));
    assertValidId(table, newId);
    const primaryKey = (key_1.KeyUtil.fromColumn(newId));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const { isLateral, alias, columns, usedRef, autoIncrement, 
    //id,
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id: newId.columnAlias,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setId = setId;
//# sourceMappingURL=set-id.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/set-primary-key.js":
/*!************************************************************!*\
  !*** ../tsql/dist/table/util/operation/set-primary-key.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "../tsql/node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "../tsql/dist/column/index.js");
const add_candidate_key_1 = __webpack_require__(/*! ./add-candidate-key */ "../tsql/dist/table/util/operation/add-candidate-key.js");
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
function setPrimaryKeyColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => !tm.canOutputNull(column.mapper))
        .map(column => column.columnAlias));
    return result;
}
exports.setPrimaryKeyColumnMap = setPrimaryKeyColumnMap;
function assertValidPrimaryKey(table, columns) {
    //An extra run-time check, just to be safe...
    //For all the JS-land users
    for (const column of columns) {
        if (tm.canOutputNull(column.mapper)) {
            throw new Error(`${column.tableAlias}.${column.columnAlias} cannot be part of a PRIMARY KEY; it is nullable`);
        }
    }
    add_candidate_key_1.assertValidCandidateKey(table, columns);
}
exports.assertValidPrimaryKey = assertValidPrimaryKey;
/**
 * Sets the `PRIMARY KEY` of the table.
 *
 * In MySQL, a `PRIMARY KEY` is just a candidate key
 * where all its columns are non-nullable.
 *
 * -----
 *
 * + `PRIMARY KEY` columns cannot be nullable
 * + `PRIMARY KEY` columns must be a candidate key
 */
function setPrimaryKey(table, delegate) {
    const newPrimaryKey = delegate(setPrimaryKeyColumnMap(table));
    assertValidPrimaryKey(table, newPrimaryKey);
    const primaryKey = (key_1.KeyUtil.fromColumnArray(newPrimaryKey));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const { isLateral, alias, columns, usedRef, autoIncrement, id, 
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setPrimaryKey = setPrimaryKey;
//# sourceMappingURL=set-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/set-schema-name.js":
/*!************************************************************!*\
  !*** ../tsql/dist/table/util/operation/set-schema-name.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
/**
 * Sets the `schema` that this table belongs to.
 *
 * This is usually not required because the schema used
 * will be the one your database connection session is using.
 *
 * -----
 *
 * This library does not support cross-schema compile-time safe queries.
 *
 * However, if you **do** need cross-schema support,
 * this library can support it somewhat.
 *
 * -----
 *
 * @param table
 * @param newSchemaName
 */
function setSchemaName(table, newSchemaName) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    return new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, (ast_1.isIdentifierNode(table.unaliasedAst) ?
        ast_1.identifierNode(newSchemaName, 
        //The table alias on the database
        table.unaliasedAst.identifiers[table.unaliasedAst.identifiers.length - 1]) :
        ast_1.identifierNode(newSchemaName, alias)));
}
exports.setSchemaName = setSchemaName;
//# sourceMappingURL=set-schema-name.js.map

/***/ }),

/***/ "../tsql/dist/table/util/operation/set-table-alias.js":
/*!************************************************************!*\
  !*** ../tsql/dist/table/util/operation/set-table-alias.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "../tsql/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
/**
 * Changes the alias of the table.
 *
 * Useful if you have multiple tables with exactly the same structure.
 *
 * This is different from `.as()`!
 *
 * -----
 *
 * You will have to call `.setSchemaName()` again if you called it before.
 *
 * @param table
 * @param newTableAlias
 */
function setTableAlias(table, newTableAlias) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const columns = table.columns;
    const { isLateral, 
    //tableAlias,
    //columns,
    usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    return new table_impl_1.Table({
        isLateral,
        alias: newTableAlias,
        columns: column_map_1.ColumnMapUtil.withTableAlias(columns, newTableAlias),
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, ((ast_1.isIdentifierNode(table.unaliasedAst) &&
        table.unaliasedAst.identifiers.length == 2) ?
        ast_1.identifierNode(
        //The `schemaName`
        table.unaliasedAst.identifiers[0], newTableAlias) :
        ast_1.identifierNode(newTableAlias)));
}
exports.setTableAlias = setTableAlias;
//# sourceMappingURL=set-table-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/assert-delete-enabled.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/assert-delete-enabled.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isDeleteEnabled(table) {
    return table.deleteEnabled;
}
exports.isDeleteEnabled = isDeleteEnabled;
function assertDeleteEnabled(table) {
    if (!isDeleteEnabled(table)) {
        throw new Error(`Cannot DELETE FROM/REPLACE INTO ${table.alias}`);
    }
}
exports.assertDeleteEnabled = assertDeleteEnabled;
//# sourceMappingURL=assert-delete-enabled.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/assert-has-candidate-key.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/assert-has-candidate-key.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertHasCandidateKey(table) {
    if (table.candidateKeys.length == 0) {
        throw new Error(`${table.alias} must have a candidate key`);
    }
}
exports.assertHasCandidateKey = assertHasCandidateKey;
//# sourceMappingURL=assert-has-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/assert-has-column-identifiers.js":
/*!**************************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/assert-has-column-identifiers.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "../tsql/dist/column-identifier-map/index.js");
/**
 * A run-time check mostly for JS-land users.
 *
 * Checks that the `table` contains all `columns` passed through,
 * using just the `tableAlias` and `columnAlias`.
 *
 * @param table
 * @param columns
 */
function assertHasColumnIdentifiers(table, columns) {
    for (const column of columns) {
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(table.columns, column);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=assert-has-column-identifiers.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js":
/*!****************************************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
const has_null_safe_comparable_primary_key_1 = __webpack_require__(/*! ./has-null-safe-comparable-primary-key */ "../tsql/dist/table/util/predicate/has-null-safe-comparable-primary-key.js");
function assertHasNullSafeComparablePrimaryKey(table, columnMap) {
    if (!has_null_safe_comparable_primary_key_1.hasNullSafeComparablePrimaryKey(table, columnMap)) {
        const myTableAlias = column_map_1.ColumnMapUtil.tableAlias(table.columns);
        const myPrimaryKey = table.primaryKey.join(",");
        const otherTableAlias = column_map_1.ColumnMapUtil.tableAlias(columnMap);
        const otherColumnAliases = table.primaryKey
            .filter(pk => (Object.prototype.hasOwnProperty.call(columnMap, pk) &&
            Object.prototype.propertyIsEnumerable.call(columnMap, pk)))
            .join(",");
        throw new Error(`${myTableAlias} primary key (${myPrimaryKey}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
    }
}
exports.assertHasNullSafeComparablePrimaryKey = assertHasNullSafeComparablePrimaryKey;
//# sourceMappingURL=assert-has-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/assert-insert-enabled.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/assert-insert-enabled.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isInsertEnabled(table) {
    return table.insertEnabled;
}
exports.isInsertEnabled = isInsertEnabled;
function assertInsertEnabled(table) {
    if (!isInsertEnabled(table)) {
        throw new Error(`Cannot INSERT INTO ${table.alias}`);
    }
}
exports.assertInsertEnabled = assertInsertEnabled;
//# sourceMappingURL=assert-insert-enabled.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/has-null-safe-comparable-primary-key.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/table/util/predicate/has-null-safe-comparable-primary-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ideally, we'd want to have run-time checks
 * ensuring PK columns and `columnMap` columns
 * have null-safe comparable types.
 *
 * However, due to how the project is structured,
 * this is not possible.
 *
 * So, at the very least, we just check
 * the columns exist.
 */
function hasNullSafeComparablePrimaryKey(table, columnMap) {
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring PK columns and `columnMap` columns
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    const myColumnAliases = Object.keys(table.columns);
    for (const pkColumnAlias of table.primaryKey) {
        if (!myColumnAliases.includes(pkColumnAlias)) {
            /**
             * My column does not exist
             */
            return false;
        }
    }
    const otherColumnAliases = Object.keys(columnMap);
    for (const pkColumnAlias of table.primaryKey) {
        if (!otherColumnAliases.includes(pkColumnAlias)) {
            /**
             * Other column does not exist
             */
            return false;
        }
    }
    return true;
}
exports.hasNullSafeComparablePrimaryKey = hasNullSafeComparablePrimaryKey;
//# sourceMappingURL=has-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/index.js":
/*!**************************************************!*\
  !*** ../tsql/dist/table/util/predicate/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-delete-enabled */ "../tsql/dist/table/util/predicate/assert-delete-enabled.js"));
__export(__webpack_require__(/*! ./assert-has-candidate-key */ "../tsql/dist/table/util/predicate/assert-has-candidate-key.js"));
__export(__webpack_require__(/*! ./assert-has-column-identifiers */ "../tsql/dist/table/util/predicate/assert-has-column-identifiers.js"));
__export(__webpack_require__(/*! ./assert-has-null-safe-comparable-primary-key */ "../tsql/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js"));
__export(__webpack_require__(/*! ./assert-insert-enabled */ "../tsql/dist/table/util/predicate/assert-insert-enabled.js"));
__export(__webpack_require__(/*! ./has-null-safe-comparable-primary-key */ "../tsql/dist/table/util/predicate/has-null-safe-comparable-primary-key.js"));
__export(__webpack_require__(/*! ./is-table */ "../tsql/dist/table/util/predicate/is-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/predicate/is-table.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/table/util/predicate/is-table.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
/**
 * Actually only checks if it has all the properties of `ITable`.
 *
 * So, if it has all the properties but they're of the wrong data type...
 */
function isTable(mixed) {
    return type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "isLateral",
        "alias",
        "columns",
        "usedRef",
        "unaliasedAst",
        "autoIncrement",
        "id",
        "primaryKey",
        "candidateKeys",
        "insertEnabled",
        "deleteEnabled",
        "generatedColumns",
        "nullableColumns",
        "explicitDefaultValueColumns",
        "mutableColumns",
        "explicitAutoIncrementValueEnabled",
    ]);
}
exports.isTable = isTable;
//# sourceMappingURL=is-table.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/column-alias.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/table/util/query/column-alias.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "../tsql/dist/column-map/index.js");
/**
 * @todo Pluralize this and others where relevant?
 * Be more consistent with pluralization.
 */
function columnAlias(table) {
    return column_map_1.ColumnMapUtil.columnAlias(table.columns);
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/explicit-auto-increment.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/table/util/query/explicit-auto-increment.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isExplicitAutoIncrement(table, columnAlias) {
    if (table.explicitAutoIncrementValueEnabled) {
        return columnAlias === table.autoIncrement;
    }
    else {
        return false;
    }
}
exports.isExplicitAutoIncrement = isExplicitAutoIncrement;
function isImplicitAutoIncrement(table, columnAlias) {
    if (!table.explicitAutoIncrementValueEnabled) {
        return columnAlias === table.autoIncrement;
    }
    else {
        return false;
    }
}
exports.isImplicitAutoIncrement = isImplicitAutoIncrement;
//# sourceMappingURL=explicit-auto-increment.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js":
/*!******************************************************************************************!*\
  !*** ../tsql/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const key_1 = __webpack_require__(/*! ../../../key */ "../tsql/dist/key/index.js");
function extractCandidateKeysWithColumnAliasInTable(candidateKeysTable, columnAliasesTable) {
    const result = [];
    const columnAliases = Object.keys(columnAliasesTable.columns);
    for (const candidateKey of candidateKeysTable.candidateKeys) {
        if (key_1.KeyUtil.isSubKey(candidateKey, columnAliases)) {
            result.push(candidateKey);
        }
    }
    return result;
}
exports.extractCandidateKeysWithColumnAliasInTable = extractCandidateKeysWithColumnAliasInTable;
//# sourceMappingURL=extract-candidate-keys-with-column-alias-in-table.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/index.js":
/*!**********************************************!*\
  !*** ../tsql/dist/table/util/query/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "../tsql/dist/table/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./explicit-auto-increment */ "../tsql/dist/table/util/query/explicit-auto-increment.js"));
__export(__webpack_require__(/*! ./extract-candidate-keys-with-column-alias-in-table */ "../tsql/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js"));
__export(__webpack_require__(/*! ./insertable-column-alias */ "../tsql/dist/table/util/query/insertable-column-alias.js"));
__export(__webpack_require__(/*! ./optional-column-alias */ "../tsql/dist/table/util/query/optional-column-alias.js"));
__export(__webpack_require__(/*! ./required-column-alias */ "../tsql/dist/table/util/query/required-column-alias.js"));
__export(__webpack_require__(/*! ./try-get-schema-name */ "../tsql/dist/table/util/query/try-get-schema-name.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/insertable-column-alias.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/table/util/query/insertable-column-alias.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/table/util/query/column-alias.js");
const explicit_auto_increment_1 = __webpack_require__(/*! ./explicit-auto-increment */ "../tsql/dist/table/util/query/explicit-auto-increment.js");
function isInsertableColumnAlias(table, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
        !table.generatedColumns.includes(columnAlias) &&
        !explicit_auto_increment_1.isImplicitAutoIncrement(table, columnAlias));
}
exports.isInsertableColumnAlias = isInsertableColumnAlias;
function insertableColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isInsertableColumnAlias(table, columnAlias)));
}
exports.insertableColumnAlias = insertableColumnAlias;
//# sourceMappingURL=insertable-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/optional-column-alias.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/table/util/query/optional-column-alias.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/table/util/query/column-alias.js");
const explicit_auto_increment_1 = __webpack_require__(/*! ./explicit-auto-increment */ "../tsql/dist/table/util/query/explicit-auto-increment.js");
function isOptionalColumnAlias(table, columnAlias) {
    return (explicit_auto_increment_1.isExplicitAutoIncrement(table, columnAlias) ||
        ((table.nullableColumns.indexOf(columnAlias) >= 0 ||
            table.explicitDefaultValueColumns.indexOf(columnAlias) >= 0) &&
            table.generatedColumns.indexOf(columnAlias) < 0));
}
exports.isOptionalColumnAlias = isOptionalColumnAlias;
function optionalColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isOptionalColumnAlias(table, columnAlias)));
}
exports.optionalColumnAlias = optionalColumnAlias;
//# sourceMappingURL=optional-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/required-column-alias.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/table/util/query/required-column-alias.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "../tsql/dist/table/util/query/column-alias.js");
function isRequiredColumnAlias(table, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
        table.generatedColumns.indexOf(columnAlias) < 0 &&
        table.nullableColumns.indexOf(columnAlias) < 0 &&
        table.explicitDefaultValueColumns.indexOf(columnAlias) < 0 &&
        table.autoIncrement !== columnAlias);
}
exports.isRequiredColumnAlias = isRequiredColumnAlias;
function requiredColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isRequiredColumnAlias(table, columnAlias)));
}
exports.requiredColumnAlias = requiredColumnAlias;
//# sourceMappingURL=required-column-alias.js.map

/***/ }),

/***/ "../tsql/dist/table/util/query/try-get-schema-name.js":
/*!************************************************************!*\
  !*** ../tsql/dist/table/util/query/try-get-schema-name.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = __webpack_require__(/*! ../../../ast */ "../tsql/dist/ast/index.js");
function tryGetSchemaName(table) {
    return ((ast_1.isIdentifierNode(table.unaliasedAst) &&
        table.unaliasedAst.identifiers.length == 2) ?
        table.unaliasedAst.identifiers[0] :
        undefined);
}
exports.tryGetSchemaName = tryGetSchemaName;
//# sourceMappingURL=try-get-schema-name.js.map

/***/ }),

/***/ "../tsql/dist/transaction-access-mode.js":
/*!***********************************************!*\
  !*** ../tsql/dist/transaction-access-mode.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction access modes ranked from least to most permissive,
 * 1. `READ_ONLY`
 * 2. `READ_WRITE`
 *
 * https://github.com/AnyhowStep/tsql/issues/14
 */
var TransactionAccessMode;
(function (TransactionAccessMode) {
    TransactionAccessMode["READ_ONLY"] = "READ_ONLY";
    TransactionAccessMode["READ_WRITE"] = "READ_WRITE";
})(TransactionAccessMode = exports.TransactionAccessMode || (exports.TransactionAccessMode = {}));
var TransactionAccessModeUtil;
(function (TransactionAccessModeUtil) {
    const transactionAccessModePermissions = {
        [TransactionAccessMode.READ_ONLY]: 0,
        [TransactionAccessMode.READ_WRITE]: 1,
    };
    /**
     * Is transaction access mode `a` less permissive than `b`?
     */
    function isLessPermissiveThan(a, b) {
        return transactionAccessModePermissions[a] < transactionAccessModePermissions[b];
    }
    TransactionAccessModeUtil.isLessPermissiveThan = isLessPermissiveThan;
})(TransactionAccessModeUtil = exports.TransactionAccessModeUtil || (exports.TransactionAccessModeUtil = {}));
//# sourceMappingURL=transaction-access-mode.js.map

/***/ }),

/***/ "../tsql/dist/tuple-util/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/tuple-util/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-hint.js":
/*!*********************************!*\
  !*** ../tsql/dist/type-hint.js ***!
  \*********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TypeHint;
(function (TypeHint) {
    TypeHint["DECIMAL"] = "DECIMAL";
    TypeHint["STRING"] = "STRING";
    TypeHint["DOUBLE"] = "DOUBLE";
    TypeHint["BIGINT_SIGNED"] = "BIGINT_SIGNED";
    TypeHint["BOOLEAN"] = "BOOLEAN";
    TypeHint["BUFFER"] = "BUFFER";
    TypeHint["NULL"] = "NULL";
    TypeHint["DATE_TIME"] = "DATE_TIME";
})(TypeHint = exports.TypeHint || (exports.TypeHint = {}));
//# sourceMappingURL=type-hint.js.map

/***/ }),

/***/ "../tsql/dist/type-map/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/type-map/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeMapUtil = __webpack_require__(/*! ./util */ "../tsql/dist/type-map/util/index.js");
exports.TypeMapUtil = TypeMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-map/util/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/type-map/util/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-ref/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/type-ref/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeRefUtil = __webpack_require__(/*! ./util */ "../tsql/dist/type-ref/util/index.js");
exports.TypeRefUtil = TypeRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-ref/util/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/type-ref/util/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-util/assert-same-own-enumerable-keys.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/type-util/assert-same-own-enumerable-keys.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertSameOwnEnumerableKeys(a, b) {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const extraKeys = aKeys.filter(k => !bKeys.includes(k));
    const missingKeys = bKeys.filter(k => !aKeys.includes(k));
    if (extraKeys.length > 0) {
        if (missingKeys.length > 0) {
            throw new Error(`Extra keys found: ${extraKeys.join(",")}; Missing keys found: ${missingKeys.join(",")}`);
        }
        else {
            throw new Error(`Extra keys found: ${extraKeys.join(",")}`);
        }
    }
    else {
        if (missingKeys.length > 0) {
            throw new Error(`Missing keys found: ${missingKeys.join(",")}`);
        }
        else {
            //Do nothing
        }
    }
}
exports.assertSameOwnEnumerableKeys = assertSameOwnEnumerableKeys;
//# sourceMappingURL=assert-same-own-enumerable-keys.js.map

/***/ }),

/***/ "../tsql/dist/type-util/index.js":
/*!***************************************!*\
  !*** ../tsql/dist/type-util/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-same-own-enumerable-keys */ "../tsql/dist/type-util/assert-same-own-enumerable-keys.js"));
__export(__webpack_require__(/*! ./is-object-with-own-enumerable-keys */ "../tsql/dist/type-util/is-object-with-own-enumerable-keys.js"));
__export(__webpack_require__(/*! ./omit-own-enumerable */ "../tsql/dist/type-util/omit-own-enumerable.js"));
__export(__webpack_require__(/*! ./pick-own-enumerable */ "../tsql/dist/type-util/pick-own-enumerable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/type-util/is-object-with-own-enumerable-keys.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/type-util/is-object-with-own-enumerable-keys.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isObjectWithOwnEnumerableKeys() {
    return (raw, keys) => {
        if (raw == undefined) {
            return false;
        }
        if (!(raw instanceof Object)) {
            return false;
        }
        for (const k of keys) {
            if (!Object.prototype.hasOwnProperty.call(raw, k)) {
                return false;
            }
            if (!Object.prototype.propertyIsEnumerable.call(raw, k)) {
                return false;
            }
        }
        return true;
    };
}
exports.isObjectWithOwnEnumerableKeys = isObjectWithOwnEnumerableKeys;
//# sourceMappingURL=is-object-with-own-enumerable-keys.js.map

/***/ }),

/***/ "../tsql/dist/type-util/omit-own-enumerable.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/type-util/omit-own-enumerable.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function omitOwnEnumerable(obj, keys) {
    const result = {};
    for (const k of Object.keys(obj)) {
        if (Object.prototype.propertyIsEnumerable.call(obj, k) &&
            keys.indexOf(k) < 0) {
            result[k] = obj[k];
        }
    }
    return result;
}
exports.omitOwnEnumerable = omitOwnEnumerable;
//# sourceMappingURL=omit-own-enumerable.js.map

/***/ }),

/***/ "../tsql/dist/type-util/pick-own-enumerable.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/type-util/pick-own-enumerable.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function pickOwnEnumerable(obj, keys) {
    const result = {};
    for (const k of keys) {
        if (Object.prototype.hasOwnProperty.call(obj, k) &&
            Object.prototype.propertyIsEnumerable.call(obj, k)) {
            result[k] = obj[k];
        }
    }
    return result;
}
exports.pickOwnEnumerable = pickOwnEnumerable;
//# sourceMappingURL=pick-own-enumerable.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/convenience.js":
/*!*************************************************!*\
  !*** ../tsql/dist/unified-query/convenience.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const QueryUtil = __webpack_require__(/*! ./util */ "../tsql/dist/unified-query/util/index.js");
function from(aliasedTable) {
    return QueryUtil.newInstance()
        .from(aliasedTable);
}
exports.from = from;
function requireOuterQueryJoins(...aliasedTables) {
    return QueryUtil.newInstance()
        .requireOuterQueryJoins(...aliasedTables);
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
function requireNullableOuterQueryJoins(...aliasedTables) {
    return QueryUtil.newInstance()
        .requireNullableOuterQueryJoins(...aliasedTables);
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
function select(selectDelegate) {
    return QueryUtil.newInstance()
        .select(selectDelegate);
}
exports.select = select;
function selectValue(selectValueDelegate) {
    return QueryUtil.newInstance()
        .selectValue(selectValueDelegate);
}
exports.selectValue = selectValue;
//# sourceMappingURL=convenience.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/unified-query/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./convenience */ "../tsql/dist/unified-query/convenience.js"));
__export(__webpack_require__(/*! ./query-impl */ "../tsql/dist/unified-query/query-impl.js"));
const QueryUtil = __webpack_require__(/*! ./util */ "../tsql/dist/unified-query/util/index.js");
exports.QueryUtil = QueryUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/query-impl.js":
/*!************************************************!*\
  !*** ../tsql/dist/unified-query/query-impl.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Rename to `UnifiedQueryUtil` or something
 */
const QueryUtil = __webpack_require__(/*! ./util */ "../tsql/dist/unified-query/util/index.js");
const query_base_1 = __webpack_require__(/*! ../query-base */ "../tsql/dist/query-base/index.js");
const compound_query_1 = __webpack_require__(/*! ../compound-query */ "../tsql/dist/compound-query/index.js");
const execution_1 = __webpack_require__(/*! ../execution */ "../tsql/dist/execution/index.js");
class Query {
    constructor(data, extraData) {
        this.fromClause = data.fromClause;
        this.selectClause = data.selectClause;
        this.limitClause = data.limitClause;
        this.compoundQueryClause = data.compoundQueryClause;
        this.compoundQueryLimitClause = data.compoundQueryLimitClause;
        this.mapDelegate = data.mapDelegate;
        this.groupByClause = data.groupByClause;
        this.whereClause = extraData.whereClause;
        this.havingClause = extraData.havingClause;
        this.orderByClause = extraData.orderByClause;
        this.compoundQueryOrderByClause = extraData.compoundQueryOrderByClause;
        this.isDistinct = extraData.isDistinct;
    }
    limit(maxRowCount) {
        return QueryUtil.limit(this, maxRowCount);
    }
    offset(offset) {
        return QueryUtil.offset(this, offset);
    }
    compoundQueryLimit(maxRowCount) {
        return QueryUtil.compoundQueryLimit(this, maxRowCount);
    }
    compoundQueryOffset(offset) {
        return QueryUtil.compoundQueryOffset(this, offset);
    }
    requireOuterQueryJoins(...aliasedTables) {
        return QueryUtil.requireOuterQueryJoins(this, ...aliasedTables);
    }
    requireNullableOuterQueryJoins(...aliasedTables) {
        return QueryUtil.requireNullableOuterQueryJoins(this, ...aliasedTables);
    }
    from(aliasedTable) {
        return QueryUtil.from(this, aliasedTable);
    }
    crossJoin(aliasedTable) {
        return QueryUtil.crossJoin(this, aliasedTable);
    }
    groupBy(groupByDelegate) {
        return QueryUtil.groupBy(this, groupByDelegate);
    }
    having(havingDelegate) {
        return QueryUtil.having(this, havingDelegate);
    }
    innerJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        return QueryUtil.innerJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
    }
    innerJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
        return QueryUtil.innerJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
    }
    innerJoin(aliasedTable, onDelegate) {
        return QueryUtil.innerJoin(this, aliasedTable, onDelegate);
    }
    leftJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        return QueryUtil.leftJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
    }
    leftJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
        return QueryUtil.leftJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
    }
    leftJoin(aliasedTable, onDelegate) {
        return QueryUtil.leftJoin(this, aliasedTable, onDelegate);
    }
    orderBy(orderByDelegate) {
        return QueryUtil.orderBy(this, orderByDelegate);
    }
    selectValue(selectValueDelegate) {
        return QueryUtil.selectValue(this, selectValueDelegate);
    }
    select(selectDelegate) {
        return QueryUtil.select(this, selectDelegate);
    }
    compoundQueryOrderBy(compoundQueryOrderByDelegate) {
        return QueryUtil.compoundQueryOrderBy(this, compoundQueryOrderByDelegate);
    }
    unionDistinct(targetQuery) {
        return QueryUtil.compoundQuery(this, compound_query_1.CompoundQueryType.UNION, true, targetQuery);
    }
    unionAll(targetQuery) {
        return QueryUtil.compoundQuery(this, compound_query_1.CompoundQueryType.UNION, false, targetQuery);
    }
    whereEqCandidateKey(
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqCandidateKey(this, ...args);
    }
    whereEqColumns(
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqColumns(this, ...args);
    }
    whereEqInnerQueryPrimaryKey(srcDelegate, dstDelegate) {
        return QueryUtil.whereEqInnerQueryPrimaryKey(this, srcDelegate, dstDelegate);
    }
    whereEqOuterQueryPrimaryKey(
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate, dstDelegate) {
        return QueryUtil.whereEqOuterQueryPrimaryKey(this, srcDelegate, dstDelegate);
    }
    whereEqPrimaryKey(
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqPrimaryKey(this, ...args);
    }
    whereEqSuperKey(
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqSuperKey(this, ...args);
    }
    whereEq(
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEq(this, ...args);
    }
    whereIsNotNull(whereIsNotNullDelegate) {
        return QueryUtil.whereIsNotNull(this, whereIsNotNullDelegate);
    }
    whereIsNull(whereIsNullDelegate) {
        return QueryUtil.whereIsNull(this, whereIsNullDelegate);
    }
    whereNullSafeEq(
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereNullSafeEq(this, ...args);
    }
    where(whereDelegate) {
        return QueryUtil.where(this, whereDelegate);
    }
    as(alias) {
        return query_base_1.QueryBaseUtil.as(this, alias);
    }
    correlate() {
        return QueryUtil.correlate(this);
    }
    /**
     * @todo Maybe implement `selectDistinct()` as a convenience method?
     */
    distinct() {
        return QueryUtil.distinct(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  tsql.coalesce(myQuery.limit(1), myDefaultValue);
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).coalesce(myDefaultValue);
     * ```
     */
    coalesce(defaultValue) {
        return query_base_1.QueryBaseUtil.coalesce(this, defaultValue);
    }
    /**
     * Convenience method for,
     * ```ts
     *  tsql.throwIfNull(myQuery.limit(1));
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).throwIfNull();
     * ```
     */
    throwIfNull() {
        return query_base_1.QueryBaseUtil.throwIfNull(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).asc();
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).asc();
     * ```
     */
    asc() {
        return query_base_1.QueryBaseUtil.asc(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).desc();
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).desc();
     * ```
     */
    desc() {
        return query_base_1.QueryBaseUtil.desc(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).sort(sortDirection);
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).sort(sortDirection);
     * ```
     */
    sort(sortDirection) {
        return query_base_1.QueryBaseUtil.sort(this, sortDirection);
    }
    map(mapDelegate) {
        if (this.mapDelegate == undefined) {
            return QueryUtil.mapInitial(this, mapDelegate);
        }
        else {
            return QueryUtil.mapCompose(this, mapDelegate);
        }
    }
    fetchAllMapped(connection) {
        return execution_1.ExecutionUtil.fetchAllMapped(this, connection);
    }
    fetchAllUnmappedFlattened(connection) {
        return execution_1.ExecutionUtil.fetchAllUnmappedFlattened(this, connection);
    }
    fetchAllUnmapped(connection) {
        return execution_1.ExecutionUtil.fetchAllUnmapped(this, connection);
    }
    fetchAll(connection) {
        return execution_1.ExecutionUtil.fetchAll(this, connection);
    }
    fetchOneOrUndefined(connection) {
        return execution_1.ExecutionUtil.fetchOneOrUndefined(this, connection);
    }
    fetchOneOr(connection, defaultValue) {
        return execution_1.ExecutionUtil.fetchOneOr(this, connection, defaultValue);
    }
    fetchOne(connection) {
        return execution_1.ExecutionUtil.fetchOne(this, connection);
    }
    fetchValueArray(connection) {
        return execution_1.ExecutionUtil.fetchValueArray(this, connection);
    }
    fetchValueOrUndefined(connection) {
        return execution_1.ExecutionUtil.fetchValueOrUndefined(this, connection);
    }
    fetchValueOr(connection, defaultValue) {
        return execution_1.ExecutionUtil.fetchValueOr(this, connection, defaultValue);
    }
    fetchValue(connection) {
        return execution_1.ExecutionUtil.fetchValue(this, connection);
    }
    count(connection) {
        return execution_1.ExecutionUtil.count(this, connection);
    }
    paginate(connection, rawArgs) {
        return execution_1.ExecutionUtil.paginate(this, connection, rawArgs);
    }
    exists(connection) {
        return execution_1.ExecutionUtil.exists(this, connection);
    }
    assertExists(connection) {
        return execution_1.ExecutionUtil.assertExists(this, connection);
    }
    emulatedCursor(connection, 
    /**
     * If set, determines the starting `page` of the cursor.
     * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
     */
    rawArgs = {}) {
        return execution_1.ExecutionUtil.emulatedCursor(this, connection, rawArgs);
    }
    insert(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.insertSelect(connection, this, table, rowDelegate);
    }
    insertIgnore(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.insertIgnoreSelect(connection, this, table, rowDelegate);
    }
    replace(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.replaceSelect(connection, this, table, rowDelegate);
    }
}
exports.Query = Query;
//# sourceMappingURL=query-impl.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/constructor/index.js":
/*!************************************************************!*\
  !*** ../tsql/dist/unified-query/util/constructor/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./new-instance */ "../tsql/dist/unified-query/util/constructor/new-instance.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/constructor/new-instance.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/unified-query/util/constructor/new-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function newInstance() {
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.newInstance(),
        selectClause: undefined,
        limitClause: undefined,
        compoundQueryClause: undefined,
        compoundQueryLimitClause: undefined,
        mapDelegate: undefined,
        groupByClause: undefined,
    }, {
        whereClause: undefined,
        havingClause: undefined,
        orderByClause: undefined,
        compoundQueryOrderByClause: undefined,
        isDistinct: false,
    });
    return result;
}
exports.newInstance = newInstance;
//# sourceMappingURL=new-instance.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/index.js":
/*!************************************************!*\
  !*** ../tsql/dist/unified-query/util/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/unified-query/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/unified-query/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/unified-query/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js":
/*!**********************************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function compoundQueryLimit(query, maxRowCount) {
    const compoundQueryLimitClause = limit_clause_1.LimitClauseUtil.limit(query.compoundQueryLimitClause, maxRowCount);
    const { fromClause, selectClause, limitClause, compoundQueryClause, 
    //compoundQueryLimitClause,
    mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQueryLimit = compoundQueryLimit;
//# sourceMappingURL=compound-query-limit.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query-limit/index.js":
/*!*******************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query-limit/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-limit */ "../tsql/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js":
/*!************************************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function compoundQueryOffset(query, offset) {
    const compoundQueryLimitClause = limit_clause_1.LimitClauseUtil.offset(query.compoundQueryLimitClause, offset);
    const { fromClause, selectClause, limitClause, compoundQueryClause, 
    //compoundQueryLimitClause,
    mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQueryOffset = compoundQueryOffset;
//# sourceMappingURL=compound-query-offset.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query-offset/index.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query-offset/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-offset */ "../tsql/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query-order-by.js":
/*!****************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query-order-by.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const compound_query_order_by_clause_1 = __webpack_require__(/*! ../../../compound-query-order-by-clause */ "../tsql/dist/compound-query-order-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function compoundQueryOrderBy(query, compoundQueryOrderByDelegate) {
    const compoundQueryOrderByClause = compound_query_order_by_clause_1.CompoundQueryOrderByClauseUtil.compoundQueryOrderBy(query.selectClause, query.compoundQueryOrderByClause, compoundQueryOrderByDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, 
    //compoundQueryOrderByClause,
    isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.compoundQueryOrderBy = compoundQueryOrderBy;
//# sourceMappingURL=compound-query-order-by.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/compound-query.js":
/*!*******************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/compound-query.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const compound_query_clause_1 = __webpack_require__(/*! ../../../compound-query-clause */ "../tsql/dist/compound-query-clause/index.js");
function compoundQuery(query, compoundQueryType, isDistinct, targetQuery) {
    const { selectClause, compoundQueryClause, } = compound_query_clause_1.CompoundQueryClauseUtil.compoundQuery(query.fromClause, query.selectClause, query.compoundQueryClause, compoundQueryType, isDistinct, targetQuery);
    const { fromClause, 
    //selectClause,
    limitClause, 
    //compoundQueryClause,
    compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQuery = compoundQuery;
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/correlate.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/correlate.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
/**
 * @todo A reference to the `query` needs to be added to the following,
 * + `OnDelegate`
 * + `HavingDelegate`
 * + `OrderByDelegate`
 * + `SelectDelegate`
 * + `WhereDelegate`
 *
 * Basically, anywhere a correlated subquery is allowed.
 */
function correlate(query) {
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.correlate(query.fromClause),
        selectClause: undefined,
        limitClause: undefined,
        compoundQueryClause: undefined,
        compoundQueryLimitClause: undefined,
        mapDelegate: undefined,
        groupByClause: undefined,
    }, {
        whereClause: undefined,
        havingClause: undefined,
        orderByClause: undefined,
        compoundQueryOrderByClause: undefined,
        isDistinct: false,
    });
    return result;
}
exports.correlate = correlate;
//# sourceMappingURL=correlate.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/cross-join.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/cross-join.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function crossJoin(query, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.crossJoin(query.fromClause, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.crossJoin = crossJoin;
//# sourceMappingURL=cross-join.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/distinct.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/distinct.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function distinct(query) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, } = query;
    const result = new query_impl_1.Query(
    /**
     * If you replace the below object literal with
     * just the variable `query`, you will cause `tsc`
     * to OOM.
     */
    //query
    {
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct: true,
    });
    return result;
}
exports.distinct = distinct;
//# sourceMappingURL=distinct.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/from.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/from.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function from(query, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.from(query.fromClause, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/group-by.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/group-by.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const group_by_clause_1 = __webpack_require__(/*! ../../../group-by-clause */ "../tsql/dist/group-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function groupBy(query, groupByDelegate) {
    const groupByClause = group_by_clause_1.GroupByClauseUtil.groupBy(query.fromClause, query.groupByClause, groupByDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.groupBy = groupBy;
//# sourceMappingURL=group-by.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/having.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/having.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const having_clause_1 = __webpack_require__(/*! ../../../having-clause */ "../tsql/dist/having-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function having(query, havingDelegate) {
    const havingClause = having_clause_1.HavingClauseUtil.having(query.fromClause, query.groupByClause, query.havingClause, havingDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.having = having;
//# sourceMappingURL=having.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-limit */ "../tsql/dist/unified-query/util/operation/compound-query-limit/index.js"));
__export(__webpack_require__(/*! ./compound-query-offset */ "../tsql/dist/unified-query/util/operation/compound-query-offset/index.js"));
__export(__webpack_require__(/*! ./limit */ "../tsql/dist/unified-query/util/operation/limit/index.js"));
__export(__webpack_require__(/*! ./map */ "../tsql/dist/unified-query/util/operation/map/index.js"));
__export(__webpack_require__(/*! ./offset */ "../tsql/dist/unified-query/util/operation/offset/index.js"));
__export(__webpack_require__(/*! ./compound-query-order-by */ "../tsql/dist/unified-query/util/operation/compound-query-order-by.js"));
__export(__webpack_require__(/*! ./compound-query */ "../tsql/dist/unified-query/util/operation/compound-query.js"));
__export(__webpack_require__(/*! ./correlate */ "../tsql/dist/unified-query/util/operation/correlate.js"));
__export(__webpack_require__(/*! ./cross-join */ "../tsql/dist/unified-query/util/operation/cross-join.js"));
__export(__webpack_require__(/*! ./distinct */ "../tsql/dist/unified-query/util/operation/distinct.js"));
__export(__webpack_require__(/*! ./from */ "../tsql/dist/unified-query/util/operation/from.js"));
__export(__webpack_require__(/*! ./group-by */ "../tsql/dist/unified-query/util/operation/group-by.js"));
__export(__webpack_require__(/*! ./having */ "../tsql/dist/unified-query/util/operation/having.js"));
__export(__webpack_require__(/*! ./inner-join-using-candidate-key */ "../tsql/dist/unified-query/util/operation/inner-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./inner-join-using-primary-key */ "../tsql/dist/unified-query/util/operation/inner-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./inner-join */ "../tsql/dist/unified-query/util/operation/inner-join.js"));
__export(__webpack_require__(/*! ./left-join-using-candidate-key */ "../tsql/dist/unified-query/util/operation/left-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./left-join-using-primary-key */ "../tsql/dist/unified-query/util/operation/left-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./left-join */ "../tsql/dist/unified-query/util/operation/left-join.js"));
__export(__webpack_require__(/*! ./order-by */ "../tsql/dist/unified-query/util/operation/order-by.js"));
__export(__webpack_require__(/*! ./require-nullable-outer-query-joins */ "../tsql/dist/unified-query/util/operation/require-nullable-outer-query-joins.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins */ "../tsql/dist/unified-query/util/operation/require-outer-query-joins.js"));
__export(__webpack_require__(/*! ./select-value */ "../tsql/dist/unified-query/util/operation/select-value.js"));
__export(__webpack_require__(/*! ./select */ "../tsql/dist/unified-query/util/operation/select.js"));
__export(__webpack_require__(/*! ./where-eq-candidate-key */ "../tsql/dist/unified-query/util/operation/where-eq-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-columns */ "../tsql/dist/unified-query/util/operation/where-eq-columns.js"));
__export(__webpack_require__(/*! ./where-eq-inner-query-primary-key */ "../tsql/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-primary-key */ "../tsql/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-primary-key */ "../tsql/dist/unified-query/util/operation/where-eq-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-super-key */ "../tsql/dist/unified-query/util/operation/where-eq-super-key.js"));
__export(__webpack_require__(/*! ./where-eq */ "../tsql/dist/unified-query/util/operation/where-eq.js"));
__export(__webpack_require__(/*! ./where-is-not-null */ "../tsql/dist/unified-query/util/operation/where-is-not-null.js"));
__export(__webpack_require__(/*! ./where-is-null */ "../tsql/dist/unified-query/util/operation/where-is-null.js"));
__export(__webpack_require__(/*! ./where-null-safe-eq */ "../tsql/dist/unified-query/util/operation/where-null-safe-eq.js"));
__export(__webpack_require__(/*! ./where */ "../tsql/dist/unified-query/util/operation/where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/inner-join-using-candidate-key.js":
/*!***********************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/inner-join-using-candidate-key.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function innerJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
//# sourceMappingURL=inner-join-using-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/inner-join-using-primary-key.js":
/*!*********************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/inner-join-using-primary-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function innerJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
//# sourceMappingURL=inner-join-using-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/inner-join.js":
/*!***************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/inner-join.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "../tsql/dist/on-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function innerJoin(query, aliasedTable, onDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoin(query.fromClause, aliasedTable, columns => {
            const rawOnClause = onDelegate(columns);
            /**
             * @todo Investigate assignability
             */
            const result = rawOnClause;
            on_clause_1.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
            return result;
        }),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoin = innerJoin;
//# sourceMappingURL=inner-join.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/left-join-using-candidate-key.js":
/*!**********************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/left-join-using-candidate-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function leftJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
//# sourceMappingURL=left-join-using-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/left-join-using-primary-key.js":
/*!********************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/left-join-using-primary-key.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function leftJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
//# sourceMappingURL=left-join-using-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/left-join.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/left-join.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "../tsql/dist/on-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "../tsql/dist/unified-query/util/predicate/index.js");
function leftJoin(query, aliasedTable, onDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoin(query.fromClause, aliasedTable, columns => {
            const rawOnClause = onDelegate(columns);
            /**
             * @todo Investigate assignability
             */
            const result = rawOnClause;
            on_clause_1.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
            return result;
        }),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoin = leftJoin;
//# sourceMappingURL=left-join.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/limit/index.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/limit/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./limit */ "../tsql/dist/unified-query/util/operation/limit/limit.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/limit/limit.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/limit/limit.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function limit(query, maxRowCount) {
    const limitClause = limit_clause_1.LimitClauseUtil.limit(query.limitClause, maxRowCount);
    const { fromClause, selectClause, 
    //limitClause,
    compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.limit = limit;
//# sourceMappingURL=limit.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/map/index.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/map/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./map-compose */ "../tsql/dist/unified-query/util/operation/map/map-compose.js"));
__export(__webpack_require__(/*! ./map-initial */ "../tsql/dist/unified-query/util/operation/map/map-initial.js"));
__export(__webpack_require__(/*! ./map */ "../tsql/dist/unified-query/util/operation/map/map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/map/map-compose.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/map/map-compose.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const map_delegate_1 = __webpack_require__(/*! ../../../../map-delegate */ "../tsql/dist/map-delegate/index.js");
function mapCompose(query, mapDelegate) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
    //mapDelegate,
    groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate: (map_delegate_1.MapDelegateUtil.compose(
        /**
         * @todo Clean up?
         */
        query.mapDelegate, mapDelegate)),
        groupByClause,
    }, query);
    return result;
}
exports.mapCompose = mapCompose;
//# sourceMappingURL=map-compose.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/map/map-initial.js":
/*!********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/map/map-initial.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function mapInitial(query, mapDelegate) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
    //mapDelegate,
    groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate: mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.mapInitial = mapInitial;
//# sourceMappingURL=map-initial.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/map/map.js":
/*!************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/map/map.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const map_initial_1 = __webpack_require__(/*! ./map-initial */ "../tsql/dist/unified-query/util/operation/map/map-initial.js");
const map_compose_1 = __webpack_require__(/*! ./map-compose */ "../tsql/dist/unified-query/util/operation/map/map-compose.js");
/**
 * @todo Clean up usages of `any`
 *
 * Removing the usages of `any` will cause build times to jump 30s!
 */
function map(query, mapDelegate) {
    if (query.mapDelegate == undefined) {
        return map_initial_1.mapInitial(query, mapDelegate);
    }
    else {
        return map_compose_1.mapCompose(query, mapDelegate);
    }
}
exports.map = map;
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/offset/index.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/offset/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./offset */ "../tsql/dist/unified-query/util/operation/offset/offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/offset/offset.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/offset/offset.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "../tsql/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function offset(query, offset) {
    const limitClause = limit_clause_1.LimitClauseUtil.offset(query.limitClause, offset);
    const { fromClause, selectClause, 
    //limitClause,
    compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.offset = offset;
//# sourceMappingURL=offset.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/order-by.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/order-by.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const order_by_clause_1 = __webpack_require__(/*! ../../../order-by-clause */ "../tsql/dist/order-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const correlate_1 = __webpack_require__(/*! ./correlate */ "../tsql/dist/unified-query/util/operation/correlate.js");
function orderBy(query, orderByDelegate) {
    const orderByClause = order_by_clause_1.OrderByClauseUtil.orderBy(query.fromClause, query.groupByClause, query.selectClause, query.orderByClause, (columns) => {
        return orderByDelegate(columns, correlate_1.correlate(query));
    });
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.orderBy = orderBy;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/require-nullable-outer-query-joins.js":
/*!***************************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/require-nullable-outer-query-joins.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function requireNullableOuterQueryJoins(query, ...aliasedTables) {
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.requireNullableOuterQueryJoins(query.fromClause, ...aliasedTables),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
//# sourceMappingURL=require-nullable-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/require-outer-query-joins.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/require-outer-query-joins.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function requireOuterQueryJoins(query, ...aliasedTables) {
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.requireOuterQueryJoins(query.fromClause, ...aliasedTables),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
//# sourceMappingURL=require-outer-query-joins.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/select-value.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/select-value.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
const select_1 = __webpack_require__(/*! ./select */ "../tsql/dist/unified-query/util/operation/select.js");
/**
 * @todo Rename to `selectScalar`?
 */
function selectValue(query, selectValueDelegate) {
    return select_1.select(query, (columns, subquery) => select_clause_1.SelectClauseUtil.valueFromBuiltInExpr(selectValueDelegate(columns, subquery)));
}
exports.selectValue = selectValue;
//# sourceMappingURL=select-value.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/select.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/select.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "../tsql/dist/select-clause/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "../tsql/dist/query-base/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const correlate_1 = __webpack_require__(/*! ./correlate */ "../tsql/dist/unified-query/util/operation/correlate.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function select(query, selectDelegate
//selectDelegate : SelectDelegate<QueryT["fromClause"], QueryT["selectClause"], SelectsT>
) {
    if (!query_base_1.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
        throw new Error(`Cannot SELECT after COMPOUND QUERY clause; this will change the number of columns`);
    }
    //const correlated = correlate<QueryT>(query);
    const selectClause = select_clause_1.SelectClauseUtil.select(query.fromClause, query.groupByClause, query.selectClause, (columns) => {
        return selectDelegate(columns, correlate_1.correlate(query));
    });
    const { fromClause, 
    //selectClause,
    limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause: (groupByClause != undefined ?
            groupByClause :
            selectClause.some(selectItem => (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(selectItem) &&
                built_in_expr_1.BuiltInExprUtil.isAggregate(selectItem))) ?
                [] :
                undefined),
    }, query);
    return result;
}
exports.select = select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-candidate-key.js":
/*!***************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-candidate-key.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEqCandidateKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqCandidateKey(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqCandidateKey = whereEqCandidateKey;
//# sourceMappingURL=where-eq-candidate-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-columns.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-columns.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEqColumns(query, 
/**
 * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqColumns(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqColumns = whereEqColumns;
//# sourceMappingURL=where-eq-columns.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEqInnerQueryPrimaryKey(query, srcDelegate, dstDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqInnerQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
//# sourceMappingURL=where-eq-inner-query-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js":
/*!*************************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEqOuterQueryPrimaryKey(query, 
/**
 * This construction effectively makes it impossible for
 * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
srcDelegate, dstDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqOuterQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
//# sourceMappingURL=where-eq-outer-query-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-primary-key.js":
/*!*************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-primary-key.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEqPrimaryKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqPrimaryKey(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqPrimaryKey = whereEqPrimaryKey;
//# sourceMappingURL=where-eq-primary-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq-super-key.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq-super-key.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
const expr_library_1 = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
function whereEqSuperKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqSuperKey(query.fromClause, query.whereClause, expr_library_1.eqSuperKey, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqSuperKey = whereEqSuperKey;
//# sourceMappingURL=where-eq-super-key.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-eq.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-eq.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereEq(query, 
/**
 * This construction effectively makes it impossible for `WhereEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEq(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEq = whereEq;
//# sourceMappingURL=where-eq.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-is-not-null.js":
/*!**********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-is-not-null.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereIsNotNull(query, whereIsNotNullDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereIsNotNull(query.fromClause, query.whereClause, whereIsNotNullDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereIsNotNull = whereIsNotNull;
//# sourceMappingURL=where-is-not-null.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-is-null.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-is-null.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereIsNull(query, whereIsNullDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereIsNull(query.fromClause, query.whereClause, whereIsNullDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereIsNull = whereIsNull;
//# sourceMappingURL=where-is-null.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where-null-safe-eq.js":
/*!***********************************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where-null-safe-eq.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function whereNullSafeEq(query, 
/**
 * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereNullSafeEq(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereNullSafeEq = whereNullSafeEq;
//# sourceMappingURL=where-null-safe-eq.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/operation/where.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/unified-query/util/operation/where.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "../tsql/dist/where-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "../tsql/dist/unified-query/query-impl.js");
function where(query, whereDelegate) {
    const whereClause = where_clause_1.WhereClauseUtil.where(query.fromClause, query.whereClause, whereDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.where = where;
//# sourceMappingURL=where.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/predicate/assert-valid-current-join.js":
/*!******************************************************************************!*\
  !*** ../tsql/dist/unified-query/util/predicate/assert-valid-current-join.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
function assertValidJoinTarget(query, aliasedTable) {
    from_clause_1.FromClauseUtil.assertValidCurrentJoinBase(query.fromClause, aliasedTable);
    from_clause_1.FromClauseUtil.assertNoUsedRef(aliasedTable);
    from_clause_1.FromClauseUtil.assertNotLateral(aliasedTable);
}
exports.assertValidJoinTarget = assertValidJoinTarget;
//# sourceMappingURL=assert-valid-current-join.js.map

/***/ }),

/***/ "../tsql/dist/unified-query/util/predicate/index.js":
/*!**********************************************************!*\
  !*** ../tsql/dist/unified-query/util/predicate/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-valid-current-join */ "../tsql/dist/unified-query/util/predicate/assert-valid-current-join.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/update/index.js":
/*!************************************!*\
  !*** ../tsql/dist/update/index.js ***!
  \************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UpdateUtil = __webpack_require__(/*! ./util */ "../tsql/dist/update/util/index.js");
exports.UpdateUtil = UpdateUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/update/util/index.js":
/*!*****************************************!*\
  !*** ../tsql/dist/update/util/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/update/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/update/util/operation/clean-assignment-map.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/update/util/operation/clean-assignment-map.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
function cleanAssignmentMap(table, raw) {
    const result = {};
    const allowed = used_ref_1.UsedRefUtil.fromColumnMap(table.columns);
    for (const columnAlias of Object.keys(raw)) {
        const customExpr = raw[columnAlias];
        if (customExpr === undefined) {
            continue;
        }
        if (table.mutableColumns.indexOf(columnAlias) < 0) {
            //This columnAlias is not mutable...
            if (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
                Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias)) {
                throw new Error(`${table.alias}.${columnAlias} is not mutable`);
            }
            else {
                //Just some random extra property that is not a `columnAlias` of `TableT`.
                //This probably only got through because TS does not have exact types at the moment.
                continue;
            }
        }
        result[columnAlias] = built_in_expr_1.BuiltInExprUtil.fromCustomExpr_MapCorrelated(table.columns[columnAlias], allowed, customExpr);
    }
    /*
    if (Object.keys(result).length == 0) {
        //The user specified an empty assignment map?
        //Very weird...
        if (table.mutableColumns.length == 0) {
            throw new Error(`${table.alias} has no mutable columns`);
        }
        const firstColumnAlias = table.mutableColumns[0];
        const firstColumn = table.columns[firstColumnAlias];
        //We specify a no-op assignment, to prevent the `UpdateConnection` from crashing
        result[firstColumnAlias as keyof typeof result] = firstColumn as any;
    }
    */
    return result;
}
exports.cleanAssignmentMap = cleanAssignmentMap;
//# sourceMappingURL=clean-assignment-map.js.map

/***/ }),

/***/ "../tsql/dist/update/util/operation/index.js":
/*!***************************************************!*\
  !*** ../tsql/dist/update/util/operation/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-assignment-map */ "../tsql/dist/update/util/operation/clean-assignment-map.js"));
__export(__webpack_require__(/*! ./set */ "../tsql/dist/update/util/operation/set.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/update/util/operation/set.js":
/*!*************************************************!*\
  !*** ../tsql/dist/update/util/operation/set.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const clean_assignment_map_1 = __webpack_require__(/*! ./clean-assignment-map */ "../tsql/dist/update/util/operation/clean-assignment-map.js");
function set(table, assignmentMapDelegate) {
    const raw = assignmentMapDelegate(table.columns);
    return clean_assignment_map_1.cleanAssignmentMap(table, raw);
}
exports.set = set;
//# sourceMappingURL=set.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/index.js":
/*!**************************************!*\
  !*** ../tsql/dist/used-ref/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UsedRefUtil = __webpack_require__(/*! ./util */ "../tsql/dist/used-ref/util/index.js");
exports.UsedRefUtil = UsedRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/from-column-map.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/from-column-map.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function fromColumnMap(map) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.fromColumnMap(map),
    };
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/from-column-ref.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/from-column-ref.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnRef(ref) {
    const result = {
        __contravarianceMarker: () => { },
        columns: ref,
    };
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/from-column.js":
/*!*************************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/from-column.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = {
        __contravarianceMarker: () => { },
        columns: {
            [column.tableAlias]: {
                [column.columnAlias]: column
            }
        },
    };
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/from-from-clause.js":
/*!******************************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/from-from-clause.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_array_1 = __webpack_require__(/*! ./from-join-array */ "../tsql/dist/used-ref/util/constructor/from-join-array.js");
function fromFromClause(fromClause) {
    return from_join_array_1.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
}
exports.fromFromClause = fromFromClause;
//# sourceMappingURL=from-from-clause.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/from-join-array.js":
/*!*****************************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/from-join-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function fromJoinArray(joins) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(joins),
    };
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/constructor/index.js":
/*!*******************************************************!*\
  !*** ../tsql/dist/used-ref/util/constructor/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "../tsql/dist/used-ref/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "../tsql/dist/used-ref/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-column */ "../tsql/dist/used-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-from-clause */ "../tsql/dist/used-ref/util/constructor/from-from-clause.js"));
__export(__webpack_require__(/*! ./from-join-array */ "../tsql/dist/used-ref/util/constructor/from-join-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/index.js":
/*!*******************************************!*\
  !*** ../tsql/dist/used-ref/util/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "../tsql/dist/used-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/used-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "../tsql/dist/used-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/used-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/operation/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/used-ref/util/operation/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "../tsql/dist/used-ref/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/operation/intersect.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/used-ref/util/operation/intersect.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function intersect(...arr) {
    let columns = {};
    for (const u of arr) {
        columns = column_identifier_ref_1.ColumnIdentifierRefUtil.intersect(columns, u.columns);
    }
    const result = {
        __contravarianceMarker: () => { },
        columns,
    };
    return result;
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/predicate/assert-allowed.js":
/*!**************************************************************!*\
  !*** ../tsql/dist/used-ref/util/predicate/assert-allowed.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
/**
 * @todo Better naming
 *
 * @param allowed - Which references are allowed
 * @param used - Which references were actually used
 */
function assertAllowed(allowed, used) {
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(allowed.columns, column_identifier_1.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
}
exports.assertAllowed = assertAllowed;
//# sourceMappingURL=assert-allowed.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/predicate/assert-empty.js":
/*!************************************************************!*\
  !*** ../tsql/dist/used-ref/util/predicate/assert-empty.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "../tsql/dist/column-identifier/index.js");
/**
 * @todo Better naming
 *
 * @param used - Which references were actually used
 */
function assertEmpty(used) {
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers({}, column_identifier_1.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
}
exports.assertEmpty = assertEmpty;
//# sourceMappingURL=assert-empty.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/predicate/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/used-ref/util/predicate/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-allowed */ "../tsql/dist/used-ref/util/predicate/assert-allowed.js"));
__export(__webpack_require__(/*! ./assert-empty */ "../tsql/dist/used-ref/util/predicate/assert-empty.js"));
__export(__webpack_require__(/*! ./is-used-ref */ "../tsql/dist/used-ref/util/predicate/is-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/predicate/is-used-ref.js":
/*!***********************************************************!*\
  !*** ../tsql/dist/used-ref/util/predicate/is-used-ref.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "../tsql/dist/type-util/index.js");
//import {ColumnIdentifierRefUtil} from "../../../column-identifier-ref";
/**
 * Does not actually check that `x.columns` is a `ColumnIdentifierRef`.
 *
 * @todo Consider adding check for increased type safety.
 */
function isUsedRef(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "__contravarianceMarker",
        "columns",
    ])) {
        return false;
    }
    return ((typeof x.__contravarianceMarker == "function") // &&
    //(ColumnIdentifierRefUtil.isColumnIdentifierRef(x.usedRef))
    );
}
exports.isUsedRef = isUsedRef;
//# sourceMappingURL=is-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/query/extract-column-identifier.js":
/*!*********************************************************************!*\
  !*** ../tsql/dist/used-ref/util/query/extract-column-identifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "../tsql/dist/column-identifier-ref/index.js");
function extractColumnIdentifiers(usedRef, columnIdentifiers) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.extractColumnIdentifiers(usedRef.columns, columnIdentifiers),
    };
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "../tsql/dist/used-ref/util/query/index.js":
/*!*************************************************!*\
  !*** ../tsql/dist/used-ref/util/query/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "../tsql/dist/used-ref/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/value-expr/index.js":
/*!****************************************!*\
  !*** ../tsql/dist/value-expr/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ValueExprUtil = __webpack_require__(/*! ./util */ "../tsql/dist/value-expr/util/index.js");
exports.ValueExprUtil = ValueExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/value-expr/util/index.js":
/*!*********************************************!*\
  !*** ../tsql/dist/value-expr/util/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/index.js":
/*!******************************************!*\
  !*** ../tsql/dist/where-clause/index.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WhereClauseUtil = __webpack_require__(/*! ./util */ "../tsql/dist/where-clause/util/index.js");
exports.WhereClauseUtil = WhereClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/util/index.js":
/*!***********************************************!*\
  !*** ../tsql/dist/where-clause/util/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "../tsql/dist/where-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "../tsql/dist/where-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/util/operation/index.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/where-clause/util/operation/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./where */ "../tsql/dist/where-clause/util/operation/where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/util/operation/where.js":
/*!*********************************************************!*\
  !*** ../tsql/dist/where-clause/util/operation/where.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "../tsql/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "../tsql/dist/expr-library/index.js");
const query_1 = __webpack_require__(/*! ../query */ "../tsql/dist/where-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "../tsql/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "../tsql/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "../tsql/dist/expr/index.js");
/**
 * Returns the MySQL equivalent of `whereClause AND whereDelegate(columns)`
 *
 * @param fromClause
 * @param whereClause
 * @param whereDelegate
 */
function where(fromClause, whereClause, whereDelegate) {
    const columns = query_1.allowedColumnRef(fromClause);
    /**
     * Explicit type annotation required or `tsc` crashes
     */
    const operand = whereDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    used_ref_1.UsedRefUtil.assertAllowed({ columns }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    const result = (whereClause == undefined ?
        expr_1.ExprUtil.fromBuiltInExpr(operand) :
        ExprLib.and(whereClause, operand));
    return result;
}
exports.where = where;
//# sourceMappingURL=where.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/util/query/allowed-used-ref.js":
/*!****************************************************************!*\
  !*** ../tsql/dist/where-clause/util/query/allowed-used-ref.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "../tsql/dist/from-clause/index.js");
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "../tsql/dist/where-clause/util/query/index.js":
/*!*****************************************************!*\
  !*** ../tsql/dist/where-clause/util/query/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "../tsql/dist/where-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/constants.js":
/*!**********************************!*\
  !*** ./dist/driver/constants.js ***!
  \**********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_SCHEMA_NAME = "main";
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./dist/driver/execution/connection/connection.js":
/*!********************************************************!*\
  !*** ./dist/driver/execution/connection/connection.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ../../sqlfier */ "./dist/driver/sqlfier/index.js");
const schema_introspection_1 = __webpack_require__(/*! ../../schema-introspection */ "./dist/driver/schema-introspection/index.js");
const worker_1 = __webpack_require__(/*! ../../worker */ "./dist/driver/worker.js");
const ExprLib = __webpack_require__(/*! ../../expr-library */ "./dist/driver/expr-library/index.js");
class IdAllocator {
    constructor() {
        this.nextId = 0;
    }
    allocateId() {
        return ++this.nextId;
    }
}
exports.IdAllocator = IdAllocator;
function onMessage(data, id, action, resolve, reject) {
    if (data.id != id) {
        reject(new Error(`Expected id ${id}; received ${data.id}`));
        return;
    }
    if (data.action != action) {
        reject(new Error(`Expected action ${action}; received ${data.action}`));
        return;
    }
    if (data.error == undefined) {
        resolve(data);
    }
    else {
        reject(new Error(data.error));
    }
}
function postMessage(worker, id, action, data, resolve) {
    return new Promise((innerResolve, originalInnerReject) => {
        const innerReject = (error) => {
            const sql = ("sql" in data ?
                data.sql :
                undefined);
            if (error instanceof Error) {
                if (error.message.startsWith("DataOutOfRangeError") || error.message.includes("overflow")) {
                    const newErr = new squill.DataOutOfRangeError({
                        innerError: error,
                        sql,
                    });
                    originalInnerReject(newErr);
                }
                else if (error.message.startsWith("DivideByZeroError")) {
                    const newErr = new squill.DivideByZeroError({
                        innerError: error,
                        sql,
                    });
                    originalInnerReject(newErr);
                }
                else {
                    const newErr = new squill.SqlError({
                        innerError: error,
                        sql,
                    });
                    originalInnerReject(newErr);
                }
            }
            else {
                const newErr = new squill.SqlError({
                    innerError: error,
                    sql,
                });
                originalInnerReject(newErr);
            }
        };
        worker.onmessage = (e) => {
            const data = e.data;
            onMessage(data, id, action, (data) => {
                innerResolve(resolve(data));
            }, innerReject);
        };
        worker.onmessageerror = innerReject;
        worker.onerror = innerReject;
        worker.postMessage({
            id,
            action,
            ...data,
        });
    });
}
class Connection {
    constructor({ pool, eventEmitters, worker, idAllocator, sharedConnectionInformation, }) {
        this.savepointData = undefined;
        this.deallocatePromise = undefined;
        this.pool = pool;
        this.eventEmitters = eventEmitters;
        this.idAllocator = idAllocator;
        this.asyncQueue = worker instanceof squill.AsyncQueue ?
            worker :
            new squill.AsyncQueue(() => {
                return {
                    item: worker,
                    deallocate: async () => { }
                };
            });
        this.sharedConnectionInformation = sharedConnectionInformation;
        this.sharedConnectionInformation;
    }
    tryGetFullConnection() {
        if (this.sharedConnectionInformation.transactionData != undefined &&
            this.sharedConnectionInformation.transactionData.accessMode == squill.TransactionAccessMode.READ_ONLY) {
            /**
             * Can't give a full connection if we are in a readonly transaction.
             * No `INSERT/UPDATE/DELETE` allowed.
             */
            return undefined;
        }
        else {
            return this;
        }
    }
    lock(callback) {
        return this.asyncQueue.lock((nestedAsyncQueue) => {
            const nestedConnection = new Connection({
                pool: this.pool,
                eventEmitters: this.eventEmitters,
                idAllocator: this.idAllocator,
                worker: nestedAsyncQueue,
                sharedConnectionInformation: this.sharedConnectionInformation
            });
            return callback(nestedConnection);
        });
    }
    rollback() {
        if (!this.isInTransaction()) {
            return Promise.reject(new Error("Not in transaction; cannot rollback"));
        }
        return this.rawQuery("ROLLBACK")
            .then(() => {
            this.sharedConnectionInformation.transactionData = undefined;
            /**
             * @todo Handle sync errors somehow.
             * Maybe propagate them to `IPool` and have an `onError` handler or something
             */
            this.eventEmitters.rollback();
        });
    }
    commit() {
        if (!this.isInTransaction()) {
            return Promise.reject(new Error("Not in transaction; cannot commit"));
        }
        return this.rawQuery("COMMIT")
            .then(() => {
            this.sharedConnectionInformation.transactionData = undefined;
            /**
             * @todo Handle sync errors somehow.
             * Maybe propagate them to `IPool` and have an `onError` handler or something
             */
            this.eventEmitters.commit();
        });
    }
    getMinimumIsolationLevel() {
        if (this.sharedConnectionInformation.transactionData == undefined) {
            throw new Error(`Not in transaction`);
        }
        return this.sharedConnectionInformation.transactionData.minimumIsolationLevel;
    }
    getTransactionAccessMode() {
        if (this.sharedConnectionInformation.transactionData == undefined) {
            throw new Error(`Not in transaction`);
        }
        return this.sharedConnectionInformation.transactionData.accessMode;
    }
    transactionImpl(minimumIsolationLevel, accessMode, callback) {
        if (this.sharedConnectionInformation.transactionData != undefined) {
            return Promise.reject(new Error(`Transaction already started or starting`));
        }
        /**
         * SQLite only has `SERIALIZABLE` transactions.
         * So, no matter what we request, we will always get a
         * `SERIALIZABLE` transaction.
         *
         * However, we will just pretend that we have all
         * isolation levels supported.
         */
        this.sharedConnectionInformation.transactionData = {
            minimumIsolationLevel,
            accessMode,
        };
        return new Promise((resolve, reject) => {
            return this.rawQuery(`BEGIN TRANSACTION`)
                .then(() => {
                /**
                 * @todo Handle sync errors somehow.
                 * Maybe propagate them to `IPool` and have an `onError` handler or something
                 */
                this.eventEmitters.commit();
                if (!this.isInTransaction()) {
                    /**
                     * Why did one of the `OnCommit` listeners call `commit()` or `rollback()`?
                     */
                    throw new Error(`Expected to be in transaction`);
                }
                return callback(this);
            })
                .then((result) => {
                if (!this.isInTransaction()) {
                    resolve(result);
                    return;
                }
                this.commit()
                    .then(() => {
                    resolve(result);
                })
                    .catch((commitErr) => {
                    this.rollback()
                        .then(() => {
                        reject(commitErr);
                    })
                        .catch((rollbackErr) => {
                        commitErr.rollbackErr = rollbackErr;
                        reject(commitErr);
                    });
                });
            })
                .catch((err) => {
                if (!this.isInTransaction()) {
                    reject(err);
                    return;
                }
                this.rollback()
                    .then(() => {
                    reject(err);
                })
                    .catch((rollbackErr) => {
                    err.rollbackErr = rollbackErr;
                    reject(err);
                });
            });
        });
    }
    transactionIfNotInOneImpl(minimumIsolationLevel, accessMode, callback) {
        return this.lock(async (nestedConnection) => {
            if (nestedConnection.isInTransaction()) {
                if (squill.IsolationLevelUtil.isWeakerThan(this.getMinimumIsolationLevel(), minimumIsolationLevel)) {
                    /**
                     * For example, our current isolation level is
                     * `READ_UNCOMMITTED` but we want
                     * `SERIALIZABLE`.
                     *
                     * Obviously, `READ_UNCOMMITTED` is weaker than
                     * `SERIALIZABLE`.
                     *
                     * So, we error.
                     *
                     * @todo Custom error type
                     */
                    return Promise.reject(new Error(`Current isolation level is ${this.getMinimumIsolationLevel()}; cannot guarantee ${minimumIsolationLevel}`));
                }
                if (squill.TransactionAccessModeUtil.isLessPermissiveThan(this.getTransactionAccessMode(), accessMode)) {
                    return Promise.reject(new Error(`Current transaction access mode is ${this.getTransactionAccessMode()}; cannot allow ${accessMode}`));
                }
                try {
                    return callback(nestedConnection);
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
            else {
                return nestedConnection.transactionImpl(minimumIsolationLevel, accessMode, callback);
            }
        });
    }
    transactionIfNotInOne(...args) {
        return this.transactionIfNotInOneImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_WRITE, args.length == 1 ? args[0] : args[1]);
    }
    readOnlyTransactionIfNotInOne(...args) {
        return this.transactionIfNotInOneImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_ONLY, args.length == 1 ? args[0] : args[1]);
    }
    allocateId() {
        return this.idAllocator.allocateId();
    }
    open(dbFile) {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.OPEN, {
                buffer: dbFile,
            }, () => { });
        });
    }
    export() {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.EXPORT, {}, data => data.buffer);
        });
    }
    close() {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CLOSE, {}, () => { });
        });
    }
    createGlobalJsFunction(functionName, impl) {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_GLOBAL_JS_FUNCTION, {
                functionName,
                impl: impl.toString(),
            }, () => { });
        });
    }
    /**
     * The `impl` function will be stringified using `impl.toString()`.
     *
     * Then, the function will be "rebuilt" using `eval()`.
     *
     * This means your `impl` cannot rely on anything outside its scope.
     * It must be a "pure" function.
     *
     * Also, you really shouldn't pass user input to this method.
     */
    createFunction(functionName, options, impl) {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_FUNCTION, {
                functionName,
                options,
                impl: impl.toString(),
            }, () => { });
        });
    }
    createAggregate(functionName, init, step, finalize) {
        return this.asyncQueue.enqueue((worker) => {
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.CREATE_AGGREGATE, {
                functionName,
                init: init.toString(),
                step: step.toString(),
                finalize: finalize.toString(),
            }, () => { });
        });
    }
    exec(sql) {
        return this.asyncQueue.enqueue((worker) => {
            //console.log("sql", sql);
            return postMessage(worker, this.allocateId(), worker_1.SqliteAction.EXEC, {
                sql,
            }, ({ execResult, rowsModified }) => {
                return { execResult, rowsModified };
            });
        });
    }
    rawQuery(sql) {
        //console.log("sql", sql);
        return this
            .exec(sql)
            .then((result) => {
            if (result.execResult.length == 0) {
                return {
                    query: { sql },
                    results: undefined,
                    columns: undefined,
                };
            }
            return {
                query: { sql },
                results: result.execResult[0].values,
                columns: result.execResult[0].columns,
            };
        });
    }
    async select(query) {
        const sql = squill.AstUtil.toSql(query, sqlfier_1.sqlfier);
        return this.exec(sql)
            .then((result) => {
            if (result.execResult.length > 1) {
                throw new Error(`Expected to run 1 SELECT statement; found ${result.execResult.length}`);
            }
            /**
             * When SQLite fetches zero rows, we get zero execResults...
             * Which is frustrating.
             */
            const resultSet = ((result.execResult.length == 0) ?
                {
                    values: [],
                    columns: [],
                } :
                result.execResult[0]);
            const selectResult = {
                query: { sql, },
                rows: resultSet.values.map((row) => {
                    const obj = {};
                    for (let i = 0; i < resultSet.columns.length; ++i) {
                        const k = resultSet.columns[i];
                        const v = row[i];
                        obj[k] = v;
                    }
                    return obj;
                }),
                columns: resultSet.columns,
            };
            return selectResult;
        });
    }
    async insertOne(table, row) {
        const sql = sqlfier_1.insertOneSqlString("INSERT", table, row);
        return this.lock((rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertOne() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified != 1) {
                    throw new Error(`insertOne() should modify one row`);
                }
                const autoIncrementId = ((table.autoIncrement == undefined) ?
                    undefined :
                    (row[table.autoIncrement] === undefined) ?
                        await squill
                            .selectValue(() => ExprLib.lastInsertRowId())
                            .fetchValue(nestedConnection) :
                        /**
                         * Emulate MySQL behaviour
                         */
                        tm.BigInt(0));
                const insertOneResult = {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(1),
                    autoIncrementId: (autoIncrementId == undefined ?
                        undefined :
                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?
                            undefined :
                            autoIncrementId),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
                return insertOneResult;
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    async insertMany(table, rows) {
        const sql = await sqlfier_1.insertManySqlString(this, "INSERT", table, rows);
        return this.lock(async (rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertMany() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified != rows.length) {
                    throw new Error(`insertMany() should modify ${rows.length} rows; only modified ${result.rowsModified} rows`);
                }
                return {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(result.rowsModified),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    insertIgnoreOne(table, row) {
        const sql = sqlfier_1.insertOneSqlString("INSERT OR IGNORE", table, row);
        return this.lock((rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertIgnoreOne() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified != 0 && result.rowsModified != 1) {
                    throw new Error(`insertIgnoreOne() should modify zero or one row`);
                }
                if (result.rowsModified == 0) {
                    return {
                        query: { sql, },
                        insertedRowCount: tm.BigInt(result.rowsModified),
                        autoIncrementId: undefined,
                        warningCount: tm.BigInt(1),
                        message: "ok",
                    };
                }
                const autoIncrementId = ((table.autoIncrement == undefined) ?
                    undefined :
                    (row[table.autoIncrement] === undefined) ?
                        await squill
                            .selectValue(() => ExprLib.lastInsertRowId())
                            .fetchValue(nestedConnection) :
                        /**
                         * Emulate MySQL behaviour
                         */
                        tm.BigInt(0));
                return {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(result.rowsModified),
                    autoIncrementId: (autoIncrementId == undefined ?
                        undefined :
                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?
                            undefined :
                            autoIncrementId),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    async insertIgnoreMany(table, rows) {
        const sql = await sqlfier_1.insertManySqlString(this, "INSERT OR IGNORE", table, rows);
        return this.lock(async (rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertIgnoreMany() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified > rows.length) {
                    throw new Error(`insertIgnoreMany() should modify ${rows.length} rows or less; modified ${result.rowsModified} rows`);
                }
                return {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(result.rowsModified),
                    warningCount: tm.BigInt(rows.length - result.rowsModified),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    replaceOne(table, row) {
        const sql = sqlfier_1.insertOneSqlString("REPLACE", table, row);
        return this.lock((rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`replaceOne() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified != 1) {
                    throw new Error(`replaceOne() should modify one row`);
                }
                const autoIncrementId = ((table.autoIncrement == undefined) ?
                    undefined :
                    (row[table.autoIncrement] === undefined) ?
                        await squill
                            .selectValue(() => ExprLib.lastInsertRowId())
                            .fetchValue(nestedConnection) :
                        /**
                         * Emulate MySQL behaviour
                         */
                        tm.BigInt(0));
                return {
                    query: { sql, },
                    insertedOrReplacedRowCount: tm.BigInt(1),
                    autoIncrementId: (autoIncrementId == undefined ?
                        undefined :
                        tm.BigIntUtil.equal(autoIncrementId, tm.BigInt(0)) ?
                            undefined :
                            autoIncrementId),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    async replaceMany(table, rows) {
        const sql = await sqlfier_1.insertManySqlString(this, "REPLACE", table, rows);
        return this.exec(sql)
            .then(async (result) => {
            if (result.execResult.length != 0) {
                throw new Error(`replaceMany() should have no result set; found ${result.execResult.length}`);
            }
            if (result.rowsModified != rows.length) {
                throw new Error(`replaceMany() should modify ${rows.length} rows; modified ${result.rowsModified} rows`);
            }
            return {
                query: { sql, },
                insertedOrReplacedRowCount: tm.BigInt(result.rowsModified),
                warningCount: tm.BigInt(0),
                message: "ok",
            };
        })
            .catch((err) => {
            //console.error("error encountered", sql);
            throw err;
        });
    }
    async insertSelect(query, table, insertSelectRow) {
        const sql = await sqlfier_1.insertSelectSqlString(this, "INSERT", query, table, insertSelectRow);
        return this.lock(async (rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertSelect() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified < 0) {
                    throw new Error(`insertSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);
                }
                return {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(result.rowsModified),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    async insertIgnoreSelect(query, table, insertSelectRow) {
        const sql = await sqlfier_1.insertSelectSqlString(this, "INSERT OR IGNORE", query, table, insertSelectRow);
        return this.transactionIfNotInOne(async (rawNestedConnection) => {
            const nestedConnection = rawNestedConnection;
            const maxInsertCount = await squill.ExecutionUtil.count(query, nestedConnection);
            return nestedConnection.exec(sql)
                .then(async (result) => {
                if (result.execResult.length != 0) {
                    throw new Error(`insertIgnoreSelect() should have no result set; found ${result.execResult.length}`);
                }
                if (result.rowsModified < 0) {
                    throw new Error(`insertIgnoreSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);
                }
                return {
                    query: { sql, },
                    insertedRowCount: tm.BigInt(result.rowsModified),
                    warningCount: tm.BigIntUtil.sub(maxInsertCount, result.rowsModified),
                    message: "ok",
                };
            })
                .catch((err) => {
                //console.error("error encountered", sql);
                throw err;
            });
        });
    }
    async replaceSelect(query, table, insertSelectRow) {
        const sql = await sqlfier_1.insertSelectSqlString(this, "REPLACE", query, table, insertSelectRow);
        return this.exec(sql)
            .then(async (result) => {
            if (result.execResult.length != 0) {
                throw new Error(`replaceSelect() should have no result set; found ${result.execResult.length}`);
            }
            if (result.rowsModified < 0) {
                throw new Error(`replaceSelect() should modify zero, or more rows; modified ${result.rowsModified} rows`);
            }
            return {
                query: { sql, },
                insertedOrReplacedRowCount: tm.BigInt(result.rowsModified),
                warningCount: tm.BigInt(0),
                message: "ok",
            };
        })
            .catch((err) => {
            //console.error("error encountered", sql);
            throw err;
        });
    }
    update(table, whereClause, assignmentMap) {
        const sql = sqlfier_1.updateSqlString(table, whereClause, assignmentMap);
        if (sql == undefined) {
            return squill.from(table)
                .where(() => whereClause)
                .count(this)
                .then((count) => {
                return {
                    query: {
                        /**
                         * No `UPDATE` statement executed
                         */
                        sql: "",
                    },
                    foundRowCount: count,
                    updatedRowCount: tm.BigInt(0),
                    warningCount: tm.BigInt(0),
                    message: "ok",
                };
            });
        }
        return this.exec(sql)
            .then(async (result) => {
            if (result.execResult.length != 0) {
                throw new Error(`update() should have no result set; found ${result.execResult.length}`);
            }
            if (result.rowsModified < 0) {
                throw new Error(`update() should modify zero, or more rows; modified ${result.rowsModified} rows`);
            }
            return {
                query: { sql, },
                foundRowCount: tm.BigInt(result.rowsModified),
                updatedRowCount: tm.BigInt(result.rowsModified),
                warningCount: tm.BigInt(0),
                message: "ok",
            };
        })
            .catch((err) => {
            //console.error("error encountered", sql);
            throw err;
        });
    }
    delete(table, whereClause) {
        const sql = sqlfier_1.deleteSqlString(table, whereClause);
        return this.exec(sql)
            .then(async (result) => {
            if (result.execResult.length != 0) {
                throw new Error(`delete() should have no result set; found ${result.execResult.length}`);
            }
            if (result.rowsModified < 0) {
                throw new Error(`delete() should modify zero, or more rows; modified ${result.rowsModified} rows`);
            }
            return {
                query: { sql, },
                deletedRowCount: tm.BigInt(result.rowsModified),
                warningCount: tm.BigInt(0),
                message: "ok",
            };
        })
            .catch((err) => {
            //console.error("error encountered", sql);
            throw err;
        });
    }
    tryFetchSchemaMeta(schemaAlias) {
        return schema_introspection_1.tryFetchSchemaMeta(this, schemaAlias);
    }
    tryFetchGeneratedColumnExpression(schemaAlias, tableAlias, columnAlias) {
        return schema_introspection_1.tryFetchGeneratedColumnExpression(this, schemaAlias, tableAlias, columnAlias);
    }
    transaction(...args) {
        return this.lock(async (nestedConnection) => {
            return nestedConnection.transactionImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_WRITE, args.length == 1 ? args[0] : args[1]);
        });
    }
    readOnlyTransaction(...args) {
        return this.lock(async (nestedConnection) => {
            return nestedConnection.transactionImpl(args.length == 1 ? squill.IsolationLevel.SERIALIZABLE : args[0], squill.TransactionAccessMode.READ_ONLY, args.length == 1 ? args[0] : args[1]);
        });
    }
    isInTransaction() {
        return this.sharedConnectionInformation.transactionData != undefined;
    }
    savepointImpl(callback) {
        if (this.sharedConnectionInformation.transactionData == undefined) {
            return Promise.reject(new Error(`Cannot use savepoint outside transaction`));
        }
        if (this.savepointData != undefined) {
            return Promise.reject(new Error(`A savepoint is already in progress`));
        }
        const savepointData = {
            savepointName: `squill_savepoint_${++this.sharedConnectionInformation.savepointId}`,
        };
        this.savepointData = savepointData;
        this.eventEmitters.savepoint();
        return new Promise((resolve, reject) => {
            this.rawQuery(`SAVEPOINT ${savepointData.savepointName}`)
                .then(() => {
                if (!this.isInTransaction()) {
                    throw new Error(`Expected to be in transaction`);
                }
                if (this.savepointData != savepointData) {
                    /**
                     * Why did the savepoint information change?
                     */
                    throw new Error(`Expected to be in savepoint ${savepointData.savepointName}`);
                }
                return callback(this);
            })
                .then((result) => {
                if (!this.isInTransaction()) {
                    /**
                     * `.rollback()` was probably explicitly called
                     */
                    resolve(result);
                    return;
                }
                if (this.savepointData == undefined) {
                    /**
                     * `.rollbackToSavepoint()` was probably explicitly called
                     */
                    resolve(result);
                    return;
                }
                if (this.savepointData != savepointData) {
                    /**
                     * Some weird thing is going on here.
                     * This should never happen.
                     */
                    reject(new Error(`Expected to be in savepoint ${savepointData.savepointName} or to not be in a savepoint`));
                    return;
                }
                this.releaseSavepoint()
                    .then(() => {
                    resolve(result);
                })
                    .catch((_releaseErr) => {
                    /**
                     * Being unable to release a savepoint isn't so bad.
                     * It usually just means the DBMS cannot reclaim resources
                     * until the transaction ends.
                     *
                     * @todo Do something with `_releaseErr`
                     */
                    resolve(result);
                });
            })
                .catch((err) => {
                if (!this.isInTransaction()) {
                    /**
                     * `.rollback()` was probably explicitly called
                     */
                    reject(err);
                    return;
                }
                if (this.savepointData == undefined) {
                    /**
                     * `.rollbackToSavepoint()` was probably explicitly called
                     */
                    reject(err);
                    return;
                }
                if (this.savepointData != savepointData) {
                    /**
                     * Some weird thing is going on here.
                     * This should never happen.
                     */
                    err.savepointErr = new Error(`Expected to be in savepoint ${savepointData.savepointName} or to not be in a savepoint`);
                    reject(err);
                    return;
                }
                this.rollbackToSavepoint()
                    .then(() => {
                    reject(err);
                })
                    .catch((rollbackToSavepointErr) => {
                    err.rollbackToSavepointErr = rollbackToSavepointErr;
                    reject(err);
                });
            });
        });
    }
    rollbackToSavepoint() {
        if (this.savepointData == undefined) {
            return Promise.reject(new Error("Not in savepoint; cannot release savepoint"));
        }
        return this.rawQuery(`ROLLBACK TO SAVEPOINT ${this.savepointData.savepointName}`)
            .then(() => {
            this.savepointData = undefined;
            this.eventEmitters.rollbackToSavepoint();
        });
    }
    releaseSavepoint() {
        if (this.savepointData == undefined) {
            return Promise.reject(new Error("Not in savepoint; cannot release savepoint"));
        }
        return this.rawQuery(`RELEASE SAVEPOINT ${this.savepointData.savepointName}`)
            .then(() => {
            this.savepointData = undefined;
            this.eventEmitters.releaseSavepoint();
        });
    }
    savepoint(callback) {
        return this.lock(async (nestedConnection) => {
            return nestedConnection.savepointImpl(callback);
        });
    }
    deallocate() {
        //console.log("deallocating...");
        if (this.deallocatePromise == undefined) {
            this.deallocatePromise = this.asyncQueue.stop()
                .then(() => {
                //console.log("deallocated");
                /**
                 * @todo Handle sync errors somehow.
                 * Maybe propagate them to `IPool` and have an `onError` handler or something
                 */
                this.eventEmitters.commit();
            }, (err) => {
                //console.log("deallocated with error");
                /**
                 * @todo Handle sync errors somehow.
                 * Maybe propagate them to `IPool` and have an `onError` handler or something
                 */
                this.eventEmitters.commit();
                throw err;
            });
            return this.deallocatePromise;
        }
        return Promise.reject("This connection has already been deallocated");
    }
    isDeallocated() {
        return this.deallocatePromise != undefined;
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./dist/driver/execution/connection/index.js":
/*!***************************************************!*\
  !*** ./dist/driver/execution/connection/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection */ "./dist/driver/execution/connection/connection.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/execution/index.js":
/*!****************************************!*\
  !*** ./dist/driver/execution/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection */ "./dist/driver/execution/connection/index.js"));
__export(__webpack_require__(/*! ./pool */ "./dist/driver/execution/pool/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/bigint-polyfill.js":
/*!*******************************************************!*\
  !*** ./dist/driver/execution/pool/bigint-polyfill.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UnsignedDecimalStrUtil = __webpack_require__(/*! ./unsigned-decimal-str-util */ "./dist/driver/execution/pool/unsigned-decimal-str-util.js");
const SignedDecimalStrUtil = __webpack_require__(/*! ./signed-decimal-str-util */ "./dist/driver/execution/pool/signed-decimal-str-util.js");
const BigIntUtil = __webpack_require__(/*! ./bigint-util */ "./dist/driver/execution/pool/bigint-util.js");
const { unsignedDigitArrayAdd, unsignedDigitArraySubtract, unsignedDecimalStrAdd, unsignedDecimalStrSubtract, unsignedDecimalStrMultiply, unsignedDigitArrayGreaterThanOrEqual, unsignedDigitArrayLessThanOrEqual, unsignedDecimalStrDivide, } = UnsignedDecimalStrUtil;
const { signedDecimalStrLessThanOrEqual, signedDecimalStrGreaterThanOrEqual, signedDecimalStrUnaryMinus, signedDecimalStrAdd, signedDecimalStrSubtract, signedDecimalStrMultiply, signedDecimalStrDivide, } = SignedDecimalStrUtil;
const { isSafeBigIntSigned, assertSafeBigIntSigned, bigIntAdd, bigIntSubtract, bigIntUnaryMinus, bigIntMultiply, bigIntDivide, } = BigIntUtil;
async function initBigIntPolyfill(connection) {
    await connection.createGlobalJsFunction("unsignedDigitArrayAdd", unsignedDigitArrayAdd);
    await connection.createGlobalJsFunction("unsignedDigitArraySubtract", unsignedDigitArraySubtract);
    await connection.createGlobalJsFunction("unsignedDecimalStrAdd", unsignedDecimalStrAdd);
    await connection.createGlobalJsFunction("unsignedDecimalStrSubtract", unsignedDecimalStrSubtract);
    await connection.createGlobalJsFunction("unsignedDecimalStrMultiply", unsignedDecimalStrMultiply);
    await connection.createGlobalJsFunction("unsignedDigitArrayGreaterThanOrEqual", unsignedDigitArrayGreaterThanOrEqual);
    await connection.createGlobalJsFunction("unsignedDigitArrayLessThanOrEqual", unsignedDigitArrayLessThanOrEqual);
    await connection.createGlobalJsFunction("unsignedDecimalStrDivide", unsignedDecimalStrDivide);
    await connection.createGlobalJsFunction("signedDecimalStrLessThanOrEqual", signedDecimalStrLessThanOrEqual);
    await connection.createGlobalJsFunction("signedDecimalStrGreaterThanOrEqual", signedDecimalStrGreaterThanOrEqual);
    await connection.createGlobalJsFunction("signedDecimalStrUnaryMinus", signedDecimalStrUnaryMinus);
    await connection.createGlobalJsFunction("signedDecimalStrAdd", signedDecimalStrAdd);
    await connection.createGlobalJsFunction("signedDecimalStrSubtract", signedDecimalStrSubtract);
    await connection.createGlobalJsFunction("signedDecimalStrMultiply", signedDecimalStrMultiply);
    await connection.createGlobalJsFunction("signedDecimalStrDivide", signedDecimalStrDivide);
    await connection.createGlobalJsFunction("isSafeBigIntSigned", isSafeBigIntSigned);
    await connection.createGlobalJsFunction("assertSafeBigIntSigned", assertSafeBigIntSigned);
    await connection.createGlobalJsFunction("bigIntAdd", bigIntAdd);
    await connection.createGlobalJsFunction("bigIntSubtract", bigIntSubtract);
    await connection.createGlobalJsFunction("bigIntUnaryMinus", bigIntUnaryMinus);
    await connection.createGlobalJsFunction("bigIntMultiply", bigIntMultiply);
    await connection.createGlobalJsFunction("bigIntDivide", bigIntDivide);
    await connection.createFunction("bigint_add", { isVarArg: true, isDeterministic: true }, (...arr) => {
        if (arr.length == 0) {
            return BigInt(0);
        }
        if (arr.length == 1) {
            const a = arr[0];
            if (isBigInt(a)) {
                return a;
            }
            else {
                throw new Error(`Cannot add non-bigint`);
            }
        }
        const [a, b, ...rest] = arr;
        if (!isBigInt(a) || !isBigInt(b)) {
            throw new Error(`Cannot add non-bigint`);
        }
        const sum = bigIntAdd(a, b);
        return rest.reduce((result, x) => {
            if (!isBigInt(x)) {
                throw new Error(`Cannot add non-bigint`);
            }
            return bigIntAdd(result, x);
        }, sum);
    });
    await connection.createFunction("bigint_sub", { isVarArg: false, isDeterministic: true }, (a, b) => {
        if (!isBigInt(a) || !isBigInt(b)) {
            throw new Error(`Cannot subtract non-bigint`);
        }
        return bigIntSubtract(a, b);
    });
    await connection.createFunction("bigint_mul", { isVarArg: true, isDeterministic: true }, (...arr) => {
        if (arr.length == 0) {
            return BigInt(1);
        }
        if (arr.length == 1) {
            const a = arr[0];
            if (isBigInt(a)) {
                return a;
            }
            else {
                throw new Error(`Cannot multiply non-bigint`);
            }
        }
        const [a, b, ...rest] = arr;
        if (!isBigInt(a) || !isBigInt(b)) {
            throw new Error(`Cannot multiply non-bigint`);
        }
        const product = bigIntMultiply(a, b);
        return rest.reduce((result, x) => {
            if (!isBigInt(x)) {
                throw new Error(`Cannot multiply non-bigint`);
            }
            return bigIntMultiply(result, x);
        }, product);
    });
    await connection.createFunction("bigint_neg", { isVarArg: false, isDeterministic: true }, (a) => {
        if (!isBigInt(a)) {
            throw new Error(`Cannot unary minus non-bigint`);
        }
        return bigIntUnaryMinus(a);
    });
    await connection.createFunction("bigint_div", { isVarArg: false, isDeterministic: true }, (a, b) => {
        if (!isBigInt(a) || !isBigInt(b)) {
            throw new Error(`Cannot divide non-bigint ${typeof a}/${typeof b}`);
        }
        return bigIntDivide(a, b);
    });
}
exports.initBigIntPolyfill = initBigIntPolyfill;
//# sourceMappingURL=bigint-polyfill.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/bigint-util.js":
/*!***************************************************!*\
  !*** ./dist/driver/execution/pool/bigint-util.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SignedDecimalStrUtil = __webpack_require__(/*! ./signed-decimal-str-util */ "./dist/driver/execution/pool/signed-decimal-str-util.js");
const { signedDecimalStrLessThanOrEqual, signedDecimalStrGreaterThanOrEqual, signedDecimalStrAdd, signedDecimalStrSubtract, signedDecimalStrMultiply, signedDecimalStrDivide, } = SignedDecimalStrUtil;
function isSafeBigIntSigned(x) {
    const MAX_SAFE_BIGINT_SIGNED = "9223372036854775807";
    const MIN_SAFE_BIGINT_SIGNED = "-9223372036854775808";
    if (typeof x == "bigint") {
        return (x <= BigInt(MAX_SAFE_BIGINT_SIGNED) &&
            x >= BigInt(MIN_SAFE_BIGINT_SIGNED));
    }
    return (signedDecimalStrLessThanOrEqual(x, MAX_SAFE_BIGINT_SIGNED) &&
        signedDecimalStrGreaterThanOrEqual(x, MIN_SAFE_BIGINT_SIGNED));
}
exports.isSafeBigIntSigned = isSafeBigIntSigned;
function assertSafeBigIntSigned(x) {
    if (!isSafeBigIntSigned(x)) {
        throw new RangeError(`BIGINT SIGNED overflow`);
    }
}
exports.assertSafeBigIntSigned = assertSafeBigIntSigned;
function bigIntAdd(a, b) {
    if (typeof a == "bigint" && typeof b == "bigint") {
        const result = a + b;
        assertSafeBigIntSigned(result);
        return result;
    }
    const result = signedDecimalStrAdd(a.toString(), b.toString());
    assertSafeBigIntSigned(result);
    return BigInt(result);
}
exports.bigIntAdd = bigIntAdd;
function bigIntSubtract(a, b) {
    if (typeof a == "bigint" && typeof b == "bigint") {
        const result = a - b;
        assertSafeBigIntSigned(result);
        return result;
    }
    const result = signedDecimalStrSubtract(a.toString(), b.toString());
    assertSafeBigIntSigned(result);
    return BigInt(result);
}
exports.bigIntSubtract = bigIntSubtract;
function bigIntUnaryMinus(a) {
    if (typeof a == "bigint") {
        const result = -a;
        assertSafeBigIntSigned(result);
        return result;
    }
    const str = String(a);
    if (str == "0") {
        return BigInt("0");
    }
    const result = (str[0] == "-" ?
        str.substr(1) :
        "-" + str);
    assertSafeBigIntSigned(result);
    return BigInt(result);
}
exports.bigIntUnaryMinus = bigIntUnaryMinus;
function bigIntMultiply(a, b) {
    if (typeof a == "bigint" && typeof b == "bigint") {
        const result = a * b;
        assertSafeBigIntSigned(result);
        return result;
    }
    const result = signedDecimalStrMultiply(a.toString(), b.toString());
    assertSafeBigIntSigned(result);
    return BigInt(result);
}
exports.bigIntMultiply = bigIntMultiply;
function bigIntDivide(a, b) {
    if (typeof a == "bigint" && typeof b == "bigint") {
        if (b == BigInt(0)) {
            throw new Error(`DivideByZeroError: Cannot divide by zero`);
        }
        const result = a / b;
        assertSafeBigIntSigned(result);
        return result;
    }
    const result = signedDecimalStrDivide(a.toString(), b.toString());
    assertSafeBigIntSigned(result);
    return BigInt(result);
}
exports.bigIntDivide = bigIntDivide;
//# sourceMappingURL=bigint-util.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/decimal-polyfill.js":
/*!********************************************************!*\
  !*** ./dist/driver/execution/pool/decimal-polyfill.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FixedPointUtil = __webpack_require__(/*! ./fixed-point-util */ "./dist/driver/execution/pool/fixed-point-util.js");
const FloatingPointUtil = __webpack_require__(/*! ./floating-point-util */ "./dist/driver/execution/pool/floating-point-util.js");
const { tryParseFixedPoint } = FixedPointUtil;
const { tryParseFloatingPoint, floatingPointToIntegerAndExponent } = FloatingPointUtil;
async function initDecimalPolyfill(connection) {
    await connection.createGlobalJsFunction("tryParseFloatingPoint", tryParseFloatingPoint);
    await connection.createGlobalJsFunction("floatingPointToIntegerAndExponent", floatingPointToIntegerAndExponent);
    await connection.createGlobalJsFunction("tryParseFixedPoint", tryParseFixedPoint);
    await connection.createFunction("decimal_ctor", { isVarArg: false, isDeterministic: true }, (x, precision, scale) => {
        if (!isBigInt(precision) ||
            !isBigInt(scale)) {
            throw new Error(`Precision and scale must be bigint`);
        }
        const maxPrecision = Number(precision);
        const maxScale = Number(scale);
        if (maxPrecision < 1) {
            throw new Error(`Precision cannot be less than 1`);
        }
        if (maxScale < 0) {
            throw new Error(`Scale cannot be less than 0`);
        }
        if (maxScale > maxPrecision) {
            throw new Error(`Scale cannot be greater than precision`);
        }
        if (!isBigInt(x) &&
            typeof x != "number" &&
            typeof x != "string") {
            throw new Error(`Cannot cast ${typeof x} to DECIMAL(${precision}, ${scale})`);
        }
        const str = String(x);
        const parsed = tryParseFixedPoint(str);
        if (parsed == undefined) {
            throw new Error(`Could not cast to DECIMAL(${precision}, ${scale}); invalid fixed point format`);
        }
        const curScale = (parsed.getFixedPointFractionalPartString() == "0" ?
            0 :
            parsed.getFixedPointFractionalPartString().length);
        const curPrecision = (curScale +
            (parsed.getFixedPointIntegerPartString() == "0" ?
                0 :
                parsed.getFixedPointIntegerPartString().length));
        if (curPrecision > maxPrecision) {
            throw new Error(`DECIMAL(${precision}, ${scale}) precision pverflow`);
        }
        if (curScale > maxScale) {
            throw new Error(`DECIMAL(${precision}, ${scale}) scale pverflow`);
        }
        return parsed.getFixedPointString();
    });
}
exports.initDecimalPolyfill = initDecimalPolyfill;
//# sourceMappingURL=decimal-polyfill.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/fixed-point-util.js":
/*!********************************************************!*\
  !*** ./dist/driver/execution/pool/fixed-point-util.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FloatingPointUtil = __webpack_require__(/*! ./floating-point-util */ "./dist/driver/execution/pool/floating-point-util.js");
const { tryParseFloatingPoint, floatingPointToIntegerAndExponent } = FloatingPointUtil;
/**
 * @todo Make `getXxx()` functions cache results
 */
function tryParseFixedPoint(str) {
    const parsed = tryParseFloatingPoint(str);
    if (parsed == undefined) {
        return undefined;
    }
    const { isNegative, integerPart, isZero, exponentValue, } = floatingPointToIntegerAndExponent(parsed);
    function lazyInit(initDelegate) {
        let initialized = false;
        let value = undefined;
        return () => {
            if (!initialized) {
                value = initDelegate();
                initialized = true;
            }
            return value;
        };
    }
    if (isZero) {
        const fixedPointIntegerPartLength = 1;
        const fixedPointFractionalPartLength = 1;
        const fixedPointLength = ((isNegative ? 1 : 0) +
            fixedPointIntegerPartLength +
            1 +
            fixedPointFractionalPartLength);
        const getFixedPointIntegerPartString = () => "0";
        const getFixedPointFractionalPartString = () => "0";
        const getFixedPointString = lazyInit(() => {
            const sign = isNegative ? "-" : "";
            return (sign +
                getFixedPointIntegerPartString() +
                "." +
                getFixedPointFractionalPartString());
        });
        return {
            isInteger: true,
            isNegative,
            isZero,
            fixedPointIntegerPartLength,
            fixedPointFractionalPartLength,
            fixedPointLength,
            getFixedPointIntegerPartString,
            getFixedPointFractionalPartString,
            getFixedPointString,
        };
    }
    if (exponentValue >= 0) {
        const fixedPointIntegerPartLength = integerPart.length + exponentValue;
        const fixedPointFractionalPartLength = 1;
        const fixedPointLength = ((isNegative ? 1 : 0) +
            fixedPointIntegerPartLength +
            1 +
            fixedPointFractionalPartLength);
        const getFixedPointIntegerPartString = lazyInit(() => (integerPart + "0".repeat(exponentValue)));
        const getFixedPointFractionalPartString = () => "0";
        const getFixedPointString = lazyInit(() => {
            const sign = isNegative ? "-" : "";
            return (sign +
                getFixedPointIntegerPartString() +
                "." +
                getFixedPointFractionalPartString());
        });
        return {
            isInteger: true,
            isNegative,
            isZero,
            fixedPointIntegerPartLength,
            fixedPointFractionalPartLength,
            fixedPointLength,
            getFixedPointIntegerPartString,
            getFixedPointFractionalPartString,
            getFixedPointString,
        };
    }
    else {
        const fractionalOffset = -exponentValue;
        if (fractionalOffset < integerPart.length) {
            const newIntegerPart = integerPart.substring(0, integerPart.length - fractionalOffset);
            let newFractionalPart = integerPart.substring(integerPart.length - fractionalOffset, integerPart.length).replace(/(0+)$/, "");
            if (newFractionalPart == "") {
                newFractionalPart = "0";
            }
            const fixedPointIntegerPartLength = newIntegerPart.length;
            const fixedPointFractionalPartLength = newFractionalPart.length;
            const fixedPointLength = ((isNegative ? 1 : 0) +
                fixedPointIntegerPartLength +
                1 +
                fixedPointFractionalPartLength);
            const getFixedPointIntegerPartString = () => newIntegerPart;
            const getFixedPointFractionalPartString = () => newFractionalPart;
            const getFixedPointString = lazyInit(() => {
                const sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString() +
                    "." +
                    getFixedPointFractionalPartString());
            });
            return {
                isInteger: (newFractionalPart == "0"),
                isNegative,
                isZero,
                fixedPointIntegerPartLength,
                fixedPointFractionalPartLength,
                fixedPointLength,
                getFixedPointIntegerPartString,
                getFixedPointFractionalPartString,
                getFixedPointString,
            };
        }
        else if (fractionalOffset == integerPart.length) {
            let newFractionalPart = integerPart.replace(/(0+)$/, "");
            if (newFractionalPart == "") {
                newFractionalPart = "0";
            }
            const fixedPointIntegerPartLength = 1;
            const fixedPointFractionalPartLength = newFractionalPart.length;
            const fixedPointLength = ((isNegative ? 1 : 0) +
                fixedPointIntegerPartLength +
                1 +
                fixedPointFractionalPartLength);
            const getFixedPointIntegerPartString = () => ("0");
            const getFixedPointFractionalPartString = () => newFractionalPart;
            const getFixedPointString = lazyInit(() => {
                const sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString() +
                    "." +
                    getFixedPointFractionalPartString());
            });
            return {
                isInteger: (newFractionalPart == "0"),
                isNegative,
                isZero,
                fixedPointIntegerPartLength,
                fixedPointFractionalPartLength,
                fixedPointLength,
                getFixedPointIntegerPartString,
                getFixedPointFractionalPartString,
                getFixedPointString,
            };
        }
        else {
            let leadingZeroCount = fractionalOffset - integerPart.length;
            let newFractionalPart = integerPart.replace(/(0+)$/, "");
            if (newFractionalPart == "") {
                leadingZeroCount = 0;
                newFractionalPart = "0";
            }
            const fixedPointIntegerPartLength = 1;
            const fixedPointFractionalPartLength = leadingZeroCount + newFractionalPart.length;
            const fixedPointLength = ((isNegative ? 1 : 0) +
                fixedPointIntegerPartLength +
                1 +
                fixedPointFractionalPartLength);
            const getFixedPointIntegerPartString = () => ("0");
            const getFixedPointFractionalPartString = lazyInit(() => ("0".repeat(leadingZeroCount) +
                newFractionalPart));
            const getFixedPointString = lazyInit(() => {
                const sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString() +
                    "." +
                    getFixedPointFractionalPartString());
            });
            return {
                isInteger: (newFractionalPart == "0"),
                isNegative,
                isZero,
                fixedPointIntegerPartLength,
                fixedPointFractionalPartLength,
                fixedPointLength,
                getFixedPointIntegerPartString,
                getFixedPointFractionalPartString,
                getFixedPointString,
            };
        }
    }
}
exports.tryParseFixedPoint = tryParseFixedPoint;
//# sourceMappingURL=fixed-point-util.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/floating-point-util.js":
/*!***********************************************************!*\
  !*** ./dist/driver/execution/pool/floating-point-util.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryParseFloatingPoint(str) {
    const floatingPointRegex = /^([-+])?([0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)([eE]([-+])?([0-9]+))?$/;
    const m = floatingPointRegex.exec(str);
    if (m == undefined) {
        return undefined;
    }
    //-123.456e+789
    //~
    const rawCoefficientSign = m[1];
    //-123.456e+789
    // ~~~~~~~
    const rawCoefficientValue = m[2];
    //-123.456e+789
    //         ~
    const rawExponentSign = m[4];
    //-123.456e+789
    //          ~~~
    const rawExponentValue = m[5];
    const rawDecimalPlaceIndex = rawCoefficientValue.indexOf(".");
    const rawIntegerPart = (rawDecimalPlaceIndex < 0 ?
        rawCoefficientValue :
        rawCoefficientValue.substring(0, rawDecimalPlaceIndex));
    const rawFractionalPart = (rawDecimalPlaceIndex < 0 ?
        "" :
        rawCoefficientValue.substring(rawDecimalPlaceIndex + 1, rawCoefficientValue.length));
    const trimmedIntegerPart = rawIntegerPart.replace(/^(0+)/, "");
    const integerPart = (trimmedIntegerPart == "" ?
        "0" :
        trimmedIntegerPart);
    const trimmedFractionalPart = rawFractionalPart.replace(/(0+)$/, "");
    const fractionalPart = (trimmedFractionalPart == "" ?
        "0" :
        trimmedFractionalPart);
    const isZero = (integerPart == "0" && fractionalPart == "0");
    function safeCastToNumber(str) {
        const result = Number(str);
        if (result.toString() != str) {
            throw new Error(`Cannot cast exponent to number`);
        }
        return result;
    }
    const exponentValue = (isZero ?
        0 :
        rawExponentValue == undefined ?
            0 :
            rawExponentSign === "-" ?
                -safeCastToNumber(rawExponentValue) :
                safeCastToNumber(rawExponentValue));
    return {
        isNegative: (rawCoefficientSign === "-"),
        integerPart,
        fractionalPart,
        isZero,
        exponentValue,
    };
}
exports.tryParseFloatingPoint = tryParseFloatingPoint;
/**
 * Converts the fractional part to an integer part,
 * by lowering the exponent
 */
function floatingPointToIntegerAndExponent(arg) {
    if (arg.fractionalPart == "0") {
        return arg;
    }
    const exponentValue = (arg.exponentValue -
        arg.fractionalPart.length);
    const integerPart = (arg.integerPart == "0" ?
        arg.fractionalPart.replace(/^(0+)/, "") :
        arg.integerPart + arg.fractionalPart);
    return {
        isNegative: arg.isNegative,
        integerPart,
        fractionalPart: "0",
        isZero: arg.isZero,
        exponentValue,
    };
}
exports.floatingPointToIntegerAndExponent = floatingPointToIntegerAndExponent;
//# sourceMappingURL=floating-point-util.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/index.js":
/*!*********************************************!*\
  !*** ./dist/driver/execution/pool/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./pool */ "./dist/driver/execution/pool/pool.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/polyfill.js":
/*!************************************************!*\
  !*** ./dist/driver/execution/pool/polyfill.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_polyfill_1 = __webpack_require__(/*! ./decimal-polyfill */ "./dist/driver/execution/pool/decimal-polyfill.js");
const bigint_polyfill_1 = __webpack_require__(/*! ./bigint-polyfill */ "./dist/driver/execution/pool/bigint-polyfill.js");
async function initPolyfill(connection) {
    await decimal_polyfill_1.initDecimalPolyfill(connection);
    await bigint_polyfill_1.initBigIntPolyfill(connection);
    await connection.createFunction("ASCII", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "string") {
            if (x == "") {
                return 0;
            }
            return x.charCodeAt(0);
        }
        else {
            throw new Error(`ASCII only implemented for string`);
        }
    });
    await connection.createFunction("BIN", { isVarArg: false, isDeterministic: true }, (x) => {
        if (isBigInt(x)) {
            const str = x.toString();
            if (str[0] == "-") {
                return binaryStrSetWidth(signedDecimalStrToBinaryStr(str), 64);
            }
            else {
                //substr to remove leading 0
                return signedDecimalStrToBinaryStr(str).substr(1);
            }
            /*
            if (tm.BigIntUtil.greaterThanOrEqual(x, 0)) {
                return tm.BigIntUtil.toString(
                    x,
                    2
                );
            } else {
                return tm.BigIntUtil.toString(
                    tm.BigIntUtil.add(
                        tm.BigIntUtil.leftShift(tm.BigInt(1), 64),
                        x
                    ),
                    2
                );
            }
            */
        }
        else {
            throw new Error(`BIN only implemented for bigint`);
        }
    });
    await connection.createFunction("CONCAT_WS", { isVarArg: true, isDeterministic: true }, (separator, ...args) => {
        if (typeof separator == "string") {
            return args.filter(arg => arg !== null).join(separator);
        }
        else {
            throw new Error(`CONCAT_WS only implemented for string`);
        }
    });
    await connection.createFunction("FROM_BASE64", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "string") {
            const result = new Uint8Array(atob(x).split("").filter(s => s != "").map(s => s.charCodeAt(0)));
            return result;
        }
        else {
            throw new Error(`FROM_BASE64 only implemented for string`);
        }
    });
    await connection.createFunction("LPAD", { isVarArg: false, isDeterministic: true }, (str, len, pad) => {
        if (typeof str == "string" &&
            isBigInt(len) &&
            typeof pad == "string") {
            if (str.length > Number(len)) {
                return str.substr(0, Number(len));
            }
            else if (str.length == Number(len)) {
                return str;
            }
            else {
                return str.padStart(Number(len), pad);
            }
        }
        else {
            throw new Error(`LPAD only implemented for (string, bigint, string)`);
        }
    });
    await connection.createFunction("RPAD", { isVarArg: false, isDeterministic: true }, (str, len, pad) => {
        if (typeof str == "string" &&
            isBigInt(len) &&
            typeof pad == "string") {
            if (str.length > Number(len)) {
                return str.substr(0, Number(len));
            }
            else if (str.length == Number(len)) {
                return str;
            }
            else {
                return str.padEnd(Number(len), pad);
            }
        }
        else {
            throw new Error(`RPAD only implemented for (string, bigint, string)`);
        }
    });
    await connection.createFunction("REPEAT", { isVarArg: false, isDeterministic: true }, (str, count) => {
        if (typeof str == "string" &&
            isBigInt(count)) {
            if (Number(count) < 0) {
                return "";
            }
            return str.repeat(Number(count));
        }
        else {
            throw new Error(`REPEAT only implemented for (string, bigint)`);
        }
    });
    await connection.createFunction("REVERSE", { isVarArg: false, isDeterministic: true }, (str) => {
        if (typeof str == "string") {
            return [...str].reverse().join("");
        }
        else {
            throw new Error(`REVERSE only implemented for (string)`);
        }
    });
    await connection.createFunction("TO_BASE64", { isVarArg: false, isDeterministic: true }, (blob) => {
        if (blob instanceof Uint8Array) {
            return btoa([...blob].map(n => String.fromCharCode(n)).join(""));
        }
        else {
            throw new Error(`TO_BASE64 only implemented for (Uint8Array)`);
        }
    });
    await connection.createFunction("UNHEX", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "string") {
            const matches = x.match(/.{2}/g);
            if (matches == undefined) {
                throw new Error(`Invalid Hex string`);
            }
            const result = new Uint8Array(matches.map(str => parseInt(str, 16)));
            const hexResult = [...result].map((n) => ("00" + n.toString(16)).slice(-2)).join("");
            if (x.toUpperCase() == hexResult.toUpperCase()) {
                return result;
            }
            else {
                throw new Error(`Invalid Hex string`);
            }
        }
        else {
            throw new Error(`UNHEX only implemented for string`);
        }
    });
    await connection.createFunction("FLOOR", { isVarArg: false, isDeterministic: true }, (x) => {
        if (isBigInt(x)) {
            return x;
        }
        else if (typeof x == "number") {
            return Math.floor(x);
        }
        else if (x === null) {
            return null;
        }
        else {
            throw new Error(`Can only FLOOR bigint, double or null; received ${typeof x}`);
        }
    });
    await connection.createFunction("CEILING", { isVarArg: false, isDeterministic: true }, (x) => {
        if (isBigInt(x)) {
            return x;
        }
        else if (typeof x == "number") {
            return Math.ceil(x);
        }
        else if (x === null) {
            return null;
        }
        else {
            throw new Error(`Can only CEILING bigint, double or null; received ${typeof x}`);
        }
    });
    await connection.createFunction("CBRT", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "number") {
            return Math.cbrt(x);
        }
        else {
            throw new Error(`CBRT(${typeof x}) not implmented`);
        }
    });
    await connection.createFunction("COT", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "number") {
            const divisor = Math.cos(x);
            const dividend = Math.sin(x);
            if (dividend == 0) {
                return null;
            }
            else {
                return divisor / dividend;
            }
        }
        else {
            throw new Error(`COT(${typeof x}) not implmented`);
        }
    });
    await connection.createFunction("LN", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "number") {
            if (x == 0) {
                return null;
            }
            const result = Math.log(x);
            return result;
        }
        else {
            throw new Error(`LN(${typeof x}) not implmented`);
        }
    });
    await connection.createFunction("LOG", { isVarArg: false, isDeterministic: true }, (x, y) => {
        if (typeof x == "number" && typeof y == "number") {
            if (x <= 0 || x == 1) {
                return null;
            }
            if (y == 0) {
                return null;
            }
            return Math.log(y) / Math.log(x);
        }
        else {
            throw new Error(`LOG(${typeof x}, ${typeof y}) not implmented`);
        }
    });
    await connection.createFunction("LOG2", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "number") {
            if (x == 0) {
                return null;
            }
            const result = Math.log2(x);
            return result;
        }
        else {
            throw new Error(`LOG2(${typeof x}) not implmented`);
        }
    });
    await connection.createFunction("LOG10", { isVarArg: false, isDeterministic: true }, (x) => {
        if (typeof x == "number") {
            if (x == 0) {
                return null;
            }
            const result = Math.log10(x);
            return result;
        }
        else {
            throw new Error(`LOG10(${typeof x}) not implmented`);
        }
    });
    await connection.createFunction("FRANDOM", { isVarArg: false, isDeterministic: false }, () => {
        return Math.random();
    });
    await connection.createAggregate("STDDEV_POP", () => {
        return {
            values: [],
        };
    }, (state, x) => {
        if (x === null) {
            return;
        }
        if (typeof x == "number") {
            state.values.push(x);
        }
        else {
            throw new Error(`STDDEV_POP(${typeof x}) not implmented`);
        }
    }, (state) => {
        if (state == undefined) {
            return null;
        }
        if (state.values.length == 0) {
            return null;
        }
        const sum = state.values.reduce((sum, value) => sum + value, 0);
        const count = state.values.length;
        const avg = sum / count;
        const squaredErrors = state.values.map(value => {
            return Math.pow(value - avg, 2);
        });
        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);
        return Math.sqrt(sumSquaredErrors / count);
    });
    await connection.createAggregate("STDDEV_SAMP", () => {
        return {
            values: [],
        };
    }, (state, x) => {
        if (x === null) {
            return;
        }
        if (typeof x == "number") {
            state.values.push(x);
        }
        else {
            throw new Error(`STDDEV_SAMP(${typeof x}) not implmented`);
        }
    }, (state) => {
        if (state == undefined) {
            return null;
        }
        if (state.values.length == 0) {
            return null;
        }
        if (state.values.length == 1) {
            return null;
        }
        const sum = state.values.reduce((sum, value) => sum + value, 0);
        const count = state.values.length;
        const avg = sum / count;
        const squaredErrors = state.values.map(value => {
            return Math.pow(value - avg, 2);
        });
        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);
        return Math.sqrt(sumSquaredErrors / (count - 1));
    });
    await connection.createAggregate("VAR_POP", () => {
        return {
            values: [],
        };
    }, (state, x) => {
        if (x === null) {
            return;
        }
        if (typeof x == "number") {
            state.values.push(x);
        }
        else {
            throw new Error(`VAR_POP(${typeof x}) not implmented`);
        }
    }, (state) => {
        if (state == undefined) {
            return null;
        }
        if (state.values.length == 0) {
            return null;
        }
        const sum = state.values.reduce((sum, value) => sum + value, 0);
        const count = state.values.length;
        const avg = sum / count;
        const squaredErrors = state.values.map(value => {
            return Math.pow(value - avg, 2);
        });
        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);
        return sumSquaredErrors / count;
    });
    await connection.createAggregate("VAR_SAMP", () => {
        return {
            values: [],
        };
    }, (state, x) => {
        if (x === null) {
            return;
        }
        if (typeof x == "number") {
            state.values.push(x);
        }
        else {
            throw new Error(`VAR_SAMP(${typeof x}) not implmented`);
        }
    }, (state) => {
        if (state == undefined) {
            return null;
        }
        if (state.values.length == 0) {
            return null;
        }
        if (state.values.length == 1) {
            return null;
        }
        const sum = state.values.reduce((sum, value) => sum + value, 0);
        const count = state.values.length;
        const avg = sum / count;
        const squaredErrors = state.values.map(value => {
            return Math.pow(value - avg, 2);
        });
        const sumSquaredErrors = squaredErrors.reduce((sumSquaredErrors, squaredError) => sumSquaredErrors + squaredError, 0);
        return sumSquaredErrors / (count - 1);
    });
}
exports.initPolyfill = initPolyfill;
//# sourceMappingURL=polyfill.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/pool.js":
/*!********************************************!*\
  !*** ./dist/driver/execution/pool/pool.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const worker_1 = __webpack_require__(/*! ../../worker */ "./dist/driver/worker.js");
const connection_1 = __webpack_require__(/*! ../connection */ "./dist/driver/execution/connection/index.js");
const polyfill_1 = __webpack_require__(/*! ./polyfill */ "./dist/driver/execution/pool/polyfill.js");
class Pool {
    constructor(worker) {
        this.sharedConnectionInfo = {
            transactionData: undefined,
            savepointId: 0,
        };
        this.onInsert = new squill.PoolEventEmitter();
        this.onInsertOne = new squill.PoolEventEmitter();
        this.onInsertAndFetch = new squill.PoolEventEmitter();
        this.onInsertSelect = new squill.PoolEventEmitter();
        this.onReplace = new squill.PoolEventEmitter();
        this.onReplaceOne = new squill.PoolEventEmitter();
        this.onReplaceSelect = new squill.PoolEventEmitter();
        this.onUpdate = new squill.PoolEventEmitter();
        this.onUpdateAndFetch = new squill.PoolEventEmitter();
        this.onDelete = new squill.PoolEventEmitter();
        this.worker = worker;
        this.idAllocator = new connection_1.IdAllocator();
        this.asyncQueue = new squill.AsyncQueue(() => {
            const connection = new connection_1.Connection({
                pool: this,
                eventEmitters: new squill.ConnectionEventEmitterCollection(this),
                worker: this.worker,
                idAllocator: this.idAllocator,
                sharedConnectionInformation: this.sharedConnectionInfo,
            });
            return {
                item: connection,
                deallocate: () => {
                    return connection.deallocate();
                },
            };
        });
        this.acquire = this.asyncQueue.enqueue;
        this.acquire(async (connection) => {
            await polyfill_1.initPolyfill(connection);
        }).then(() => { }, (err) => {
            //console.error("Error creating functions", err);
            //process.exit(1);
            throw err;
        });
    }
    acquireTransaction(...args) {
        return this.acquire((connection) => {
            /**
             * TS has weird narrowing behaviours
             */
            if (args.length == 1) {
                return connection.transaction(...args);
            }
            else {
                return connection.transaction(...args);
            }
        });
    }
    acquireReadOnlyTransaction(...args) {
        return this.acquire((connection) => {
            /**
             * TS has weird narrowing behaviours
             */
            if (args.length == 1) {
                return connection.readOnlyTransaction(...args);
            }
            else {
                return connection.readOnlyTransaction(...args);
            }
        });
    }
    disconnect() {
        return this.asyncQueue.stop()
            .then(() => this.worker.postMessage({
            id: this.idAllocator.allocateId(),
            action: worker_1.SqliteAction.CLOSE,
        }), () => this.worker.postMessage({
            id: this.idAllocator.allocateId(),
            action: worker_1.SqliteAction.CLOSE,
        }));
    }
    isDeallocated() {
        return this.asyncQueue.getShouldStop();
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/signed-decimal-str-util.js":
/*!***************************************************************!*\
  !*** ./dist/driver/execution/pool/signed-decimal-str-util.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UnsignedDecimalStrUtil = __webpack_require__(/*! ./unsigned-decimal-str-util */ "./dist/driver/execution/pool/unsigned-decimal-str-util.js");
const { unsignedDecimalStrAdd, unsignedDecimalStrSubtract, unsignedDecimalStrMultiply, unsignedDecimalStrDivide, } = UnsignedDecimalStrUtil;
/**
 *
 * @param {string} decimalStr
 */
function signedDecimalStrIsPositive(decimalStr) {
    return decimalStr[0] != "-";
}
exports.signedDecimalStrIsPositive = signedDecimalStrIsPositive;
/**
 *
 * @param {string} a
 * @param {string} b
 */
function signedDecimalStrGreaterThanOrEqual(a, b) {
    if (signedDecimalStrIsPositive(a)) {
        if (signedDecimalStrIsPositive(b)) {
            if (a.length > b.length) {
                return true;
            }
            if (a.length < b.length) {
                return false;
            }
            for (let i = 0; i < a.length; ++i) {
                if (Number(a[i]) > Number(b[i])) {
                    return true;
                }
                if (Number(a[i]) < Number(b[i])) {
                    return false;
                }
            }
            return true;
        }
        else {
            //a > b
            return true;
        }
    }
    else {
        if (signedDecimalStrIsPositive(b)) {
            //a < b
            return false;
        }
        else {
            return signedDecimalStrGreaterThanOrEqual(b.substr(1), a.substr(1));
        }
    }
}
exports.signedDecimalStrGreaterThanOrEqual = signedDecimalStrGreaterThanOrEqual;
/**
 *
 * @param {string} a
 * @param {string} b
 */
function signedDecimalStrLessThanOrEqual(a, b) {
    return signedDecimalStrGreaterThanOrEqual(b, a);
}
exports.signedDecimalStrLessThanOrEqual = signedDecimalStrLessThanOrEqual;
function signedDecimalStrUnaryMinus(a) {
    if (a == "0") {
        return a;
    }
    const aNegative = a[0] == "-";
    return aNegative ? a.substr(1) : ("-" + a);
}
exports.signedDecimalStrUnaryMinus = signedDecimalStrUnaryMinus;
function signedDecimalStrSubtract(a, b) {
    if (a == b) {
        return "0";
    }
    if (b[0] == "-") {
        //a - negative = a + (-negative)
        return signedDecimalStrAdd(a, b.substr(1));
    }
    if (a[0] == "-") {
        //negative - b = -((-negative) + b)
        return signedDecimalStrUnaryMinus(signedDecimalStrAdd(a.substr(1), b));
    }
    if (signedDecimalStrGreaterThanOrEqual(a, b)) {
        //a > b
        return unsignedDecimalStrSubtract(a, b);
    }
    else {
        //a < b
        return signedDecimalStrUnaryMinus(signedDecimalStrSubtract(b, a));
    }
}
exports.signedDecimalStrSubtract = signedDecimalStrSubtract;
function signedDecimalStrAdd(a, b) {
    if (b[0] == "-") {
        //a + negative = a - (-negative)
        return signedDecimalStrSubtract(a, b.substr(1));
    }
    if (a[0] == "-") {
        //negative + b = b - (-negative)
        const absA = a.substr(1);
        if (absA == b) {
            //-x + x = 0
            return "0";
        }
        else if (signedDecimalStrGreaterThanOrEqual(absA, b)) {
            //x > b
            return signedDecimalStrUnaryMinus(signedDecimalStrSubtract(absA, b));
        }
        else {
            //x < b
            return signedDecimalStrSubtract(b, absA);
        }
    }
    return unsignedDecimalStrAdd(a, b);
}
exports.signedDecimalStrAdd = signedDecimalStrAdd;
function signedDecimalStrMultiply(a, b) {
    const aNegative = a[0] == "-";
    const bNegative = b[0] == "-";
    const absMul = unsignedDecimalStrMultiply(aNegative ? a.substr(1) : a, bNegative ? b.substr(1) : b);
    if (aNegative == bNegative) {
        return absMul;
    }
    else {
        return signedDecimalStrUnaryMinus(absMul);
    }
}
exports.signedDecimalStrMultiply = signedDecimalStrMultiply;
function signedDecimalStrDivide(a, b) {
    const aNegative = a[0] == "-";
    const bNegative = b[0] == "-";
    const absDiv = unsignedDecimalStrDivide(aNegative ? a.substr(1) : a, bNegative ? b.substr(1) : b);
    if (aNegative == bNegative) {
        return absDiv;
    }
    else {
        return signedDecimalStrUnaryMinus(absDiv);
    }
}
exports.signedDecimalStrDivide = signedDecimalStrDivide;
//# sourceMappingURL=signed-decimal-str-util.js.map

/***/ }),

/***/ "./dist/driver/execution/pool/unsigned-decimal-str-util.js":
/*!*****************************************************************!*\
  !*** ./dist/driver/execution/pool/unsigned-decimal-str-util.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function unsignedDigitArrayAdd(numA, numB) {
    const result = [];
    let carry = 0;
    for (let i = 0; i < Math.max(numA.length, numB.length); ++i) {
        carry += (i < numA.length ?
            numA[numA.length - i - 1] :
            0);
        carry += (i < numB.length ?
            numB[numB.length - i - 1] :
            0);
        const digit = carry % 10;
        carry = Math.floor(carry / 10);
        result.unshift(digit);
    }
    if (carry != 0) {
        result.unshift(carry);
    }
    return result;
}
exports.unsignedDigitArrayAdd = unsignedDigitArrayAdd;
function unsignedDigitArraySubtract(numA, numB) {
    const result = [];
    let carry = 0;
    for (let i = 0; i < numA.length; ++i) {
        carry += numA[numA.length - i - 1];
        carry -= (i < numB.length ?
            numB[numB.length - i - 1] :
            0);
        if (carry >= 0) {
            result.unshift(carry);
            carry = 0;
        }
        else {
            carry += 10;
            result.unshift(carry);
            carry = -1;
        }
    }
    if (carry < 0) {
        throw new Error(`Result of unsigned subtraction is negative`);
    }
    while (result[0] == 0 && result.length >= 2) {
        result.shift();
    }
    return result;
}
exports.unsignedDigitArraySubtract = unsignedDigitArraySubtract;
function unsignedDecimalStrAdd(a, b) {
    const numA = a.toString().split("").map(Number);
    const numB = b.toString().split("").map(Number);
    return unsignedDigitArrayAdd(numA, numB).join("");
}
exports.unsignedDecimalStrAdd = unsignedDecimalStrAdd;
function unsignedDecimalStrSubtract(a, b) {
    if (a == b) {
        return "0";
    }
    if (a.length < b.length) {
        throw new Error(`Result of unsigned subtraction is negative`);
    }
    const numA = a.toString().split("").map(Number);
    const numB = b.toString().split("").map(Number);
    return unsignedDigitArraySubtract(numA, numB).join("");
}
exports.unsignedDecimalStrSubtract = unsignedDecimalStrSubtract;
function unsignedDecimalStrMultiply(a, b) {
    if (a == "0" || b == "0") {
        return "0";
    }
    if (a == "1") {
        return b;
    }
    if (b == "1") {
        return a;
    }
    const numA = a.toString().split("").map(Number);
    const numB = b.toString().split("").map(Number);
    const arr = numB.map((digitB, indexB) => {
        const result = [];
        let carry = 0;
        for (let i = numA.length - 1; i >= 0; --i) {
            const digitA = numA[i];
            carry += digitA * digitB;
            const digit = carry % 10;
            carry = Math.floor(carry / 10);
            result.unshift(digit);
        }
        if (carry != 0) {
            result.unshift(carry);
        }
        const powerOf10 = numB.length - indexB - 1;
        for (let i = 0; i < powerOf10; ++i) {
            result.push(0);
        }
        return result;
    });
    if (arr.length == 0) {
        return "0";
    }
    if (arr.length == 1) {
        return arr[0].join("");
    }
    const [x, y, ...rest] = arr;
    let result = unsignedDigitArrayAdd(x, y);
    for (const r of rest) {
        result = unsignedDigitArrayAdd(result, r);
    }
    return result.join("");
}
exports.unsignedDecimalStrMultiply = unsignedDecimalStrMultiply;
function unsignedDigitArrayGreaterThanOrEqual(numA, numB) {
    if (numA.length > numB.length) {
        return true;
    }
    if (numA.length < numB.length) {
        return false;
    }
    for (let i = 0; i < numA.length; ++i) {
        const digitA = numA[i];
        const digitB = numB[i];
        if (digitA > digitB) {
            return true;
        }
        if (digitA < digitB) {
            return false;
        }
    }
    return true;
}
exports.unsignedDigitArrayGreaterThanOrEqual = unsignedDigitArrayGreaterThanOrEqual;
function unsignedDigitArrayLessThanOrEqual(numA, numB) {
    return unsignedDigitArrayGreaterThanOrEqual(numB, numA);
}
exports.unsignedDigitArrayLessThanOrEqual = unsignedDigitArrayLessThanOrEqual;
function unsignedDecimalStrDivide(a, b) {
    if (b == "0") {
        throw new Error(`DivideByZeroError: Cannot divide by zero`);
    }
    if (b == "1") {
        return a;
    }
    if (a == "0") {
        return "0";
    }
    const numA = a.toString().split("").map(Number);
    const numB = b.toString().split("").map(Number);
    const quotient = [];
    let remainder = [];
    for (let i = 0; i < numA.length; ++i) {
        remainder.push(numA[i]);
        while (remainder[0] == 0 && remainder.length >= 2) {
            remainder.shift();
        }
        if (remainder.length < numB.length) {
            quotient.push(0);
            continue;
        }
        let tmp = [0];
        let q = 0;
        while (q <= 9) {
            const tmp2 = unsignedDigitArrayAdd(tmp, numB);
            if (unsignedDigitArrayLessThanOrEqual(tmp2, remainder)) {
                tmp = tmp2;
                ++q;
            }
            else {
                break;
            }
        }
        if (q == 0) {
            quotient.push(0);
            continue;
        }
        quotient.push(q);
        remainder = unsignedDigitArraySubtract(remainder, tmp);
    }
    while (quotient[0] == 0 && quotient.length >= 2) {
        quotient.shift();
    }
    return quotient.join("");
}
exports.unsignedDecimalStrDivide = unsignedDecimalStrDivide;
//# sourceMappingURL=unsigned-decimal-str-util.js.map

/***/ }),

/***/ "./dist/driver/expr-library/index.js":
/*!*******************************************!*\
  !*** ./dist/driver/expr-library/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./information */ "./dist/driver/expr-library/information/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/expr-library/information/index.js":
/*!*******************************************************!*\
  !*** ./dist/driver/expr-library/information/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./last-insert-row-id */ "./dist/driver/expr-library/information/last-insert-row-id.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/expr-library/information/last-insert-row-id.js":
/*!********************************************************************!*\
  !*** ./dist/driver/expr-library/information/last-insert-row-id.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
exports.lastInsertRowId = squill.makeCustomOperator0("LAST_INSERT_ROWID()", tm.mysql.bigIntSigned());
//# sourceMappingURL=last-insert-row-id.js.map

/***/ }),

/***/ "./dist/driver/index.js":
/*!******************************!*\
  !*** ./dist/driver/index.js ***!
  \******************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./execution */ "./dist/driver/execution/index.js"));
__export(__webpack_require__(/*! ./expr-library */ "./dist/driver/expr-library/index.js"));
__export(__webpack_require__(/*! ./schema-introspection */ "./dist/driver/schema-introspection/index.js"));
__export(__webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/index.js"));
__export(__webpack_require__(/*! ./constants */ "./dist/driver/constants.js"));
__export(__webpack_require__(/*! ./worker */ "./dist/driver/worker.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/schema-introspection/index.js":
/*!***************************************************!*\
  !*** ./dist/driver/schema-introspection/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./sqlite-master */ "./dist/driver/schema-introspection/sqlite-master.js"));
__export(__webpack_require__(/*! ./try-fetch-generated-column-expression */ "./dist/driver/schema-introspection/try-fetch-generated-column-expression.js"));
__export(__webpack_require__(/*! ./try-fetch-schema-meta */ "./dist/driver/schema-introspection/try-fetch-schema-meta.js"));
__export(__webpack_require__(/*! ./try-fetch-table-meta */ "./dist/driver/schema-introspection/try-fetch-table-meta.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/schema-introspection/sqlite-master.js":
/*!***********************************************************!*\
  !*** ./dist/driver/schema-introspection/sqlite-master.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
exports.sqlite_master = squill.table("sqlite_master")
    .addColumns({
    //table, index
    type: squill.dtVarChar(),
    name: squill.dtVarChar(),
    tbl_name: squill.dtVarChar(),
    rootpage: squill.dtBigIntSigned(),
    sql: squill.dtVarChar().orNull(),
})
    .setPrimaryKey(columns => [columns.name]);
//# sourceMappingURL=sqlite-master.js.map

/***/ }),

/***/ "./dist/driver/schema-introspection/try-fetch-generated-column-expression.js":
/*!***********************************************************************************!*\
  !*** ./dist/driver/schema-introspection/try-fetch-generated-column-expression.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const try_fetch_table_meta_1 = __webpack_require__(/*! ./try-fetch-table-meta */ "./dist/driver/schema-introspection/try-fetch-table-meta.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./dist/driver/constants.js");
async function tryFetchGeneratedColumnExpression(connection, rawSchemaAlias, tableAlias, columnAlias) {
    const schemaAlias = (rawSchemaAlias == undefined ?
        constants_1.DEFAULT_SCHEMA_NAME :
        rawSchemaAlias);
    const tableMeta = await try_fetch_table_meta_1.tryFetchTableMeta(connection, schemaAlias, tableAlias);
    if (tableMeta == undefined) {
        return undefined;
    }
    const columnMeta = tableMeta.columns
        .find(column => column.columnAlias == columnAlias);
    if (columnMeta == undefined) {
        return undefined;
    }
    return columnMeta.generationExpression;
}
exports.tryFetchGeneratedColumnExpression = tryFetchGeneratedColumnExpression;
//# sourceMappingURL=try-fetch-generated-column-expression.js.map

/***/ }),

/***/ "./dist/driver/schema-introspection/try-fetch-schema-meta.js":
/*!*******************************************************************!*\
  !*** ./dist/driver/schema-introspection/try-fetch-schema-meta.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const try_fetch_table_meta_1 = __webpack_require__(/*! ./try-fetch-table-meta */ "./dist/driver/schema-introspection/try-fetch-table-meta.js");
const sqlite_master_1 = __webpack_require__(/*! ./sqlite-master */ "./dist/driver/schema-introspection/sqlite-master.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./dist/driver/constants.js");
async function tryFetchSchemaMeta(connection, rawSchemaAlias) {
    const schemaAlias = (rawSchemaAlias == undefined ?
        constants_1.DEFAULT_SCHEMA_NAME :
        rawSchemaAlias);
    const tables = await squill
        .from(sqlite_master_1.sqlite_master
        .setSchemaName(schemaAlias))
        .whereEq(columns => columns.type, "table")
        .selectValue(columns => columns.name)
        .map(async (row) => {
        const tableMeta = await try_fetch_table_meta_1.tryFetchTableMeta(connection, schemaAlias, row.sqlite_master.name);
        if (tableMeta == undefined) {
            throw new Error(`Table ${squill.pascalStyleEscapeString(schemaAlias)}.${squill.pascalStyleEscapeString(row.sqlite_master.name)} does not exist`);
        }
        else {
            return tableMeta;
        }
    })
        .fetchAll(connection);
    return {
        schemaAlias,
        tables,
    };
}
exports.tryFetchSchemaMeta = tryFetchSchemaMeta;
//# sourceMappingURL=try-fetch-schema-meta.js.map

/***/ }),

/***/ "./dist/driver/schema-introspection/try-fetch-table-meta.js":
/*!******************************************************************!*\
  !*** ./dist/driver/schema-introspection/try-fetch-table-meta.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlite_master_1 = __webpack_require__(/*! ./sqlite-master */ "./dist/driver/schema-introspection/sqlite-master.js");
async function tryFetchTableMeta(connection, schemaAlias, tableAlias) {
    const sql = await sqlite_master_1.sqlite_master
        .setSchemaName(schemaAlias)
        .whereEqSuperKey({
        name: tableAlias,
        type: "table",
    })
        .fetchValue(connection, columns => columns.sql)
        .orUndefined();
    if (sql === undefined) {
        return undefined;
    }
    if (sql === null) {
        throw new Error(`Table ${tableAlias} should have SQL string`);
    }
    //Modified version of
    //http://afoucal.free.fr/index.php/2009/01/26/get-default-value-and-unique-attribute-field-sqlite-database-using-air/
    const allColumnDefSql = sql.replace(/^CREATE\s+\w+\s+(("\w+"|\w+)|\[(.+)\])\s+(\(|AS|)/im, "");
    function getColumnDefSqlImpl(columnAlias, untilEnd) {
        const columnRegex = new RegExp(columnAlias + "(\\s*\\w+)(.*?)(,|\r|$)", "m");
        const columnDefSqlMatch = allColumnDefSql.match(columnRegex);
        if (columnDefSqlMatch == undefined) {
            return undefined;
        }
        if (untilEnd) {
            return allColumnDefSql.substr(columnDefSqlMatch.index);
        }
        else {
            return columnDefSqlMatch[1] + columnDefSqlMatch[2];
        }
    }
    function getColumnDefSql(columnAlias, untilEnd = false) {
        const resultQuoted = getColumnDefSqlImpl(squill.escapeIdentifierWithDoubleQuotes(columnAlias), untilEnd);
        if (resultQuoted != undefined) {
            return resultQuoted;
        }
        const resultUnquoted = getColumnDefSqlImpl(columnAlias, untilEnd);
        if (resultUnquoted != undefined) {
            return resultUnquoted;
        }
        throw new Error(`Cannot find column definition for ${tableAlias}.${columnAlias}`);
    }
    /**
     * @todo Improve
     * This regex approach is brittle. Very easy to craft counterexamples
     */
    function isAutoIncrement(columnAlias) {
        return /AUTOINCREMENT/i.test(getColumnDefSql(columnAlias));
    }
    /**
     * @todo Improve
     * This regex approach is brittle. Very easy to craft counterexamples
     */
    function isUnique(columnAlias) {
        return /UNIQUE/i.test(getColumnDefSql(columnAlias));
    }
    /**
     * @todo Improve
     * This regex approach is brittle. Very easy to craft counterexamples
     */
    function isPrimaryKey(columnAlias) {
        return /PRIMARY\s+KEY/i.test(getColumnDefSql(columnAlias));
    }
    /*
    function getGenerationExpression (columnAlias : string) {
        const columnDefSql = getColumnDefSql(columnAlias, /** untilEnd * /true);
        const match = columnDefSql.match(/\s+AS\s*(\((.|\n)+)/im)
        if (match == undefined) {
            return undefined;
        }
        //Should start with open parentheses
        const rawGenerationExpression = match[1];

        let parenthesesCount = 0;
        let inString = false;

        for (let i=0; i<rawGenerationExpression.length; ++i) {
            const cur = rawGenerationExpression[i];
            if (inString) {
                if (cur == "'") {
                    if (rawGenerationExpression[i+1] == "'") {
                        ++i;
                    } else {
                        inString = false;
                    }
                }
            } else {
                if (cur == "'") {
                    inString = true;
                } else if (cur == "(") {
                    ++parenthesesCount;
                } else if (cur == ")") {
                    --parenthesesCount;
                    if (parenthesesCount == 0) {
                        return rawGenerationExpression.substr(0, i+1);
                    }
                }
            }
        }
        throw new Error(`Could not parse generation expression for ${tableAlias}.${columnAlias}`)
    }
    */
    let constraintSql = allColumnDefSql;
    /**
     * ```sql
     *  -- This will not return the identifiers of GENERATED columns!
     *  pragma table_info()
     *
     *  -- Use this instead!
     *  pragma table_xinfo()
     * ```
     */
    const { execResult } = await connection
        .exec(`pragma table_xinfo(${squill.escapeIdentifierWithDoubleQuotes(tableAlias)})`);
    if (execResult.length != 1) {
        throw new Error(`Expected to fetch table info`);
    }
    const candidateKeys = [];
    let primaryKey = undefined;
    const resultSet = execResult[0];
    const objArr = resultSet.values.map((row) => {
        const obj = resultSet.columns.reduce((obj, columnAlias, index) => {
            obj[columnAlias] = row[index];
            return obj;
        }, {});
        obj.isAutoIncrement = isAutoIncrement(obj.name);
        /**
         * @todo
         *
         * Should fetch unique indexes, too...
         * Unique columns/candidate keys may be created separately with
         * `CREATE UNIQUE INDEX myUniqueIndex ON myTable(myColumn0, myColumn1, ...);`
         */
        obj.isUnique = isUnique(obj.name);
        obj.isPrimaryKey = isPrimaryKey(obj.name);
        obj.columnAlias = obj.name;
        obj.isNullable = tm.BigIntUtil.equal(obj.notnull, tm.BigInt(0));
        obj.explicitDefaultValue = typeof obj.dflt_value == "string" ?
            obj.dflt_value :
            undefined;
        /**
         * @todo Support getting the generationExpression.
         * For now, it'll take too much effort to implement this.
         *
         * @see {@link https://stackoverflow.com/questions/60632730/extracting-the-expression-of-a-generated-column-in-sqlite-3-31}
         */
        obj.generationExpression = obj.hidden.toString() == "2" ?
            /**
             * For now, return an empty string...
             * We can't get the generation expression yet =(
             */
            "" :
            undefined;
        const columnDef = getColumnDefSql(obj.name);
        constraintSql = constraintSql.replace(columnDef, "");
        if (isPrimaryKey(obj.name)) {
            if (primaryKey != undefined) {
                throw new Error(`Multiple primary keys found`);
            }
            primaryKey = {
                candidateKeyName: obj.name,
                columnAliases: [obj.name],
            };
        }
        else if (isUnique(obj.name)) {
            const constraintRegex = /CONSTRAINT\s+(.+)\s+UNIQUE/gi;
            const constraintMatch = constraintRegex.exec(columnDef);
            if (constraintMatch == undefined) {
                throw new Error(`Cannot get UNIQUE constraint of ${obj.name}`);
            }
            candidateKeys.push({
                candidateKeyName: squill.tryUnescapeIdentifierWithDoubleQuotes(constraintMatch[1]),
                columnAliases: [obj.name],
            });
        }
        return obj;
    });
    const constraintRegex = /CONSTRAINT\s+(.+)\s+(UNIQUE|PRIMARY\s+KEY)\s*\((.+)\)/gi;
    while (true) {
        const constraintMatch = constraintRegex.exec(constraintSql);
        if (constraintMatch == undefined) {
            break;
        }
        const constraintName = squill.tryUnescapeIdentifierWithDoubleQuotes(constraintMatch[1]);
        const constraintType = constraintMatch[2];
        const constraintColumns = constraintMatch[3];
        const columnRegex = /\s*(.+?)\s*(,|$)/gi;
        const columnAliases = [];
        while (true) {
            const columnMatch = columnRegex.exec(constraintColumns);
            if (columnMatch == undefined) {
                break;
            }
            columnAliases.push(squill.tryUnescapeIdentifierWithDoubleQuotes(columnMatch[1]));
        }
        if (constraintType.toUpperCase() == "UNIQUE") {
            candidateKeys.push({
                candidateKeyName: constraintName,
                columnAliases,
            });
        }
        else {
            if (primaryKey != undefined) {
                throw new Error(`Multiple primary keys found`);
            }
            primaryKey = {
                candidateKeyName: constraintName,
                columnAliases,
            };
        }
    }
    return {
        tableAlias,
        columns: objArr,
        candidateKeys,
        primaryKey: candidateKeys.find(candidateKey => candidateKey.candidateKeyName == "PRIMARY"),
    };
}
exports.tryFetchTableMeta = tryFetchTableMeta;
//# sourceMappingURL=try-fetch-table-meta.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/convenience.js":
/*!********************************************!*\
  !*** ./dist/driver/sqlfier/convenience.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
/**
 * Returns an unprettified SQL string.
 * Is fast-ish.
 *
 * @param ast - The AST to convert to a SQL string
 * @see {toSqlPretty} for pretty output but slower performance.
 */
function toSql(ast) {
    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
}
exports.toSql = toSql;
/**
 * Returns a prettified SQL string.
 * Is slow-ish.
 *
 * @param ast - The AST to convert to a SQL string
 * @see {toSql} for ugly output but faster performance.
 */
function toSqlPretty(ast) {
    return squill.AstUtil.toSqlPretty(ast, sqlfier_1.sqlfier, {
        stringTypes: [/*`""`,*/ "N''", /*"''",*/ "``", "[]", "X''", "pascal-single", "pascal-double"],
        /**
         * These `undefined` values should be ignored,
         * and should not overwrite.
         */
        openParens: undefined,
        closeParens: undefined,
    });
}
exports.toSqlPretty = toSqlPretty;
//# sourceMappingURL=convenience.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/delete-sql-string.js":
/*!**************************************************!*\
  !*** ./dist/driver/sqlfier/delete-sql-string.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
function deleteSqlString(table, whereClause) {
    const ast = [
        "DELETE FROM",
        table.unaliasedAst,
        "WHERE",
        whereClause.ast
    ];
    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
}
exports.deleteSqlString = deleteSqlString;
//# sourceMappingURL=delete-sql-string.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/index.js":
/*!**************************************!*\
  !*** ./dist/driver/sqlfier/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./convenience */ "./dist/driver/sqlfier/convenience.js"));
__export(__webpack_require__(/*! ./delete-sql-string */ "./dist/driver/sqlfier/delete-sql-string.js"));
__export(__webpack_require__(/*! ./insert-many-sql-string */ "./dist/driver/sqlfier/insert-many-sql-string.js"));
__export(__webpack_require__(/*! ./insert-one-sql-string */ "./dist/driver/sqlfier/insert-one-sql-string.js"));
__export(__webpack_require__(/*! ./insert-select-sql-string */ "./dist/driver/sqlfier/insert-select-sql-string.js"));
__export(__webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js"));
__export(__webpack_require__(/*! ./update-sql-string */ "./dist/driver/sqlfier/update-sql-string.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/insert-many-sql-string.js":
/*!*******************************************************!*\
  !*** ./dist/driver/sqlfier/insert-many-sql-string.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
const schema_introspection_1 = __webpack_require__(/*! ../schema-introspection */ "./dist/driver/schema-introspection/index.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./dist/driver/constants.js");
async function insertManySqlString(connection, insertType, table, insertRows) {
    const rawSchemaName = squill.TableUtil.tryGetSchemaName(table);
    const schemaName = (rawSchemaName == undefined ?
        constants_1.DEFAULT_SCHEMA_NAME :
        rawSchemaName);
    /**
     * We need to fetch the `tableMeta` because SQLite does not support the
     * `DEFAULT` keyword.
     */
    const tableMeta = await schema_introspection_1.tryFetchTableMeta(connection, schemaName, table.alias);
    if (tableMeta == undefined) {
        throw new Error(`Table ${squill.pascalStyleEscapeString(schemaName)}.${squill.pascalStyleEscapeString(table.alias)} does not exist`);
    }
    const structure = tableMeta.columns;
    //console.log(structure);
    const columnAliases = squill.TableUtil.columnAlias(table)
        .sort()
        .filter(columnAlias => {
        const columnDef = structure.find(columnDef => {
            return columnDef.name == columnAlias;
        });
        if (columnDef == undefined) {
            throw new Error(`Unknown column ${table.alias}.${columnAlias}`);
        }
        return columnDef.generationExpression == undefined;
    });
    const values = insertRows.map(insertRow => {
        const ast = columnAliases
            .map(columnAlias => {
            const value = insertRow[columnAlias];
            if (value === undefined) {
                const columnDef = structure.find(columnDef => {
                    return columnDef.name == columnAlias;
                });
                if (columnDef == undefined) {
                    throw new Error(`Unknown column ${table.alias}.${columnAlias}`);
                }
                if (columnDef.dflt_value != undefined) {
                    return columnDef.dflt_value;
                }
                if (tm.BigIntUtil.equal(columnDef.notnull, tm.BigInt(1))) {
                    if (columnDef.isAutoIncrement) {
                        return "NULL";
                    }
                    throw new Error(`${table.alias}.${columnAlias} is not nullable`);
                }
                else {
                    return "NULL";
                }
            }
            else {
                return squill.BuiltInExprUtil.buildAst(value);
            }
        })
            .reduce((values, ast) => {
            if (values.length > 0) {
                values.push(", ");
            }
            values.push(ast);
            return values;
        }, []);
        ast.unshift("(");
        ast.push(")");
        return ast;
    })
        .reduce((values, ast) => {
        if (values.length > 0) {
            values.push(", ");
        }
        values.push(ast);
        return values;
    }, []);
    const ast = [
        `${insertType} INTO`,
        /**
         * We use the `unaliasedAst` because the user may have called `setSchemaName()`
         */
        table.unaliasedAst,
        "(",
        columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(", "),
        ") VALUES",
        ...values,
    ];
    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
    return sql;
}
exports.insertManySqlString = insertManySqlString;
//# sourceMappingURL=insert-many-sql-string.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/insert-one-sql-string.js":
/*!******************************************************!*\
  !*** ./dist/driver/sqlfier/insert-one-sql-string.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
function insertOneSqlString(insertType, table, insertRow) {
    const columnAliases = squill.TableUtil.columnAlias(table)
        .filter(columnAlias => {
        return insertRow[columnAlias] !== undefined;
    })
        .sort();
    const values = columnAliases
        .map(columnAlias => squill.BuiltInExprUtil.buildAst(insertRow[columnAlias]))
        .reduce((values, ast) => {
        if (values.length > 0) {
            values.push(", ");
        }
        values.push(ast);
        return values;
    }, []);
    const ast = values.length == 0 ?
        [
            `${insertType} INTO`,
            /**
             * We use the `unaliasedAst` because the user may have called `setSchemaName()`
             */
            table.unaliasedAst,
            "DEFAULT VALUES",
        ] :
        [
            `${insertType} INTO`,
            /**
             * We use the `unaliasedAst` because the user may have called `setSchemaName()`
             */
            table.unaliasedAst,
            "(",
            columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(", "),
            ") VALUES (",
            ...values,
            ")",
        ];
    return squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
}
exports.insertOneSqlString = insertOneSqlString;
//# sourceMappingURL=insert-one-sql-string.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/insert-select-sql-string.js":
/*!*********************************************************!*\
  !*** ./dist/driver/sqlfier/insert-select-sql-string.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./dist/driver/constants.js");
const schema_introspection_1 = __webpack_require__(/*! ../schema-introspection */ "./dist/driver/schema-introspection/index.js");
async function insertSelectSqlString(connection, insertType, query, table, insertSelectRow) {
    const rawSchemaName = squill.TableUtil.tryGetSchemaName(table);
    const schemaName = (rawSchemaName == undefined ?
        constants_1.DEFAULT_SCHEMA_NAME :
        rawSchemaName);
    /**
     * We need to fetch the `tableMeta` because SQLite does not support the
     * `DEFAULT` keyword.
     */
    const tableMeta = await schema_introspection_1.tryFetchTableMeta(connection, schemaName, table.alias);
    if (tableMeta == undefined) {
        throw new Error(`Table ${squill.pascalStyleEscapeString(schemaName)}.${squill.pascalStyleEscapeString(table.alias)} does not exist`);
    }
    const structure = tableMeta.columns;
    //console.log(structure);
    const columnAliases = squill.TableUtil.columnAlias(table)
        .sort()
        .filter(columnAlias => {
        const columnDef = structure.find(columnDef => {
            return columnDef.name == columnAlias;
        });
        if (columnDef == undefined) {
            throw new Error(`Unknown column ${table.alias}.${columnAlias}`);
        }
        return columnDef.generationExpression == undefined;
    });
    const values = columnAliases
        .map(columnAlias => {
        const value = insertSelectRow[columnAlias];
        if (value === undefined) {
            const columnDef = structure.find(columnDef => {
                return columnDef.name == columnAlias;
            });
            if (columnDef == undefined) {
                throw new Error(`Unknown column ${table.alias}.${columnAlias}`);
            }
            if (columnDef.dflt_value != undefined) {
                return columnDef.dflt_value;
            }
            if (tm.BigIntUtil.equal(columnDef.notnull, tm.BigInt(1))) {
                if (columnDef.isAutoIncrement) {
                    return "NULL";
                }
                throw new Error(`${table.alias}.${columnAlias} is not nullable`);
            }
            else {
                return "NULL";
            }
        }
        else {
            if (squill.ColumnUtil.isColumn(value)) {
                return squill.escapeIdentifierWithDoubleQuotes(`${value.tableAlias}${squill.SEPARATOR}${value.columnAlias}`);
            }
            else {
                return squill.BuiltInExprUtil.buildAst(value);
            }
        }
    })
        .reduce((values, ast) => {
        if (values.length > 0) {
            values.push(", ");
        }
        values.push(ast);
        return values;
    }, []);
    const ast = [
        `${insertType} INTO`,
        /**
         * We use the `unaliasedAst` because the user may have called `setSchemaName()`
         */
        table.unaliasedAst,
        "(",
        columnAliases.map(squill.escapeIdentifierWithDoubleQuotes).join(", "),
        ")",
        "SELECT",
        ...values,
        "FROM",
        "(",
        query,
        ") AS tmp"
    ];
    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
    return sql;
}
exports.insertSelectSqlString = insertSelectSqlString;
//# sourceMappingURL=insert-select-sql-string.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/sqlfier.js":
/*!****************************************!*\
  !*** ./dist/driver/sqlfier/sqlfier.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./dist/driver/constants.js");
/**
* We do not use `ABS(-9223372036854775808)` because of,
* https://github.com/AnyhowStep/tsql/issues/233
*/
exports.THROW_AST = "(SELECT SUM(9223372036854775807) FROM (SELECT NULL UNION ALL SELECT NULL))";
const insertBetween = squill.AstUtil.insertBetween;
function normalizeOrderByAndLimitClauses(query) {
    /**
     * MySQL behaviour,
     * No `UNION` clause.
     *
     * | `ORDER BY` | `LIMIT` | `UNION ORDER BY` | `UNION LIMIT` | Result
     * |------------|---------|------------------|---------------|-------------------------------------------------
     * | Y          | Y       | Y                | Y             | `ORDER BY ... LIMIT ...) ORDER BY ... LIMIT ...`
     * | Y          | Y       | Y                | N             | `ORDER BY ... LIMIT ...) ORDER BY ...`
     * | Y          | Y       | N                | Y             | `ORDER BY ...) LIMIT ...`
     * | Y          | Y       | N                | N             | `ORDER BY ... LIMIT ...)`
     * | Y          | N       | Y                | Y             | `) ORDER BY ... LIMIT ...`
     * | Y          | N       | Y                | N             | `) ORDER BY ...`
     * | Y          | N       | N                | Y             | `ORDER BY ...) LIMIT ...`
     * | Y          | N       | N                | N             | `ORDER BY ...)`
     * |------------|---------|------------------|---------------|-------------------------------------------------
     * | N          | Y       | Y                | Y             | `LIMIT ...) ORDER BY ... LIMIT ...`
     * | N          | Y       | Y                | N             | `LIMIT ...) ORDER BY ...`
     * | N          | Y       | N                | Y             | `) LIMIT ...`
     * | N          | Y       | N                | N             | `LIMIT ...)`
     * | N          | N       | Y                | Y             | `) ORDER BY ... LIMIT ...`
     * | N          | N       | Y                | N             | `) ORDER BY ...`
     * | N          | N       | N                | Y             | `) LIMIT ...`
     * | N          | N       | N                | N             | `)`
     *
     * Observations:
     * + With no `LIMIT` clause, the `UNION ORDER BY` and `UNION LIMIT` take over, regardless of `ORDER BY`
     * + With the `LIMIT` clause, the `UNION ORDER BY` never takes over
     * + With the `LIMIT` clause, the `UNION LIMIT` takes over when there is no `UNION ORDER BY`
     *
     * + `UNION LIMIT` takes over when, !`LIMIT` || !`UNION ORDER BY`
     * + `UNION ORDER BY` takes over when, !`LIMIT`
     */
    /**
     *
     * MySQL behaviour,
     * With `UNION` clause.
     *
     * Nothing is taken over.
     */
    const orderByClause = ((query.compoundQueryOrderByClause != undefined &&
        query.compoundQueryClause == undefined &&
        query.limitClause == undefined) ?
        query.compoundQueryOrderByClause :
        query.orderByClause);
    const limitClause = ((query.compoundQueryLimitClause != undefined &&
        query.compoundQueryClause == undefined &&
        (query.limitClause == undefined ||
            query.compoundQueryOrderByClause == undefined)) ?
        query.compoundQueryLimitClause :
        query.limitClause);
    const compoundQueryOrderByClause = (orderByClause == query.compoundQueryOrderByClause ?
        undefined :
        query.compoundQueryOrderByClause);
    const compoundQueryLimitClause = (limitClause == query.compoundQueryLimitClause ?
        undefined :
        query.compoundQueryLimitClause);
    return {
        ...query,
        orderByClause,
        limitClause,
        compoundQueryOrderByClause,
        compoundQueryLimitClause,
    };
}
function selectClauseColumnToSql(column, isDerivedTable) {
    return [
        [
            squill.escapeIdentifierWithDoubleQuotes(column.tableAlias),
            ".",
            squill.escapeIdentifierWithDoubleQuotes(column.columnAlias)
        ].join(""),
        "AS",
        squill.escapeIdentifierWithDoubleQuotes(isDerivedTable ?
            column.columnAlias :
            `${column.tableAlias}${squill.SEPARATOR}${column.columnAlias}`)
    ];
}
function selectClauseColumnArrayToSql(columns, isDerivedTable) {
    columns.sort((a, b) => {
        const tableAliasCmp = a.tableAlias.localeCompare(b.tableAlias);
        if (tableAliasCmp != 0) {
            return tableAliasCmp;
        }
        return a.columnAlias.localeCompare(b.columnAlias);
    });
    const result = [];
    for (const column of columns) {
        if (result.length > 0) {
            result.push(",");
        }
        result.push(...selectClauseColumnToSql(column, isDerivedTable));
    }
    return result;
}
function selectClauseColumnMapToSql(map, isDerivedTable) {
    const columns = squill.ColumnUtil.fromColumnMap(map);
    return selectClauseColumnArrayToSql(columns, isDerivedTable);
}
function selectClauseColumnRefToSql(ref, isDerivedTable) {
    const columns = squill.ColumnUtil.fromColumnRef(ref);
    return selectClauseColumnArrayToSql(columns, isDerivedTable);
}
function selectClauseToSql(selectClause, toSql, isDerivedTable, isDistinct) {
    const result = [];
    for (const selectItem of selectClause) {
        if (result.length > 0) {
            result.push(",");
        }
        if (squill.ColumnUtil.isColumn(selectItem)) {
            result.push(...selectClauseColumnToSql(selectItem, isDerivedTable));
        }
        else if (squill.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            result.push(toSql(selectItem.unaliasedAst), "AS", squill.escapeIdentifierWithDoubleQuotes(isDerivedTable ?
                selectItem.alias :
                `${selectItem.tableAlias}${squill.SEPARATOR}${selectItem.alias}`));
        }
        else if (squill.ColumnMapUtil.isColumnMap(selectItem)) {
            result.push(...selectClauseColumnMapToSql(selectItem, isDerivedTable));
        }
        else if (squill.ColumnRefUtil.isColumnRef(selectItem)) {
            result.push(...selectClauseColumnRefToSql(selectItem, isDerivedTable));
        }
        else {
            throw new Error(`Not implemented`);
        }
    }
    return isDistinct ?
        ["SELECT DISTINCT", ...result] :
        ["SELECT", ...result];
}
function fromClauseToSql(currentJoins, toSql) {
    const result = [];
    for (const join of currentJoins) {
        if (join.joinType == squill.JoinType.FROM) {
            result.push("FROM");
        }
        else {
            result.push(join.joinType, "JOIN");
        }
        if (squill.isIdentifierNode(join.tableAst)) {
            const lastIdentifier = join.tableAst.identifiers[join.tableAst.identifiers.length - 1];
            if (lastIdentifier == join.tableAlias) {
                result.push(toSql(join.tableAst));
            }
            else {
                result.push(toSql(join.tableAst), "AS", squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));
            }
        }
        else if (squill.QueryBaseUtil.isQuery(join.tableAst)) {
            result.push("(", queryToSql(join.tableAst, toSql, true), ")");
            result.push("AS");
            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));
        }
        else if (squill.Parentheses.IsParentheses(join.tableAst) && squill.QueryBaseUtil.isQuery(join.tableAst.ast)) {
            const subQuery = join.tableAst.ast;
            result.push("(", queryToSql(subQuery, toSql, true), ")");
            result.push("AS");
            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));
        }
        else {
            result.push("(", toSql(join.tableAst), ")");
            result.push("AS");
            result.push(squill.escapeIdentifierWithDoubleQuotes(join.tableAlias));
        }
        if (join.onClause != undefined) {
            result.push("ON");
            result.push(toSql(squill.AstUtil.tryUnwrapParentheses(join.onClause.ast)));
        }
    }
    return result;
}
function whereClauseToSql(whereClause, toSql) {
    return [
        "WHERE",
        toSql(squill.AstUtil.tryUnwrapParentheses(whereClause.ast))
    ];
}
function orderByClauseToSql(orderByClause, toSql) {
    if (orderByClause.length == 0) {
        return [];
    }
    const result = [];
    for (const [sortExpr, sortDirection] of orderByClause) {
        if (result.length > 0) {
            result.push(",");
        }
        if (squill.ColumnUtil.isColumn(sortExpr)) {
            if (sortExpr.unaliasedAst == undefined) {
                result.push([
                    squill.escapeIdentifierWithDoubleQuotes(sortExpr.tableAlias),
                    ".",
                    squill.escapeIdentifierWithDoubleQuotes(sortExpr.columnAlias)
                ].join(""));
            }
            else {
                result.push(squill.escapeIdentifierWithDoubleQuotes(`${sortExpr.tableAlias}${squill.SEPARATOR}${sortExpr.columnAlias}`));
            }
        }
        else if (squill.ExprUtil.isExpr(sortExpr)) {
            if (squill.LiteralValueNodeUtil.isLiteralValueNode(sortExpr.ast)) {
                if (sortExpr.ast.literalValueType == squill.LiteralValueType.BIGINT_SIGNED) {
                    result.push(toSql([sortExpr.ast, "+ 0"]));
                }
                else {
                    result.push(toSql(sortExpr.ast));
                }
            }
            else {
                result.push(toSql(sortExpr.ast));
            }
        }
        else {
            result.push(toSql(sortExpr.unaliasedAst));
        }
        result.push(sortDirection);
    }
    return [
        "ORDER BY",
        ...result
    ];
}
function groupByClauseToSql(groupByClause, _toSql) {
    if (groupByClause.length == 0) {
        return [];
    }
    const result = [];
    for (const column of groupByClause) {
        if (result.length > 0) {
            result.push(",");
        }
        if (column.tableAlias == squill.ALIASED) {
            result.push(squill.escapeIdentifierWithDoubleQuotes(`${column.tableAlias}${squill.SEPARATOR}${column.columnAlias}`));
        }
        else {
            result.push([
                squill.escapeIdentifierWithDoubleQuotes(column.tableAlias),
                ".",
                squill.escapeIdentifierWithDoubleQuotes(column.columnAlias)
            ].join(""));
        }
    }
    return [
        "GROUP BY",
        ...result
    ];
}
function havingClauseToSql(havingClause, toSql) {
    return [
        "HAVING",
        toSql(squill.AstUtil.tryUnwrapParentheses(havingClause.ast))
    ];
}
function limitClauseToSql(limitClause, _toSql) {
    return [
        "LIMIT",
        squill.escapeValue(limitClause.maxRowCount),
        "OFFSET",
        squill.escapeValue(limitClause.offset),
    ];
}
function compoundQueryClauseToSql(compoundQueryClause, toSql) {
    const result = [];
    for (const rawCompoundQuery of compoundQueryClause) {
        result.push(rawCompoundQuery.compoundQueryType);
        if (!rawCompoundQuery.isDistinct) {
            result.push("ALL");
        }
        const query = rawCompoundQuery.query;
        if (query.orderByClause != undefined ||
            query.limitClause != undefined ||
            query.compoundQueryClause != undefined ||
            query.compoundQueryOrderByClause != undefined ||
            query.compoundQueryLimitClause != undefined) {
            result.push("SELECT * FROM (", toSql(query), ")");
        }
        else {
            result.push(toSql(query));
        }
    }
    return result;
}
function queryToSql(rawQuery, toSql, isDerivedTable) {
    const query = normalizeOrderByAndLimitClauses(rawQuery);
    if ((
    /**
     * If we have both a compound `ORDER BY/LIMIT` clause
     * and regular `ORDER BY/LIMIT` clause,
     * we will need a derived table because
     * SQLite only supports on `ORDER BY` and `LIMIT` clause for the entire query.
     */
    (query.compoundQueryOrderByClause != undefined ||
        query.compoundQueryLimitClause != undefined) &&
        (query.orderByClause != undefined ||
            query.limitClause != undefined)) ||
        /**
         * If we have a compound query and an `ORDER BY` or `LIMIT` clause,
         * we will need to make the query a derived table because
         * SQLite only supports on `ORDER BY` and `LIMIT` clause for the entire query.
         */
        (query.compoundQueryClause != undefined &&
            (query.orderByClause != undefined ||
                query.limitClause != undefined))) {
        /**
         * We have to apply some hackery to get the same behaviour as MySQL.
         */
        const innerQuery = {
            ...query,
            compoundQueryClause: undefined,
            compoundQueryOrderByClause: undefined,
            compoundQueryLimitClause: undefined,
        };
        const result = [
            "SELECT * FROM (",
            toSql(innerQuery),
            ")"
        ];
        if (query.compoundQueryClause != undefined) {
            result.push(compoundQueryClauseToSql(query.compoundQueryClause, toSql).join(" "));
        }
        if (query.compoundQueryOrderByClause != undefined) {
            result.push(orderByClauseToSql(query.compoundQueryOrderByClause, toSql).join(" "));
        }
        if (query.compoundQueryLimitClause != undefined) {
            result.push(limitClauseToSql(query.compoundQueryLimitClause, toSql).join(" "));
        }
        return result.join(" ");
    }
    const result = [];
    if (query.selectClause != undefined) {
        result.push(selectClauseToSql(query.selectClause, toSql, isDerivedTable, query.isDistinct).join(" "));
    }
    if (query.fromClause != undefined && query.fromClause.currentJoins != undefined) {
        result.push(fromClauseToSql(query.fromClause.currentJoins, toSql).join(" "));
    }
    if (query.limitClause != undefined && tm.BigIntUtil.equal(query.limitClause.maxRowCount, 0)) {
        /**
         * ```sql
         *  CREATE TABLE "myTable" ("myColumn" INT PRIMARY KEY);
         *  INSERT INTO "myTable"("myColumn") VALUES (4);
         *  SELECT
         *      COALESCE(
         *          (
         *              SELECT
         *                  "myTable"."myColumn" AS "myTable--myColumn"
         *              FROM
         *                  "myTable"
         *              LIMIT
         *                  0
         *              OFFSET
         *                  0
         *          ),
         *          3
         *      );
         * ```
         * The above gives `4` on SQLite.
         * Gives `3` on MySQL and PostgreSQL.
         * SQLite is bugged.
         *
         * The fix is to use `WHERE FALSE` when `LIMIT 0` is detected.
         *
         * ```sql
         *  CREATE TABLE "myTable" ("myColumn" INT PRIMARY KEY);
         *  INSERT INTO "myTable"("myColumn") VALUES (4);
         *  SELECT
         *      COALESCE(
         *          (
         *              SELECT
         *                  "myTable"."myColumn" AS "myTable--myColumn"
         *              FROM
         *                  "myTable"
         *              WHERE
         *                  FALSE
         *              LIMIT
         *                  0
         *              OFFSET
         *                  0
         *          ),
         *          3
         *      );
         * ```
         */
        result.push("WHERE FALSE");
    }
    else {
        if (query.whereClause != undefined) {
            result.push(whereClauseToSql(query.whereClause, toSql).join(" "));
        }
    }
    if (query.groupByClause == undefined || query.groupByClause.length == 0) {
        if (query.havingClause != undefined) {
            /**
             * Workaround for `<empty grouping set>` not supported by SQLite
             */
            throw new Error(`SQLite does not support ... GROUP BY () HAVING ...`);
            //result.push(havingClauseToSql(query.havingClause, toSql).join(" "));
        }
    }
    else {
        result.push(groupByClauseToSql(query.groupByClause, toSql).join(" "));
        if (query.havingClause != undefined) {
            result.push(havingClauseToSql(query.havingClause, toSql).join(" "));
        }
    }
    if (query.orderByClause != undefined) {
        result.push(orderByClauseToSql(query.orderByClause, toSql).join(" "));
    }
    if (query.limitClause != undefined) {
        result.push(limitClauseToSql(query.limitClause, toSql).join(" "));
    }
    if (query.compoundQueryClause != undefined) {
        result.push(compoundQueryClauseToSql(query.compoundQueryClause, toSql).join(" "));
    }
    if (query.compoundQueryOrderByClause != undefined) {
        result.push(orderByClauseToSql(query.compoundQueryOrderByClause, toSql).join(" "));
    }
    if (query.compoundQueryLimitClause != undefined) {
        result.push(limitClauseToSql(query.compoundQueryLimitClause, toSql).join(" "));
    }
    return result.join(" ");
}
exports.sqlfier = {
    identifierSqlfier: (identifierNode) => identifierNode.identifiers
        .map(squill.escapeIdentifierWithDoubleQuotes)
        .join("."),
    literalValueSqlfier: {
        [squill.LiteralValueType.DECIMAL]: ({ literalValue, precision, scale }) => squill.functionCall("decimal_ctor", [
            squill.pascalStyleEscapeString(literalValue),
            squill.escapeValue(precision),
            squill.escapeValue(scale)
        ]) /*toSql(
            castAsDecimal(
                literalValue,
                precision,
                scale
            ).ast
        )*/,
        [squill.LiteralValueType.STRING]: ({ literalValue }) => {
            if (literalValue.includes('\0')) {
                throw new Error(`String literal may not contain null characters`);
            }
            return squill.pascalStyleEscapeString(literalValue);
        },
        [squill.LiteralValueType.DOUBLE]: ({ literalValue }) => {
            if (isNaN(literalValue)) {
                throw new squill.DataOutOfRangeError({
                    message: `Literal ${literalValue} not allowed`,
                    /**
                     * @todo Figure out how to get the entire SQL, then throw?
                     */
                    sql: undefined,
                });
            }
            if (literalValue == Infinity) {
                return "(1e999)";
            }
            if (literalValue == -Infinity) {
                return "(-1e999)";
            }
            return squill.escapeValue(literalValue);
        },
        [squill.LiteralValueType.BIGINT_SIGNED]: ({ literalValue }) => squill.escapeValue(literalValue),
        /**
         * @deprecated
         */
        //[LiteralValueType.BIGINT_UNSIGNED] : ({literalValue}) => escapeValue(literalValue),
        [squill.LiteralValueType.BOOLEAN]: ({ literalValue }) => squill.escapeValue(literalValue),
        [squill.LiteralValueType.BUFFER]: ({ literalValue }) => squill.escapeValue(literalValue),
        [squill.LiteralValueType.NULL]: ({ literalValue }) => squill.escapeValue(literalValue),
        [squill.LiteralValueType.DATE_TIME]: ({ literalValue }, toSql) => toSql(squill.utcStringToTimestamp(squill.DateTimeUtil.toSqlUtc(literalValue, 3)).ast),
    },
    operatorSqlfier: {
        /*
            Comparison Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html
        */
        [squill.OperatorType.BETWEEN_AND]: ({ operands }) => [
            operands[0],
            "BETWEEN",
            operands[1],
            "AND",
            operands[2]
        ],
        [squill.OperatorType.NOT_BETWEEN_AND]: ({ operands }) => [
            operands[0],
            "NOT BETWEEN",
            operands[1],
            "AND",
            operands[2]
        ],
        [squill.OperatorType.COALESCE]: ({ operatorType, operands }) => squill.functionCall(operatorType, operands),
        [squill.OperatorType.EQUAL]: ({ operands }) => insertBetween(operands, "="),
        [squill.OperatorType.NULL_SAFE_EQUAL]: ({ operands }) => insertBetween(operands, "IS"),
        [squill.OperatorType.NOT_NULL_SAFE_EQUAL]: ({ operands }) => insertBetween(operands, "IS NOT"),
        [squill.OperatorType.LESS_THAN]: ({ operands }) => insertBetween(operands, "<"),
        [squill.OperatorType.GREATER_THAN]: ({ operands }) => insertBetween(operands, ">"),
        [squill.OperatorType.LESS_THAN_OR_EQUAL]: ({ operands }) => insertBetween(operands, "<="),
        [squill.OperatorType.GREATER_THAN_OR_EQUAL]: ({ operands }) => insertBetween(operands, ">="),
        [squill.OperatorType.IN_ARRAY]: ({ operands: [x, ...rest] }) => {
            return [
                x,
                squill.functionCall("IN", [...rest])
            ];
        },
        [squill.OperatorType.IN_QUERY]: ({ operands: [x, y] }) => {
            /**
             * https://github.com/AnyhowStep/tsql/issues/198
             */
            return [
                x,
                squill.functionCall("IN", [
                    squill.Parentheses.IsParentheses(y) ?
                        y.ast :
                        y
                ])
            ];
        },
        [squill.OperatorType.NOT_IN_ARRAY]: ({ operands: [x, ...rest] }) => {
            return [
                x,
                squill.functionCall("NOT IN", [...rest])
            ];
        },
        [squill.OperatorType.NOT_IN_QUERY]: ({ operands: [x, y] }) => {
            /**
             * https://github.com/AnyhowStep/tsql/issues/198
             */
            return [
                x,
                squill.functionCall("NOT IN", [
                    squill.Parentheses.IsParentheses(y) ?
                        y.ast :
                        y
                ])
            ];
        },
        [squill.OperatorType.IS_NOT_NULL]: ({ operands }) => [operands[0], "IS NOT NULL"],
        [squill.OperatorType.IS_NULL]: ({ operands }) => [operands[0], "IS NULL"],
        [squill.OperatorType.IS_UNKNOWN]: ({ operands }) => [operands[0], "IS NULL"],
        [squill.OperatorType.IS_NOT_UNKNOWN]: ({ operands }) => [operands[0], "IS NOT NULL"],
        [squill.OperatorType.IS_TRUE]: ({ operands }) => [operands[0], "IS TRUE"],
        [squill.OperatorType.IS_NOT_TRUE]: ({ operands }) => [operands[0], "IS NOT TRUE"],
        [squill.OperatorType.IS_FALSE]: ({ operands }) => [operands[0], "IS FALSE"],
        [squill.OperatorType.IS_NOT_FALSE]: ({ operands }) => [operands[0], "IS NOT FALSE"],
        [squill.OperatorType.LIKE_ESCAPE]: ({ operands: [expr, pattern, escapeChar] }) => {
            if (squill.LiteralValueNodeUtil.isLiteralValueNode(escapeChar) && escapeChar.literalValue === "") {
                return [
                    expr, "LIKE", pattern
                ];
            }
            else {
                return [
                    expr, "LIKE", pattern, "ESCAPE", escapeChar
                ];
            }
        },
        [squill.OperatorType.NOT_LIKE_ESCAPE]: ({ operands: [expr, pattern, escapeChar] }) => {
            if (squill.LiteralValueNodeUtil.isLiteralValueNode(escapeChar) && escapeChar.literalValue === "") {
                return [
                    expr, "NOT LIKE", pattern
                ];
            }
            else {
                return [
                    expr, "NOT LIKE", pattern, "ESCAPE", escapeChar
                ];
            }
        },
        [squill.OperatorType.NOT_EQUAL]: ({ operands }) => insertBetween(operands, "<>"),
        [squill.OperatorType.LEAST]: ({ operands }) => squill.functionCall("MIN", operands),
        [squill.OperatorType.GREATEST]: ({ operands }) => squill.functionCall("MAX", operands),
        /*
            Logical Operators
            https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html
        */
        [squill.OperatorType.AND]: ({ operands }) => insertBetween(operands, "AND"),
        [squill.OperatorType.OR]: ({ operands }) => insertBetween(operands, "OR"),
        [squill.OperatorType.NOT]: ({ operands }) => [
            "NOT",
            operands[0]
        ],
        [squill.OperatorType.XOR]: ({ operands }) => insertBetween(operands, "<>"),
        /*
            Control Flow Functions
            https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html
        */
        [squill.OperatorType.IF]: ({ operands: [a, b, c] }) => [
            "CASE WHEN",
            a,
            "THEN",
            b,
            "ELSE",
            c,
            "END"
        ],
        [squill.OperatorType.IF_NULL]: ({ operands }) => squill.functionCall("IFNULL", operands),
        [squill.OperatorType.NULL_IF_EQUAL]: ({ operands }) => squill.functionCall("NULLIF", operands),
        /*
            String Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
        */
        [squill.OperatorType.ASCII]: ({ operands }) => squill.functionCall("ASCII", operands),
        [squill.OperatorType.BIN]: ({ operands }) => squill.functionCall("BIN", operands),
        [squill.OperatorType.BIT_LENGTH]: ({ operands }) => ([
            squill.functionCall("LENGTH", [
                squill.functionCall("CAST", [[operands, "AS BLOB"]])
            ]),
            "* 8"
        ]),
        [squill.OperatorType.CHAR_LENGTH]: ({ operands }) => squill.functionCall("LENGTH", operands),
        [squill.OperatorType.OCTET_LENGTH]: ({ operands }) => squill.functionCall("LENGTH", [
            squill.functionCall("CAST", [[operands, "AS BLOB"]])
        ]),
        [squill.OperatorType.CONCAT]: ({ operands }) => insertBetween(operands, "||"),
        [squill.OperatorType.NULL_SAFE_CONCAT]: ({ operands }) => (insertBetween(operands.map(operand => squill.functionCall("COALESCE", [operand, "''"])), "||")),
        [squill.OperatorType.CONCAT_WS]: ({ operands }) => squill.functionCall("CONCAT_WS", operands),
        [squill.OperatorType.FROM_BASE64]: ({ operands }) => squill.functionCall("FROM_BASE64", operands),
        [squill.OperatorType.HEX]: ({ operands }) => squill.functionCall("HEX", operands),
        [squill.OperatorType.IN_STR]: ({ operands }) => squill.functionCall("INSTR", operands),
        [squill.OperatorType.LPAD]: ({ operands }) => squill.functionCall("LPAD", operands),
        [squill.OperatorType.RPAD]: ({ operands }) => squill.functionCall("RPAD", operands),
        [squill.OperatorType.LTRIM]: ({ operands }) => squill.functionCall("LTRIM", operands),
        [squill.OperatorType.RTRIM]: ({ operands }) => squill.functionCall("RTRIM", operands),
        [squill.OperatorType.TRIM]: ({ operands }) => squill.functionCall("TRIM", operands),
        [squill.OperatorType.POSITION]: ({ operands }) => squill.functionCall("INSTR", [operands[1], operands[0]]),
        [squill.OperatorType.REPEAT]: ({ operands }) => squill.functionCall("REPEAT", operands),
        [squill.OperatorType.REPLACE]: ({ operands }) => squill.functionCall("REPLACE", operands),
        [squill.OperatorType.REVERSE]: ({ operands }) => squill.functionCall("REVERSE", operands),
        [squill.OperatorType.TO_BASE64]: ({ operands }) => squill.functionCall("TO_BASE64", operands),
        [squill.OperatorType.UNHEX]: ({ operands }) => squill.functionCall("UNHEX", operands),
        [squill.OperatorType.UPPER]: ({ operands }) => squill.functionCall("UPPER", operands),
        [squill.OperatorType.LOWER]: ({ operands }) => squill.functionCall("LOWER", operands),
        /*
            Arithmetic Operators
            https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html
        */
        [squill.OperatorType.FRACTIONAL_DIVISION]: ({ operands }) => insertBetween(operands, "/"),
        [squill.OperatorType.INTEGER_DIVISION]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.DOUBLE) {
                return squill.functionCall("CAST", [
                    [
                        insertBetween(operands, "/"),
                        "AS BIGINT"
                    ]
                ]);
            }
            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("bigint_div", operands);
            }
            else {
                throw new Error(`INTEGER_DIVISION not implemented for ${typeHint}`);
            }
        },
        /**
         * In SQLite, `%` ONLY does integer remainder
         */
        [squill.OperatorType.INTEGER_REMAINDER]: ({ operands, typeHint }, toSql) => {
            if (typeHint == squill.TypeHint.DOUBLE) {
                return squill.functionCall("CAST", [
                    toSql(insertBetween(operands.map(op => squill.functionCall("CAST", [
                        toSql(op) + " AS INTEGER"
                    ])), "%")) + " AS DOUBLE"
                ]);
            }
            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return insertBetween(operands, "%");
            }
            else {
                throw new Error(`INTEGER_REMAINDER not implemented for ${typeHint}`);
            }
        },
        [squill.OperatorType.FRACTIONAL_REMAINDER]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.DOUBLE) {
                function naiveFractionalRemainder(dividend, divisor) {
                    const absDivisor = squill.functionCall("ABS", [divisor]);
                    return squill.parentheses([
                        dividend,
                        "-",
                        squill.functionCall("FLOOR", [
                            [
                                dividend,
                                "/",
                                absDivisor
                            ]
                        ]),
                        "*",
                        absDivisor
                    ], false);
                }
                const dividend = operands[0];
                const divisor = operands[1];
                return [
                    "CASE",
                    "WHEN", dividend, "= 1e999 THEN NULL",
                    "WHEN", dividend, "= -1e999 THEN NULL",
                    "WHEN", divisor, "= 1e999 THEN",
                    dividend,
                    "WHEN", divisor, "= -1e999 THEN",
                    dividend,
                    "WHEN", dividend, ">= 0 THEN", naiveFractionalRemainder(dividend, divisor),
                    "ELSE",
                    "-", naiveFractionalRemainder(squill.parentheses(["-", dividend], false), divisor),
                    "END"
                ];
            }
            else {
                throw new Error(`FRACTIONAL_REMAINDER not implemented for ${typeHint}`);
            }
        },
        [squill.OperatorType.ADDITION]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("bigint_add", operands);
            }
            else {
                return squill.functionCall("COALESCE", [
                    insertBetween(operands, "+"),
                    exports.THROW_AST
                ]);
            }
        },
        [squill.OperatorType.SUBTRACTION]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("bigint_sub", operands);
            }
            else {
                return squill.functionCall("COALESCE", [
                    insertBetween(operands, "-"),
                    exports.THROW_AST
                ]);
            }
        },
        [squill.OperatorType.MULTIPLICATION]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("bigint_mul", operands);
            }
            else {
                return squill.functionCall("COALESCE", [
                    insertBetween(operands, "*"),
                    exports.THROW_AST
                ]);
            }
        },
        [squill.OperatorType.UNARY_MINUS]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("bigint_neg", operands);
            }
            else {
                return ["-", operands[0]];
            }
        },
        /*
            Mathematical Functions
            https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html
        */
        [squill.OperatorType.ABSOLUTE_VALUE]: ({ operands }) => squill.functionCall("ABS", operands),
        [squill.OperatorType.ARC_COSINE]: ({ operands }) => squill.functionCall("ACOS", operands),
        [squill.OperatorType.ARC_SINE]: ({ operands }) => squill.functionCall("ASIN", operands),
        [squill.OperatorType.ARC_TANGENT]: ({ operands }) => squill.functionCall("ATAN", operands),
        [squill.OperatorType.ARC_TANGENT_2]: ({ operands }) => squill.functionCall("ATAN2", operands),
        [squill.OperatorType.CUBE_ROOT]: ({ operands }) => squill.functionCall("CBRT", operands),
        [squill.OperatorType.CEILING]: ({ operands }) => squill.functionCall("CEILING", operands),
        [squill.OperatorType.COSINE]: ({ operands }) => squill.functionCall("COS", operands),
        [squill.OperatorType.COTANGENT]: ({ operands }) => squill.functionCall("COT", operands),
        [squill.OperatorType.DEGREES]: ({ operands }) => [operands[0], "* (180.0/3.141592653589793)"],
        [squill.OperatorType.NATURAL_EXPONENTIATION]: ({ operands }) => squill.functionCall("EXP", operands),
        [squill.OperatorType.FLOOR]: ({ operands }) => squill.functionCall("FLOOR", operands),
        [squill.OperatorType.LN]: ({ operands }) => squill.functionCall("LN", operands),
        [squill.OperatorType.LOG]: ({ operands }) => squill.functionCall("LOG", operands),
        [squill.OperatorType.LOG2]: ({ operands }) => squill.functionCall("LOG2", operands),
        [squill.OperatorType.LOG10]: ({ operands }) => squill.functionCall("LOG10", operands),
        [squill.OperatorType.PI]: () => squill.functionCall("PI", []),
        [squill.OperatorType.POWER]: ({ operands }) => squill.functionCall("POWER", operands),
        [squill.OperatorType.RADIANS]: ({ operands }) => [operands[0], "* (3.141592653589793/180.0)"],
        [squill.OperatorType.RANDOM]: ({ operands, typeHint }) => {
            if (typeHint == squill.TypeHint.DOUBLE) {
                return squill.functionCall("FRANDOM", operands);
            }
            else if (typeHint == squill.TypeHint.BIGINT_SIGNED) {
                return squill.functionCall("RANDOM", operands);
            }
            else {
                throw new Error(`RANDOM not implemented for ${typeHint}`);
            }
        },
        //[squill.OperatorType.ROUND] : ({operands}) => squill.functionCall("ROUND", operands),
        [squill.OperatorType.SIGN]: ({ operands }) => squill.functionCall("SIGN", operands),
        [squill.OperatorType.SINE]: ({ operands }) => squill.functionCall("SIN", operands),
        [squill.OperatorType.SQUARE_ROOT]: ({ operands }) => squill.functionCall("SQRT", operands),
        [squill.OperatorType.TANGENT]: ({ operands }) => squill.functionCall("TAN", operands),
        //[squill.OperatorType.TRUNCATE] : ({operands}) => squill.functionCall("TRUNCATE", operands),
        /*
            Date and Time Functions
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
        */
        [squill.OperatorType.CURRENT_DATE]: () => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d"),
            squill.pascalStyleEscapeString("now")
        ]),
        [squill.OperatorType.CURRENT_TIMESTAMP_0]: () => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%S"),
            squill.pascalStyleEscapeString("now")
        ]),
        [squill.OperatorType.CURRENT_TIMESTAMP_1]: () => squill.functionCall("substr", [
            squill.functionCall("strftime", [
                squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
                squill.pascalStyleEscapeString("now")
            ]),
            "1",
            "21"
        ]),
        [squill.OperatorType.CURRENT_TIMESTAMP_2]: () => squill.functionCall("substr", [
            squill.functionCall("strftime", [
                squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
                squill.pascalStyleEscapeString("now")
            ]),
            "1",
            "22"
        ]),
        [squill.OperatorType.CURRENT_TIMESTAMP_3]: () => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            squill.pascalStyleEscapeString("now")
        ]),
        [squill.OperatorType.EXTRACT_YEAR]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%Y"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_MONTH]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%m"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_DAY]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%d"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_HOUR]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%H"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_MINUTE]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%M"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_INTEGER_SECOND]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%S"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.EXTRACT_FRACTIONAL_SECOND_3]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%f"),
                    operands[0]
                ]),
                "AS DOUBLE"
            ]
        ]),
        [squill.OperatorType.LAST_DAY]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d"),
            operands[0],
            squill.pascalStyleEscapeString("+1 month"),
            [
                squill.pascalStyleEscapeString("-"),
                "||",
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%d"),
                    operands[0]
                ]),
                "||",
                squill.pascalStyleEscapeString(" day")
            ]
        ]),
        [squill.OperatorType.TIMESTAMPADD_YEAR]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            [
                operands[0],
                "||",
                squill.pascalStyleEscapeString(" year")
            ]
        ]),
        /**
         * @todo Just use a polyfill, rather than trying to emulate with SQLite built-ins.
         * Seriously. But, for now, this actually works, which surprises me.
         */
        [squill.OperatorType.TIMESTAMPADD_MONTH]: ({ operands }, toSql, sqlfier) => {
            /*
                The following gives SQLite's and JS' understanding of what
                "adding months" means. However, it is different from what
                MySQL understands as "adding months".

                Since the function is named for MySQL's `TIMESTAMPADD()`,
                we follow MySQL's convention, and emultate MySQL's behaviour.

                squill.functionCall(
                    "strftime",
                    [
                        squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
                        operands[1],
                        [
                            operands[0],
                            "||",
                            squill.pascalStyleEscapeString(" month")
                        ]
                    ]
                )
            */
            const rawDeltaMonth = operands[0];
            const dateTime = operands[1];
            const curYear = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_YEAR](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_YEAR, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);
            const curMonth = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_MONTH](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_MONTH, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);
            const curDay = sqlfier.operatorSqlfier[squill.OperatorType.EXTRACT_DAY](squill.OperatorNodeUtil.operatorNode1(squill.OperatorType.EXTRACT_DAY, [dateTime], squill.TypeHint.DATE_TIME), toSql, sqlfier);
            const curTimeComponent = squill.functionCall("strftime", [
                squill.pascalStyleEscapeString(" %H:%M:%f"),
                dateTime
            ]);
            function lastDay(year, month) {
                return squill.parentheses([
                    "CASE",
                    "WHEN", month, "= 2 THEN (CASE WHEN", year, "%4 = 0 THEN 29 ELSE 28 END)",
                    "WHEN", month, "IN(1,3,5,7,8,10,12) THEN 31",
                    "ELSE 30",
                    "END"
                ], false);
            }
            function setYearMonth(resultYear, resultMonth) {
                const lastDayOfResult = lastDay(resultYear, resultMonth);
                const lastDayOfAdd = squill.parentheses(["CASE WHEN", curDay, ">", lastDayOfResult, "THEN", lastDayOfResult, "ELSE", curDay, "END"], false);
                /**
                 * @todo Instead of `LPAD()`, use this?
                 * https://stackoverflow.com/a/9603175
                 */
                return [
                    squill.functionCall("LPAD", [squill.functionCall("CAST", [[resultYear, "AS TEXT"]]), "4", "'0'"]),
                    "|| '-' ||",
                    squill.functionCall("LPAD", [squill.functionCall("CAST", [[resultMonth, "AS TEXT"]]), "2", "'0'"]),
                    "|| '-' ||",
                    squill.functionCall("LPAD", [squill.functionCall("CAST", [[lastDayOfAdd, "AS TEXT"]]), "2", "'0'"]),
                    "||",
                    curTimeComponent
                ];
            }
            const monthsSince_0000_01 = squill.parentheses([curYear, "* 12 + (", curMonth, "-1) +", rawDeltaMonth], false);
            const resultYear = squill.functionCall("FLOOR", [[monthsSince_0000_01, "/12"]]);
            const resultMonth = squill.parentheses([monthsSince_0000_01, "%12 + 1"], false);
            return [
                "CASE",
                "WHEN", monthsSince_0000_01, "BETWEEN 0 AND 119999 THEN", setYearMonth(resultYear, resultMonth),
                "ELSE NULL",
                "END"
            ];
        },
        [squill.OperatorType.TIMESTAMPADD_DAY]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            insertBetween([
                operands[0],
                squill.pascalStyleEscapeString(" day")
            ], "||")
        ]),
        [squill.OperatorType.TIMESTAMPADD_HOUR]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            insertBetween([
                operands[0],
                squill.pascalStyleEscapeString(" hour")
            ], "||")
        ]),
        [squill.OperatorType.TIMESTAMPADD_MINUTE]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            insertBetween([
                operands[0],
                squill.pascalStyleEscapeString(" minute")
            ], "||")
        ]),
        [squill.OperatorType.TIMESTAMPADD_SECOND]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            insertBetween([
                operands[0],
                squill.pascalStyleEscapeString(" second")
            ], "||")
        ]),
        [squill.OperatorType.TIMESTAMPADD_MILLISECOND]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[1],
            insertBetween([
                squill.parentheses(insertBetween([
                    operands[0],
                    "1000e0"
                ], "/"), 
                //canUnwrap
                false),
                squill.pascalStyleEscapeString(" second")
            ], "||")
        ]),
        [squill.OperatorType.TIMESTAMPDIFF_DAY]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%J"),
                    operands[1]
                ]),
                "-",
                squill.functionCall("strftime", [
                    squill.pascalStyleEscapeString("%J"),
                    operands[0]
                ]),
                "AS BIGINT"
            ]
        ]),
        [squill.OperatorType.TIMESTAMPDIFF_HOUR]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[0]
                    ])
                ], false),
                "* 24 AS BIGINT"
            ]
        ]),
        [squill.OperatorType.TIMESTAMPDIFF_MINUTE]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[0]
                    ])
                ], false),
                "* 24 * 60 AS BIGINT"
            ]
        ]),
        [squill.OperatorType.TIMESTAMPDIFF_SECOND]: ({ operands }) => squill.functionCall("CAST", [
            [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        operands[0]
                    ])
                ], false),
                "* 24 * 60 * 60 AS BIGINT"
            ]
        ]),
        [squill.OperatorType.TIMESTAMPDIFF_MILLISECOND]: ({ operands }) => {
            /*
                This naive implementation suffers from precision problems,
                squill.functionCall(
                    "CAST",
                    [
                        [
                            squill.parentheses(
                                [
                                    squill.functionCall(
                                        "strftime",
                                        [
                                            squill.pascalStyleEscapeString("%J"),
                                            operands[1]
                                        ]
                                    ),
                                    "-",
                                    squill.functionCall(
                                        "strftime",
                                        [
                                            squill.pascalStyleEscapeString("%J"),
                                            operands[0]
                                        ]
                                    )
                                ],
                                false
                            ),
                            "* 24 * 60 * 60 * 1000 AS BIGINT"
                        ]
                    ]
                )
            */
            function castAsBigInt(x) {
                return squill.functionCall("CAST", [[x, "AS BIGINT"]]);
            }
            const diffDate = [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        squill.functionCall("strftime", [
                            squill.pascalStyleEscapeString("%Y-%m-%d"),
                            operands[1]
                        ])
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%J"),
                        squill.functionCall("strftime", [
                            squill.pascalStyleEscapeString("%Y-%m-%d"),
                            operands[0]
                        ])
                    ])
                ], false),
                "* 24 * 60 * 60 * 1000"
            ];
            const diffHour = [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%H"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%H"),
                        operands[0]
                    ])
                ], false),
                "* 60 * 60 * 1000"
            ];
            const diffMinute = [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%M"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%M"),
                        operands[0]
                    ])
                ], false),
                "* 60 * 1000"
            ];
            const diffSecond = [
                squill.parentheses([
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%S"),
                        operands[1]
                    ]),
                    "-",
                    squill.functionCall("strftime", [
                        squill.pascalStyleEscapeString("%S"),
                        operands[0]
                    ])
                ], false),
                "* 1000"
            ];
            const diffMillisecond = [
                squill.parentheses([
                    squill.functionCall("substr", [
                        squill.functionCall("strftime", [
                            squill.pascalStyleEscapeString("%f"),
                            operands[1]
                        ]),
                        "4"
                    ]),
                    "-",
                    squill.functionCall("substr", [
                        squill.functionCall("strftime", [
                            squill.pascalStyleEscapeString("%f"),
                            operands[0]
                        ]),
                        "4"
                    ])
                ], false)
            ];
            return castAsBigInt(insertBetween([
                diffDate,
                diffHour,
                diffMinute,
                diffSecond,
                diffMillisecond
            ], "+"));
        },
        [squill.OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR]: ({ operands }) => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%Y-%m-%d %H:%M:%f"),
            operands[0]
        ]),
        [squill.OperatorType.UNIX_TIMESTAMP_NOW]: () => squill.functionCall("strftime", [
            squill.pascalStyleEscapeString("%s"),
            squill.pascalStyleEscapeString("now")
        ]),
        /*
            Cast Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html
        */
        [squill.OperatorType.CAST_AS_DECIMAL]: ({ operands: [arg, precision, scale] }) => squill.functionCall("decimal_ctor", [
            arg,
            precision,
            scale
        ]) /*functionCall(
            "CAST",
            [
                toSql(arg) + `AS DECIMAL(${toSql(precision)}, ${toSql(scale)})`
            ]
        )*/,
        [squill.OperatorType.CAST_AS_DOUBLE]: ({ operands }, toSql) => squill.functionCall("CAST", [`${toSql(operands)} AS DOUBLE`]),
        [squill.OperatorType.CAST_AS_BIGINT_SIGNED]: ({ operands }, toSql) => squill.functionCall("CAST", [`${toSql(operands)} AS BIGINT`]),
        [squill.OperatorType.CAST_AS_BINARY]: ({ operands }) => squill.functionCall("CAST", [[operands[0], `AS BLOB`]]),
        [squill.OperatorType.CAST_AS_VARCHAR]: ({ operands }) => squill.functionCall("CAST", [[operands[0], `AS VARCHAR`]]),
        [squill.OperatorType.CAST_AS_JSON]: ({ operands }) => squill.functionCall("CAST", [[operands[0], `AS TEXT`]]),
        /*
            Bit Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html
        */
        [squill.OperatorType.BITWISE_AND]: ({ operands }) => insertBetween(operands, "&"),
        [squill.OperatorType.BITWISE_OR]: ({ operands }) => insertBetween(operands, "|"),
        [squill.OperatorType.BITWISE_XOR]: ({ operands }) => [
            ["~", squill.parentheses(insertBetween(operands, "&"), false)],
            "&",
            squill.parentheses(insertBetween(operands, "|"), false)
        ],
        [squill.OperatorType.BITWISE_NOT]: ({ operands }) => ["~", operands],
        [squill.OperatorType.BITWISE_LEFT_SHIFT]: ({ operands }) => insertBetween(operands, "<<"),
        [squill.OperatorType.BITWISE_RIGHT_SHIFT]: ({ operands }) => insertBetween(operands, ">>"),
        /*
            Aggregate (GROUP BY) Function Descriptions
            https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html
        */
        [squill.OperatorType.AGGREGATE_COUNT_ALL]: () => squill.functionCall("COUNT", ["*"]),
        [squill.OperatorType.AGGREGATE_COUNT_EXPR]: ({ operands, operatorType }) => {
            if (operands.length == 2) {
                const [isDistinct, expr] = operands;
                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&
                    isDistinct.literalValue === true) {
                    return squill.functionCall("COUNT", [["DISTINCT", expr]]);
                }
                else {
                    return squill.functionCall("COUNT", [expr]);
                }
            }
            else {
                throw new Error(`${operatorType} only implemented for 2 args`);
            }
        },
        [squill.OperatorType.AGGREGATE_AVERAGE]: ({ operands, operatorType }) => {
            if (operands.length == 2) {
                const [isDistinct, expr] = operands;
                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&
                    isDistinct.literalValue === true) {
                    return squill.functionCall("AVG", [["DISTINCT", expr]]);
                }
                else {
                    return squill.functionCall("AVG", [expr]);
                }
            }
            else {
                throw new Error(`${operatorType} only implemented for 2 args`);
            }
        },
        [squill.OperatorType.AGGREGATE_MAX]: ({ operands }) => {
            return squill.functionCall("MAX", operands);
        },
        [squill.OperatorType.AGGREGATE_MIN]: ({ operands }) => {
            return squill.functionCall("MIN", operands);
        },
        [squill.OperatorType.AGGREGATE_SUM]: ({ operands, operatorType }) => {
            if (operands.length == 2) {
                const [isDistinct, expr] = operands;
                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&
                    isDistinct.literalValue === true) {
                    return squill.functionCall("SUM", [["DISTINCT", expr]]);
                }
                else {
                    return squill.functionCall("SUM", [expr]);
                }
            }
            else {
                throw new Error(`${operatorType} only implemented for 2 args`);
            }
        },
        [squill.OperatorType.AGGREGATE_SUM_AS_BIGINT_SIGNED]: ({ operands, operatorType }) => {
            if (operands.length == 2) {
                const [isDistinct, expr] = operands;
                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&
                    isDistinct.literalValue === true) {
                    return squill.functionCall("SUM", [["DISTINCT", expr]]);
                }
                else {
                    return squill.functionCall("SUM", [expr]);
                }
            }
            else {
                throw new Error(`${operatorType} only implemented for 2 args`);
            }
        },
        [squill.OperatorType.AGGREGATE_SUM_AS_DECIMAL]: ({ operands, operatorType }) => {
            if (operands.length == 2) {
                const [isDistinct, expr] = operands;
                if (squill.LiteralValueNodeUtil.isLiteralValueNode(isDistinct) &&
                    isDistinct.literalValue === true) {
                    return squill.functionCall("SUM", [
                        [
                            "DISTINCT",
                            //@todo
                            squill.functionCall("CAST", [
                                [expr, "AS REAL"]
                            ])
                        ]
                    ]);
                }
                else {
                    return squill.functionCall("SUM", [
                        //@todo
                        squill.functionCall("CAST", [
                            [expr, "AS REAL"]
                        ])
                    ]);
                }
            }
            else {
                throw new Error(`${operatorType} only implemented for 2 args`);
            }
        },
        [squill.OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT]: ({ operands }) => squill.functionCall("GROUP_CONCAT", [
            ["DISTINCT", operands[0]]
        ]),
        [squill.OperatorType.AGGREGATE_GROUP_CONCAT_ALL]: ({ operands }) => squill.functionCall("GROUP_CONCAT", operands),
        [squill.OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION]: ({ operands }) => {
            return squill.functionCall("STDDEV_POP", operands);
        },
        [squill.OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION]: ({ operands }) => {
            return squill.functionCall("STDDEV_SAMP", operands);
        },
        [squill.OperatorType.AGGREGATE_POPULATION_VARIANCE]: ({ operands }) => {
            return squill.functionCall("VAR_POP", operands);
        },
        [squill.OperatorType.AGGREGATE_SAMPLE_VARIANCE]: ({ operands }) => {
            return squill.functionCall("VAR_SAMP", operands);
        },
        [squill.OperatorType.EXISTS]: ({ operands: [query] }, toSql) => {
            if (squill.QueryBaseUtil.isAfterFromClause(query)) {
                //EXISTS(... FROM table)
                if (squill.QueryBaseUtil.isAfterSelectClause(query)) {
                    //EXISTS(SELECT x FROM table)
                    return squill.functionCall("EXISTS", [query]);
                }
                else {
                    //EXISTS(FROM table)
                    return squill.functionCall("EXISTS", [
                        "SELECT 1 " + toSql(query)
                    ]);
                }
            }
            else {
                if (squill.QueryBaseUtil.isAfterSelectClause(query)) {
                    //EXISTS(SELECT x)
                    return squill.functionCall("EXISTS", [query]);
                }
                else {
                    throw new Error(`Query should have either FROM or SELECT clause`);
                }
            }
        },
        /*
            https://dev.mysql.com/doc/refman/5.7/en/information-functions.html

            Information Functions
        */
        [squill.OperatorType.CURRENT_SCHEMA]: () => squill.pascalStyleEscapeString(constants_1.DEFAULT_SCHEMA_NAME),
        [squill.OperatorType.CURRENT_USER]: () => "NULL",
        /*
            Custom library functions

            These functions are not standard SQL,
            but can be implemented using standard SQL.
        */
        [squill.OperatorType.THROW_IF_NULL]: ({ operands: [arg] }) => {
            return squill.functionCall("COALESCE", [
                arg,
                exports.THROW_AST
            ]);
        },
    },
    queryBaseSqlfier: (rawQuery, toSql) => {
        const sql = queryToSql(rawQuery, toSql, false);
        //console.log(sql);
        return sql;
    },
    caseValueSqlfier: (node) => {
        const result = [
            "CASE", node.value,
        ];
        for (const [compareValue, thenResult] of node.cases) {
            result.push(["WHEN", compareValue, "THEN", thenResult]);
        }
        if (node.else != undefined) {
            result.push(["ELSE", node.else]);
        }
        result.push("END");
        return result;
    },
    caseConditionSqlfier: (node) => {
        const result = [
            "CASE"
        ];
        for (const [condition, thenResult] of node.branches) {
            result.push(["WHEN", condition, "THEN", thenResult]);
        }
        if (node.else != undefined) {
            result.push(["ELSE", node.else]);
        }
        result.push("END");
        return result;
    }
};
//# sourceMappingURL=sqlfier.js.map

/***/ }),

/***/ "./dist/driver/sqlfier/update-sql-string.js":
/*!**************************************************!*\
  !*** ./dist/driver/sqlfier/update-sql-string.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const squill = __webpack_require__(/*! @squill/squill */ "../tsql/dist/index.js");
const sqlfier_1 = __webpack_require__(/*! ./sqlfier */ "./dist/driver/sqlfier/sqlfier.js");
function updateSqlString(table, whereClause, assignmentMap) {
    const mutableColumnAlias = Object.keys(assignmentMap)
        .filter(columnAlias => {
        const value = assignmentMap[columnAlias];
        return (value !== undefined &&
            table.mutableColumns.indexOf(columnAlias) >= 0);
    })
        .sort();
    if (mutableColumnAlias.length == 0) {
        //Empty assignment list...
        return undefined;
    }
    const assignmentList = mutableColumnAlias.reduce((ast, columnAlias) => {
        const value = assignmentMap[columnAlias];
        const assignment = [
            squill.escapeIdentifierWithDoubleQuotes(columnAlias),
            "=",
            squill.BuiltInExprUtil.buildAst(value)
        ];
        if (ast.length > 0) {
            ast.push(",");
        }
        ast.push(assignment);
        return ast;
    }, []);
    const ast = [
        "UPDATE",
        table.unaliasedAst,
        "SET",
        ...assignmentList,
        "WHERE",
        whereClause.ast
    ];
    const sql = squill.AstUtil.toSql(ast, sqlfier_1.sqlfier);
    return sql;
}
exports.updateSqlString = updateSqlString;
//# sourceMappingURL=update-sql-string.js.map

/***/ }),

/***/ "./dist/driver/worker.js":
/*!*******************************!*\
  !*** ./dist/driver/worker.js ***!
  \*******************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SqliteAction;
(function (SqliteAction) {
    SqliteAction["OPEN"] = "OPEN";
    SqliteAction["EXEC"] = "EXEC";
    SqliteAction["EXPORT"] = "EXPORT";
    SqliteAction["CLOSE"] = "CLOSE";
    SqliteAction["CREATE_GLOBAL_JS_FUNCTION"] = "CREATE_GLOBAL_JS_FUNCTION";
    SqliteAction["CREATE_FUNCTION"] = "CREATE_FUNCTION";
    SqliteAction["CREATE_AGGREGATE"] = "CREATE_AGGREGATE";
})(SqliteAction = exports.SqliteAction || (exports.SqliteAction = {}));
class SqliteWorker {
    constructor(rawWorker) {
        this.onResult = (data) => {
            if (this.onmessage == undefined) {
                return;
            }
            this.onmessage({ data });
        };
        this.processMessage = rawWorker.postMessage;
        rawWorker.setOnMessage(this.onResult);
    }
    postMessage(message) {
        this.processMessage(message);
    }
}
exports.SqliteWorker = SqliteWorker;
//# sourceMappingURL=worker.js.map

/***/ }),

/***/ "./test-browser/src/index.ts":
/*!***********************************!*\
  !*** ./test-browser/src/index.ts ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sqlite3 = __webpack_require__(/*! ../../dist/driver */ "./dist/driver/index.js");
const worker = new Worker("worker-browser.js");
const sqlite3Worker = new sqlite3.SqliteWorker({
    postMessage: worker.postMessage.bind(worker),
    setOnMessage: (onMessage) => {
        worker.onmessage = (event) => {
            onMessage(event.data);
            if (event.data.action == sqlite3.SqliteAction.CLOSE) {
                worker.terminate();
            }
        };
    },
});
const pool = new sqlite3.Pool(sqlite3Worker);
window.rawQuery = (sqlString) => pool.acquire(connection => connection.rawQuery(sqlString));
window.exec = (sqlString) => pool.acquire(connection => connection.exec(sqlString));
window.exportDb = () => pool.acquire(connection => connection.export());
window.importDb = (dbFile) => pool.acquire(connection => connection.open(dbFile));


/***/ })

/******/ });
//# sourceMappingURL=index.js.map