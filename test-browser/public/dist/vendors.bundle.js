(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors"],{

/***/ "./node_modules/@squill/squill/dist/aliased-expr/aliased-expr-impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-expr/aliased-expr-impl.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
/**
 * An aliased expression
 *
 * ```sql
 *  SELECT
 *      (1+2) AS x --This is an `AliasedExpr`
 * ```
 *
 * -----
 *
 * ### Using `AliasedExpr` as "normal" expression
 *
 * Normally, you cannot use an aliased expression as a "normal" expression.
 *
 * This is usually invalid,
 * ```sql
 *  SELECT
 *      (((1+2) AS x) + 3) AS y
 * ```
 *
 * However, `tsql` allows this!
 *
 * When the query is generated, it extracts the inner unaliased expression,
 *
 * ```sql
 *  SELECT
 *      ((1+2) + 3) AS y
 * ```
 *
 * -----
 *
 * Allowing the above lets us write composable expressions that
 * can also be used in `SELECT` clauses more consistently!
 *
 * For example,
 * ```ts
 *  function x () {
 *      return tsql.add(1, 2).as("x");
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //SELECT (1+2) AS x, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 * If we did not allow aliased expressions to be used as "normal" expressions,
 * we would have an increased risk of typos,
 *
 * ```ts
 *  function x () {
 *      //Removed `.as("x")`
 *      return tsql.add(1, 2);
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x().as("x"),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //Intended: SELECT (1+2) AS x, (1+2+3+4+5) AS y
 *  //Actual  : SELECT (1+2) AS typo, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x().as("typo"),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 * -----
 *
 * ### Re-aliasing
 *
 * Normally, you can only alias an expression once,
 * ```sql
 *  SELECT
 *      (1+2) AS x AS y --Error: Cannot alias an expression more than once!
 * ```
 *
 * However, `tsql` allows this!
 *
 * When the query is generated, it uses the **last** set alias,
 * ```sql
 *  SELECT
 *      (1+2) AS y
 * ```
 *
 * -----
 *
 * With re-aliasing, you can set a **default alias** for your composable expressions.
 * Then, when you want a different alias, you can change it.
 *
 * For example,
 * ```ts
 *  function x () {
 *      //Default alias is `x`
 *      return tsql.add(1, 2).as("x");
 *  }
 *  //SELECT (1+2) AS x, (1+2+3) AS y
 *  tsql.select(() => [
 *      x(),
 *      tsql.add(x(), 3).as("y"),
 *  ]);
 *  //SELECT (1+2) AS realiased, (1+2+3+4+5) AS y
 *  tsql.select(() => [
 *      x().as("realiased"),
 *      tsql.add(x(), 3, 4, 5).as("y"),
 *  ]);
 * ```
 *
 */
class AliasedExpr extends expr_1.ExprImpl {
    constructor(data, ast) {
        super(data, ast);
        this.tableAlias = data.tableAlias;
        this.alias = data.alias;
        this.unaliasedAst = ast;
    }
}
exports.AliasedExpr = AliasedExpr;
//# sourceMappingURL=aliased-expr-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-expr/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-expr/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-expr-impl */ "./node_modules/@squill/squill/dist/aliased-expr/aliased-expr-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/aliased-table.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/aliased-table.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A table can be aliased,
 *
 * ```sql
 * SELECT
 *  *
 * FROM
 *  myTable
 * CROSS JOIN
 *  (
 *      myTable
 *  ) AS otherTable --This is an `AliasedTable`
 * ```
 *
 * For aliasing a query (derived tables), @see {@link DerivedTable}
 */
class AliasedTable {
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
    }
}
exports.AliasedTable = AliasedTable;
//# sourceMappingURL=aliased-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/array-util/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/array-util/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/aliased-table/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/aliased-table/array-util/query/index.js");
function assertNoDuplicateTableAlias(arr) {
    const duplicates = query_1.duplicateTableAlias(arr);
    if (duplicates.length > 0) {
        throw new Error(`Duplicate table alias not allowed; ${duplicates.join(", ")}`);
    }
}
exports.assertNoDuplicateTableAlias = assertNoDuplicateTableAlias;
//# sourceMappingURL=assert-no-duplicate-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-no-duplicate-table-alias */ "./node_modules/@squill/squill/dist/aliased-table/array-util/predicate/assert-no-duplicate-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/array-util/query/duplicate-table-alias.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/array-util/query/duplicate-table-alias.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function duplicateTableAlias(arr) {
    const result = [];
    for (let i = 0; i < arr.length; ++i) {
        const cur = arr[i].alias;
        for (let j = i + 1; j < arr.length; ++j) {
            const nxt = arr[j].alias;
            if (cur == nxt && !result.includes(cur)) {
                result.push(cur);
            }
        }
    }
    return result;
}
exports.duplicateTableAlias = duplicateTableAlias;
//# sourceMappingURL=duplicate-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/array-util/query/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/array-util/query/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./duplicate-table-alias */ "./node_modules/@squill/squill/dist/aliased-table/array-util/query/duplicate-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-table */ "./node_modules/@squill/squill/dist/aliased-table/aliased-table.js"));
const AliasedTableArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/aliased-table/array-util/index.js");
exports.AliasedTableArrayUtil = AliasedTableArrayUtil;
const AliasedTableUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/aliased-table/util/index.js");
exports.AliasedTableUtil = AliasedTableUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/aliased-table/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/query/candidate-keys.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/query/candidate-keys.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function candidateKeys(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.candidateKeys;
    }
    else {
        return [];
    }
}
exports.candidateKeys = candidateKeys;
//# sourceMappingURL=candidate-keys.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/query/delete-enabled.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/query/delete-enabled.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function deleteEnabled(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.deleteEnabled;
    }
    else {
        return false;
    }
}
exports.deleteEnabled = deleteEnabled;
//# sourceMappingURL=delete-enabled.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/query/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/query/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./candidate-keys */ "./node_modules/@squill/squill/dist/aliased-table/util/query/candidate-keys.js"));
__export(__webpack_require__(/*! ./delete-enabled */ "./node_modules/@squill/squill/dist/aliased-table/util/query/delete-enabled.js"));
__export(__webpack_require__(/*! ./mutable-columns */ "./node_modules/@squill/squill/dist/aliased-table/util/query/mutable-columns.js"));
__export(__webpack_require__(/*! ./primary-key */ "./node_modules/@squill/squill/dist/aliased-table/util/query/primary-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/query/mutable-columns.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/query/mutable-columns.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function mutableColumns(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.mutableColumns;
    }
    else {
        return [];
    }
}
exports.mutableColumns = mutableColumns;
//# sourceMappingURL=mutable-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/aliased-table/util/query/primary-key.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/aliased-table/util/query/primary-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function primaryKey(aliasedTable) {
    if (table_1.TableUtil.isTable(aliasedTable)) {
        return aliasedTable.primaryKey;
    }
    else {
        return undefined;
    }
}
exports.primaryKey = primaryKey;
//# sourceMappingURL=primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-condition-node/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-condition-node/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CaseConditionNodeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/index.js");
exports.CaseConditionNodeUtil = CaseConditionNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-condition-node/util/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-case-condition-node */ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-condition-node/util/predicate/is-case-condition-node.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function isCaseConditionNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "branches",
        "else"
    ])) {
        return false;
    }
    return (mixed.type === "CaseCondition");
}
exports.isCaseConditionNode = isCaseConditionNode;
//# sourceMappingURL=is-case-condition-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-value-node/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-value-node/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CaseValueNodeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/case-value-node/util/index.js");
exports.CaseValueNodeUtil = CaseValueNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-value-node/util/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-value-node/util/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-case-value-node */ "./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/is-case-value-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/is-case-value-node.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/case-value-node/util/predicate/is-case-value-node.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function isCaseValueNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "value",
        "cases",
        "else"
    ])) {
        return false;
    }
    return (mixed.type === "CaseValue");
}
exports.isCaseValueNode = isCaseValueNode;
//# sourceMappingURL=is-case-value-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/function-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/function-call.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ./parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js");
const AstUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/util/index.js");
class FunctionArg {
    constructor(ast) {
        this.type = "FunctionArg";
        this.toSql = (sqlfier) => {
            return AstUtil.toSql(this.ast, sqlfier);
        };
        if (parentheses_1.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
            //No need to wrap arguments in parentheses...
            //Unless the argument is a sub-query...
            this.ast = ast.ast;
        }
        else {
            this.ast = ast;
        }
    }
    static IsFunctionArg(x) {
        if (x instanceof FunctionArg) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "FunctionArg") &&
            /**
             * @todo Debate if this is necessary.
             * Safer, but slower.
             */
            //AstUtil.isAst(mixed.ast) &&
            (typeof mixed.toSql == "function"));
    }
}
exports.FunctionArg = FunctionArg;
class FunctionCall {
    constructor(functionName, args) {
        this.type = "FunctionCall";
        this.toSql = (sqlfier) => {
            const argsSql = this.args
                .map(arg => arg.toSql(sqlfier))
                .join(", ");
            return `${this.functionName}(${argsSql})`;
        };
        this.functionName = functionName;
        this.args = args;
    }
    static IsFunctionCall(x) {
        if (x instanceof FunctionCall) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "FunctionCall") &&
            (typeof mixed.functionName == "string") &&
            /**
             * @todo Debate if we should check each element is `FunctionArg`
             * Safer, but slower.
             */
            (Array.isArray(mixed.args)) &&
            (typeof mixed.toSql == "function"));
    }
}
exports.FunctionCall = FunctionCall;
function functionArg(ast) {
    if (FunctionArg.IsFunctionArg(ast)) {
        return ast;
    }
    return new FunctionArg(ast);
}
exports.functionArg = functionArg;
function functionCall(functionName, args) {
    return new FunctionCall(functionName, args.map(functionArg));
}
exports.functionCall = functionCall;
//# sourceMappingURL=function-call.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/identifier-node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/identifier-node.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function identifierNode(...identifiers) {
    return {
        type: "Identifier",
        identifiers,
    };
}
exports.identifierNode = identifierNode;
/**
 * Does not check that each element of the `identifiers` property is a `string`
 *
 * @param mixed
 */
function isIdentifierNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "identifiers",
    ])) {
        return false;
    }
    return (mixed.type === "Identifier" &&
        Array.isArray(mixed.identifiers) &&
        mixed.identifiers.length >= 1);
}
exports.isIdentifierNode = isIdentifierNode;
//# sourceMappingURL=identifier-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition-node */ "./node_modules/@squill/squill/dist/ast/case-condition-node/index.js"));
__export(__webpack_require__(/*! ./case-value-node */ "./node_modules/@squill/squill/dist/ast/case-value-node/index.js"));
__export(__webpack_require__(/*! ./literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js"));
__export(__webpack_require__(/*! ./operator-node */ "./node_modules/@squill/squill/dist/ast/operator-node/index.js"));
__export(__webpack_require__(/*! ./sqlfier */ "./node_modules/@squill/squill/dist/ast/sqlfier/index.js"));
__export(__webpack_require__(/*! ./function-call */ "./node_modules/@squill/squill/dist/ast/function-call.js"));
__export(__webpack_require__(/*! ./identifier-node */ "./node_modules/@squill/squill/dist/ast/identifier-node.js"));
__export(__webpack_require__(/*! ./parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js"));
const AstUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/util/index.js");
exports.AstUtil = AstUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js"));
const LiteralValueNodeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/index.js");
exports.LiteralValueNodeUtil = LiteralValueNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//import {BuiltInValueExpr} from "../../built-in-value-expr";
//import * as tm from "type-mapping";
Object.defineProperty(exports, "__esModule", { value: true });
var LiteralValueType;
(function (LiteralValueType) {
    /**
     * Can only be created using the `decimalLiteral()` function
     */
    LiteralValueType["DECIMAL"] = "DECIMAL";
    /**
     * ```ts
     * typeof x == "string"
     * ```
     */
    LiteralValueType["STRING"] = "STRING";
    /**
     * ```ts
     * typeof x == "number"
     * ```
     */
    LiteralValueType["DOUBLE"] = "DOUBLE";
    /**
     * ```ts
     * tm.TypeUtil.isBigInt(x) &&
     * //bigint signed minimum value
     * tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
     * //bigint signed maximum value
     * tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807"))
     * ```
     */
    LiteralValueType["BIGINT_SIGNED"] = "BIGINT_SIGNED";
    /**
     * ```ts
     * typeof x == "boolean"
     * ```
     */
    LiteralValueType["BOOLEAN"] = "BOOLEAN";
    /**
     * An unsigned char array (8-bit unsigned integer)
     * ```ts
     * x instanceof Uint8Array
     * ```
     * @todo Rename this to `UINT8ARRAY`?
     */
    LiteralValueType["BUFFER"] = "BUFFER";
    /**
     * ```ts
     * x === null
     * ```
     */
    LiteralValueType["NULL"] = "NULL";
    /**
     * ```ts
     * DateUtil.isDate(x)
     * ```
     */
    LiteralValueType["DATE_TIME"] = "DATE_TIME";
})(LiteralValueType = exports.LiteralValueType || (exports.LiteralValueType = {}));
exports.literalValueTypeElements = Object.values(LiteralValueType);
//# sourceMappingURL=literal-value-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function isBigIntSigned(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint signed minimum value
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
        //bigint signed maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807")));
}
exports.isBigIntSigned = isBigIntSigned;
/**
 * @todo Remove
 * @deprecated
 */
function isBigIntUnsigned(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint unsigned minimum value
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("0")) &&
        //bigint unsigned maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
}
exports.isBigIntUnsigned = isBigIntUnsigned;
function isBigIntSignedLiteral(x) {
    return isBigIntSigned(x);
}
exports.isBigIntSignedLiteral = isBigIntSignedLiteral;
/**
 * @todo Remove
 * @deprecated
 */
function isBigIntUnsignedLiteral(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (
    //bigint signed maximum value + 1
    tm.BigIntUtil.greaterThanOrEqual(x, BigInt("9223372036854775808")) &&
        //bigint unsigned maximum value
        tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
}
exports.isBigIntUnsignedLiteral = isBigIntUnsignedLiteral;
function bigIntSignedLiteralNode(literalValue) {
    if (isBigIntSignedLiteral(literalValue)) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_1.LiteralValueType.BIGINT_SIGNED,
            literalValue,
        };
    }
    else {
        //Can only really be an `BIGINT UNSIGNED` or `DECIMAL` value
        throw new Error(`Literal value is too small/large to be a signed bigint; consider using BIGINT UNSIGNED or DECIMAL`);
    }
}
exports.bigIntSignedLiteralNode = bigIntSignedLiteralNode;
//# sourceMappingURL=bigint-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function booleanLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.BOOLEAN,
        literalValue,
    };
}
exports.booleanLiteralNode = booleanLiteralNode;
//# sourceMappingURL=boolean-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function bufferLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.BUFFER,
        literalValue,
    };
}
exports.bufferLiteralNode = bufferLiteralNode;
//# sourceMappingURL=buffer-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function dateTimeLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DATE_TIME,
        literalValue,
    };
}
exports.dateTimeLiteralNode = dateTimeLiteralNode;
//# sourceMappingURL=date-time-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
const ExprLib = __webpack_require__(/*! ../../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function decimalLiteralNode(rawDecimalLiteral, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const mapper = tm.mysql.decimal(precision, scale);
    const decimalDefinition = ExprLib.assertValidDecimalPrecisionAndScale(precision, scale);
    const literalValue = mapper("rawDecimalLiteral", rawDecimalLiteral).toString();
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DECIMAL,
        literalValue,
        precision: decimalDefinition.precision,
        scale: decimalDefinition.scale,
    };
}
exports.decimalLiteralNode = decimalLiteralNode;
//# sourceMappingURL=decimal-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/double-literal-node.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/double-literal-node.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function doubleLiteralNode(literalValue) {
    /**
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    /*
    if (!isFinite(literalValue)) {
        throw new Error(`Double literal must be finite`);
    }
    */
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.DOUBLE,
        literalValue,
    };
}
exports.doubleLiteralNode = doubleLiteralNode;
//# sourceMappingURL=double-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/bigint-literal-node.js"));
__export(__webpack_require__(/*! ./boolean-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/boolean-literal-node.js"));
__export(__webpack_require__(/*! ./buffer-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/buffer-literal-node.js"));
__export(__webpack_require__(/*! ./date-time-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/date-time-literal-node.js"));
__export(__webpack_require__(/*! ./decimal-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/decimal-literal-node.js"));
__export(__webpack_require__(/*! ./double-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/double-literal-node.js"));
__export(__webpack_require__(/*! ./null-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/null-literal-node.js"));
__export(__webpack_require__(/*! ./string-literal-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/string-literal-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/null-literal-node.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/null-literal-node.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function nullLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.NULL,
        literalValue,
    };
}
exports.nullLiteralNode = nullLiteralNode;
//# sourceMappingURL=null-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/string-literal-node.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/string-literal-node.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
function stringLiteralNode(literalValue) {
    return {
        type: "LiteralValue",
        literalValueType: literal_value_node_1.LiteralValueType.STRING,
        literalValue,
    };
}
exports.stringLiteralNode = stringLiteralNode;
//# sourceMappingURL=string-literal-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/literal-value-node/util/predicate/is-literal-value-node.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const literal_value_node_1 = __webpack_require__(/*! ../../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/literal-value-node.js");
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
/**
 * Does not check for `precision` and `scale` for `DecimalLiteralNode`.
 * Just assumes it exists.
 */
function isLiteralValueNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "literalValueType",
        "literalValue"
    ])) {
        return false;
    }
    return (mixed.type === "LiteralValue" &&
        literal_value_node_1.literalValueTypeElements.includes(mixed.literalValueType));
}
exports.isLiteralValueNode = isLiteralValueNode;
//# sourceMappingURL=is-literal-value-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OperatorNodeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/operator-node/util/index.js");
exports.OperatorNodeUtil = OperatorNodeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operator-node-0 */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-0.js"));
__export(__webpack_require__(/*! ./operator-node-1-to-n */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js"));
__export(__webpack_require__(/*! ./operator-node-1 */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1.js"));
__export(__webpack_require__(/*! ./operator-node-2-to-n */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js"));
__export(__webpack_require__(/*! ./operator-node-2 */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2.js"));
__export(__webpack_require__(/*! ./operator-node-3 */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-3.js"));
__export(__webpack_require__(/*! ./operator-node */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-0.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-0.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode0(operatorType, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: [],
        typeHint,
    };
}
exports.operatorNode0 = operatorNode0;
//# sourceMappingURL=operator-node-0.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1-to-n.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode1ToN(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode1ToN = operatorNode1ToN;
//# sourceMappingURL=operator-node-1-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-1.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode1(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode1 = operatorNode1;
//# sourceMappingURL=operator-node-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2-to-n.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode2ToN(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode2ToN = operatorNode2ToN;
//# sourceMappingURL=operator-node-2-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-2.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode2(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode2 = operatorNode2;
//# sourceMappingURL=operator-node-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-3.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node-3.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode3(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands: operands,
        typeHint,
    };
}
exports.operatorNode3 = operatorNode3;
//# sourceMappingURL=operator-node-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/operator-node.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function operatorNode(operatorType, operands, typeHint) {
    return {
        type: "Operator",
        operatorType,
        operands,
        typeHint,
    };
}
exports.operatorNode = operatorNode;
//# sourceMappingURL=operator-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/ast/operator-node/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-operator-node */ "./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/is-operator-node.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/is-operator-node.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/operator-node/util/predicate/is-operator-node.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function isOperatorNode(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "type",
        "operatorType",
        "operands",
        "typeHint"
    ])) {
        return false;
    }
    return (mixed.type === "Operator");
}
exports.isOperatorNode = isOperatorNode;
//# sourceMappingURL=is-operator-node.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/parentheses.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/parentheses.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AstUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/ast/util/index.js");
const function_call_1 = __webpack_require__(/*! ./function-call */ "./node_modules/@squill/squill/dist/ast/function-call.js");
const identifier_node_1 = __webpack_require__(/*! ./identifier-node */ "./node_modules/@squill/squill/dist/ast/identifier-node.js");
const literal_value_node_1 = __webpack_require__(/*! ./literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
function shouldWrap(ast, canUnwrap) {
    if (Parentheses.IsParentheses(ast)) {
        if (!canUnwrap && ast.canUnwrap) {
            return true;
        }
        else {
            return false;
        }
    }
    if (function_call_1.FunctionCall.IsFunctionCall(ast)) {
        return false;
    }
    if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
        return false;
    }
    if (identifier_node_1.isIdentifierNode(ast)) {
        return false;
    }
    if (typeof ast == "string") {
        return false;
    }
    if (Array.isArray(ast)) {
        if (ast.length == 0) {
            throw new Error(`Attempt to add parentheses around empty query tree`);
        }
        else if (ast.length == 1) {
            return shouldWrap(ast[0], canUnwrap);
        }
        else {
            return true;
        }
    }
    return true;
}
class Parentheses {
    constructor(ast, canUnwrap) {
        this.type = "Parentheses";
        this.toSql = (sqlfier) => {
            /**
             * @todo Investigate this logic
             */
            const sqlAst = (sqlfier.parenthesesSqlfier == undefined ?
                AstUtil.toSqlAst(this.ast, sqlfier) :
                sqlfier.parenthesesSqlfier(this, (ast2) => AstUtil.toSql(ast2, sqlfier), sqlfier));
            if (!this.canUnwrap || shouldWrap(sqlAst, this.canUnwrap)) {
                return `(${AstUtil.toSql(sqlAst, sqlfier)})`;
            }
            else {
                return AstUtil.toSql(sqlAst, sqlfier);
            }
        };
        this.ast = ast;
        this.canUnwrap = canUnwrap;
    }
    static IsParentheses(x) {
        if (x instanceof Parentheses) {
            return true;
        }
        if (x == undefined) {
            return false;
        }
        const mixed = x;
        return ((mixed.type == "Parentheses") &&
            /**
             * @todo Debate if this is necessary.
             * Safer, but slower.
             */
            //AstUtil.isAst(mixed.ast) &&
            (typeof mixed.canUnwrap == "boolean") &&
            (typeof mixed.toSql == "function"));
    }
    static Create(ast, canUnwrap = true) {
        if (shouldWrap(ast, canUnwrap)) {
            if (Parentheses.IsParentheses(ast)) {
                return new Parentheses(ast.ast, canUnwrap);
            }
            else {
                return new Parentheses(ast, canUnwrap);
            }
        }
        else {
            return ast;
        }
    }
}
exports.Parentheses = Parentheses;
function parentheses(ast, canUnwrap) {
    return Parentheses.Create(ast, canUnwrap);
}
exports.parentheses = parentheses;
//# sourceMappingURL=parentheses.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/sqlfier/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/sqlfier/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./not-implemented-sqlfier */ "./node_modules/@squill/squill/dist/ast/sqlfier/not-implemented-sqlfier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/sqlfier/not-implemented-sqlfier.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/sqlfier/not-implemented-sqlfier.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const notImplemented = () => {
    throw new Error(`Not implemented`);
};
const operatorNotImplemented = (operatorNode) => {
    throw new Error(`Not implemented ${operatorNode.operatorType}`);
};
const literalValueNotImplemented = (literalValueNode) => {
    throw new Error(`Not implemented ${literalValueNode.literalValueType}`);
};
exports.notImplementedSqlfier = {
    identifierSqlfier: notImplemented,
    literalValueSqlfier: Object
        .values(literal_value_node_1.LiteralValueType)
        .reduce((memo, literalValueType) => {
        memo[literalValueType] = literalValueNotImplemented;
        return memo;
    }, {}),
    operatorSqlfier: Object
        .values(operator_type_1.OperatorType)
        .reduce((memo, operatorType) => {
        memo[operatorType] = operatorNotImplemented;
        return memo;
    }, {}),
    queryBaseSqlfier: notImplemented,
    caseValueSqlfier: notImplemented,
    caseConditionSqlfier: notImplemented,
};
//# sourceMappingURL=not-implemented-sqlfier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-between */ "./node_modules/@squill/squill/dist/ast/util/insert-between.js"));
__export(__webpack_require__(/*! ./is-ast */ "./node_modules/@squill/squill/dist/ast/util/is-ast.js"));
__export(__webpack_require__(/*! ./to-sql-pretty */ "./node_modules/@squill/squill/dist/ast/util/to-sql-pretty.js"));
__export(__webpack_require__(/*! ./to-sql */ "./node_modules/@squill/squill/dist/ast/util/to-sql.js"));
__export(__webpack_require__(/*! ./try-extract-ast */ "./node_modules/@squill/squill/dist/ast/util/try-extract-ast.js"));
__export(__webpack_require__(/*! ./try-unwrap-parentheses */ "./node_modules/@squill/squill/dist/ast/util/try-unwrap-parentheses.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/insert-between.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/insert-between.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function insertBetween(operands, insertElement) {
    const result = [];
    for (const operand of operands) {
        if (result.length > 0) {
            result.push(insertElement);
        }
        result.push(operand);
    }
    return result;
}
exports.insertBetween = insertBetween;
//# sourceMappingURL=insert-between.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/is-ast.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/is-ast.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js");
const function_call_1 = __webpack_require__(/*! ../function-call */ "./node_modules/@squill/squill/dist/ast/function-call.js");
const operator_node_1 = __webpack_require__(/*! ../operator-node */ "./node_modules/@squill/squill/dist/ast/operator-node/index.js");
const identifier_node_1 = __webpack_require__(/*! ../identifier-node */ "./node_modules/@squill/squill/dist/ast/identifier-node.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const case_value_node_1 = __webpack_require__(/*! ../case-value-node */ "./node_modules/@squill/squill/dist/ast/case-value-node/index.js");
const case_condition_node_1 = __webpack_require__(/*! ../case-condition-node */ "./node_modules/@squill/squill/dist/ast/case-condition-node/index.js");
/**
 * A type guard for the `Ast` type
 *
 * @param raw
 */
function isAst(raw) {
    if (typeof raw == "string") {
        return true;
    }
    if (parentheses_1.Parentheses.IsParentheses(raw)) {
        return true;
    }
    if (function_call_1.FunctionCall.IsFunctionCall(raw)) {
        return true;
    }
    if (operator_node_1.OperatorNodeUtil.isOperatorNode(raw)) {
        return true;
    }
    if (identifier_node_1.isIdentifierNode(raw)) {
        return true;
    }
    if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(raw)) {
        return true;
    }
    if (Array.isArray(raw)) {
        for (const item of raw) {
            if (!isAst(item)) {
                return false;
            }
        }
        return true;
    }
    if (query_base_1.QueryBaseUtil.isQuery(raw)) {
        return true;
    }
    if (case_value_node_1.CaseValueNodeUtil.isCaseValueNode(raw)) {
        return true;
    }
    if (case_condition_node_1.CaseConditionNodeUtil.isCaseConditionNode(raw)) {
        return true;
    }
    return false;
}
exports.isAst = isAst;
//# sourceMappingURL=is-ast.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/to-sql-pretty.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/to-sql-pretty.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const formatter_1 = __webpack_require__(/*! ../../formatter */ "./node_modules/@squill/squill/dist/formatter/index.js");
const to_sql_1 = __webpack_require__(/*! ./to-sql */ "./node_modules/@squill/squill/dist/ast/util/to-sql.js");
/**
 * Converts an AST to a SQL string.
 *
 * Prettifies the output.
 *
 * -----
 *
 * Perfomance is generally "okay" but when queries become
 * hundreds of thousands of characters long,
 * it can take a long time.
 *
 * Use this with caution.
 *
 * @param ast
 */
function toSqlPretty(ast, sqlfier, tokenizerConfig) {
    const sql = to_sql_1.toSql(ast, sqlfier);
    return new formatter_1.SqlFormatter(undefined, tokenizerConfig).format(sql);
}
exports.toSqlPretty = toSqlPretty;
//# sourceMappingURL=to-sql-pretty.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/to-sql.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/to-sql.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js");
const function_call_1 = __webpack_require__(/*! ../function-call */ "./node_modules/@squill/squill/dist/ast/function-call.js");
const operator_node_1 = __webpack_require__(/*! ../operator-node */ "./node_modules/@squill/squill/dist/ast/operator-node/index.js");
const identifier_node_1 = __webpack_require__(/*! ../identifier-node */ "./node_modules/@squill/squill/dist/ast/identifier-node.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const case_value_node_1 = __webpack_require__(/*! ../case-value-node */ "./node_modules/@squill/squill/dist/ast/case-value-node/index.js");
const case_condition_node_1 = __webpack_require__(/*! ../case-condition-node */ "./node_modules/@squill/squill/dist/ast/case-condition-node/index.js");
function toSqlAst(ast, sqlfier) {
    if (typeof ast == "string") {
        return ast;
    }
    else if (parentheses_1.Parentheses.IsParentheses(ast)) {
        return ast.toSql(sqlfier);
    }
    else if (function_call_1.FunctionCall.IsFunctionCall(ast)) {
        return ast.toSql(sqlfier);
    }
    else if (operator_node_1.OperatorNodeUtil.isOperatorNode(ast)) {
        return sqlfier.operatorSqlfier[ast.operatorType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (identifier_node_1.isIdentifierNode(ast)) {
        return sqlfier.identifierSqlfier(ast);
    }
    else if (query_base_1.QueryBaseUtil.isQuery(ast)) {
        return sqlfier.queryBaseSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
        return sqlfier.literalValueSqlfier[ast.literalValueType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (case_value_node_1.CaseValueNodeUtil.isCaseValueNode(ast)) {
        return sqlfier.caseValueSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else if (case_condition_node_1.CaseConditionNodeUtil.isCaseConditionNode(ast)) {
        return sqlfier.caseConditionSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
    }
    else {
        return ast.map(subAst => toSql(subAst, sqlfier)).join(" ");
    }
}
exports.toSqlAst = toSqlAst;
/**
 * Converts an AST to a SQL string.
 *
 * **DOES NOT** prettify the output.
 *
 * @see {@link toSqlPretty} for prettified output.
 *
 * @param ast
 */
function toSql(ast, sqlfier) {
    const result = toSqlAst(ast, sqlfier);
    if (typeof result == "string") {
        return result;
    }
    else {
        return toSql(result, sqlfier);
    }
}
exports.toSql = toSql;
//# sourceMappingURL=to-sql.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/try-extract-ast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/try-extract-ast.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js");
/**
 * + If the AST satisfies the predicate, it is returned.
 * + If the AST is a `Parentheses` that contains an AST satisfying the predicate,
 * the `Parentheses` is returned.
 * + Else, `undefined` is returned.
 */
function tryExtractAst(operand, extractDelegate) {
    const extractResult = extractDelegate(operand);
    if (extractResult != undefined) {
        if (typeof extractResult == "boolean") {
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (extractResult) {
                return operand;
            }
        }
        else {
            return extractResult;
        }
    }
    if (parentheses_1.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
        return tryExtractAst(operand.ast, extractDelegate);
    }
    return undefined;
}
exports.tryExtractAst = tryExtractAst;
function tryExtractAstOr(operand, extractDelegate, noMatchDelegate) {
    const extractResult = extractDelegate(operand);
    if (extractResult != undefined) {
        if (typeof extractResult == "boolean") {
            if (extractResult) {
                return operand;
            }
        }
        else {
            return extractResult;
        }
    }
    if (parentheses_1.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
        return tryExtractAstOr(operand.ast, extractDelegate, noMatchDelegate);
    }
    return noMatchDelegate(operand);
}
exports.tryExtractAstOr = tryExtractAstOr;
//# sourceMappingURL=try-extract-ast.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/ast/util/try-unwrap-parentheses.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/ast/util/try-unwrap-parentheses.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const parentheses_1 = __webpack_require__(/*! ../parentheses */ "./node_modules/@squill/squill/dist/ast/parentheses.js");
function tryUnwrapParentheses(ast) {
    if (parentheses_1.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
        return ast.ast;
    }
    else {
        return ast;
    }
}
exports.tryUnwrapParentheses = tryUnwrapParentheses;
//# sourceMappingURL=try-unwrap-parentheses.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/async-queue.js":
/*!*********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/async-queue.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const promise_util_1 = __webpack_require__(/*! ./promise-util */ "./node_modules/@squill/squill/dist/promise-util/index.js");
const emptyPromise = Promise.resolve();
class AsyncQueueStoppingError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, AsyncQueueStoppingError.prototype);
    }
}
exports.AsyncQueueStoppingError = AsyncQueueStoppingError;
AsyncQueueStoppingError.prototype.name = "AsyncQueueStoppingError";
/**
 * Only one `ItemT` can be allocated at a time.
 * Only one enqueued callback can be running at a time.
 *
 * This can be used to implement `IConnection.lock()`
 */
class AsyncQueue {
    constructor(allocateDelegate) {
        this.shouldStop = false;
        this.lastPromise = emptyPromise;
        this.deallocateErr = undefined;
        /**
         * Enqueues a callback that will be run asynchronously.
         *
         * Only one callback will be running at any given time.
         */
        this.enqueue = (callback) => {
            if (this.shouldStop) {
                return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
            }
            if (this.deallocateErr != undefined) {
                /**
                 * We should not enqueue anymore callbacks,
                 * our allocator/deallocator has run into problems.
                 */
                return Promise.reject(this.deallocateErr);
            }
            const tryResetQueue = () => {
                if (this.lastPromise == callbackPromise) {
                    this.lastPromise = emptyPromise;
                }
            };
            const runCallback = () => {
                /**
                 * It's okay if this throws because we execute
                 * `runCallback` inside of a `.then()`
                 */
                const { item, deallocate } = this.allocateDelegate();
                return promise_util_1.invokeAsyncCallbackSafely(() => callback(item), (result) => {
                    return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                        tryResetQueue();
                        return result;
                    }, (deallocateErr) => {
                        tryResetQueue();
                        this.deallocateErr = deallocateErr;
                        return result;
                    });
                }, (callbackErr) => {
                    return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                        tryResetQueue();
                        return Promise.reject(callbackErr);
                    }, (deallocateErr) => {
                        tryResetQueue();
                        this.deallocateErr = deallocateErr;
                        return Promise.reject(callbackErr);
                    });
                });
            };
            const callbackPromise = this.lastPromise.then(runCallback, runCallback);
            this.lastPromise = callbackPromise;
            return callbackPromise;
        };
        /**
         * This makes all future calls to `.enqueue()` throw a run-time error.
         *
         * Returns a promise that resolves when the last enqueued
         * callback resolves.
         */
        this.stop = () => {
            this.shouldStop = true;
            return this.lastPromise.then(() => { }, () => { });
        };
        /**
         * Enqueues a callback that will be run asynchronously.
         * This callback will be given another `AsyncQueue` instance.
         *
         * This `AsyncQueue` will wait for the other instance to
         * complete before continuing.
         *
         * Only one callback will be running at any given time.
         */
        this.lock = (callback) => {
            if (this.shouldStop) {
                return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
            }
            if (this.deallocateErr != undefined) {
                /**
                 * We should not enqueue anymore callbacks,
                 * our allocator/deallocator has run into problems.
                 */
                return Promise.reject(this.deallocateErr);
            }
            const tryResetQueue = () => {
                if (this.lastPromise == callbackPromise) {
                    this.lastPromise = emptyPromise;
                }
            };
            const runCallback = () => {
                const nestedAsyncQueue = new AsyncQueue(this.allocateDelegate);
                return promise_util_1.invokeAsyncCallbackSafely(() => callback(nestedAsyncQueue), (result) => {
                    const onStop = () => {
                        tryResetQueue();
                        /**
                         * Copy over the `deallocateErr` because
                         * they share the same `allocateDelegate`
                         */
                        this.deallocateErr = nestedAsyncQueue.deallocateErr;
                        return result;
                    };
                    /**
                     * Calling `.stop()` should never throw a synchronous error...
                     * I think.
                     */
                    return nestedAsyncQueue.stop()
                        .then(onStop, onStop);
                }, (callbackErr) => {
                    const onStop = () => {
                        tryResetQueue();
                        /**
                         * Copy over the `deallocateErr` because
                         * they share the same `allocateDelegate`
                         */
                        this.deallocateErr = nestedAsyncQueue.deallocateErr;
                        return Promise.reject(callbackErr);
                    };
                    /**
                     * Calling `.stop()` should never throw a synchronous error...
                     * I think.
                     */
                    return nestedAsyncQueue.stop()
                        .then(onStop, onStop);
                });
            };
            const callbackPromise = this.lastPromise.then(runCallback, runCallback);
            this.lastPromise = callbackPromise;
            return callbackPromise;
        };
        this.allocateDelegate = allocateDelegate;
    }
    getShouldStop() {
        return this.shouldStop;
    }
}
exports.AsyncQueue = AsyncQueue;
//# sourceMappingURL=async-queue.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BuiltInExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/built-in-expr/util/index.js");
exports.BuiltInExprUtil = BuiltInExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js");
const from_value_expr_1 = __webpack_require__(/*! ./from-value-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-value-expr.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
 * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
 */
function fromCustomExpr_MapCorrelated(mapper, allowed, customExpr) {
    if (predicate_1.isAnyNonValueExpr(customExpr)) {
        used_ref_1.UsedRefUtil.assertAllowed(allowed, query_1.usedRef(customExpr));
        return customExpr;
    }
    else {
        return from_value_expr_1.fromValueExpr(mapper, customExpr);
    }
}
exports.fromCustomExpr_MapCorrelated = fromCustomExpr_MapCorrelated;
//# sourceMappingURL=from-custom-expr-map-correlated.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-value-expr.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-value-expr.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
 * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
 */
function fromValueExpr(mapper, value) {
    let valueName = "literal-value";
    if (column_1.ColumnUtil.isColumn(mapper)) {
        valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
        mapper = mapper.mapper;
    }
    if (data_type_1.DataTypeUtil.isDataType(mapper)) {
        return mapper.toBuiltInExpr_NonCorrelated(
        /**
         * Validate the incoming value again, just to be sure...
         */
        mapper(valueName, value));
    }
    else {
        if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(value)) {
            return mapper(valueName, value);
        }
        else {
            /**
             * @todo Custom `Error` type
             */
            throw new Error(`Don't know how to convert ${tm.TypeUtil.toTypeStr(value)} value with keys ${Object.keys(value).map(k => JSON.stringify(k)).join(", ")} to RawExpr`);
        }
    }
}
exports.fromValueExpr = fromValueExpr;
//# sourceMappingURL=from-value-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/constructor/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-custom-expr-map-correlated */ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-custom-expr-map-correlated.js"));
__export(__webpack_require__(/*! ./from-value-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/from-value-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/built-in-expr/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/build-ast.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/operation/build-ast.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "./node_modules/@squill/squill/dist/date-util/index.js");
/**
 * + `bigint` is considered a `signed bigint` by this library.
 * +`DECIMAL` is not supported by this function.
 * +`BIGINT UNSIGNED` is not supported by this function.
 */
function buildAst(builtInExpr) {
    //Check built-in cases first
    if (typeof builtInExpr == "number") {
        return ast_1.LiteralValueNodeUtil.doubleLiteralNode(builtInExpr);
    }
    if (tm.TypeUtil.isBigInt(builtInExpr)) {
        return ast_1.LiteralValueNodeUtil.bigIntSignedLiteralNode(builtInExpr);
    }
    if (typeof builtInExpr == "string") {
        return ast_1.LiteralValueNodeUtil.stringLiteralNode(builtInExpr);
    }
    if (typeof builtInExpr == "boolean") {
        return ast_1.LiteralValueNodeUtil.booleanLiteralNode(builtInExpr);
    }
    if (date_util_1.isDate(builtInExpr)) {
        return ast_1.LiteralValueNodeUtil.dateTimeLiteralNode(builtInExpr);
    }
    if (builtInExpr instanceof Uint8Array) {
        //escape(Buffer.from("hello")) == "X'68656c6c6f'"
        return ast_1.LiteralValueNodeUtil.bufferLiteralNode(builtInExpr);
    }
    if (builtInExpr === null) {
        return ast_1.LiteralValueNodeUtil.nullLiteralNode(builtInExpr);
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.ast;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return column_1.ColumnUtil.buildAst(builtInExpr);
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(builtInExpr)) {
        /**
         * @todo Check if this is desirable
         */
        //return builtInExpr.buildExprAst();
        return ast_1.parentheses(builtInExpr, false /*canUnwrap*/);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        /**
         * @todo Check if this is desirable.
         * If anything, the `query` ast, when used as a value query,
         * should wrap an unwrappable parentheses around itself.
         */
        //return Parentheses.Create(builtInExpr.unaliasedAst, false/*canUnwrap*/);
        return ast_1.parentheses(builtInExpr.unaliasedAst);
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.buildAst = buildAst;
//# sourceMappingURL=build-ast.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./build-ast */ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/build-ast.js"));
__export(__webpack_require__(/*! ./intersect-used-ref */ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/intersect-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/operation/intersect-used-ref.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/operation/intersect-used-ref.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function intersectUsedRef(...arr) {
    const result = used_ref_1.UsedRefUtil.intersect(...arr.map(u => query_1.usedRef(u)));
    return result;
}
exports.intersectUsedRef = intersectUsedRef;
//# sourceMappingURL=intersect-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-aggregate.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-aggregate.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js");
function assertNonAggregate(name, builtInExpr) {
    if (query_1.isAggregate(builtInExpr)) {
        throw new Error(`${name} must not be an aggregate expression`);
    }
}
exports.assertNonAggregate = assertNonAggregate;
function assertAllNonAggregate(name, builtInExprArr) {
    for (let i = 0; i < builtInExprArr.length; ++i) {
        assertNonAggregate(`${name}[${i}]`, builtInExprArr[i]);
    }
}
exports.assertAllNonAggregate = assertAllNonAggregate;
//# sourceMappingURL=assert-non-aggregate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-null.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-null.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js");
/**
 * @todo Rename to `assertNonNullable`
 */
function assertNonNull(name, builtInExpr) {
    if (tm.canOutputNull(query_1.mapper(builtInExpr))) {
        throw new Error(`${name} must not be nullable`);
    }
}
exports.assertNonNull = assertNonNull;
//# sourceMappingURL=assert-non-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-non-aggregate */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-aggregate.js"));
__export(__webpack_require__(/*! ./assert-non-null */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/assert-non-null.js"));
__export(__webpack_require__(/*! ./is-any-non-value-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-non-value-expr.js"));
__export(__webpack_require__(/*! ./is-any-subquery-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-subquery-expr.js"));
__export(__webpack_require__(/*! ./is-built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-non-value-expr.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-non-value-expr.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
function isAnyNonValueExpr(mixed) {
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mixed)) {
        return false;
    }
    if (expr_1.ExprUtil.isExpr(mixed)) {
        return true;
    }
    if (column_1.ColumnUtil.isColumn(mixed)) {
        return true;
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(mixed)) {
        return true;
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(mixed)) {
        return true;
    }
    return false;
}
exports.isAnyNonValueExpr = isAnyNonValueExpr;
//# sourceMappingURL=is-any-non-value-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-subquery-expr.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-subquery-expr.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
function isAnySubqueryExpr(x) {
    return query_base_1.QueryBaseUtil.isOneSelectItem(x) && query_base_1.QueryBaseUtil.isZeroOrOneRow(x);
}
exports.isAnySubqueryExpr = isAnySubqueryExpr;
//# sourceMappingURL=is-any-subquery-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-built-in-expr.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-built-in-expr.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const is_any_non_value_expr_1 = __webpack_require__(/*! ./is-any-non-value-expr */ "./node_modules/@squill/squill/dist/built-in-expr/util/predicate/is-any-non-value-expr.js");
function isBuiltInExpr(raw) {
    return (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(raw) ||
        is_any_non_value_expr_1.isAnyNonValueExpr(raw));
}
exports.isBuiltInExpr = isBuiltInExpr;
//# sourceMappingURL=is-built-in-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/query/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-aggregate */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/is-aggregate.js"));
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/mapper.js"));
__export(__webpack_require__(/*! ./used-ref */ "./node_modules/@squill/squill/dist/built-in-expr/util/query/used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/query/is-aggregate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/query/is-aggregate.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isAggregate(builtInExpr) {
    if (builtInExpr instanceof Object &&
        "isAggregate" in builtInExpr &&
        typeof builtInExpr.isAggregate == "boolean") {
        return builtInExpr.isAggregate;
    }
    /**
     * If this came from the`SELECT` clause,
     * it may be an aggregate expression, or a non-aggregate expression.
     *
     * We need to know if this is an aggregate expression to avoid the following query,
     * ```sql
     *  SELECT
     *      COUNT(*) AS x
     *  FROM
     *      T
     *  GROUP BY
     *      id
     *  ORDER BY
     *      -- Error, Cannot nest aggregate expressions
     *      SUM(x) ASC;
     * ```
     *
     * @todo Fix the `OrderByDelegate` to not use `ColumnRef`
     */
    return false;
}
exports.isAggregate = isAggregate;
//# sourceMappingURL=is-aggregate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/query/mapper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/query/mapper.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "./node_modules/@squill/squill/dist/date-util/index.js");
function mapper(builtInExpr) {
    //Check built-in cases first
    if (typeof builtInExpr == "number") {
        /**
         * The SQL standard forbids NaN, Infinity, -Infinity.
         * However, SQLite supports infinities.
         *
         * The job of throwing on these 3 values will have to
         * fall to the sqlfiers.
         */
        return tm.toUnsafeNumber();
    }
    if (tm.TypeUtil.isBigInt(builtInExpr)) {
        return tm.toBigInt();
    }
    if (typeof builtInExpr == "string") {
        return tm.string();
    }
    if (typeof builtInExpr == "boolean") {
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        builtInExpr ?
            tm.mysql.true() :
            tm.mysql.false());
    }
    if (date_util_1.isDate(builtInExpr)) {
        return tm.mysql.dateTime(3);
    }
    if (builtInExpr instanceof Uint8Array) {
        return tm.instanceOfUint8Array();
    }
    if (builtInExpr === null) {
        return tm.null();
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.mapper;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return builtInExpr.mapper;
    }
    if (query_base_1.QueryBaseUtil.isOneSelectItem(builtInExpr) &&
        query_base_1.QueryBaseUtil.isZeroOrOneRow(builtInExpr)) {
        return query_base_1.QueryBaseUtil.mapper(builtInExpr);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return builtInExpr.mapper;
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-expr/util/query/used-ref.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-expr/util/query/used-ref.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
function usedRef(builtInExpr) {
    //Check built-in cases first
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromColumnRef({});
    }
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return builtInExpr.usedRef;
    }
    if (column_1.ColumnUtil.isColumn(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromColumn(builtInExpr);
    }
    if (query_base_1.QueryBaseUtil.isQuery(builtInExpr)) {
        return used_ref_1.UsedRefUtil.fromFromClause(builtInExpr.fromClause);
    }
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return builtInExpr.usedRef;
    }
    throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
}
exports.usedRef = usedRef;
//# sourceMappingURL=used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/array-util/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-non-null-built-in-value-expr-array */ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js"));
__export(__webpack_require__(/*! ./is-built-in-value-expr-array */ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-built-in-value-expr-array.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_built_in_value_expr_1 = __webpack_require__(/*! ../../util/predicate/is-built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js");
function isBuiltInValueExprArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!is_built_in_value_expr_1.isBuiltInValueExpr(item)) {
            return false;
        }
    }
    return true;
}
exports.isBuiltInValueExprArray = isBuiltInValueExprArray;
//# sourceMappingURL=is-built-in-value-expr-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_non_null_built_in_value_expr_1 = __webpack_require__(/*! ../../util/predicate/is-non-null-built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js");
function isNonNullBuiltInValueExprArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!is_non_null_built_in_value_expr_1.isNonNullBuiltInValueExpr(item)) {
            return false;
        }
    }
    return true;
}
exports.isNonNullBuiltInValueExprArray = isNonNullBuiltInValueExprArray;
//# sourceMappingURL=is-non-null-built-in-value-expr-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BuiltInValueExprArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/built-in-value-expr/array-util/index.js");
exports.BuiltInValueExprArrayUtil = BuiltInValueExprArrayUtil;
const BuiltInValueExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/index.js");
exports.BuiltInValueExprUtil = BuiltInValueExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/util/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/util/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-equal */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-equal.js"));
__export(__webpack_require__(/*! ./is-non-null-built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js"));
__export(__webpack_require__(/*! ./is-built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "./node_modules/@squill/squill/dist/date-util/index.js");
function isBuiltInValueExpr(raw) {
    if (tm.TypeUtil.isBigInt(raw)) {
        return true;
    }
    switch (typeof raw) {
        case "number":
        case "string":
        case "boolean": {
            return true;
        }
    }
    if (date_util_1.isDate(raw)) {
        return true;
    }
    if (raw instanceof Uint8Array) {
        return true;
    }
    if (raw === null) {
        return true;
    }
    return false;
}
exports.isBuiltInValueExpr = isBuiltInValueExpr;
//# sourceMappingURL=is-built-in-value-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-equal.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-equal.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const date_util_1 = __webpack_require__(/*! ../../../date-util */ "./node_modules/@squill/squill/dist/date-util/index.js");
function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (date_util_1.isDate(a)) {
        if (date_util_1.isDate(b)) {
            if (isNaN(a.getTime()) && isNaN(b.getTime())) {
                return true;
            }
            return a.getTime() === b.getTime();
        }
        else {
            return false;
        }
    }
    if (a instanceof Uint8Array) {
        if (b instanceof Uint8Array) {
            return tm.ArrayBufferUtil.equals(a, b);
        }
        else {
            return false;
        }
    }
    /**
     * Use `strictEqual()` algorithm that handles `bigint` polyfill
     */
    return tm.TypeUtil.strictEqual(a, b);
}
exports.isEqual = isEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-non-null-built-in-value-expr.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_built_in_value_expr_1 = __webpack_require__(/*! ./is-built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/util/predicate/is-built-in-value-expr.js");
function isNonNullBuiltInValueExpr(raw) {
    if (raw === null) {
        return false;
    }
    return is_built_in_value_expr_1.isBuiltInValueExpr(raw);
}
exports.isNonNullBuiltInValueExpr = isNonNullBuiltInValueExpr;
//# sourceMappingURL=is-non-null-built-in-value-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/candidate-key/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/candidate-key/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CandidateKeyUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/candidate-key/util/index.js");
exports.CandidateKeyUtil = CandidateKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/candidate-key/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/candidate-key/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/candidate-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/candidate-key/util/query/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/candidate-key/util/query/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/candidate-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/candidate-key/util/query/mapper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/candidate-key/util/query/mapper.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
function mapper(table) {
    return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
        return column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, candidateKey));
    }));
}
exports.mapper = mapper;
function mapperPreferPrimaryKey(table) {
    if (table.primaryKey == undefined) {
        return mapper(table);
    }
    return tm.unsafeOr(primary_key_1.PrimaryKeyUtil.mapper(table), mapper(table));
}
exports.mapperPreferPrimaryKey = mapperPreferPrimaryKey;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierMapUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column-identifier-map/util/index.js");
exports.ColumnIdentifierMapUtil = ColumnIdentifierMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/from-column-map.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/from-column-map.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
function fromColumnMap(columnMap) {
    return Object.keys(columnMap).reduce((memo, columnAlias) => {
        memo[columnAlias] = column_identifier_1.ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]);
        return memo;
    }, {});
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/from-column-map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-identifier-map/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/column-identifier-map/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/column-identifier-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/operation/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/operation/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/column-identifier-map/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/operation/intersect.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/operation/intersect.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function intersect(mapA, mapB) {
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...mapA,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/has-column-identifier.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/has-column-identifier.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
function hasColumnIdentifier(map, identifier) {
    const column = map[identifier.columnAlias];
    if (!column_identifier_1.ColumnIdentifierUtil.isColumnIdentifier(column)) {
        return false;
    }
    return column_identifier_1.ColumnIdentifierUtil.isEqual(column, identifier);
}
exports.hasColumnIdentifier = hasColumnIdentifier;
function assertHasColumnIdentifier(map, identifier) {
    if (!hasColumnIdentifier(map, identifier)) {
        throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier map`);
    }
}
exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
function assertHasColumnIdentifiers(map, identifiers) {
    for (const columnIdentifier of identifiers) {
        assertHasColumnIdentifier(map, columnIdentifier);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=has-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-column-identifier */ "./node_modules/@squill/squill/dist/column-identifier-map/util/predicate/has-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/query/extract-column-identifier.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/query/extract-column-identifier.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Does not check `tableAlias`
 */
function extractColumnIdentifiers(map, columnIdentifiers) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-map/util/query/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-map/util/query/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "./node_modules/@squill/squill/dist/column-identifier-map/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierRefUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/index.js");
exports.ColumnIdentifierRefUtil = ColumnIdentifierRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column-map.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column-map.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column.js");
function appendColumnMap(ref, columnMap) {
    for (const columnAlias of Object.keys(columnMap)) {
        from_column_1.appendColumn(ref, columnMap[columnAlias]);
    }
    return ref;
}
exports.appendColumnMap = appendColumnMap;
function fromColumnMap(columnMap) {
    const result = appendColumnMap({}, columnMap);
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
function appendColumn(ref, column) {
    let map = ref[column.tableAlias];
    if (map == undefined) {
        map = {};
        ref[column.tableAlias] = map;
    }
    map[column.columnAlias] = column_identifier_1.ColumnIdentifierUtil.fromColumn(column);
    return ref;
}
exports.appendColumn = appendColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-join-array.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-join-array.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column-map.js");
function appendJoin(ref, join) {
    from_column_map_1.appendColumnMap(ref, join.columns);
    return ref;
}
exports.appendJoin = appendJoin;
function appendJoinArray(ref, arr) {
    for (const join of arr) {
        appendJoin(ref, join);
    }
    return ref;
}
exports.appendJoinArray = appendJoinArray;
function fromJoinArray(arr) {
    const result = {};
    appendJoinArray(result, arr);
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-select-clause.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-select-clause.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column.js");
function fromSelectClause(selectClause) {
    const result = {};
    for (const columnIdentifier of column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selectClause)) {
        from_column_1.appendColumn(result, columnIdentifier);
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./left-intersect */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/left-intersect.js"));
__export(__webpack_require__(/*! ./try-flatten */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/try-flatten.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/intersect.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/intersect.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/left-intersect.js");
function intersect(refA, refB) {
    const left = left_intersect_1.leftIntersect(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/left-intersect.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/left-intersect.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function leftIntersect(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_identifier_map_1.ColumnIdentifierMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/try-flatten.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/operation/try-flatten.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryFlatten(ref) {
    const tableAliases = Object.keys(ref);
    if (tableAliases.length == 1) {
        return ref[tableAliases[0]];
    }
    else {
        return ref;
    }
}
exports.tryFlatten = tryFlatten;
//# sourceMappingURL=try-flatten.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/has-column-identifier.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/has-column-identifier.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function hasColumnIdentifier(ref, identifier) {
    if (!Object.prototype.hasOwnProperty.call(ref, identifier.tableAlias)) {
        return false;
    }
    const columnMap = ref[identifier.tableAlias];
    return column_identifier_map_1.ColumnIdentifierMapUtil.hasColumnIdentifier(columnMap, identifier);
}
exports.hasColumnIdentifier = hasColumnIdentifier;
function assertHasColumnIdentifier(ref, identifier) {
    if (!hasColumnIdentifier(ref, identifier)) {
        throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier ref`);
    }
}
exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
function assertHasColumnIdentifiers(ref, identifiers) {
    for (const identifier of identifiers) {
        assertHasColumnIdentifier(ref, identifier);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=has-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-column-identifier */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/predicate/has-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/query/extract-column-identifier.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/query/extract-column-identifier.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function extractColumnIdentifiers(ref, columnIdentifiers) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
        if (arr.length > 0) {
            result[tableAlias] = column_identifier_map_1.ColumnIdentifierMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier-ref/util/query/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier-ref/util/query/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "./node_modules/@squill/squill/dist/column-identifier-ref/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-map.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-map.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/column-identifier/util/index.js");
function fromColumnMap(columnMap) {
    const result = [];
    for (const columnAlias of Object.keys(columnMap)) {
        result.push(ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]));
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-ref.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-ref.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-map.js");
function fromColumnRef(columnRef) {
    const result = [];
    for (const tableAlias of Object.keys(columnRef)) {
        result.push(...from_column_map_1.fromColumnMap(columnRef[tableAlias]));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/from-column-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-identifier/array-util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-disjoint.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-disjoint.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/column-identifier/util/index.js");
function assertDisjoint(arrA, arrB) {
    for (const a of arrA) {
        for (const b of arrB) {
            if (util_1.isEqual(a, b)) {
                throw new Error(`Duplicate column identifier ${a.tableAlias}.${a.columnAlias} found; consider aliasing`);
            }
        }
    }
}
exports.assertDisjoint = assertDisjoint;
//# sourceMappingURL=assert-disjoint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-no-duplicate.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-no-duplicate.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/column-identifier/util/index.js");
function assertNoDuplicate(arr) {
    for (let i = 0; i < arr.length; ++i) {
        for (let j = i + 1; j < arr.length; ++j) {
            if (util_1.isEqual(arr[i], arr[j])) {
                throw new Error(`Duplicate column identifier ${arr[i].tableAlias}.${arr[i].columnAlias}`);
            }
        }
    }
}
exports.assertNoDuplicate = assertNoDuplicate;
//# sourceMappingURL=assert-no-duplicate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-disjoint */ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-disjoint.js"));
__export(__webpack_require__(/*! ./assert-no-duplicate */ "./node_modules/@squill/squill/dist/column-identifier/array-util/predicate/assert-no-duplicate.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnIdentifierArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/column-identifier/array-util/index.js");
exports.ColumnIdentifierArrayUtil = ColumnIdentifierArrayUtil;
const ColumnIdentifierUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column-identifier/util/index.js");
exports.ColumnIdentifierUtil = ColumnIdentifierUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-map.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-map.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column.js");
function fromColumnMap(map) {
    const result = [];
    for (const columnAlias of Object.keys(map)) {
        result.push(from_column_1.fromColumn(map[columnAlias]));
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-ref.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-ref.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-map.js");
function fromColumnRef(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        result.push(...from_column_map_1.fromColumnMap(ref[tableAlias]));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = {
        tableAlias: column.tableAlias,
        columnAlias: column.columnAlias,
    };
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-expr-select-item.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-expr-select-item.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromExprSelectItem(column) {
    const result = {
        tableAlias: column.tableAlias,
        columnAlias: column.alias,
    };
    return result;
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-clause.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-clause.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-item.js");
/**
 * Does not remove duplicate identifiers
 *
 * @param selectClause
 */
function fromSelectClause(selectClause) {
    const result = [];
    for (const selectItem of selectClause) {
        result.push(...from_select_item_1.fromSelectItem(selectItem));
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-item.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-item.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-expr-select-item.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-ref.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-map.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function fromSelectItem(selectItem) {
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
        return [from_expr_select_item_1.fromExprSelectItem(selectItem)];
    }
    else if (column_1.ColumnUtil.isColumn(selectItem)) {
        return [from_column_1.fromColumn(selectItem)];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
        return from_column_map_1.fromColumnMap(selectItem);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(selectItem)) {
        return from_column_ref_1.fromColumnRef(selectItem);
    }
    else {
        throw new Error(`Unknown SelectItem`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/constructor/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-expr-select-item */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-expr-select-item.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-clause.js"));
__export(__webpack_require__(/*! ./from-select-item */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/from-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-identifier/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/predicate/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-column-identifier.js"));
__export(__webpack_require__(/*! ./is-equal */ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-equal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-column-identifier.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-column-identifier.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function isColumnIdentifier(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias"
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string"));
}
exports.isColumnIdentifier = isColumnIdentifier;
//# sourceMappingURL=is-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-equal.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-identifier/util/predicate/is-equal.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isEqual(a, b) {
    return (a.tableAlias == b.tableAlias &&
        a.columnAlias == b.columnAlias);
}
exports.isEqual = isEqual;
function assertIsEqual(a, b) {
    if (a.tableAlias != b.tableAlias) {
        throw new Error(`Table alias mismatch ${a.tableAlias} != ${b.tableAlias}`);
    }
    if (a.columnAlias != b.columnAlias) {
        throw new Error(`Column alias mismatch ${a.columnAlias} != ${b.columnAlias}`);
    }
}
exports.assertIsEqual = assertIsEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnMapUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column-map/util/index.js");
exports.ColumnMapUtil = ColumnMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnArray(columns) {
    const result = {};
    for (const column of columns) {
        result[column.columnAlias] = column;
    }
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-ref.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-ref.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnRef(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const columnMap = ref[tableAlias];
        for (const columnAlias in columnMap) {
            const column = columnMap[columnAlias];
            result[column.columnAlias] = column;
        }
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-column.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    return {
        [column.columnAlias]: column
    };
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-expr-select-item.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-expr-select-item.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function fromExprSelectItem(item) {
    return from_column_1.fromColumn(column_1.ColumnUtil.fromExprSelectItem(item));
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-field-array.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-field-array.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function fromFieldArray(tableAlias, fields) {
    const result = {};
    for (const field of fields) {
        result[field.__name] = new column_1.Column({
            tableAlias: tableAlias,
            columnAlias: field.__name,
            mapper: field,
        }, undefined);
    }
    return result;
}
exports.fromFieldArray = fromFieldArray;
//# sourceMappingURL=from-field-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-join.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-join.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/column-map/util/operation/index.js");
function fromJoin(join) {
    if (join.nullable) {
        return operation_1.toNullable(join.columns);
    }
    else {
        return join.columns;
    }
}
exports.fromJoin = fromJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-mapper-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-mapper-map.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function fromMapperMap(tableAlias, mapperMap) {
    const result = {};
    for (const columnAlias of Object.keys(mapperMap)) {
        result[columnAlias] = new column_1.Column({
            tableAlias,
            columnAlias,
            mapper: mapperMap[columnAlias],
        }, undefined);
    }
    return result;
}
exports.fromMapperMap = fromMapperMap;
//# sourceMappingURL=from-mapper-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-clause.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-clause.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-item.js");
/**
 * Assumes no duplicate `columnAlias` in `SelectClauseT`
 */
function fromSelectClause(selectsClause, tableAlias, preserveUnaliasedAst) {
    const result = {};
    for (const item of selectsClause) {
        const map = from_select_item_1.fromSelectItem(item);
        for (const columnAlias of Object.keys(map)) {
            if (preserveUnaliasedAst) {
                result[columnAlias] = column_1.ColumnUtil.withTableAlias(map[columnAlias], tableAlias);
            }
            else {
                result[columnAlias] = column_1.ColumnUtil.withUnaliasedAst(column_1.ColumnUtil.withTableAlias(map[columnAlias], tableAlias), undefined);
            }
        }
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-item.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-item.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-expr-select-item.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-ref.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/column-map/util/predicate/index.js");
function fromSelectItem(item) {
    if (column_1.ColumnUtil.isColumn(item)) {
        return from_column_1.fromColumn(item);
    }
    else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(item)) {
        return from_expr_select_item_1.fromExprSelectItem(item);
    }
    else if (predicate_1.isColumnMap(item)) {
        return item;
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
        return from_column_ref_1.fromColumnRef(item);
    }
    else {
        throw new Error(`Unknown select item`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/constructor/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/constructor/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-field-array */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-field-array.js"));
__export(__webpack_require__(/*! ./from-join */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-join.js"));
__export(__webpack_require__(/*! ./from-mapper-map */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-mapper-map.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "./node_modules/@squill/squill/dist/column-map/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-map/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/column-map/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-map/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/column-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/compound.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/compound.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_compound_1 = __webpack_require__(/*! ./left-compound */ "./node_modules/@squill/squill/dist/column-map/util/operation/left-compound.js");
function compound(mapA, mapB) {
    const left = left_compound_1.leftCompound(mapA, mapB);
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.compound = compound;
//# sourceMappingURL=compound.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound */ "./node_modules/@squill/squill/dist/column-map/util/operation/compound.js"));
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/column-map/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./left-compound */ "./node_modules/@squill/squill/dist/column-map/util/operation/left-compound.js"));
__export(__webpack_require__(/*! ./left-intersect */ "./node_modules/@squill/squill/dist/column-map/util/operation/left-intersect.js"));
__export(__webpack_require__(/*! ./omit */ "./node_modules/@squill/squill/dist/column-map/util/operation/omit.js"));
__export(__webpack_require__(/*! ./pick */ "./node_modules/@squill/squill/dist/column-map/util/operation/pick.js"));
__export(__webpack_require__(/*! ./replace-column */ "./node_modules/@squill/squill/dist/column-map/util/operation/replace-column.js"));
__export(__webpack_require__(/*! ./to-nullable */ "./node_modules/@squill/squill/dist/column-map/util/operation/to-nullable.js"));
__export(__webpack_require__(/*! ./with-table-alias */ "./node_modules/@squill/squill/dist/column-map/util/operation/with-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/intersect.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/intersect.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "./node_modules/@squill/squill/dist/column-map/util/operation/left-intersect.js");
function intersect(mapA, mapB) {
    const left = left_intersect_1.leftIntersect(mapA, mapB);
    const right = {};
    for (const columnAlias of Object.keys(mapB)) {
        if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
            continue;
        }
        right[columnAlias] = mapB[columnAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/left-compound.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/left-compound.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function leftCompound(mapA, mapB) {
    const result = {};
    for (const columnAlias of Object.keys(mapA)) {
        const columnA = mapA[columnAlias];
        const columnB = mapB[columnAlias];
        if (column_1.ColumnUtil.isColumn(columnB)) {
            result[columnAlias] = new column_1.Column({
                tableAlias: columnA.tableAlias,
                columnAlias: columnA.columnAlias,
                mapper: tm.or(columnA.mapper, mapB[columnAlias].mapper),
            }, columnA.unaliasedAst);
        }
        else {
            result[columnAlias] = columnA;
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/left-intersect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/left-intersect.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
function leftIntersect(mapA, mapB) {
    const result = {};
    for (const columnAlias of Object.keys(mapA)) {
        const columnA = mapA[columnAlias];
        const columnB = mapB[columnAlias];
        if (column_1.ColumnUtil.isColumn(columnB)) {
            result[columnAlias] = new column_1.Column({
                tableAlias: columnA.tableAlias,
                columnAlias: columnA.columnAlias,
                mapper: data_type_1.DataTypeUtil.intersect(columnA.mapper, mapB[columnAlias].mapper),
            }, columnA.unaliasedAst);
        }
        else {
            result[columnAlias] = columnA;
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/omit.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/omit.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function omit(map, arr) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (arr.indexOf(columnAlias) < 0) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.omit = omit;
//# sourceMappingURL=omit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/pick.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/pick.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function pick(map, arr) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (arr.indexOf(columnAlias) >= 0) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.pick = pick;
//# sourceMappingURL=pick.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/replace-column.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/replace-column.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function replaceColumn(map, columnAlias, mapper) {
    const result = {};
    for (const myColumnAlias of Object.keys(map)) {
        if (myColumnAlias == columnAlias) {
            result[myColumnAlias] = column_1.ColumnUtil.withType(map[myColumnAlias], mapper);
        }
        else {
            result[myColumnAlias] = map[myColumnAlias];
        }
    }
    return result;
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/to-nullable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/to-nullable.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function toNullable(columnMap) {
    const result = {};
    for (const columnAlias of Object.keys(columnMap)) {
        result[columnAlias] = column_1.ColumnUtil.toNullable(columnMap[columnAlias]);
    }
    return result;
}
exports.toNullable = toNullable;
//# sourceMappingURL=to-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/operation/with-table-alias.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/operation/with-table-alias.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function withTableAlias(columnMap, newTableAlias) {
    const result = {};
    for (const columnAlias of Object.keys(columnMap)) {
        result[columnAlias] = column_1.ColumnUtil.withTableAlias(columnMap[columnAlias], newTableAlias);
    }
    return result;
}
exports.withTableAlias = withTableAlias;
//# sourceMappingURL=with-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/predicate/assert-is-null-safe-comparable.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/predicate/assert-is-null-safe-comparable.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_null_safe_comparable_1 = __webpack_require__(/*! ./is-null-safe-comparable */ "./node_modules/@squill/squill/dist/column-map/util/predicate/is-null-safe-comparable.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/column-map/util/query/index.js");
function assertIsNullSafeComparable(a, b) {
    if (!is_null_safe_comparable_1.isNullSafeComparable(a, b)) {
        const myTableAlias = query_1.tableAlias(a);
        const myColumnAliases = Object.keys(a).join(",");
        const otherTableAlias = query_1.tableAlias(b);
        const otherColumnAliases = Object.keys(a)
            .filter(myColumnAlias => (Object.prototype.hasOwnProperty.call(b, myColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(b, myColumnAlias)))
            .join(",");
        throw new Error(`${myTableAlias} (${myColumnAliases}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
    }
}
exports.assertIsNullSafeComparable = assertIsNullSafeComparable;
//# sourceMappingURL=assert-is-null-safe-comparable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/predicate/has-column-alias.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/predicate/has-column-alias.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function hasColumnAlias(map, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(map, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(map, columnAlias));
}
exports.hasColumnAlias = hasColumnAlias;
//# sourceMappingURL=has-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/predicate/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/predicate/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-is-null-safe-comparable */ "./node_modules/@squill/squill/dist/column-map/util/predicate/assert-is-null-safe-comparable.js"));
__export(__webpack_require__(/*! ./has-column-alias */ "./node_modules/@squill/squill/dist/column-map/util/predicate/has-column-alias.js"));
__export(__webpack_require__(/*! ./is-column-map */ "./node_modules/@squill/squill/dist/column-map/util/predicate/is-column-map.js"));
__export(__webpack_require__(/*! ./is-null-safe-comparable */ "./node_modules/@squill/squill/dist/column-map/util/predicate/is-null-safe-comparable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/predicate/is-column-map.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/predicate/is-column-map.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function isColumnMap(mixed) {
    if (!(mixed instanceof Object)) {
        return false;
    }
    for (const columnAlias of Object.keys(mixed)) {
        const possiblyColumn = mixed[columnAlias];
        if (!column_1.ColumnUtil.isColumn(possiblyColumn)) {
            return false;
        }
    }
    return true;
}
exports.isColumnMap = isColumnMap;
//# sourceMappingURL=is-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/predicate/is-null-safe-comparable.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/predicate/is-null-safe-comparable.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ideally, we'd want to have run-time checks
 * ensuring columns in `a` and columns in `b`
 * have null-safe comparable types.
 *
 * However, due to how the project is structured,
 * this is not possible.
 *
 * So, at the very least, we just check
 * the columns exist.
 */
function isNullSafeComparable(a, b) {
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring columns in `a` and columns in `b`
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    const otherColumnAliases = Object.keys(b);
    for (const myColumnAlias of Object.keys(a)) {
        if (!otherColumnAliases.includes(myColumnAlias)) {
            /**
             * Other column does not exist
             */
            return false;
        }
    }
    return true;
}
exports.isNullSafeComparable = isNullSafeComparable;
//# sourceMappingURL=is-null-safe-comparable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/column-alias.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/column-alias.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function columnAlias(map) {
    return Object.keys(map);
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/extract-column-identifier.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/extract-column-identifier.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Does not check `tableAlias`
 */
function extractColumnIdentifiers(map, columnIdentifiers) {
    const result = {};
    for (const columnAlias of Object.keys(map)) {
        if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
            result[columnAlias] = map[columnAlias];
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/extract-non-nullable.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/extract-non-nullable.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const non_nullable_column_alias_1 = __webpack_require__(/*! ./non-nullable-column-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/non-nullable-column-alias.js");
function extractNonNullable(map) {
    const result = {};
    for (const columnAlias of non_nullable_column_alias_1.nonNullableColumnAliases(map)) {
        result[columnAlias] = map[columnAlias];
    }
    return result;
}
exports.extractNonNullable = extractNonNullable;
//# sourceMappingURL=extract-non-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/extract-nullable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/extract-nullable.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/nullable-column-alias.js");
function extractNullable(map) {
    const result = {};
    for (const columnAlias of nullable_column_alias_1.nullableColumnAliases(map)) {
        result[columnAlias] = map[columnAlias];
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./extract-column-identifier */ "./node_modules/@squill/squill/dist/column-map/util/query/extract-column-identifier.js"));
__export(__webpack_require__(/*! ./extract-non-nullable */ "./node_modules/@squill/squill/dist/column-map/util/query/extract-non-nullable.js"));
__export(__webpack_require__(/*! ./extract-nullable */ "./node_modules/@squill/squill/dist/column-map/util/query/extract-nullable.js"));
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/column-map/util/query/mapper.js"));
__export(__webpack_require__(/*! ./non-nullable-column-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/non-nullable-column-alias.js"));
__export(__webpack_require__(/*! ./nullable-column-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/nullable-column-alias.js"));
__export(__webpack_require__(/*! ./partial-mapper */ "./node_modules/@squill/squill/dist/column-map/util/query/partial-mapper.js"));
__export(__webpack_require__(/*! ./table-alias */ "./node_modules/@squill/squill/dist/column-map/util/query/table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/mapper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/mapper.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function mapper(map) {
    const fields = [];
    for (const columnAlias of Object.keys(map)) {
        /**
         * It's possible that this is not an `IColumnUtil`.
         * But, in general, if we pass in candidateKey and columnMap
         * without any outside hack-ery, this should be correct.
         */
        const column = map[columnAlias];
        fields.push(tm.withName(column.mapper, column.columnAlias));
    }
    return tm.objectFromArray(...fields);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/non-nullable-column-alias.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/non-nullable-column-alias.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function nonNullableColumnAliases(map) {
    return Object.keys(map)
        .filter(columnAlias => !tm.canOutputNull(map[columnAlias].mapper));
}
exports.nonNullableColumnAliases = nonNullableColumnAliases;
//# sourceMappingURL=non-nullable-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/nullable-column-alias.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/nullable-column-alias.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function nullableColumnAliases(map) {
    return Object.keys(map)
        .filter(columnAlias => tm.canOutputNull(map[columnAlias].mapper));
}
exports.nullableColumnAliases = nullableColumnAliases;
//# sourceMappingURL=nullable-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/partial-mapper.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/partial-mapper.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function partialMapper(map) {
    const fields = [];
    for (const columnAlias of Object.keys(map)) {
        /**
         * It's possible that this is not an `IColumnUtil`.
         * But, in general, if we pass in candidateKey and columnMap
         * without any outside hack-ery, this should be correct.
         */
        const column = map[columnAlias];
        fields.push(tm.withName(column.mapper, column.columnAlias));
    }
    return tm.partialObjectFromArray(...fields);
}
exports.partialMapper = partialMapper;
//# sourceMappingURL=partial-mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-map/util/query/table-alias.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-map/util/query/table-alias.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the **first** table alias found.
 *
 * All columns in a `ColumnMap` should have the same table alias.
 * If multiple table aliases exist, the one it returns is arbitrary.
 *
 * If no columns exist, it throws an error.
 */
function tableAlias(map) {
    const columnAliases = Object.keys(map);
    if (columnAliases.length == 0) {
        throw new Error(`No columns in ColumnMap`);
    }
    else {
        return map[columnAliases[0]].tableAlias;
    }
}
exports.tableAlias = tableAlias;
//# sourceMappingURL=table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnRefUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column-ref/util/index.js");
exports.ColumnRefUtil = ColumnRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js");
function fromColumnArray(columns) {
    const result = {};
    for (const column of columns) {
        from_column_1.setColumn(result, column);
    }
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-map.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js");
function setColumnMap(ref, map) {
    for (const columnAlias of Object.keys(map)) {
        from_column_1.setColumn(ref, map[columnAlias]);
    }
}
exports.setColumnMap = setColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function setColumn(ref, column) {
    let map = ref[column.tableAlias];
    if (map == undefined) {
        map = {};
        ref[column.tableAlias] = map;
    }
    map[column.columnAlias] = column;
    return ref;
}
exports.setColumn = setColumn;
function fromColumn(column) {
    return setColumn({}, column);
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-from-clause.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-from-clause.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_array_1 = __webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join-array.js");
function setFromClause(ref, fromClause) {
    if (fromClause.currentJoins != undefined) {
        from_join_array_1.setJoinArray(ref, fromClause.currentJoins);
    }
    if (fromClause.outerQueryJoins != undefined) {
        from_join_array_1.setJoinArray(ref, fromClause.outerQueryJoins);
    }
}
exports.setFromClause = setFromClause;
function fromFromClause(fromClause) {
    const result = {};
    setFromClause(result, fromClause);
    return result;
}
exports.fromFromClause = fromFromClause;
//# sourceMappingURL=from-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join-array.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join-array.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_1 = __webpack_require__(/*! ./from-join */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join.js");
function setJoinArray(ref, joins) {
    for (const join of joins) {
        from_join_1.setJoin(ref, join);
    }
}
exports.setJoinArray = setJoinArray;
function fromJoinArray(joins) {
    const result = {};
    setJoinArray(result, joins);
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-map.js");
function setJoin(ref, join) {
    from_column_map_1.setColumnMap(ref, column_map_1.ColumnMapUtil.fromJoin(join));
}
exports.setJoin = setJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-select-clause.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/from-select-clause.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const from_column_1 = __webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js");
function fromSelectClause(selectClause) {
    const result = {};
    for (const column of column_1.ColumnUtil.fromSelectClause(selectClause)) {
        from_column_1.setColumn(result, column);
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/constructor/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/constructor/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-from-clause */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-from-clause.js"));
__export(__webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/from-select-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/column-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/column-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/compound.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/compound.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_compound_1 = __webpack_require__(/*! ./left-compound */ "./node_modules/@squill/squill/dist/column-ref/util/operation/left-compound.js");
function compound(refA, refB) {
    const left = left_compound_1.leftCompound(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.compound = compound;
//# sourceMappingURL=compound.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound */ "./node_modules/@squill/squill/dist/column-ref/util/operation/compound.js"));
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/column-ref/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./try-flatten */ "./node_modules/@squill/squill/dist/column-ref/util/operation/try-flatten.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/intersect.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/intersect.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const left_intersect_1 = __webpack_require__(/*! ./left-intersect */ "./node_modules/@squill/squill/dist/column-ref/util/operation/left-intersect.js");
function intersect(refA, refB) {
    const left = left_intersect_1.leftIntersect(refA, refB);
    const right = {};
    for (const tableAlias of Object.keys(refB)) {
        if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
            continue;
        }
        right[tableAlias] = refB[tableAlias];
    }
    return {
        ...left,
        ...right,
    };
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/left-compound.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/left-compound.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function leftCompound(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_map_1.ColumnMapUtil.compound(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/left-intersect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/left-intersect.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function leftIntersect(refA, refB) {
    const result = {};
    for (const tableAlias of Object.keys(refA)) {
        if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
            Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
            result[tableAlias] = column_map_1.ColumnMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
        }
        else {
            result[tableAlias] = refA[tableAlias];
        }
    }
    return result;
}
exports.leftIntersect = leftIntersect;
//# sourceMappingURL=left-intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/operation/try-flatten.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/operation/try-flatten.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryFlatten(ref) {
    const tableAliases = Object.keys(ref);
    if (tableAliases.length == 1) {
        return ref[tableAliases[0]];
    }
    else {
        return ref;
    }
}
exports.tryFlatten = tryFlatten;
//# sourceMappingURL=try-flatten.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/predicate/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/predicate/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column-ref */ "./node_modules/@squill/squill/dist/column-ref/util/predicate/is-column-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/predicate/is-column-ref.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/predicate/is-column-ref.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function isColumnRef(mixed) {
    if (!(mixed instanceof Object)) {
        return false;
    }
    for (const tableAlias of Object.keys(mixed)) {
        const possiblyColumnMap = mixed[tableAlias];
        if (!column_map_1.ColumnMapUtil.isColumnMap(possiblyColumnMap)) {
            return false;
        }
    }
    return true;
}
exports.isColumnRef = isColumnRef;
//# sourceMappingURL=is-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/column-alias.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/column-alias.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function columnAlias(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        result.push(...column_map_1.ColumnMapUtil.columnAlias(ref[tableAlias]));
    }
    return result;
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/duplicate-column-alias.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/duplicate-column-alias.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function duplicateColumnAlias(ref) {
    const duplicateTracker = {};
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        for (const columnAlias of column_map_1.ColumnMapUtil.columnAlias(ref[tableAlias])) {
            const isDuplicate = duplicateTracker[columnAlias];
            if (isDuplicate === undefined) {
                /**
                 * We had never encountered it, and now we have.
                 * But it isn't a duplicate.
                 */
                duplicateTracker[columnAlias] = false;
            }
            else if (!isDuplicate) {
                /**
                 * We had encountered it when it wasn't a duplicate.
                 * Now, it is a duplicate.
                 */
                duplicateTracker[columnAlias] = true;
                result.push(columnAlias);
            }
        }
    }
    return result;
}
exports.duplicateColumnAlias = duplicateColumnAlias;
//# sourceMappingURL=duplicate-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-column-identifier.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/extract-column-identifier.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function extractColumnIdentifiers(ref, columnIdentifiers) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
        if (arr.length > 0) {
            result[tableAlias] = column_map_1.ColumnMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
        }
    }
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-non-nullable.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/extract-non-nullable.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function extractNonNullable(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        result[tableAlias] = column_map_1.ColumnMapUtil.extractNonNullable(ref[tableAlias]);
    }
    return result;
}
exports.extractNonNullable = extractNonNullable;
//# sourceMappingURL=extract-non-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-nullable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/extract-nullable.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function extractNullable(ref) {
    const result = {};
    for (const tableAlias of Object.keys(ref)) {
        result[tableAlias] = column_map_1.ColumnMapUtil.extractNullable(ref[tableAlias]);
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-with-type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/extract-with-type.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns `ref` without modifying it.
 * Is basically a no-op.
 *
 * This function merely exists to enforce compile-time safety.
 */
function __noOp_extractWithType() {
    return (ref) => ref;
}
exports.__noOp_extractWithType = __noOp_extractWithType;
//# sourceMappingURL=extract-with-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column-ref/util/query/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column-ref/util/query/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/column-ref/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./duplicate-column-alias */ "./node_modules/@squill/squill/dist/column-ref/util/query/duplicate-column-alias.js"));
__export(__webpack_require__(/*! ./extract-column-identifier */ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-column-identifier.js"));
__export(__webpack_require__(/*! ./extract-non-nullable */ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-non-nullable.js"));
__export(__webpack_require__(/*! ./extract-nullable */ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-nullable.js"));
__export(__webpack_require__(/*! ./extract-with-type */ "./node_modules/@squill/squill/dist/column-ref/util/query/extract-with-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/array-util/constructor/from-column-map.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/array-util/constructor/from-column-map.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnMap(columnMap) {
    const result = [];
    for (const columnAlias of Object.keys(columnMap)) {
        result.push(columnMap[columnAlias]);
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
function fromColumnMapArray(columnMapArr) {
    const result = [];
    for (const columnMap of columnMapArr) {
        for (const columnAlias of Object.keys(columnMap)) {
            result.push(columnMap[columnAlias]);
        }
    }
    return result;
}
exports.fromColumnMapArray = fromColumnMapArray;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/array-util/constructor/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/array-util/constructor/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column/array-util/constructor/from-column-map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/array-util/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/array-util/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column/array-util/constructor/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/column-impl.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/column-impl.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColumnUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column/util/index.js");
class Column {
    /**
     * You should never need to explicitly instantiate a `Column`.
     * Use `myTable.addColumns()` instead.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.tableAlias = data.tableAlias;
        this.columnAlias = data.columnAlias;
        this.mapper = data.mapper;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * ```sql
     * SELECT
     *  myTable.myColumn AS alias
     * FROM
     *  myTable
     * ```
     *
     * @param alias - The new column name
     */
    as(alias) {
        return ColumnUtil.as(this, alias);
    }
    ;
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC
     * ```
     */
    asc() {
        return ColumnUtil.asc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn DESC
     * ```
     */
    desc() {
        return ColumnUtil.desc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC,
     *  myTable.myOtherColumn DESC
     * ```
     */
    sort(sortDirection) {
        return ColumnUtil.sort(this, sortDirection);
    }
}
exports.Column = Column;
//# sourceMappingURL=column-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js"));
const ColumnArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/column/array-util/index.js");
exports.ColumnArrayUtil = ColumnArrayUtil;
const ColumnUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/column/util/index.js");
exports.ColumnUtil = ColumnUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnMap(map) {
    const result = [];
    for (const columnAlias of Object.keys(map)) {
        result.push(map[columnAlias]);
    }
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-ref.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-column-ref.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js");
function fromColumnRef(ref) {
    const result = [];
    for (const tableAlias of Object.keys(ref)) {
        const map = ref[tableAlias];
        result.push(...from_column_map_1.fromColumnMap(map));
    }
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-expr-select-item.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-expr-select-item.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_column_1 = __webpack_require__(/*! ../../../expr-column */ "./node_modules/@squill/squill/dist/expr-column/index.js");
function fromExprSelectItem(exprSelectItem) {
    const result = new expr_column_1.ExprColumn({
        tableAlias: exprSelectItem.tableAlias,
        columnAlias: exprSelectItem.alias,
        mapper: exprSelectItem.mapper,
        isAggregate: exprSelectItem.isAggregate,
    }, exprSelectItem.unaliasedAst);
    return result;
}
exports.fromExprSelectItem = fromExprSelectItem;
//# sourceMappingURL=from-expr-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-join-array.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-join-array.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_1 = __webpack_require__(/*! ./from-join */ "./node_modules/@squill/squill/dist/column/util/constructor/from-join.js");
function fromJoinArray(joins) {
    const result = [];
    for (const join of joins) {
        result.push(...from_join_1.fromJoin(join));
    }
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-join.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-join.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js");
function fromJoin(join) {
    const result = from_column_map_1.fromColumnMap(column_map_1.ColumnMapUtil.fromJoin(join));
    return result;
}
exports.fromJoin = fromJoin;
//# sourceMappingURL=from-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-select-clause.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-select-clause.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_select_item_1 = __webpack_require__(/*! ./from-select-item */ "./node_modules/@squill/squill/dist/column/util/constructor/from-select-item.js");
/**
 * Does not remove duplicate identifiers
 *
 * @param selectClause
 */
function fromSelectClause(selectClause) {
    const result = [];
    for (const selectItem of selectClause) {
        result.push(...from_select_item_1.fromSelectItem(selectItem));
    }
    return result;
}
exports.fromSelectClause = fromSelectClause;
//# sourceMappingURL=from-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/from-select-item.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/from-select-item.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const from_expr_select_item_1 = __webpack_require__(/*! ./from-expr-select-item */ "./node_modules/@squill/squill/dist/column/util/constructor/from-expr-select-item.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const from_column_ref_1 = __webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-ref.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const from_column_map_1 = __webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
function fromSelectItem(selectItem) {
    if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
        return [from_expr_select_item_1.fromExprSelectItem(selectItem)];
    }
    else if (column_1.ColumnUtil.isColumn(selectItem)) {
        return [selectItem];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
        return from_column_map_1.fromColumnMap(selectItem);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(selectItem)) {
        return from_column_ref_1.fromColumnRef(selectItem);
    }
    else {
        throw new Error(`Unknown SelectItem`);
    }
}
exports.fromSelectItem = fromSelectItem;
//# sourceMappingURL=from-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/constructor/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/constructor/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/column/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-expr-select-item */ "./node_modules/@squill/squill/dist/column/util/constructor/from-expr-select-item.js"));
__export(__webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/column/util/constructor/from-join-array.js"));
__export(__webpack_require__(/*! ./from-join */ "./node_modules/@squill/squill/dist/column/util/constructor/from-join.js"));
__export(__webpack_require__(/*! ./from-select-clause */ "./node_modules/@squill/squill/dist/column/util/constructor/from-select-clause.js"));
__export(__webpack_require__(/*! ./from-select-item */ "./node_modules/@squill/squill/dist/column/util/constructor/from-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/column/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/column/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/column/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/column/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/as.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/as.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const build_ast_1 = __webpack_require__(/*! ./build-ast */ "./node_modules/@squill/squill/dist/column/util/operation/build-ast.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const aliased_expr_1 = __webpack_require__(/*! ../../../aliased-expr */ "./node_modules/@squill/squill/dist/aliased-expr/index.js");
function as(column, alias) {
    return new aliased_expr_1.AliasedExpr({
        usedRef: used_ref_1.UsedRefUtil.fromColumn(column),
        mapper: column.mapper,
        tableAlias: column.tableAlias,
        alias: alias,
        isAggregate: false,
    }, build_ast_1.buildAst(column));
    /*
    return {
        usedRef : UsedRefUtil.fromColumn(column),
        mapper : column.mapper,
        tableAlias : column.tableAlias,
        alias : alias,
        unaliasedAst : buildAst(column),
    };
    */
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/asc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/asc.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
function asc(column) {
    return [column, sort_direction_1.SortDirection.ASC];
}
exports.asc = asc;
//# sourceMappingURL=asc.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/build-ast.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/build-ast.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(/*! ../../../constants */ "./node_modules/@squill/squill/dist/constants.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function buildAst({ tableAlias, columnAlias, unaliasedAst, }) {
    if (tableAlias == constants_1.ALIASED) {
        /**
         * When you want to write,
         * `(1 + 2) AS three`
         *
         * You write,
         * `add(1, 2).as("three")`
         *
         * This `"three"` is an `IExprSelectItem` but has no `tableAlias`
         * associated with it.
         *
         * So, this library makes up a table alias that is very
         * unlikely to be used naturally by others.
         *
         * The table alias is the value of the variable `ALIASED`,
         * which should be `$aliased`
         */
        return ast_1.identifierNode(`${tableAlias}${constants_1.SEPARATOR}${columnAlias}`);
    }
    else {
        if (unaliasedAst == undefined) {
            /*
                The most common case, I think.
            */
            return ast_1.identifierNode(tableAlias, columnAlias);
        }
        else {
            /**
             * @todo Investigate what should be here.
             * Does the `SELECT` clause even ever have an `IColumn` with `unaliasedAst` set?
             * Initial inspection says "No"
             */
            //throw new Error(`Should use unaliasedAst, tableAlias, columnAlias in SELECT clause, use tableAlias, columnAlias in ORDER BY clause`);
            return ast_1.identifierNode(`${tableAlias}${constants_1.SEPARATOR}${columnAlias}`);
        }
    }
}
exports.buildAst = buildAst;
//# sourceMappingURL=build-ast.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/desc.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/desc.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
function desc(column) {
    return [column, sort_direction_1.SortDirection.DESC];
}
exports.desc = desc;
//# sourceMappingURL=desc.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./as */ "./node_modules/@squill/squill/dist/column/util/operation/as.js"));
__export(__webpack_require__(/*! ./asc */ "./node_modules/@squill/squill/dist/column/util/operation/asc.js"));
__export(__webpack_require__(/*! ./build-ast */ "./node_modules/@squill/squill/dist/column/util/operation/build-ast.js"));
__export(__webpack_require__(/*! ./desc */ "./node_modules/@squill/squill/dist/column/util/operation/desc.js"));
__export(__webpack_require__(/*! ./sort */ "./node_modules/@squill/squill/dist/column/util/operation/sort.js"));
__export(__webpack_require__(/*! ./to-non-nullable */ "./node_modules/@squill/squill/dist/column/util/operation/to-non-nullable.js"));
__export(__webpack_require__(/*! ./to-nullable */ "./node_modules/@squill/squill/dist/column/util/operation/to-nullable.js"));
__export(__webpack_require__(/*! ./with-table-alias */ "./node_modules/@squill/squill/dist/column/util/operation/with-table-alias.js"));
__export(__webpack_require__(/*! ./with-type */ "./node_modules/@squill/squill/dist/column/util/operation/with-type.js"));
__export(__webpack_require__(/*! ./with-unaliased-ast */ "./node_modules/@squill/squill/dist/column/util/operation/with-unaliased-ast.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/sort.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/sort.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function sort(column, sortDirection) {
    return [column, sortDirection];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/to-non-nullable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/to-non-nullable.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js");
function toNonNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
    return new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: tm.notNull(mapper),
    }, unaliasedAst);
}
exports.toNonNullable = toNonNullable;
//# sourceMappingURL=to-non-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/to-nullable.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/to-nullable.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js");
function toNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
    return new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: tm.orNull(mapper),
    }, unaliasedAst);
}
exports.toNullable = toNullable;
//# sourceMappingURL=to-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/with-table-alias.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/with-table-alias.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js");
function withTableAlias({ columnAlias, mapper, unaliasedAst, }, newTableAlias) {
    const result = new column_impl_1.Column({
        tableAlias: newTableAlias,
        columnAlias,
        mapper,
    }, unaliasedAst);
    return result;
}
exports.withTableAlias = withTableAlias;
//# sourceMappingURL=with-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/with-type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/with-type.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js");
function withType({ tableAlias, columnAlias, unaliasedAst, }, newMapper) {
    const result = new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper: newMapper,
    }, unaliasedAst);
    return result;
}
exports.withType = withType;
//# sourceMappingURL=with-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/operation/with-unaliased-ast.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/operation/with-unaliased-ast.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_impl_1 = __webpack_require__(/*! ../../column-impl */ "./node_modules/@squill/squill/dist/column/column-impl.js");
function withUnaliasedAst({ tableAlias, columnAlias, mapper, }, unaliasedAst) {
    const result = new column_impl_1.Column({
        tableAlias,
        columnAlias,
        mapper,
    }, unaliasedAst);
    return result;
}
exports.withUnaliasedAst = withUnaliasedAst;
//# sourceMappingURL=with-unaliased-ast.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/predicate/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/predicate/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-column */ "./node_modules/@squill/squill/dist/column/util/predicate/is-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/predicate/is-column.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/predicate/is-column.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function isColumn(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias",
        "mapper",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string") &&
        (typeof raw.mapper == "function") &&
        (raw.unaliasedAst == undefined ||
            ast_1.AstUtil.isAst(raw.unaliasedAst)));
}
exports.isColumn = isColumn;
//# sourceMappingURL=is-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/query/extract-nullable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/query/extract-nullable.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function extractNullable(columns) {
    const result = [];
    for (const column of columns) {
        if (tm.canOutputNull(column.mapper)) {
            result.push(column);
        }
    }
    return result;
}
exports.extractNullable = extractNullable;
//# sourceMappingURL=extract-nullable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/column/util/query/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/column/util/query/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-nullable */ "./node_modules/@squill/squill/dist/column/util/query/extract-nullable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CompoundQueryClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/compound-query-clause/util/index.js");
exports.CompoundQueryClauseUtil = CompoundQueryClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/compound-query-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/operation/compound-query.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/operation/compound-query.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/index.js");
function compoundQuery(fromClause, selectClause, compoundQueryClause, compoundQueryType, isDistinct, targetQuery) {
    predicate_1.assertCompatible(fromClause, selectClause, targetQuery);
    return {
        selectClause: select_clause_1.SelectClauseUtil.leftCompound(selectClause, targetQuery.selectClause),
        compoundQueryClause: [
            ...(compoundQueryClause == undefined ?
                [] :
                compoundQueryClause),
            {
                compoundQueryType,
                isDistinct,
                query: targetQuery,
            }
        ]
    };
}
exports.compoundQuery = compoundQuery;
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/operation/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/operation/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query */ "./node_modules/@squill/squill/dist/compound-query-clause/util/operation/compound-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-compatible.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-compatible.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_select_clause_compatible_1 = __webpack_require__(/*! ./assert-select-clause-compatible */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js");
const assert_outer_query_joins_compatible_1 = __webpack_require__(/*! ./assert-outer-query-joins-compatible */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js");
function assertCompatible(fromClause, selectClause, targetQuery) {
    assert_select_clause_compatible_1.assertSelectClauseCompatible(selectClause, targetQuery.selectClause);
    assert_outer_query_joins_compatible_1.assertOuterQueryJoinsCompatible(fromClause, targetQuery.fromClause);
}
exports.assertCompatible = assertCompatible;
//# sourceMappingURL=assert-compatible.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function assertOuterQueryJoinsCompatible(fromClause, targetFromClause) {
    used_ref_1.UsedRefUtil.assertAllowed(used_ref_1.UsedRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins), used_ref_1.UsedRefUtil.fromJoinArray(targetFromClause.outerQueryJoins == undefined ?
        [] :
        targetFromClause.outerQueryJoins));
}
exports.assertOuterQueryJoinsCompatible = assertOuterQueryJoinsCompatible;
//# sourceMappingURL=assert-outer-query-joins-compatible.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
function assertMapCompatibilityError(identifier, a, b) {
    const aColumnAliases = Object.keys(a);
    const bColumnAliases = Object.keys(b);
    const missingColumnAliases = aColumnAliases.filter(columnAlias => !bColumnAliases.includes(columnAlias));
    if (missingColumnAliases.length > 0) {
        throw new Error(`Expected ${identifier.join(" ")} to have columns ${missingColumnAliases.join(", ")}`);
    }
    const extraColumnAliases = bColumnAliases.filter(columnAlias => !aColumnAliases.includes(columnAlias));
    if (extraColumnAliases.length > 0) {
        throw new Error(`${identifier.join(" ")} has extra columns ${extraColumnAliases.join(", ")}`);
    }
    /**
     * Can't check subtype requirement during run-time
     */
}
exports.assertMapCompatibilityError = assertMapCompatibilityError;
function assertRefCompatibilityError(identifier, a, b) {
    const aTableAliases = Object.keys(a);
    const bTableAliases = Object.keys(b);
    const missingTableAliases = aTableAliases.filter(tableAlias => !bTableAliases.includes(tableAlias));
    if (missingTableAliases.length > 0) {
        throw new Error(`Expected ${identifier.join(" ")} to have tables ${missingTableAliases.join(", ")}`);
    }
    const extraTableAliases = bTableAliases.filter(tableAlias => !aTableAliases.includes(tableAlias));
    if (extraTableAliases.length > 0) {
        throw new Error(`${identifier.join(" ")} has extra tables ${extraTableAliases.join(", ")}`);
    }
    for (const tableAlias of aTableAliases) {
        assertMapCompatibilityError([...identifier, "table", tableAlias], a[tableAlias], b[tableAlias]);
    }
}
exports.assertRefCompatibilityError = assertRefCompatibilityError;
function assertSelectClauseCompatible(a, b) {
    if (a.length != b.length) {
        throw new Error(`SELECT clause length mismatch; expected ${a.length} received ${b.length}`);
    }
    for (let index = 0; index < a.length; ++index) {
        const itemA = a[index];
        const itemB = b[index];
        if (column_1.ColumnUtil.isColumn(itemA) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                /**
                 * Can't check subtype requirement during run-time
                 */
            }
            else {
                throw new Error(`Expected index ${index} to be Column or ExprSelectItem`);
            }
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(itemA)) {
            if (column_map_1.ColumnMapUtil.isColumnMap(itemB)) {
                assertMapCompatibilityError(["index", index], itemA, itemB);
            }
            else {
                throw new Error(`Expected index ${index} to be ColumnMap`);
            }
        }
        else if (column_ref_1.ColumnRefUtil.isColumnRef(itemA)) {
            if (column_ref_1.ColumnRefUtil.isColumnRef(itemB)) {
                assertRefCompatibilityError(["index", index], itemA, itemB);
            }
            else {
                throw new Error(`Expected index ${index} to be ColumnRef`);
            }
        }
        else {
            throw new Error(`Unknown SELECT item at index ${index}`);
        }
    }
}
exports.assertSelectClauseCompatible = assertSelectClauseCompatible;
//# sourceMappingURL=assert-select-clause-compatible.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-compatible */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-compatible.js"));
__export(__webpack_require__(/*! ./assert-outer-query-joins-compatible */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-outer-query-joins-compatible.js"));
__export(__webpack_require__(/*! ./assert-select-clause-compatible */ "./node_modules/@squill/squill/dist/compound-query-clause/util/predicate/assert-select-clause-compatible.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CompoundQueryOrderByClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/index.js");
exports.CompoundQueryOrderByClauseUtil = CompoundQueryOrderByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const order_1 = __webpack_require__(/*! ../../../order */ "./node_modules/@squill/squill/dist/order/index.js");
/**
 * Returns the MySQL equivalent of `...compoundQueryOrderByClause, ...compoundQueryOrderByDelegate(columns)`
 *
 * @param selectClause
 * @param compoundQueryOrderByClause
 * @param compoundQueryOrderByDelegate
 */
function compoundQueryOrderBy(selectClause, compoundQueryOrderByClause, compoundQueryOrderByDelegate) {
    const columns = query_1.allowedColumnRef(selectClause);
    const compoundQueryOrderBy = compoundQueryOrderByDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    for (const rawOrder of compoundQueryOrderBy) {
        const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
        column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
    }
    return (compoundQueryOrderByClause == undefined ?
        compoundQueryOrderBy.map(order_1.OrderUtil.fromRawOrder) :
        [...compoundQueryOrderByClause, ...compoundQueryOrderBy.map(order_1.OrderUtil.fromRawOrder)]);
}
exports.compoundQueryOrderBy = compoundQueryOrderBy;
//# sourceMappingURL=compound-query-order-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/index.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-order-by */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/operation/compound-query-order-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
function allowedColumnRef(selectClause) {
    const result = column_ref_1.ColumnRefUtil.fromSelectClause(selectClause);
    return result;
}
exports.allowedColumnRef = allowedColumnRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query/compound-query.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query/compound-query.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CompoundQueryType;
(function (CompoundQueryType) {
    CompoundQueryType["UNION"] = "UNION";
    CompoundQueryType["INTERSECT"] = "INTERSECT";
    CompoundQueryType["EXCEPT"] = "EXCEPT";
})(CompoundQueryType = exports.CompoundQueryType || (exports.CompoundQueryType = {}));
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/compound-query/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/compound-query/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query */ "./node_modules/@squill/squill/dist/compound-query/compound-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/constants.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This string value `$aliased` was picked
 * as it is unlikely to be part of an identifier
 * in a database.
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  RAND() AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  RAND() AS `$aliased--r`
 * ```
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
 * ```
 *
 * @todo Make this a reserved `tableAlias`
 * No `ITable/IAliasedTable` should be able to have
 * a `tableAlias` value of `typeof ALIASED`.
 *
 * If such a thing were to happen,
 * it would make enforcing safe interactions between
 * `SELECT` and `FROM` clause very difficult/troublesome.
 *
 * But... What's the probability of someone using `$aliased`
 * as a table name?
 */
exports.ALIASED = "$aliased";
/**
 * This string value `--` was picked
 * as it is unlikely to be part of an identifier
 * in a database.
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  RAND() AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  RAND() AS `$aliased--r`
 * ```
 *
 * -----
 *
 * This query,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS r
 * ```
 *
 * becomes,
 * ```sql
 * SELECT
 *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
 * ```
 */
exports.SEPARATOR = "--";
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CustomExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/custom-expr/util/index.js");
exports.CustomExprUtil = CustomExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/custom-expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/custom-expr/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/operation/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/operation/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./map-non-correlated */ "./node_modules/@squill/squill/dist/custom-expr/util/operation/map-non-correlated.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/operation/map-non-correlated.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/operation/map-non-correlated.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/custom-expr/util/query/index.js");
/**
 * If `value` is `AnyNonValueExpr`, we don't bother checking.
 * We can't really check, anyway.
 *
 * Else, we return `mapper(, value)`,
 * which will throw an error if `value` is invalid.
 */
function mapNonCorrelated(mapper, customExpr) {
    let valueName = "literal-value";
    if (column_1.ColumnUtil.isColumn(mapper)) {
        valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
        mapper = mapper.mapper;
    }
    if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
        /**
         * Cannot map a `NonValueExpr`
         */
        used_ref_1.UsedRefUtil.assertEmpty(query_1.usedRef(customExpr));
        return customExpr;
    }
    else {
        return mapper(valueName, customExpr);
    }
}
exports.mapNonCorrelated = mapNonCorrelated;
//# sourceMappingURL=map-non-correlated.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/query/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/query/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-aggregate */ "./node_modules/@squill/squill/dist/custom-expr/util/query/is-aggregate.js"));
__export(__webpack_require__(/*! ./used-ref */ "./node_modules/@squill/squill/dist/custom-expr/util/query/used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/query/is-aggregate.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/query/is-aggregate.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function isAggregate(customExpr) {
    if (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
        return built_in_expr_1.BuiltInExprUtil.isAggregate(customExpr);
    }
    else {
        return false;
    }
}
exports.isAggregate = isAggregate;
//# sourceMappingURL=is-aggregate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/custom-expr/util/query/used-ref.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/custom-expr/util/query/used-ref.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function usedRef(customExpr) {
    if (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
        return built_in_expr_1.BuiltInExprUtil.usedRef(customExpr);
    }
    else {
        return used_ref_1.UsedRefUtil.fromColumnRef({});
    }
}
exports.usedRef = usedRef;
//# sourceMappingURL=used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/blob.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/blob.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
const equals = tm.ArrayBufferUtil.equals;
function makeBlobDataType(mapperFactory) {
    const result = (a, b, c) => {
        if (c != undefined) {
            return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals, c);
        }
        else if (b != undefined) {
            if (typeof b == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals, b);
            }
        }
        else if (a != undefined) {
            if (typeof a == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals, a);
            }
        }
        else {
            return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals);
        }
    };
    result.maxLength = mapperFactory.maxLength;
    return result;
}
exports.makeBlobDataType = makeBlobDataType;
/**
 * + MySQL      : `BINARY`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `BINARY` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
/**
 * + MySQL      : `VARBINARY`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `VARBINARY` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtVarBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `TINY BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `TINY BLOB` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtTinyBlob = makeBlobDataType(tm.mysql.uint8ArrayTinyBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `BLOB` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtBlob = makeBlobDataType(tm.mysql.uint8ArrayBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `MEDIUM BLOB`
 * + PostgreSQL : `bytea`
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `MEDIUM BLOB` data type.
 * + Max length: `16,777,215`; `(2^24)-1`
 */
exports.dtMediumBlob = makeBlobDataType(tm.mysql.uint8ArrayMediumBlob);
/**
 * Short for "Binary Large OBject"
 *
 * + MySQL      : `LONG BLOB`
 * + PostgreSQL : `LO` (Large Object)
 * + SQLite     : `BLOB`
 *
 *
 * This corresponds to MySQL's `LONG BLOB` data type.
 * + Max length: `4,294,967,295`; `(2^32)-1`
 *
 * -----
 *
 * `bytea` supports up to 1GB. So, we cannot use `bytea`.
 *
 * https://dba.stackexchange.com/questions/127270/what-are-the-limits-of-postgresqls-large-object-facility
 * > A large object cannot exceed 4TB for PostgreSQL 9.3 or newer, or 2GB for older versions.
 * > This is based on the [release notes](https://www.postgresql.org/docs/9.3/release-9-3.html)
 *
 * From the release notes,
 * > Increase the maximum size of large objects from 2GB to 4TB (Nozomi Anzai, Yugo Nagata)
 *
 * -----
 *
 * Realistically, SQLite should support this,
 * https://www.sqlite.org/limits.html
 *
 * However, it is possible that the underlying implementation
 * may be restricted from having a `Uint8Array` of that length.
 */
exports.dtLongBlob = makeBlobDataType(tm.mysql.uint8ArrayLongBlob);
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/boolean.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/boolean.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
function makeBooleanDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
}
exports.makeBooleanDataType = makeBooleanDataType;
/**
 * + MySQL      : `TINYINT` (Emulates `boolean`)
 * + PostgreSQL : `boolean`
 * + SQLite     : `INTEGER` (Emulates `boolean`)
 */
exports.dtBoolean = makeBooleanDataType(tm.mysql.boolean());
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/date-time.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/date-time.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
function makeDateTimeDataType(mapperFactory) {
    return (fractionalSecondPrecision /*|4|5|6*/, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(fractionalSecondPrecision), value => value, (a, b) => built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b), extraMapper);
}
exports.makeDateTimeDataType = makeDateTimeDataType;
/**
 * + MySQL      : `DATETIME`
 * + PostgreSQL : `TIMESTAMP`
 * + SQLite     : `TEXT` (Emulates `DATETIME`)
 *
 * SQLite only supports up to millisecond precision.
 *
 * JS only supports up to millisecond precision.
 *
 * + `0` = second
 * + `1` = deci-second
 * + `2` = centi-second
 * + `3` = millisecond
 *
 * @param fractionalSecondPrecision - `3` is recommended; millisecond precision.
 */
exports.dtDateTime = makeDateTimeDataType(tm.mysql.dateTime);
//# sourceMappingURL=date-time.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/double.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/double.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
function makeDoubleDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
}
exports.makeDoubleDataType = makeDoubleDataType;
/**
 * 8-byte floating point number.
 *
 * + MySQL      : `DOUBLE`
 * + PostgreSQL : `double precision`
 * + SQLite     : `REAL`; is actually 8-byte floating point number
 *
 * The SQL standard forbids NaN, Infinity, -Infinity.
 * However, SQLite supports infinities.
 *
 * The job of throwing on these 3 values will have to
 * fall to the sqlfiers.
 */
exports.dtDouble = makeDoubleDataType(tm.toUnsafeNumber());
/**
 * 4-byte floating point number.
 *
 * JS does not have a 4-byte floating point number type.
 * So, attempting to use `FLOAT` will cause a loss in precision.
 *
 * + MySQL      : `FLOAT`
 * + PostgreSQL : `real`
 * + SQLite     : `REAL`; does not actually have 4-byte floating point numbers
 *
 * The SQL standard forbids NaN, Infinity, -Infinity.
 * However, SQLite supports infinities.
 *
 * The job of throwing on these 3 values will have to
 * fall to the sqlfiers.
 */
exports.dtFloat = makeDoubleDataType(tm.toUnsafeNumber());
//# sourceMappingURL=double.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./blob */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/blob.js"));
__export(__webpack_require__(/*! ./boolean */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/boolean.js"));
__export(__webpack_require__(/*! ./date-time */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/date-time.js"));
__export(__webpack_require__(/*! ./double */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/double.js"));
__export(__webpack_require__(/*! ./integer */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/integer.js"));
__export(__webpack_require__(/*! ./text */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/text.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/integer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/integer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
function makeIntegerDataType(mapper) {
    return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => tm.TypeUtil.strictEqual(a, b), extraMapper);
}
exports.makeIntegerDataType = makeIntegerDataType;
/**
 * 1-byte integer.
 *
 * + MySQL      : `TINYINT SIGNED`
 * + PostgreSQL : `smallint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `TINYINT SIGNED` data type.
 * + Min: -128; `-(2^7)`
 * + Max:  127; `(2^7)-1`
 */
exports.dtTinyIntSigned = makeIntegerDataType(tm.mysql.tinyIntSigned());
/**
 * 2-byte integer.
 *
 * + MySQL      : `SMALLINT SIGNED`
 * + PostgreSQL : `smallint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `SMALLINT SIGNED` data type.
 * + Min: -32,768; `-(2^15)`
 * + Max:  32,767; `(2^15)-1`
 */
exports.dtSmallIntSigned = makeIntegerDataType(tm.mysql.smallIntSigned());
/**
 * 3-byte integer.
 *
 * + MySQL      : `MEDIUMINT SIGNED`
 * + PostgreSQL : `integer`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `MEDIUMINT SIGNED` data type.
 * + Min: -8,388,608; `-(2^23)`
 * + Max:  8,388,607; `(2^23)-1`
 */
exports.dtMediumIntSigned = makeIntegerDataType(tm.mysql.mediumIntSigned());
/**
 * 4-byte integer.
 *
 * + MySQL      : `INT SIGNED`
 * + PostgreSQL : `integer`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `INT SIGNED` data type.
 * + Min: -2,147,483,648; `-(2^31)`
 * + Max:  2,147,483,647; `(2^31)-1`
 */
exports.dtIntSigned = makeIntegerDataType(tm.mysql.intSigned());
/**
 * 8-byte integer.
 *
 * + MySQL      : `BIGINT SIGNED`
 * + PostgreSQL : `bigint`
 * + SQLite     : `INTEGER`
 *
 * This corresponds to MySQL's `BIGINT SIGNED` data type.
 * + Min: -9,223,372,036,854,775,808; `-(2^63)`
 * + Max:  9,223,372,036,854,775,807; `(2^63)-1`
 */
exports.dtBigIntSigned = makeIntegerDataType(tm.mysql.bigIntSigned());
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/text.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/built-in-value-expr/text.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
function makeTextDataType(mapperFactory) {
    const result = (a, b, c) => {
        if (c != undefined) {
            return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b, c);
        }
        else if (b != undefined) {
            if (typeof b == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b, b);
            }
        }
        else if (a != undefined) {
            if (typeof a == "number") {
                return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b);
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b, a);
            }
        }
        else {
            return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b);
        }
    };
    result.maxLength = mapperFactory.maxLength;
    return result;
}
exports.makeTextDataType = makeTextDataType;
/**
 * + MySQL      : `CHAR`
 * + PostgreSQL : `CHAR`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `CHAR` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtChar = makeTextDataType(tm.mysql.char);
/**
 * + MySQL      : `VARCHAR`
 * + PostgreSQL : `VARCHAR`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `VARCHAR` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtVarChar = makeTextDataType(tm.mysql.varChar);
/**
 * + MySQL      : `TINY TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `TINY TEXT` data type.
 * + Max length: `255`; `(2^8)-1`
 */
exports.dtTinyText = makeTextDataType(tm.mysql.tinyText);
/**
 * + MySQL      : `TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `TEXT` data type.
 * + Max length: `65,535`; `(2^16)-1`
 */
exports.dtText = makeTextDataType(tm.mysql.text);
/**
 * + MySQL      : `MEDIUM TEXT`
 * + PostgreSQL : `text`
 * + SQLite     : `TEXT`
 *
 *
 * This corresponds to MySQL's `MEDIUM TEXT` data type.
 * + Max length: `16,777,215`; `(2^24)-1`
 */
exports.dtMediumText = makeTextDataType(tm.mysql.mediumText);
/**
 * + MySQL      : `LONG TEXT`
 * + PostgreSQL : -NA-
 * + SQLite     : `TEXT`
 *
 * This corresponds to MySQL's `LONG TEXT` data type.
 * + Max length: `4,294,967,295`; `(2^32)-1`
 *
 * -----
 *
 * `text` supports up to 1GB. So, we cannot use `text`.
 *
 * https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F
 *
 * > Maximum size for a field? 1 GB
 *
 * -----
 *
 * Realistically, SQLite should support this,
 * https://www.sqlite.org/limits.html
 *
 * However, it is possible that the underlying implementation
 * may be restricted from having a `string` of that length.
 */
exports.dtLongText = makeTextDataType(tm.mysql.longText);
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./non-built-in-value-expr */ "./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/index.js"));
__export(__webpack_require__(/*! ./built-in-value-expr */ "./node_modules/@squill/squill/dist/data-type/built-in-value-expr/index.js"));
const DataTypeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
exports.DataTypeUtil = DataTypeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/decimal.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/decimal.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const DataTypeUtil = __webpack_require__(/*! ../util */ "./node_modules/@squill/squill/dist/data-type/util/index.js");
const ExprLib = __webpack_require__(/*! ../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function makeDecimalDataType(mapperFactory) {
    return (
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(precision, scale), value => ExprLib.decimalLiteral(value, precision, scale), 
    /**
     * We consider +0 and -0 to be the same
     */
    (a, b) => {
        if (a === b) {
            //Early-exit
            return true;
        }
        if (a.toString() === b.toString()) {
            //Early-exit
            return true;
        }
        const parsedA = tm.FixedPointUtil.tryParse(a.toString());
        if (parsedA == undefined) {
            /**
             * This should never happen...
             */
            throw new Error(`Invalid DECIMAL a found`);
        }
        const parsedB = tm.FixedPointUtil.tryParse(b.toString());
        if (parsedB == undefined) {
            /**
             * This should never happen...
             */
            throw new Error(`Invalid DECIMAL b found`);
        }
        return tm.FixedPointUtil.isEqual(parsedA, parsedB, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL);
    }, extraMapper);
}
exports.makeDecimalDataType = makeDecimalDataType;
/**
 * Fixed-point number.
 *
 * + MySQL      : `DECIMAL(p, s)`
 * + PostgreSQL : `DECIMAL(p, s)`
 * + SQLite     : -NA-; Should be emulated using `TEXT` and custom functions.
 *
 * @param precision
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 *
 * @param scale
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 *
 * @param extraMapper
 */
exports.dtDecimal = makeDecimalDataType(tm.mysql.decimal);
//# sourceMappingURL=decimal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./decimal */ "./node_modules/@squill/squill/dist/data-type/non-built-in-value-expr/decimal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/constructor/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/constructor/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-data-type */ "./node_modules/@squill/squill/dist/data-type/util/constructor/make-data-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/constructor/make-data-type.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/constructor/make-data-type.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function makeDataType(mapper, toBuiltInExpr_NonCorrelated, isNullSafeEqual, extraMapper) {
    const myMapper = (extraMapper == undefined ?
        mapper :
        tm.pipe(mapper, extraMapper));
    function dataType(name, mixed) {
        return myMapper(name, mixed);
    }
    dataType.toBuiltInExpr_NonCorrelated = toBuiltInExpr_NonCorrelated;
    dataType.isNullSafeEqual = isNullSafeEqual;
    dataType.orNull = () => {
        return makeDataType(tm.orNull(myMapper), (value) => {
            if (value === null) {
                return null;
            }
            else {
                const rawExpr = toBuiltInExpr_NonCorrelated(value);
                return rawExpr;
            }
        }, (a, b) => {
            if (a === null) {
                if (b === null) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                if (b === null) {
                    return false;
                }
                else {
                    return isNullSafeEqual(a, b);
                }
            }
        });
    };
    return dataType;
}
exports.makeDataType = makeDataType;
//# sourceMappingURL=make-data-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/data-type/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/data-type/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/data-type/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-candidate-key.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-candidate-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js");
const evaluate_primary_key_1 = __webpack_require__(/*! ./evaluate-primary-key */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-primary-key.js");
async function tryEvaluateCandidateKey(table, connection, row) {
    const mappingErrors = [];
    for (const candidateKey of table.candidateKeys) {
        const evaluateResult = await evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.candidateKey`, candidateKey, row);
        if (evaluateResult.success) {
            return evaluateResult;
        }
        if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
            mappingErrors.push(evaluateResult.error);
        }
    }
    return {
        success: false,
        error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.candidateKey`, row, mappingErrors),
    };
}
exports.tryEvaluateCandidateKey = tryEvaluateCandidateKey;
async function tryEvaluateCandidateKeyPreferPrimaryKey(table, connection, row) {
    if (table.primaryKey == undefined) {
        return tryEvaluateCandidateKey(table, connection, row);
    }
    const evaluatePrimaryKeyResult = await evaluate_primary_key_1.tryEvaluatePrimaryKey(table, connection, row);
    if (evaluatePrimaryKeyResult.success) {
        return evaluatePrimaryKeyResult;
    }
    return tryEvaluateCandidateKey(table, connection, row);
}
exports.tryEvaluateCandidateKeyPreferPrimaryKey = tryEvaluateCandidateKeyPreferPrimaryKey;
//# sourceMappingURL=evaluate-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
async function tryEvaluateColumns(table, connection, name, columnAliases, row) {
    /**
     * We do not want extra properties
     */
    row = tm.TypeUtil.pick(row, ...columnAliases);
    const rowKeys = Object.keys(row);
    if (rowKeys.length < columnAliases.length) {
        const missingColumns = columnAliases
            .filter(columnAlias => !rowKeys.includes(columnAlias));
        return {
            success: false,
            error: new Error(`Input row is missing columns ${missingColumns.join(", ")}`),
        };
    }
    const outputRowMapper = column_map_1.ColumnMapUtil.mapper(column_map_1.ColumnMapUtil.pick(table.columns, columnAliases));
    const outputRowResult = tm.tryMapHandled(outputRowMapper, name, row);
    if (outputRowResult.success) {
        /**
         * The best case scenario
         */
        return {
            success: true,
            outputRow: outputRowResult.value,
        };
    }
    /**
     * Not so great.
     * We have to make a DB call to evaluate the expression(s)
     */
    const query = unified_query_1.QueryUtil
        .newInstance()
        .select(() => columnAliases
        .map(columnAlias => {
        const rawExprInput = row[columnAlias];
        return expr_1.ExprUtil.fromRawExprNoUsedRefInput(table.columns[columnAlias], rawExprInput).as(columnAlias);
    }));
    row = await execution_1.ExecutionUtil.fetchOne(query, connection);
    const outputRowResult2 = tm.tryMapHandled(outputRowMapper, name, row);
    if (outputRowResult2.success) {
        return {
            success: true,
            outputRow: outputRowResult2.value,
        };
    }
    else {
        return {
            success: false,
            error: outputRowResult2.mappingError,
        };
    }
}
exports.tryEvaluateColumns = tryEvaluateColumns;
//# sourceMappingURL=evaluate-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-custom-expr.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-custom-expr.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const util_1 = __webpack_require__(/*! ../../../built-in-expr/util */ "./node_modules/@squill/squill/dist/built-in-expr/util/index.js");
/**
 * Given a type `T`, we may have a `CustomExpr_NonCorrelated<T>`.
 *
 * This may be `T` itself, or `IExpr<T>` or `IColumn<T>` or
 * any other non-`T`.
 *
 * However, we **want** `T`.
 * This function helps us resolve non-`T` types to `T` itself.
 */
async function evaluateCustomExpr(column, connection, customExpr) {
    if (util_1.isAnyNonValueExpr(customExpr)) {
        //We have a non-value expression, evaluate it to figure out what its value is
        const rawEvaluatedValue = await unified_query_1.QueryUtil
            .newInstance()
            .selectValue(() => customExpr)
            .fetchValue(connection);
        //We must have a value now
        const evaluatedValue = column.mapper(`${column.tableAlias}.${column.columnAlias}`, rawEvaluatedValue);
        return evaluatedValue;
    }
    const valueResult = tm.mapHandled(column.mapper, `${column.tableAlias}.${column.columnAlias}`, customExpr);
    return valueResult;
}
exports.evaluateCustomExpr = evaluateCustomExpr;
//# sourceMappingURL=evaluate-custom-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-insertable-candidate-key.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-insertable-candidate-key.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js");
const evaluate_primary_key_1 = __webpack_require__(/*! ./evaluate-primary-key */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-primary-key.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
async function tryEvaluateInsertableCandidateKey(table, connection, row) {
    const insertableColumnAliases = table_1.TableUtil.insertableColumnAlias(table);
    const mappingErrors = [];
    for (const candidateKey of table.candidateKeys) {
        if (!key_1.KeyUtil.isSubKey(candidateKey, insertableColumnAliases)) {
            continue;
        }
        const evaluateResult = await evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.insertableCandidateKey`, candidateKey, row);
        if (evaluateResult.success) {
            return evaluateResult;
        }
        if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
            mappingErrors.push(evaluateResult.error);
        }
    }
    return {
        success: false,
        error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.insertableCandidateKey`, row, mappingErrors),
    };
}
exports.tryEvaluateInsertableCandidateKey = tryEvaluateInsertableCandidateKey;
async function tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row) {
    if (table.primaryKey == undefined) {
        return tryEvaluateInsertableCandidateKey(table, connection, row);
    }
    if (table.primaryKey.every(columnAlias => table_1.TableUtil.isInsertableColumnAlias(table, columnAlias))) {
        const evaluatePrimaryKeyResult = await evaluate_primary_key_1.tryEvaluatePrimaryKey(table, connection, row);
        if (evaluatePrimaryKeyResult.success) {
            return evaluatePrimaryKeyResult;
        }
    }
    return tryEvaluateInsertableCandidateKey(table, connection, row);
}
exports.tryEvaluateInsertableCandidateKeyPreferPrimaryKey = tryEvaluateInsertableCandidateKeyPreferPrimaryKey;
//# sourceMappingURL=evaluate-insertable-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-primary-key.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-primary-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const evaluate_columns_1 = __webpack_require__(/*! ./evaluate-columns */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js");
async function tryEvaluatePrimaryKey(table, connection, row) {
    return evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.primaryKey`, table.primaryKey, row);
}
exports.tryEvaluatePrimaryKey = tryEvaluatePrimaryKey;
//# sourceMappingURL=evaluate-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./evaluate-candidate-key */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-candidate-key.js"));
__export(__webpack_require__(/*! ./evaluate-columns */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-columns.js"));
__export(__webpack_require__(/*! ./evaluate-custom-expr */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-custom-expr.js"));
__export(__webpack_require__(/*! ./evaluate-insertable-candidate-key */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-insertable-candidate-key.js"));
__export(__webpack_require__(/*! ./evaluate-primary-key */ "./node_modules/@squill/squill/dist/data-type/util/operation/evaluate-primary-key.js"));
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/data-type/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/operation/intersect.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/operation/intersect.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/data-type/util/predicate/index.js");
const constructor_1 = __webpack_require__(/*! ../constructor */ "./node_modules/@squill/squill/dist/data-type/util/constructor/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
/**
 * @todo Implement something more efficient to generalize intersect `N` mappers.
 *
 * This runs a `mixed` value through both `mapperA` and `mapperB`.
 * Then, it checks that both mapped results are equal.
 *
 * It **does not** try to "deep-merge" both mapped results.
 *
 * So, you cannot combine mappers for `{x:number}` and `{y:number}`
 * and hope to have a value of type `{x:number, y:number}` during run-time.
 *
 * it will just throw a run-time error because a value of exactly type `{x:number}`
 * is not equal to a value of exactly type `{y:number}`.
 */
function intersect(mapperA, mapperB) {
    if (predicate_1.isDataType(mapperA)) {
        if (predicate_1.isDataType(mapperB)) {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperA.isNullSafeEqual(mappedA, 
                /**
                 * This may throw
                 */
                mapperA(name, mappedB))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                if (!mapperB.isNullSafeEqual(mappedB, 
                /**
                 * This may throw
                 */
                mapperB(name, mappedA))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} ${tm.TypeUtil.toTypeStr(mappedB)} fails RHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperA.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperA.isNullSafeEqual(a, b);
            });
        }
        else {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperA.isNullSafeEqual(mappedA, 
                /**
                 * This may throw
                 */
                mapperA(name, mappedB))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 *
                 * Well, we couldn't perform RHS equality checks...
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperA.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperA.isNullSafeEqual(a, b);
            });
        }
    }
    else {
        if (predicate_1.isDataType(mapperB)) {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (!mapperB.isNullSafeEqual(mappedB, 
                /**
                 * This may throw
                 */
                mapperB(name, mappedA))) {
                    /**
                     * @todo Find a way to make better messages.
                     */
                    throw tm.ErrorUtil.makeMappingError({
                        message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        inputName: name,
                        actualValue: mixed,
                        expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                        expectedMeta: {
                            mapperA,
                            mapperB,
                        },
                    });
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 *
                 * Well, we couldn't perform LHS equality checks...
                 */
                return mappedB;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 */
                return mapperB.toBuiltInExpr_NonCorrelated(value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to say they
                 * are null-safe-equal.
                 */
                return mapperB.isNullSafeEqual(a, b);
            });
        }
        else {
            return constructor_1.makeDataType((name, mixed) => {
                const mappedA = mapperA(name, mixed);
                const mappedB = mapperB(name, mixed);
                if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedA)) {
                    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                        if (!built_in_value_expr_1.BuiltInValueExprUtil.isEqual(mappedA, mappedB)) {
                            /**
                             * @todo Find a way to make better messages.
                             */
                            throw tm.ErrorUtil.makeMappingError({
                                message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                inputName: name,
                                actualValue: mixed,
                                expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                expectedMeta: {
                                    mapperA,
                                    mapperB,
                                },
                            });
                        }
                    }
                    else {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                }
                else {
                    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    else {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check; use IDataType instead of SafeMapper`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                }
                /**
                 * Since the two values are "equal",
                 * it should not matter which we return.
                 */
                return mappedA;
            }, (value) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we only need one mapper to convert to a built-in expr.
                 *
                 * So, we can assume they are built-in values
                 */
                return built_in_expr_1.BuiltInExprUtil.fromValueExpr(mapperA, value);
            }, (a, b) => {
                /**
                 * We assume that `a` and `b`
                 * have already gone through the above mapping function.
                 *
                 * So, we can assume they are built-in values
                 */
                return (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(a) &&
                    built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(b) &&
                    built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b));
            });
        }
    }
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/predicate/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/predicate/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-data-type */ "./node_modules/@squill/squill/dist/data-type/util/predicate/is-data-type.js"));
__export(__webpack_require__(/*! ./is-null-safe-equal */ "./node_modules/@squill/squill/dist/data-type/util/predicate/is-null-safe-equal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/predicate/is-data-type.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/predicate/is-data-type.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function isDataType(raw) {
    if (typeof raw != "function") {
        return false;
    }
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "toBuiltInExpr_NonCorrelated",
        "isNullSafeEqual",
    ])) {
        return false;
    }
    return ((typeof raw.toBuiltInExpr_NonCorrelated == "function") &&
        (typeof raw.isNullSafeEqual == "function"));
}
exports.isDataType = isDataType;
//# sourceMappingURL=is-data-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/data-type/util/predicate/is-null-safe-equal.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/data-type/util/predicate/is-null-safe-equal.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const is_data_type_1 = __webpack_require__(/*! ./is-data-type */ "./node_modules/@squill/squill/dist/data-type/util/predicate/is-data-type.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
/**
 * If `mapper` is `IDataType`, it uses `mapper.isNullSafeEqual()`.
 *
 * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`,
 * but may not be suitable for custom data types.
 */
function isNullSafeEqual(mapper, a, b) {
    if (column_1.ColumnUtil.isColumn(mapper)) {
        mapper = mapper.mapper;
    }
    if (is_data_type_1.isDataType(mapper)) {
        return mapper.isNullSafeEqual(a, b);
    }
    else {
        if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(a)) {
            if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(b)) {
                return built_in_value_expr_1.BuiltInValueExprUtil.isEqual(a, b);
            }
            else {
                return false;
            }
        }
        else {
            return tm.TypeUtil.strictEqual(a, b);
        }
    }
}
exports.isNullSafeEqual = isNullSafeEqual;
//# sourceMappingURL=is-null-safe-equal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/date-time-util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/date-time-util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/date-time-util/util.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/date-time-util/util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/date-time-util/util.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Right now, this is MySQL-specific.
 *
 * But I imagine this should work on most (all?) SQL databases.
 *
 * @todo Investigate. If incompatible, fix.
 */
const StringUtil = __webpack_require__(/*! ../string-util */ "./node_modules/@squill/squill/dist/string-util/index.js");
//Uses UTC
//Truncates if fractionSecondPrecision is too small.
function toSqlUtc(d, fractionalSecondPrecision /*|4|5|6*/) {
    if (!isFinite(d.getTime())) {
        throw new Error("Invalid date passed");
    }
    const year = StringUtil.zeroPad(d.getUTCFullYear(), 4);
    //getUTCMonth() returns [0, 11]
    //We want [1, 12]
    const month = StringUtil.zeroPad(d.getUTCMonth() + 1, 2);
    const day = StringUtil.zeroPad(d.getUTCDate(), 2);
    const hour = StringUtil.zeroPad(d.getUTCHours(), 2);
    const minute = StringUtil.zeroPad(d.getUTCMinutes(), 2);
    const second = StringUtil.zeroPad(d.getUTCSeconds(), 2);
    if (fractionalSecondPrecision == 0) {
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
    }
    else {
        const ms = StringUtil.zeroPad(d.getUTCMilliseconds(), fractionalSecondPrecision).substr(0, fractionalSecondPrecision);
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;
    }
}
exports.toSqlUtc = toSqlUtc;
//Month is zero-based
//Day is one-based
function isValidDate(year, month, day) {
    var d = new Date(year, month, day);
    if (d.getFullYear() === year && d.getMonth() === month && d.getDate() === day) {
        return true;
    }
    return false;
}
const mySqlDateTimeRegex = /^(\d{4})-(\d{2})-(\d{2})( (\d{2}):(\d{2}):(\d{2})(\.(\d{1,6}))?)?$/;
//Assumes UTC
function fromSqlUtc(sql, fractionalSecondPrecision /*|4|5|6*/) {
    const match = mySqlDateTimeRegex.exec(sql);
    if (match == undefined) {
        throw new Error(`Invalid MySQL DATETIME string`);
    }
    const year = parseInt(match[1]);
    //1-based
    const month = parseInt(match[2]);
    //1-based
    const dayOfMonth = parseInt(match[3]);
    if (!isValidDate(year, month - 1, dayOfMonth)) {
        throw new Error(`Invalid MySQL DATETIME string; month or day does not exist for given year`);
    }
    const hour = (match[5] == undefined) ?
        0 :
        parseInt(match[5]);
    if (hour > 23) {
        throw new Error(`Hour must be [0, 23]`);
    }
    const minute = (match[6] == undefined) ?
        0 :
        parseInt(match[6]);
    if (minute > 59) {
        throw new Error(`Minute must be [0, 59]`);
    }
    const second = (match[7] == undefined) ?
        0 :
        parseInt(match[7]);
    if (second > 59) {
        throw new Error(`Second must be [0, 59]`);
    }
    const microsecondPart = (match[9] == undefined) ?
        0 :
        parseInt(StringUtil.trailingZeroPad(match[9], 6));
    if (microsecondPart > 999999) {
        throw new Error(`Microsecond must be [0, 999999]`);
    }
    const millisecond = Math.floor(microsecondPart / 1000);
    const microsecond = microsecondPart % 1000;
    if (match[9] != undefined &&
        match[9].length > fractionalSecondPrecision) {
        throw new Error(`Expected DATETIME(${fractionalSecondPrecision}), received DATETIME(${match[9].length})`);
    }
    //TODO-FEATURE Microsecond support
    //BEGIN TEMPORARY NON-SUPPORT FOR MICROSECOND
    if (microsecond != 0) {
        throw new Error(`Microsecond support for DATETIME is not supported yet`);
    }
    //END TEMPORARY NON-SUPPORT FOR MICROSECOND
    const utcMillisecondTimestamp = Date.UTC(year, 
    //Date.UTC() expects [0, 11]
    month - 1, dayOfMonth, hour, minute, second, millisecond);
    return new Date(utcMillisecondTimestamp);
}
exports.fromSqlUtc = fromSqlUtc;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/date-util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/date-util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-date */ "./node_modules/@squill/squill/dist/date-util/is-date.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/date-util/is-date.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/date-util/is-date.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isDate(x) {
    return Object.prototype.toString.call(x) === "[object Date]";
}
exports.isDate = isDate;
//# sourceMappingURL=is-date.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table-select-item/derived-table-select-item-impl.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table-select-item/derived-table-select-item-impl.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_1 = __webpack_require__(/*! ../derived-table */ "./node_modules/@squill/squill/dist/derived-table/index.js");
const expr_1 = __webpack_require__(/*! ../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
/**
 * Meant to be a combination of `DerivedTable` and `AliasedExpr`.
 */
class DerivedTableSelectItem {
    constructor(data, unaliasedAst) {
        this.mapper = data.mapper;
        this.isLateral = data.isLateral;
        this.tableAlias = data.tableAlias;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.isAggregate = data.isAggregate;
        this.ast = unaliasedAst;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * For now, the moment you use the `LATERAL` modifier,
     * it can no longer be used as an expression or aliased expression.
     *
     * No real reason for this rule, just laziness.
     */
    lateral() {
        return derived_table_1.DerivedTableUtil.lateral(this);
    }
    /**
     * For now, the moment you try to re-alias,
     * it can no longer be used as a derived table.
     *
     * No real reason for this rule, just laziness.
     *
     * -----
     *
     * If you are running into "max instantiation depth" errors,
     * consider adding explicit `TableExpr<>` type annotations.
     *
     * If that doesn't help,
     * consider using `ExprUtil.as()` instead.
     *
     * Also, consider reading this to understand my frustration,
     * https://github.com/microsoft/TypeScript/issues/29511
     *
     * @param alias
     */
    as(alias) {
        return expr_1.ExprUtil.as(this, alias);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() ASC
     * ```
     */
    asc() {
        return expr_1.ExprUtil.asc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() DESC
     * ```
     */
    desc() {
        return expr_1.ExprUtil.desc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  (myTable.myColumn IS NOT NULL) ASC,
     *  RAND() DESC
     * ```
     */
    sort(sortDirection) {
        return expr_1.ExprUtil.sort(this, sortDirection);
    }
}
exports.DerivedTableSelectItem = DerivedTableSelectItem;
//# sourceMappingURL=derived-table-select-item-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table-select-item/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table-select-item/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./derived-table-select-item-impl */ "./node_modules/@squill/squill/dist/derived-table-select-item/derived-table-select-item-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table/derived-table-impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table/derived-table-impl.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DerivedTableUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/derived-table/util/index.js");
/**
 * A query can be aliased,
 *
 * ```sql
 * SELECT
 *  *
 * FROM
 *  myTable
 * CROSS JOIN
 *  (
 *      SELECT
 *          RAND() AS randomNumber,
 *          UTC_TIMESTAMP() AS timeNow
 *  ) AS tmpTable --This is a `DerivedTable`
 * ```
 *
 */
class DerivedTable {
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * Makes a derived table a `LATERAL` derived table.
     *
     * -----
     *
     * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      (
     *          SELECT
     *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * However, a `LATERAL` derived table can,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      LATERAL (
     *          SELECT
     *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * Note:
     * + Not supported in MySQL 5.7
     * + Supported as of MySQL 8.0.14
     */
    lateral() {
        return DerivedTableUtil.lateral(this);
    }
}
exports.DerivedTable = DerivedTable;
//# sourceMappingURL=derived-table-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./derived-table-impl */ "./node_modules/@squill/squill/dist/derived-table/derived-table-impl.js"));
const DerivedTableUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/derived-table/util/index.js");
exports.DerivedTableUtil = DerivedTableUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/derived-table/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lateral */ "./node_modules/@squill/squill/dist/derived-table/util/operation/lateral.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/derived-table/util/operation/lateral.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/derived-table/util/operation/lateral.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_impl_1 = __webpack_require__(/*! ../../derived-table-impl */ "./node_modules/@squill/squill/dist/derived-table/derived-table-impl.js");
/**
 * Makes a derived table a `LATERAL` derived table.
 *
 * -----
 *
 * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable
 *  CROSS JOIN
 *      (
 *          SELECT
 *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
 *              myTable.x + otherTable.y AS z
 *          FROM
 *              otherTable
 *      ) AS tmpTable
 * ```
 *
 * However, a `LATERAL` derived table can,
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable
 *  CROSS JOIN
 *      LATERAL (
 *          SELECT
 *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
 *              myTable.x + otherTable.y AS z
 *          FROM
 *              otherTable
 *      ) AS tmpTable
 * ```
 *
 * Note:
 * + Not supported in MySQL 5.7
 * + Supported as of MySQL 8.0.14
 */
function lateral(derivedTable) {
    const result = new derived_table_impl_1.DerivedTable({
        isLateral: true,
        alias: derivedTable.alias,
        columns: derivedTable.columns,
        usedRef: derivedTable.usedRef,
    }, derivedTable.unaliasedAst);
    return result;
}
exports.lateral = lateral;
//# sourceMappingURL=lateral.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./log-impl */ "./node_modules/@squill/squill/dist/design-pattern-log/log-impl.js"));
const LogUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/design-pattern-log/util/index.js");
exports.LogUtil = LogUtil;
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/design-pattern-log/util/index.js");
exports.log = util_1.log;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/log-impl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/log-impl.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LogUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/design-pattern-log/util/index.js");
class Log {
    constructor(data, extraData) {
        /**
         * A collection of correlated subqueries/expressions,
         * these require the `ownerTable` to be in the `FROM` clause.
         */
        this.correlatedSubquery = {
            exists: () => {
                return LogUtil.CorrelatedSubquery.exists(this);
            },
            latest: () => {
                return LogUtil.CorrelatedSubquery.latest(this);
            },
            latestValue: (selectValueDelegate) => {
                return LogUtil.CorrelatedSubquery.latestValue(this, selectValueDelegate);
            },
            latestValueOrDefault: (selectValueDelegate) => {
                return LogUtil.CorrelatedSubquery.latestValueOrDefault(this, selectValueDelegate);
            },
        };
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
        this.trackedWithDefaultValue = data.trackedWithDefaultValue;
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.copyDefaultsDelegate = extraData.copyDefaultsDelegate;
        this.trackedDefaults = extraData.trackedDefaults;
    }
    fetchDefault(connection, primaryKey) {
        return LogUtil.fetchDefault(this, connection, primaryKey);
    }
    fetchLatest(connection, primaryKey) {
        return LogUtil.fetchLatest(this, connection, primaryKey);
    }
    fetchLatestValue(connection, primaryKey, selectValueDelegate) {
        return LogUtil.fetchLatestValue(this, connection, primaryKey, selectValueDelegate);
    }
    /**
     * @todo Make this part of fluent API of `fetchLatest()`?
     */
    fetchLatestOrDefault(connection, primaryKey) {
        return LogUtil.fetchLatestOrDefault(this, connection, primaryKey);
    }
    fetchLatestValueOrDefault(connection, primaryKey, selectValueDelegate) {
        return LogUtil.fetchLatestValueOrDefault(this, connection, primaryKey, selectValueDelegate);
    }
    exists(connection, primaryKey) {
        return LogUtil.exists(this, connection, primaryKey);
    }
    trackOrInsert(connection, primaryKey, trackOrInsertRow) {
        return LogUtil.trackOrInsert(this, connection, primaryKey, trackOrInsertRow);
    }
    unsafeTrack(connection, primaryKey, unsafeTrackRow) {
        return LogUtil.unsafeTrack(this, connection, primaryKey, unsafeTrackRow);
    }
    track(connection, primaryKey, trackRow) {
        return LogUtil.track(this, connection, primaryKey, trackRow);
    }
}
exports.Log = Log;
//# sourceMappingURL=log-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/00-log.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/00-log.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const _01_set_owner_1 = __webpack_require__(/*! ./01-set-owner */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/01-set-owner.js");
function log(logTable) {
    return new _01_set_owner_1.LogMustSetOwner({
        logTable,
    });
}
exports.log = log;
/*
import {table} from "../../../table";
import * as tm from "type-mapping";
import {KeyArrayUtil} from "../../../key";
import {Identity} from "../../../type-util";
import {from, requireOuterQueryJoins} from "../../../unified-query";
import {eqPrimaryKeyOfTable} from "../../../expr-library";

export const businessFile = table("businessFile")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessFileId : tm.mysql.bigIntSigned(),
        awsS3PresignedUploadId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
        fileTypeId : tm.mysql.bigIntSigned(),
        updatedAt : tm.mysql.dateTime(),
        updatedAt2 : tm.mysql.dateTime(),
        updatedByExternalUserId : tm.mysql.varChar().orNull(),
    })
    .setAutoIncrement(c => c.businessFileId)
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt,
    ])
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt2,
    ])
    .addExplicitDefaultValue(c => [c.updatedAt])
    .addExplicitDefaultValue(c => [c.updatedAt2])
    .removeAllMutable();

export const businessFileType = table("businessFileType")
    .addColumns({
        businessId : tm.mysql.bigIntSigned(),
        businessTypeId : tm.mysql.bigIntSigned(),
        fileTypeId : tm.mysql.bigIntSigned(),
        createdAt : tm.mysql.dateTime(),
    })
    .setPrimaryKey(c => [c.businessId, c.fileTypeId])
    .addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

export const business = table("business")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
    })
    .setAutoIncrement(c => c.businessId)
    //.addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

businessFile.candidateKeys
type ca = LatestOrderColumnAlias<typeof businessFile, typeof businessFileType>;
type cm = LatestOrderColumnMap<typeof businessFile, typeof businessFileType>;

const businessFileLog = log(
    {
        logTable : businessFile,
        ownerTable : businessFileType
    },
    columns => columns.updatedAt.desc(),
    columns => [columns.awsS3PresignedUploadId]
).setDoNotCopy(
    columns => [columns.updatedByExternalUserId]
).setCopyDefaults(({ownerPrimaryKey, connection}) => {
    return business.fetchOneByPrimaryKey(
        connection,
        ownerPrimaryKey,
        c => [c.appId, c.externalUserId]
    );
}).setTrackedDefaults({
    awsS3PresignedUploadId : 1n
});
businessFileLog.setDoNotCopy(columns => [])
*/
//# sourceMappingURL=00-log.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/01-set-owner.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/01-set-owner.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const _02_set_latest_order_1 = __webpack_require__(/*! ./02-set-latest-order */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/02-set-latest-order.js");
class LogMustSetOwner {
    constructor(data) {
        this.logTable = data.logTable;
    }
    setOwner(ownerTable) {
        return new _02_set_latest_order_1.LogMustSetLatestOrder({
            logTable: this.logTable,
            ownerTable,
        });
    }
}
exports.LogMustSetOwner = LogMustSetOwner;
//# sourceMappingURL=01-set-owner.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/02-set-latest-order.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/02-set-latest-order.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const _03_set_tracked_1 = __webpack_require__(/*! ./03-set-tracked */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/03-set-tracked.js");
function latestOrderColumnAlias(data) {
    const { logTable, ownerTable } = data;
    const possibleColumnAliases = [
        ...logTable.explicitDefaultValueColumns,
        ...logTable.generatedColumns,
    ];
    const result = possibleColumnAliases.filter(columnAlias => key_1.KeyArrayUtil.hasKey(logTable.candidateKeys, [...ownerTable.primaryKey, columnAlias]));
    return result;
}
exports.latestOrderColumnAlias = latestOrderColumnAlias;
class LogMustSetLatestOrder {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
    }
    setLatestOrder(latestOrderDelegate) {
        const latestOrderColumns = column_map_1.ColumnMapUtil.pick(this.logTable.columns, latestOrderColumnAlias(this));
        const latestOrder = latestOrderDelegate(latestOrderColumns);
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(latestOrderColumns, [latestOrder[0]]);
        return new _03_set_tracked_1.LogMustSetTracked({
            logTable: this.logTable,
            ownerTable: this.ownerTable,
            latestOrder,
        });
    }
}
exports.LogMustSetLatestOrder = LogMustSetLatestOrder;
//# sourceMappingURL=02-set-latest-order.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/03-set-tracked.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/03-set-tracked.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const _04_set_do_not_copy_1 = __webpack_require__(/*! ./04-set-do-not-copy */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js");
class LogMustSetTracked {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
    }
    setTracked(trackedDelegate) {
        const trackedColumns = column_map_1.ColumnMapUtil.omit(this.logTable.columns, [
            ...this.ownerTable.primaryKey,
            ...this.logTable.generatedColumns,
            this.latestOrder[0].columnAlias,
        ]);
        const tracked = trackedDelegate(trackedColumns);
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(trackedColumns, tracked);
        const invalidCopy = [
            ...this.ownerTable.primaryKey,
            ...this.logTable.generatedColumns,
            ...(this.logTable.autoIncrement == undefined ?
                [] :
                [this.logTable.autoIncrement]),
            this.latestOrder[0].columnAlias,
            ...tracked.map(column => column.columnAlias),
        ];
        const copy = column_1.ColumnArrayUtil.fromColumnMap(this.logTable.columns)
            .map(column => column.columnAlias)
            .filter(columnAlias => {
            return !invalidCopy.includes(columnAlias);
        });
        return new _04_set_do_not_copy_1.LogMustSetDoNotCopy({
            logTable: this.logTable,
            ownerTable: this.ownerTable,
            latestOrder: this.latestOrder,
            tracked: tracked.map(column => column.columnAlias),
            copy: copy,
        });
    }
}
exports.LogMustSetTracked = LogMustSetTracked;
//# sourceMappingURL=03-set-tracked.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const _06_set_tracked_defaults_1 = __webpack_require__(/*! ./06-set-tracked-defaults */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js");
const _05_set_copy_defaults_delegate_1 = __webpack_require__(/*! ./05-set-copy-defaults-delegate */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js");
function setDoNotCopy(log, delegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.copy);
    const doNotCopy = delegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columns, doNotCopy);
    const { logTable, ownerTable, latestOrder, tracked, } = log;
    const copy = log.copy
        .filter((columnName) => {
        return !doNotCopy.some(c => c.columnAlias == columnName);
    });
    if (copy.length == 0) {
        const result = new _06_set_tracked_defaults_1.LogMustSetTrackedDefaults({
            logTable,
            ownerTable,
            latestOrder,
            tracked,
            doNotCopy: doNotCopy.map(c => c.columnAlias),
            copy,
            copyDefaultsDelegate: () => Promise.resolve({}),
        });
        return result;
    }
    else {
        const result = new _05_set_copy_defaults_delegate_1.LogMustSetCopyDefaultsDelegate({
            logTable,
            ownerTable,
            latestOrder,
            tracked,
            doNotCopy: doNotCopy.map(c => c.columnAlias),
            copy,
        });
        return result;
    }
}
exports.setDoNotCopy = setDoNotCopy;
class LogMustSetDoNotCopy {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.copy = data.copy;
    }
    setDoNotCopy(delegate) {
        return setDoNotCopy(this, delegate);
    }
}
exports.LogMustSetDoNotCopy = LogMustSetDoNotCopy;
//# sourceMappingURL=04-set-do-not-copy.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const custom_expr_1 = __webpack_require__(/*! ../../../custom-expr */ "./node_modules/@squill/squill/dist/custom-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const _06_set_tracked_defaults_1 = __webpack_require__(/*! ./06-set-tracked-defaults */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
function setCopyDefaultsDelegate(log, rawCopyDefaultsDelegate) {
    /**
     * Nothing is allowed
     */
    const allowedRef = used_ref_1.UsedRefUtil.fromColumnRef({});
    const requiredColumnAliases = table_1.TableUtil.requiredColumnAlias(log.logTable)
        .filter(columnName => (log.copy.indexOf(columnName) >= 0));
    const optionalColumnAliases = table_1.TableUtil.optionalColumnAlias(log.logTable)
        .filter(columnName => (log.copy.indexOf(columnName) >= 0));
    const copyDefaults = async (args) => {
        const customExprResult = await rawCopyDefaultsDelegate({
            ...args,
            ownerPrimaryKey: primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, args.ownerPrimaryKey),
        });
        const valueExprResult = {};
        for (const columnAlias of requiredColumnAliases) {
            const customExpr = customExprResult[columnAlias];
            if (customExpr === undefined) {
                throw new Error(`Expected a value for ${log.logTable.alias}.${columnAlias}`);
            }
            const usedRef = custom_expr_1.CustomExprUtil.usedRef(customExpr);
            used_ref_1.UsedRefUtil.assertAllowed(allowedRef, usedRef);
            valueExprResult[columnAlias] = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
        }
        for (const columnAlias of optionalColumnAliases) {
            const customExpr = customExprResult[columnAlias];
            if (customExpr === undefined) {
                continue;
            }
            const usedRef = custom_expr_1.CustomExprUtil.usedRef(customExpr);
            used_ref_1.UsedRefUtil.assertAllowed(allowedRef, usedRef);
            valueExprResult[columnAlias] = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
        }
        return valueExprResult;
    };
    const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, } = log;
    return new _06_set_tracked_defaults_1.LogMustSetTrackedDefaults({
        logTable,
        ownerTable,
        latestOrder,
        tracked,
        doNotCopy,
        copy,
        copyDefaultsDelegate: copyDefaults,
    });
}
exports.setCopyDefaultsDelegate = setCopyDefaultsDelegate;
class LogMustSetCopyDefaultsDelegate {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
    }
    setCopyDefaults(rawCopyDefaultsDelegate) {
        return setCopyDefaultsDelegate(this, rawCopyDefaultsDelegate);
    }
}
exports.LogMustSetCopyDefaultsDelegate = LogMustSetCopyDefaultsDelegate;
//# sourceMappingURL=05-set-copy-defaults-delegate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const log_impl_1 = __webpack_require__(/*! ../../log-impl */ "./node_modules/@squill/squill/dist/design-pattern-log/log-impl.js");
const custom_expr_1 = __webpack_require__(/*! ../../../custom-expr */ "./node_modules/@squill/squill/dist/custom-expr/index.js");
function setTrackedDefaults(log, rawTrackedDefaults) {
    const trackedDefaults = {};
    for (const columnAlias of log.tracked) {
        const customExpr = rawTrackedDefaults[columnAlias];
        if (customExpr === undefined) {
            continue;
        }
        const value = custom_expr_1.CustomExprUtil.mapNonCorrelated(log.logTable.columns[columnAlias], customExpr);
        trackedDefaults[columnAlias] = value;
    }
    const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, copyDefaultsDelegate, } = log;
    return new log_impl_1.Log({
        tracked,
        doNotCopy,
        copy,
        trackedWithDefaultValue: Object.keys(trackedDefaults),
        logTable,
        ownerTable,
        latestOrder,
    }, {
        copyDefaultsDelegate,
        trackedDefaults,
    });
}
exports.setTrackedDefaults = setTrackedDefaults;
class LogMustSetTrackedDefaults {
    constructor(data) {
        this.logTable = data.logTable;
        this.ownerTable = data.ownerTable;
        this.latestOrder = data.latestOrder;
        this.tracked = data.tracked;
        this.doNotCopy = data.doNotCopy;
        this.copy = data.copy;
        this.copyDefaultsDelegate = data.copyDefaultsDelegate;
    }
    setTrackedDefaults(rawTrackedDefaults) {
        return setTrackedDefaults(this, rawTrackedDefaults);
    }
}
exports.LogMustSetTrackedDefaults = LogMustSetTrackedDefaults;
//# sourceMappingURL=06-set-tracked-defaults.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./00-log */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/00-log.js"));
__export(__webpack_require__(/*! ./01-set-owner */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/01-set-owner.js"));
__export(__webpack_require__(/*! ./02-set-latest-order */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/02-set-latest-order.js"));
__export(__webpack_require__(/*! ./03-set-tracked */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/03-set-tracked.js"));
__export(__webpack_require__(/*! ./04-set-do-not-copy */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/04-set-do-not-copy.js"));
__export(__webpack_require__(/*! ./05-set-copy-defaults-delegate */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/05-set-copy-defaults-delegate.js"));
__export(__webpack_require__(/*! ./06-set-tracked-defaults */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/06-set-tracked-defaults.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/exists.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/exists.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function exists(log) {
    return ExprLib.exists(unified_query_1.QueryUtil.newInstance()
        .requireOuterQueryJoins(...[log.ownerTable])
        .from(log.logTable)
        .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable)));
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/exists.js"));
__export(__webpack_require__(/*! ./latest-value-or-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js"));
__export(__webpack_require__(/*! ./latest-value */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value.js"));
__export(__webpack_require__(/*! ./latest */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value-or-default.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const exists_1 = __webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/exists.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const latest_1 = __webpack_require__(/*! ./latest */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest.js");
function latestValueOrDefault(log, selectValueDelegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
    const column = selectValueDelegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
    if (tm.canOutputNull(column.mapper)) {
        /**
         * It is possible for a row to exist but the value is `NULL`.
         * Especially when the column is nullable.
         */
        return ExprLib.if(exists_1.exists(log), latest_1.latest(log)
            .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
    }
    else {
        /**
         * Column is not nullable, we should never have `NULL`
         * unless it's because a row does not exist.
         */
        return ExprLib.coalesce(latest_1.latest(log)
            .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
    }
}
exports.latestValueOrDefault = latestValueOrDefault;
//# sourceMappingURL=latest-value-or-default.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest-value.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_1 = __webpack_require__(/*! ./latest */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
function latestValue(log, selectValueDelegate) {
    return expr_1.ExprUtil.fromBuiltInExpr(latest_1.latest(log)
        .selectValue(selectValueDelegate));
}
exports.latestValue = latestValue;
//# sourceMappingURL=latest-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/latest.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function latest(log) {
    return unified_query_1.QueryUtil.newInstance()
        .requireOuterQueryJoins(...[log.ownerTable])
        .from(log.logTable)
        .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable))
        .orderBy(() => [log.latestOrder])
        .limit(1);
}
exports.latest = latest;
//# sourceMappingURL=latest.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/exists.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/exists.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
async function exists(log, connection, primaryKey) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return unified_query_1.QueryUtil.newInstance()
        .from(log.logTable)
        .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
        .exists(connection);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-default.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-default.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
function assertAllTrackedHasDefaultValue(log) {
    if (!key_1.KeyUtil.isEqual(log.tracked, log.trackedWithDefaultValue)) {
        throw new Error(`Not all tracked columns have a default value`);
    }
}
exports.assertAllTrackedHasDefaultValue = assertAllTrackedHasDefaultValue;
async function fetchDefault(log, // & AssertAllTrackedHasDefaultValue<LogT>,
connection, primaryKey) {
    //assertAllTrackedHasDefaultValue(log);
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        //If the owner does not exist, there is no default value
        await table_1.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
        const copyDefaults = await log.copyDefaultsDelegate({
            ownerPrimaryKey: primaryKey,
            connection,
        });
        const trackedColumnAliases = Object.keys(log.trackedDefaults);
        const selectClause = trackedColumnAliases.map((trackedColumnAlias) => {
            const rawExprNoUsedRef = log.trackedDefaults[trackedColumnAlias];
            return expr_1.ExprUtil.fromBuiltInExpr(built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], rawExprNoUsedRef)).as(trackedColumnAlias);
        });
        const trackedDefaults = await execution_1.ExecutionUtil.fetchOne(unified_query_1.QueryUtil.newInstance()
            .select(() => selectClause), connection);
        return {
            ...copyDefaults,
            ...trackedDefaults,
            ...primaryKey,
        };
    });
}
exports.fetchDefault = fetchDefault;
//# sourceMappingURL=fetch-default.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-or-default.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-or-default.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_default_1 = __webpack_require__(/*! ./fetch-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-default.js");
const fetch_latest_1 = __webpack_require__(/*! ./fetch-latest */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function fetchLatestOrDefault(log, connection, primaryKey) {
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const latestOrUndefined = await fetch_latest_1.fetchLatest(log, connection, primaryKey).orUndefined();
        if (latestOrUndefined != undefined) {
            return {
                isDefault: false,
                row: latestOrUndefined,
            };
        }
        return fetch_default_1.fetchDefault(log, connection, primaryKey)
            .then((def) => {
            return {
                isDefault: true,
                row: def,
            };
        });
    });
}
exports.fetchLatestOrDefault = fetchLatestOrDefault;
//# sourceMappingURL=fetch-latest-or-default.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_latest_value_1 = __webpack_require__(/*! ./fetch-latest-value */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function fetchLatestValueOrDefault(log, connection, primaryKey, selectValueDelegate) {
    const columns = column_map_1.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
    const column = selectValueDelegate(columns);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
    const latestValueOrUndefined = await fetch_latest_value_1.fetchLatestValue(log, connection, primaryKey, () => column).orUndefined();
    if (latestValueOrUndefined !== undefined) {
        return latestValueOrUndefined;
    }
    return connection.readOnlyTransactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        //If the owner does not exist, there is no default value
        await table_1.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
        return data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[column.columnAlias], connection, log.trackedDefaults[column.columnAlias]);
    });
}
exports.fetchLatestValueOrDefault = fetchLatestValueOrDefault;
//# sourceMappingURL=fetch-latest-value-or-default.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_by_primary_key_1 = __webpack_require__(/*! ./latest-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/latest-by-primary-key.js");
function fetchLatestValue(log, connection, primaryKey, selectValueDelegate) {
    const result = latest_by_primary_key_1.latestByPrimaryKey(log, primaryKey)
        .selectValue(selectValueDelegate)
        .fetchValue(connection);
    return result;
}
exports.fetchLatestValue = fetchLatestValue;
//# sourceMappingURL=fetch-latest-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const latest_by_primary_key_1 = __webpack_require__(/*! ./latest-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/latest-by-primary-key.js");
function fetchLatest(log, connection, primaryKey) {
    const result = latest_by_primary_key_1.latestByPrimaryKey(log, primaryKey)
        .select(((columns) => [columns]))
        .fetchOne(connection);
    return result;
}
exports.fetchLatest = fetchLatest;
//# sourceMappingURL=fetch-latest.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/exists.js"));
__export(__webpack_require__(/*! ./fetch-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-or-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-or-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-value-or-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value-or-default.js"));
__export(__webpack_require__(/*! ./fetch-latest-value */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-value.js"));
__export(__webpack_require__(/*! ./fetch-latest */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest.js"));
__export(__webpack_require__(/*! ./latest-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/latest-by-primary-key.js"));
__export(__webpack_require__(/*! ./track-or-insert */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track-or-insert.js"));
__export(__webpack_require__(/*! ./track */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track.js"));
__export(__webpack_require__(/*! ./unsafe-track */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/unsafe-track.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/latest-by-primary-key.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/latest-by-primary-key.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function latestByPrimaryKey(log, primaryKey) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
    return unified_query_1.QueryUtil.newInstance()
        .from(log.logTable)
        .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
        .orderBy(() => [log.latestOrder])
        .limit(1);
}
exports.latestByPrimaryKey = latestByPrimaryKey;
//# sourceMappingURL=latest-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track-or-insert.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track-or-insert.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unsafe_track_1 = __webpack_require__(/*! ./unsafe-track */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/unsafe-track.js");
async function trackOrInsert(log, connection, primaryKey, trackOrInsertRow) {
    return unsafe_track_1.unsafeTrack(log, connection, primaryKey, trackOrInsertRow);
}
exports.trackOrInsert = trackOrInsert;
//# sourceMappingURL=track-or-insert.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/track.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_default_1 = __webpack_require__(/*! ./fetch-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-default.js");
const unsafe_track_1 = __webpack_require__(/*! ./unsafe-track */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/unsafe-track.js");
async function track(log, connection, primaryKey, trackRow) {
    fetch_default_1.assertAllTrackedHasDefaultValue(log);
    return unsafe_track_1.unsafeTrack(log, connection, primaryKey, trackRow);
}
exports.track = track;
//# sourceMappingURL=track.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/unsafe-track.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/execution/unsafe-track.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const fetch_latest_or_default_1 = __webpack_require__(/*! ./fetch-latest-or-default */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/fetch-latest-or-default.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "./node_modules/@squill/squill/dist/sqlstring/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function toInsertRow(log, connection, prvRow, newRow) {
    const result = {};
    /**
     * Copy `prvRow`'s primary key
     */
    for (const primaryKeyColumnAlias of log.ownerTable.primaryKey) {
        const prvValueExpr = prvRow[primaryKeyColumnAlias];
        result[primaryKeyColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[primaryKeyColumnAlias], prvValueExpr);
    }
    /**
     * Copy all `tracked` values, if no new value is provided.
     */
    let changed = false;
    for (const trackedColumnAlias of log.tracked) {
        const newCustomExpr = newRow[trackedColumnAlias];
        const prvValueExpr = prvRow[trackedColumnAlias];
        if (newCustomExpr === undefined) {
            if (prvValueExpr === undefined) {
                throw new Error(`No new or previous value for ${sqlstring_1.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(trackedColumnAlias)} was found`);
            }
            else {
                /**
                 * Use the previous value, since we don't have a new value.
                 */
                result[trackedColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], prvValueExpr);
            }
        }
        else {
            const newValueExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[trackedColumnAlias], connection, newCustomExpr);
            result[trackedColumnAlias] = newValueExpr;
            if (!data_type_1.DataTypeUtil.isNullSafeEqual(log.logTable.columns[trackedColumnAlias].mapper, newValueExpr, prvValueExpr)) {
                /**
                 * New value is used, we consider this a change.
                 */
                changed = true;
            }
        }
    }
    /**
     * We expect new values for all required `doNotCopy` columns
     */
    for (const doNotCopyColumnAlias of log.doNotCopy) {
        const newCustomExpr = newRow[doNotCopyColumnAlias];
        if (newCustomExpr === undefined) {
            if (table_1.TableUtil.isRequiredColumnAlias(log.logTable, doNotCopyColumnAlias)) {
                throw new Error(`Expected a new value for ${sqlstring_1.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(doNotCopyColumnAlias)}`);
            }
            else {
                continue;
            }
        }
        const newValueExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[doNotCopyColumnAlias], connection, newCustomExpr);
        result[doNotCopyColumnAlias] = newValueExpr;
    }
    /**
     * Copy the previous row's `copy`
     */
    for (const copyColumnAlias of log.copy) {
        const prvValueExpr = prvRow[copyColumnAlias];
        result[copyColumnAlias] = built_in_expr_1.BuiltInExprUtil.fromValueExpr(log.logTable.columns[copyColumnAlias], prvValueExpr);
    }
    return {
        changed,
        insertRow: result,
    };
}
/**
 * Allows `tracked` columns without default values to be unset.
 * However, this comes with the risk of run-time errors, if no previous row is found.
 */
async function unsafeTrack(log, connection, primaryKey, unsafeTrackRow) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const latestOrDefault = await fetch_latest_or_default_1.fetchLatestOrDefault(log, connection, primaryKey);
        const { changed, insertRow } = await toInsertRow(log, connection, latestOrDefault.row, unsafeTrackRow);
        if (changed) {
            return {
                changed,
                previous: latestOrDefault,
                current: await execution_1.ExecutionUtil.insertAndFetch(log.logTable, connection, insertRow),
            };
        }
        else {
            return {
                changed,
                previous: latestOrDefault,
            };
        }
    });
}
exports.unsafeTrack = unsafeTrack;
//# sourceMappingURL=unsafe-track.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-log/util/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-log/util/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/design-pattern-log/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "./node_modules/@squill/squill/dist/design-pattern-log/util/execution/index.js"));
//export * from "./operation";
const CorrelatedSubquery = __webpack_require__(/*! ./correlated-subquery */ "./node_modules/@squill/squill/dist/design-pattern-log/util/correlated-subquery/index.js");
exports.CorrelatedSubquery = CorrelatedSubquery;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-per-type-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/table-per-type-impl.js"));
const TablePerTypeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/index.js");
exports.TablePerTypeUtil = TablePerTypeUtil;
exports.tablePerType = TablePerTypeUtil.tablePerType;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/table-per-type-impl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/table-per-type-impl.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TablePerTypeUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
class TablePerType {
    constructor(data, joins) {
        this.childTable = data.childTable;
        this.parentTables = data.parentTables;
        this.autoIncrement = data.autoIncrement;
        this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
        this.insertAndFetchPrimaryKey = data.insertAndFetchPrimaryKey;
        this.joins = joins;
    }
    addParent(parentTable) {
        return TablePerTypeUtil.addParent(this, parentTable);
    }
    fetchOne(connection, whereDelegate) {
        return TablePerTypeUtil.fetchOne(this, connection, whereDelegate);
    }
    fetchOneByCandidateKey(connection, candidateKey) {
        return TablePerTypeUtil.fetchOneByCandidateKey(this, connection, candidateKey);
    }
    fetchOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.fetchOneByPrimaryKey(this, connection, primaryKey);
    }
    fetchOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.fetchOneBySuperKey(this, connection, superKey);
    }
    insertAndFetch(connection, row) {
        return TablePerTypeUtil.insertAndFetch(this, connection, row);
    }
    updateAndFetchOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
    }
    updateAndFetchOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
    }
    updateAndFetchOneBySuperKey(connection, superKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
    }
    updateAndFetchZeroOrOneBySuperKey(connection, superKey, assignmentMapDelegate) {
        return TablePerTypeUtil.updateAndFetchZeroOrOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
    }
    deleteOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.deleteOneByCandidateKey(this, connection, candidateKey);
    }
    deleteOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.deleteOneByPrimaryKey(this, connection, primaryKey);
    }
    deleteOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.deleteOneBySuperKey(this, connection, superKey);
    }
    deleteZeroOrOneByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.deleteZeroOrOneByCandidateKey(this, connection, candidateKey);
    }
    deleteZeroOrOneByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.deleteZeroOrOneByPrimaryKey(this, connection, primaryKey);
    }
    deleteZeroOrOneBySuperKey(connection, superKey) {
        return TablePerTypeUtil.deleteZeroOrOneBySuperKey(this, connection, superKey);
    }
    existsByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey)).then(result => result.exists);
    }
    existsByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey)).then(result => result.exists);
    }
    existsBySuperKey(connection, superKey) {
        return TablePerTypeUtil.existsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey)).then(result => result.exists);
    }
    assertExistsByCandidateKey(connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey));
    }
    assertExistsByPrimaryKey(connection, primaryKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey));
    }
    assertExistsBySuperKey(connection, superKey) {
        return TablePerTypeUtil.assertExistsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey));
    }
}
exports.TablePerType = TablePerType;
//# sourceMappingURL=table-per-type-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-per-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/table-per-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/table-per-type.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/table-per-type.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_per_type_impl_1 = __webpack_require__(/*! ../../table-per-type-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/table-per-type-impl.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
function tablePerType(childTable) {
    return new table_per_type_impl_1.TablePerType({
        childTable,
        parentTables: [],
        autoIncrement: query_1.extractAutoIncrement(childTable),
        explicitAutoIncrementValueEnabled: query_1.extractExplicitAutoIncrementValueEnabled(childTable),
        insertAndFetchPrimaryKey: query_1.extractInsertAndFetchPrimaryKey(childTable),
    }, []);
}
exports.tablePerType = tablePerType;
//# sourceMappingURL=table-per-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
/**
 * @todo Better name
 *
 * Adds properties from `row` to `result`.
 *
 * If a property from `row` already exists on `result`,
 * we use `table` to check if the values on both objects are equal.
 *
 * If they are not equal, an `Error` is thrown.
 */
function absorbRow(result, table, row) {
    for (const columnAlias of Object.keys(row)) {
        /**
         * This is guaranteed to be a value expression.
         */
        const newValue = row[columnAlias];
        if (Object.prototype.hasOwnProperty.call(result, columnAlias)) {
            /**
             * This `curValue` could be a non-value expression.
             * We only want value expressions.
             */
            const curValue = result[columnAlias];
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(curValue)) {
                /**
                 * Add this new value to the `result`
                 * so we can use it to update rows of tables
                 * further down the inheritance hierarchy.
                 */
                result[columnAlias] = newValue;
                continue;
            }
            if (curValue === newValue) {
                /**
                 * They are equal, do nothing.
                 */
                continue;
            }
            /**
             * We need some custom equality checking logic
             */
            if (!data_type_1.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], 
            /**
             * This may throw
             */
            table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, curValue), newValue)) {
                /**
                 * @todo Custom `Error` type
                 */
                throw new Error(`All columns with the same name in an inheritance hierarchy must have the same value; mismatch found for ${table.alias}.${columnAlias}`);
            }
        }
        else {
            /**
             * Add this new value to the `result`
             * so we can use it to update rows of tables
             * further down the inheritance hierarchy.
             */
            result[columnAlias] = newValue;
        }
    }
}
exports.absorbRow = absorbRow;
//# sourceMappingURL=absorb-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const from_1 = __webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js");
async function assertExistsImpl(tpt, connection, whereDelegate) {
    return execution_1.ExecutionUtil.assertExists(from_1.from(tpt)
        .where(whereDelegate), connection);
}
exports.assertExistsImpl = assertExistsImpl;
//# sourceMappingURL=assert-exists-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function deleteOneImpl(tpt, connection, whereDelegate) {
    /**
     * @todo Add `assertDeletable()` or something
     */
    /**
     * Using `SERIALIZABLE` because it's possible for a different transaction to
     * `UPDATE` primary key values between the `fetchOne()` and multiple `deleteOne()` calls.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.SERIALIZABLE, async (connection) => {
        return connection.savepoint(async (connection) => {
            const primaryKeys = await execution_1.ExecutionUtil.fetchOne(execution_impl_1.from(tpt)
                .where(whereDelegate)
                .select(() => query_1.primaryKeyColumnAliases(tpt).map(columnAlias => {
                const table = query_1.findTableWithColumnAlias(tpt, columnAlias);
                return table.columns[columnAlias];
            })), connection);
            const deleteChildResult = await execution_1.ExecutionUtil.deleteOne(tpt.childTable, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKeys));
            const deleteOneResults = [
                {
                    ...deleteChildResult,
                    table: tpt.childTable,
                },
            ];
            let deletedRowCount = deleteChildResult.deletedRowCount;
            let warningCount = deleteChildResult.warningCount;
            /**
             * We use `.reverse()` here to `DELETE` the parents
             * as we go up the inheritance hierarchy.
             */
            for (const parentTable of [...tpt.parentTables].reverse()) {
                const deleteParentResult = await execution_1.ExecutionUtil.deleteOne(parentTable, connection, () => ExprLib.eqPrimaryKey(parentTable, primaryKeys));
                deleteOneResults.push({
                    ...deleteParentResult,
                    table: parentTable,
                });
                deletedRowCount = tm.BigIntUtil.add(deletedRowCount, deleteParentResult.deletedRowCount);
                warningCount = tm.BigIntUtil.add(warningCount, deleteParentResult.warningCount);
            }
            return {
                deleteOneResults,
                deletedRowCount,
                warningCount,
            };
        });
    });
}
exports.deleteOneImpl = deleteOneImpl;
//# sourceMappingURL=delete-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const delete_one_impl_1 = __webpack_require__(/*! ./delete-one-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js");
const exists_impl_1 = __webpack_require__(/*! ./exists-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function deleteZeroOrOneImpl(tpt, connection, whereDelegate) {
    /**
     * @todo Add `assertDeletable()` or something
     */
    /**
     * `SERIALIZABLE` because it uses `deleteOneImpl()`, which uses `SERIALIZABLE`
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.SERIALIZABLE, async (connection) => {
        const existsResult = await exists_impl_1.existsImpl(tpt, connection, whereDelegate);
        if (!existsResult.exists) {
            return {
                /**
                 * Used as a discriminant.
                 */
                deleteOneResults: undefined,
                query: { sql: existsResult.sql },
                //Alias for affectedRows
                deletedRowCount: tm.BigInt(0),
                /**
                 * @todo MySQL sometimes gives a `warningCount` value `> 0` for
                 * `DELETE` statements. Recall why.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
            };
        }
        return delete_one_impl_1.deleteOneImpl(tpt, connection, whereDelegate);
    });
}
exports.deleteZeroOrOneImpl = deleteZeroOrOneImpl;
//# sourceMappingURL=delete-zero-or-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const from_1 = __webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js");
async function existsImpl(tpt, connection, whereDelegate) {
    return execution_1.ExecutionUtil.existsImpl(from_1.from(tpt)
        .where(whereDelegate), connection);
}
exports.existsImpl = existsImpl;
//# sourceMappingURL=exists-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExecutionImpl = __webpack_require__(/*! ../../../execution/util/operation/impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const from_1 = __webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
function cleanFetchedRow(tpt, rawRow) {
    const cleanRow = {};
    for (const columnAlias of query_1.columnAliases(tpt)) {
        const tables = query_1.extractAllTablesWithColumnAlias(tpt, columnAlias);
        for (let i = 0; i < tables.length; ++i) {
            const table = tables[i];
            const value = rawRow[table.alias][columnAlias];
            for (let j = i + 1; j < tables.length; ++j) {
                const otherTable = tables[j];
                const otherValue = rawRow[otherTable.alias][columnAlias];
                if (!data_type_1.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], value, 
                /**
                 * This may throw
                 */
                table.columns[columnAlias].mapper(`(${otherTable.alias}->${table.alias}).${columnAlias}`, otherValue))) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Expected ${table.alias}.${columnAlias} and ${otherTable.alias}.${columnAlias} to have the same value`);
                }
                if (!data_type_1.DataTypeUtil.isNullSafeEqual(otherTable.columns[columnAlias], otherValue, 
                /**
                 * This may throw
                 */
                otherTable.columns[columnAlias].mapper(`(${table.alias}->${otherTable.alias}).${columnAlias}`, value))) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Expected ${otherTable.alias}.${columnAlias} and ${table.alias}.${columnAlias} to have the same value`);
                }
            }
        }
        //If we are here, then it doesn't matter which value of `columnAlias` we use.
        cleanRow[columnAlias] = rawRow[tables[0].alias][columnAlias];
    }
    return cleanRow;
}
/**
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function fetchOneImpl(tpt, connection, whereDelegate) {
    try {
        if (tpt.parentTables.length == 0) {
            return ExecutionImpl.fetchOneImpl(unified_query_1.QueryUtil.newInstance()
                .from(tpt.childTable)
                .where(whereDelegate)
                .select(columns => [columns]), connection);
        }
        const query = from_1.from(tpt)
            .where(whereDelegate)
            .select(columns => [columns]);
        const limitedQuery = ExecutionImpl.trySetLimit2(query);
        const fetchLimit2Promise = ExecutionImpl.fetchAllImpl(limitedQuery, connection);
        const result = fetchLimit2Promise.then((fetched) => {
            const rawRow = ExecutionImpl.ensureOne(limitedQuery, fetched);
            return {
                sql: fetched.sql,
                row: cleanFetchedRow(tpt, rawRow),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return fetchLimit2Promise
                .then((fetched) => {
                const rawRowOrDefaultValue = ExecutionImpl.ensureOneOr(limitedQuery, fetched, defaultValue);
                return {
                    sql: fetched.sql,
                    row: (rawRowOrDefaultValue === defaultValue ?
                        defaultValue :
                        cleanFetchedRow(tpt, rawRowOrDefaultValue)),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOneImpl = fetchOneImpl;
//# sourceMappingURL=fetch-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
/**
 * This is used to implement a more efficient `fetchOne` operation.
 *
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function from(tpt) {
    if (tpt.parentTables.length == 0) {
        return unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable);
    }
    let query = unified_query_1.QueryUtil.newInstance()
        .from(tpt.childTable);
    /**
     * We are iterating **backwards**.
     * This is intentional.
     */
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parent = tpt.parentTables[i];
        const [fromTableAlias,] = query_1.findLastJoinToTable(tpt, parent.alias);
        query = unified_query_1.QueryUtil.innerJoinUsingPrimaryKey(query, src => src[fromTableAlias], parent);
    }
    return query;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./absorb-row */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js"));
__export(__webpack_require__(/*! ./assert-exists-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/assert-exists-impl.js"));
__export(__webpack_require__(/*! ./delete-one-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-one-impl.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl.js"));
__export(__webpack_require__(/*! ./exists-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/exists-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/fetch-one-impl.js"));
__export(__webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/from.js"));
__export(__webpack_require__(/*! ./invoke-assignment-delegate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
/**
 * Not meant to be called externally.
 *
 * @todo Better name
 */
async function invokeAssignmentDelegate(tpt, connection, whereDelegate, assignmentMapDelegate) {
    const columns = column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnArrayUtil.fromColumnMapArray([
        tpt.childTable.columns,
        ...tpt.parentTables.map(parentTable => parentTable.columns)
    ]));
    /**
     * May contain extra properties that are not mutable columns,
     * or even columns at all.
     */
    const rawAssignmentMap = assignmentMapDelegate(columns);
    const columnAliasArr = Object.keys(rawAssignmentMap);
    if (columnAliasArr.length == 0) {
        /**
         * @todo Perform an exists check, if the row does not exist,
         * throw rowNotFound, for early-exit.
         *
         * At the moment, this isn't so important because we have
         * other methods downstream that will throw it.
         */
        return {};
    }
    const query = execution_impl_1.from(tpt)
        .where(whereDelegate)
        .select(() => columnAliasArr
        .filter(columnAlias => query_1.isMutableColumnAlias(tpt, columnAlias))
        .map(columnAlias => {
        const customExpr = rawAssignmentMap[columnAlias];
        if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
            /**
             * We have a non-value expression
             */
            return expr_1.expr({
                mapper: data_type_1.DataTypeUtil.intersect(query_1.columnMapper(tpt, columnAlias), built_in_expr_1.BuiltInExprUtil.mapper(customExpr)),
                usedRef: built_in_expr_1.BuiltInExprUtil.usedRef(customExpr),
                isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(customExpr),
            }, built_in_expr_1.BuiltInExprUtil.buildAst(customExpr)).as(columnAlias);
        }
        else {
            /**
             * We have a value expression
             */
            return expr_1.ExprUtil.fromRawExprNoUsedRefInput(query_1.columnMapper(tpt, columnAlias), customExpr).as(columnAlias);
        }
    }));
    /**
     * Should only contain value expressions now.
     */
    return execution_1.ExecutionUtil.fetchOne(query, connection);
}
exports.invokeAssignmentDelegate = invokeAssignmentDelegate;
//# sourceMappingURL=invoke-assignment-delegate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const absorb_row_1 = __webpack_require__(/*! ./absorb-row */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/absorb-row.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
/**
 * Not meant to be called externally.
 *
 * **DOES NOT** use savepoints, internally.
 * You **SHOULD** use savepoints before calling this function.
 */
async function updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const updateOneResults = [
            {
                ...updateAndFetchChildResult,
                table: tpt.childTable,
            },
        ];
        let updatedRowCount = updateAndFetchChildResult.updatedRowCount;
        let warningCount = updateAndFetchChildResult.warningCount;
        const result = updateAndFetchChildResult.row;
        /**
         * We use `.reverse()` here to `UPDATE` the parents
         * as we go up the inheritance hierarchy.
         */
        for (const parentTable of [...tpt.parentTables].reverse()) {
            const updateAndFetchParentResult = await execution_1.ExecutionUtil.updateAndFetchOneByPrimaryKey(parentTable, connection, 
            /**
             * The `result` should contain the primary key values we are interested in
             */
            result, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, parentTable.mutableColumns));
            updateOneResults.push({
                ...updateAndFetchParentResult,
                table: parentTable,
            });
            updatedRowCount = tm.BigIntUtil.add(updatedRowCount, updateAndFetchParentResult.updatedRowCount);
            warningCount = tm.BigIntUtil.add(warningCount, updateAndFetchParentResult.warningCount);
            absorb_row_1.absorbRow(result, parentTable, updateAndFetchParentResult.row);
        }
        return {
            updateOneResults,
            /**
             * +1 for the `childTable`.
             */
            foundRowCount: tm.BigInt(tpt.parentTables.length + 1),
            updatedRowCount,
            warningCount,
            row: result,
        };
    });
}
exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
//# sourceMappingURL=update-and-fetch-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.deleteOneByCandidateKey = deleteOneByCandidateKey;
//# sourceMappingURL=delete-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteOneByPrimaryKey(tpt, connection, primaryKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.deleteOneByPrimaryKey = deleteOneByPrimaryKey;
//# sourceMappingURL=delete-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js");
async function deleteOneBySuperKey(tpt, connection, superKey) {
    return execution_impl_1.deleteOneImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.deleteOneBySuperKey = deleteOneBySuperKey;
//# sourceMappingURL=delete-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteZeroOrOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.deleteZeroOrOneByCandidateKey = deleteZeroOrOneByCandidateKey;
//# sourceMappingURL=delete-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
async function deleteZeroOrOneByPrimaryKey(tpt, connection, primaryKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.deleteZeroOrOneByPrimaryKey = deleteZeroOrOneByPrimaryKey;
//# sourceMappingURL=delete-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js");
async function deleteZeroOrOneBySuperKey(tpt, connection, superKey) {
    return execution_impl_1.deleteZeroOrOneImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.deleteZeroOrOneBySuperKey = deleteZeroOrOneBySuperKey;
//# sourceMappingURL=delete-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
function fetchOneByCandidateKey(tpt, connection, candidateKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
}
exports.fetchOneByCandidateKey = fetchOneByCandidateKey;
//# sourceMappingURL=fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
function fetchOneByPrimaryKey(tpt, connection, primaryKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
}
exports.fetchOneByPrimaryKey = fetchOneByPrimaryKey;
//# sourceMappingURL=fetch-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_one_1 = __webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js");
function fetchOneBySuperKey(tpt, connection, superKey) {
    return fetch_one_1.fetchOne(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
}
exports.fetchOneBySuperKey = fetchOneBySuperKey;
//# sourceMappingURL=fetch-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
/**
 * + Assumes `parentTables` has no duplicates.
 * + Assumes `childTable` is not in `parentTables`.
 * + Assumes any shared `columnAlias` between tables **must** have the same value.
 * + Assumes `joins` represents a valid inheritance graph.
 */
function fetchOne(tpt, connection, whereDelegate) {
    try {
        const p = execution_impl_1.fetchOneImpl(tpt, connection, whereDelegate);
        const result = p.then(({ row }) => row);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ row }) => row);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./delete-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./delete-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./delete-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-one-by-super-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./fetch-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/fetch-one.js"));
__export(__webpack_require__(/*! ./insert-and-fetch */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/insert-and-fetch.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
/**
 * Assumes there are no duplicate `parentTables`.
 *
 * `.addParent()` should remove duplicates.
 */
async function insertAndFetch(tpt, connection, insertRow) {
    /**
     * @todo Add `assertInsertable()` or something
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const generated = query_1.generatedColumnAliases(tpt);
            const result = type_util_1.omitOwnEnumerable(insertRow, [
                /**
                 * We omit implicit auto-increment values because we do not
                 * want them to be set by users of the library.
                 */
                ...query_1.implicitAutoIncrement(tpt),
                /**
                 * We omit generated values because users can't set them, anyway.
                 */
                ...generated,
            ]);
            for (const columnAlias of generated) {
                const table = query_1.findTableWithGeneratedColumnAlias(tpt, columnAlias);
                const sqlString = await connection.tryFetchGeneratedColumnExpression(table_1.TableUtil.tryGetSchemaName(table), table.alias, columnAlias);
                if (sqlString == undefined) {
                    throw new Error(`Generated column ${table.alias}.${columnAlias} should have generation expression`);
                }
                result[columnAlias] = expr_1.expr({
                    mapper: table.columns[columnAlias].mapper,
                    usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
                    /**
                     * `GENERATED` columns should not have aggregate expressions.
                     */
                    isAggregate: false,
                }, 
                /**
                 * This `sqlString` is not allowed to reference any columns.
                 * If it does, there is a very high chance that it will cause an error.
                 *
                 * @todo Find use case where we need to allow this to reference columns.
                 */
                sqlString);
            }
            for (const table of [...tpt.parentTables, tpt.childTable]) {
                const fetchedRow = await execution_1.ExecutionUtil.insertAndFetch(
                /**
                 * We use `InsertAndFetchOptions`, instead of creating
                 * a new table instance because we want events to use the
                 * original `table` instance.
                 *
                 * `event.isFor()` methods use `===` internally
                 */
                table, connection, result, {
                    /**
                     * We want to allow explicit auto-increment values internally,
                     * so that the same value is used for all tables of the same
                     * inheritance hierarchy.
                     */
                    explicitAutoIncrementValueEnabled: true,
                });
                execution_impl_1.absorbRow(result, table, fetchedRow);
            }
            return result;
        });
    });
}
exports.insertAndFetch = insertAndFetch;
//# sourceMappingURL=insert-and-fetch.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, candidateKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByPrimaryKey(tpt.childTable, connection, primaryKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            const cleanedAssignmentMap = await execution_impl_1.invokeAssignmentDelegate(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey), assignmentMapDelegate);
            /**
             * @todo If `result` contains any primaryKey values,
             * then we will need to fetch the **current** primaryKey values,
             * before any `UPDATE` statements are executed.
             *
             * This function breaks if we try to update values
             * of columns that are foreign keys.
             *
             * I do not want to disable foreign key checks.
             */
            const updateAndFetchChildResult = await execution_1.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, 
            /**
             * We have already used the `superKey` to "clean" our assignment map.
             * So, we can be reasonably sure that the `superKey` itself
             * refers to exactly one row that exists.
             *
             * Now, we can pretend this `superKey` is a `candidateKey`,
             * discarding all non-key columns.
             *
             * This should not introduce any bugs.
             */
            superKey, () => type_util_1.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
            return execution_impl_1.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
        });
    });
}
exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
//# sourceMappingURL=update-and-fetch-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchZeroOrOneByCandidateKey(tpt, connection, 
/**
 * @todo Try and recall why I wanted `AssertNonUnion<>`
 * I didn't write compile-time tests for it...
 */
candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_1.ExecutionUtil.existsImpl(unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable)
            .where(() => ExprLib.eqCandidateKey(tpt.childTable, candidateKey)), connection);
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_candidate_key_1.updateAndFetchOneByCandidateKey(tpt, connection, candidateKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const execution_1 = __webpack_require__(/*! ../../../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const update_and_fetch_one_by_primary_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchZeroOrOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_1.ExecutionUtil.existsImpl(unified_query_1.QueryUtil.newInstance()
            .from(tpt.childTable)
            .where(() => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey)), connection);
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_primary_key_1.updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js");
const update_and_fetch_one_by_super_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key.js");
const execution_impl_1 = __webpack_require__(/*! ../execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateAndFetchZeroOrOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        const existsResult = await execution_impl_1.existsImpl(tpt, connection, () => operation_1.eqSuperKey(tpt, superKey));
        if (!existsResult.exists) {
            return {
                query: {
                    sql: existsResult.sql,
                },
                //Alias for affectedRows
                foundRowCount: tm.BigInt(0),
                //Alias for changedRows
                updatedRowCount: tm.BigInt(0),
                /**
                 * May be the duplicate row count, or some other value.
                 */
                warningCount: tm.BigInt(0),
                /**
                 * An arbitrary message.
                 * May be an empty string.
                 */
                message: "",
                row: undefined,
            };
        }
        return update_and_fetch_one_by_super_key_1.updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate);
    });
}
exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution/index.js"));
__export(__webpack_require__(/*! ./execution-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/execution-impl/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/add-parent.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/add-parent.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const table_per_type_impl_1 = __webpack_require__(/*! ../../table-per-type-impl */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/table-per-type-impl.js");
const remove_duplicate_parents_1 = __webpack_require__(/*! ./remove-duplicate-parents */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
function addParent_AutoIncrement(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractAutoIncrement(parent),
        ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
function addParent_ExplicitAutoIncrementValueEnabled(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractExplicitAutoIncrementValueEnabled(parent).filter(columnAlias => (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
            !tpt.autoIncrement.includes(columnAlias))),
        ...tpt.explicitAutoIncrementValueEnabled.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
function addParent_InsertAndFetchPrimaryKey(tpt, parent) {
    const parentColumnAliases = query_1.extractColumnAliases(parent);
    return key_1.KeyUtil.removeDuplicates([
        ...query_1.extractInsertAndFetchPrimaryKey(parent),
        ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
    ]);
}
/**
 * @todo Check that a column is not both auto-increment and generated at the same time
 *
 * @todo Check that `tpt.childTable` can join to `parent.childTable` using `parent.childTable`'s primary key
 *
 * @todo Check that columns have compatible types; must be assigble from child to parent
 *       Example: child.type = "red"|"blue", parent.type = "red"|"blue"|"green"
 *
 * @todo Check that inheritance is not circular
 *       Example: `Animal` cannot be a child of `Animal`.
 *       Example: This is invalid: `Dog extends Animal extends Mammal extends Dog`
 */
function addParent(tpt, parent) {
    let joins = undefined;
    if (table_1.TableUtil.isTable(parent)) {
        joins = [
            [
                tpt.childTable.alias,
                parent.alias,
            ],
            ...tpt.joins,
        ];
    }
    else if (predicate_1.isTablePerType(parent)) {
        joins = [
            ...parent.joins,
            [
                tpt.childTable.alias,
                parent.childTable.alias,
            ],
            ...tpt.joins,
        ];
    }
    else {
        throw new Error(`Expected ITable or ITablePerType for parent`);
    }
    return new table_per_type_impl_1.TablePerType({
        childTable: tpt.childTable,
        parentTables: remove_duplicate_parents_1.removeDuplicateParents([
            ...query_1.extractAllTables(parent),
            ...tpt.parentTables,
        ]),
        autoIncrement: addParent_AutoIncrement(tpt, parent),
        explicitAutoIncrementValueEnabled: addParent_ExplicitAutoIncrementValueEnabled(tpt, parent),
        insertAndFetchPrimaryKey: addParent_InsertAndFetchPrimaryKey(tpt, parent),
    }, joins);
}
exports.addParent = addParent;
//# sourceMappingURL=add-parent.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/eq-super-key.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/eq-super-key.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
exports.eqSuperKey = ((tpt, superKeyInput) => {
    const superKey = query_1.superKeyMapper(tpt)(`${tpt.childTable}.superKey`, superKeyInput);
    const arr = Object.keys(superKey)
        .filter((columnAlias) => {
        return superKey[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `superKey` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const table = query_1.findTableWithColumnAlias(tpt, columnAlias);
        const expr = ExprLib.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
        return expr;
    });
    const result = ExprLib.and(...arr);
    return result;
});
//# sourceMappingURL=eq-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./add-parent */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/add-parent.js"));
__export(__webpack_require__(/*! ./eq-super-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/eq-super-key.js"));
__export(__webpack_require__(/*! ./remove-duplicate-parents */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/operation/remove-duplicate-parents.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removeDuplicateParents(arr) {
    const result = [];
    for (const parentTable of arr) {
        /**
         * @todo Add `.schemaName` property?
         * When checking `.alias` only, it may think a different
         * table from a different schema is the same table.
         */
        if (result.find(r => r.alias == parentTable.alias) != undefined) {
            continue;
        }
        result.push(parentTable);
    }
    return result;
}
exports.removeDuplicateParents = removeDuplicateParents;
//# sourceMappingURL=remove-duplicate-parents.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-table-per-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/is-table-per-type.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
/**
 * Actually only checks if it has all the properties of `ITablePerType`.
 *
 * So, if it has all the properties but they're of the wrong data type...
 */
function isTablePerType(mixed) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "childTable",
        "parentTables",
        "autoIncrement",
        "explicitAutoIncrementValueEnabled",
        "insertAndFetchPrimaryKey",
        "joins"
    ])) {
        return false;
    }
    return (table_1.TableUtil.isTable(mixed.childTable) &&
        /**
         * Does not check if all elements are `ITable`
         */
        (mixed.parentTables instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.autoIncrement instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.explicitAutoIncrementValueEnabled instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.insertAndFetchPrimaryKey instanceof Array) &&
        /**
         * Does not check if all elements are `string`
         */
        (mixed.joins instanceof Array));
}
exports.isTablePerType = isTablePerType;
//# sourceMappingURL=is-table-per-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function columnAliases(tpt) {
    const result = table_1.TableUtil.columnAlias(tpt.childTable);
    for (const parentTable of tpt.parentTables) {
        result.push(...table_1.TableUtil.columnAlias(parentTable));
    }
    return key_1.KeyUtil.removeDuplicates(result);
}
exports.columnAliases = columnAliases;
function isColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isColumnAlias = isColumnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-type.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-type.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const extract_all_tables_with_column_alias_1 = __webpack_require__(/*! ./extract-all-tables-with-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
function columnMapper(tpt, columnAlias) {
    const mappers = extract_all_tables_with_column_alias_1.extractAllTablesWithColumnAlias(tpt, columnAlias)
        .map(table => table.columns[columnAlias].mapper);
    if (mappers.length == 0) {
        throw new Error(`Table-per-type hierarchy for ${tpt.childTable.alias} does not have column alias ${columnAlias}`);
    }
    if (mappers.length == 1) {
        return mappers[0];
    }
    let result = data_type_1.DataTypeUtil.intersect(mappers[0], mappers[1]);
    for (let i = 2; i < mappers.length; ++i) {
        result = data_type_1.DataTypeUtil.intersect(result, mappers[i]);
    }
    return result;
}
exports.columnMapper = columnMapper;
//# sourceMappingURL=column-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const parent_column_alias_1 = __webpack_require__(/*! ./parent-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/parent-column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function isExplicitDefaultValueColumnAlias(tpt, columnAlias) {
    if (parent_column_alias_1.isParentColumnAlias(tpt, columnAlias)) {
        for (const parentTable of tpt.parentTables) {
            if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
                !parentTable.explicitDefaultValueColumns.includes(columnAlias)) {
                return false;
            }
        }
        return true;
    }
    else {
        return tpt.childTable.explicitDefaultValueColumns.includes(columnAlias);
    }
}
exports.isExplicitDefaultValueColumnAlias = isExplicitDefaultValueColumnAlias;
function explicitDefaultValueColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isExplicitDefaultValueColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.explicitDefaultValueColumnAliases = explicitDefaultValueColumnAliases;
//# sourceMappingURL=explicit-default-value-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function extractAllTablesWithColumnAlias(tpt, columnAlias) {
    const result = [];
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        result.push(tpt.childTable);
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            result.push(parentTable);
        }
    }
    return result;
}
exports.extractAllTablesWithColumnAlias = extractAllTablesWithColumnAlias;
//# sourceMappingURL=extract-all-tables-with-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractAllTables(t) {
    if (predicate_1.isTablePerType(t)) {
        return [
            ...t.parentTables,
            t.childTable,
        ];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return [t];
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractAllTables = extractAllTables;
//# sourceMappingURL=extract-all-tables.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractAutoIncrement(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.autoIncrement];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return (t.autoIncrement == undefined ?
            [] :
            [t.autoIncrement]);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractAutoIncrement = extractAutoIncrement;
//# sourceMappingURL=extract-auto-increment.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-child-table.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-child-table.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function extractChildTable(t) {
    if (table_1.TableUtil.isTable(t)) {
        return t;
    }
    else {
        return t.childTable;
    }
}
exports.extractChildTable = extractChildTable;
//# sourceMappingURL=extract-child-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-column-alias.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-column-alias.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractColumnAliases(t) {
    if (predicate_1.isTablePerType(t)) {
        return column_alias_1.columnAliases(t);
    }
    else if (table_1.TableUtil.isTable(t)) {
        return table_1.TableUtil.columnAlias(t);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractColumnAliases = extractColumnAliases;
//# sourceMappingURL=extract-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractExplicitAutoIncrementValueEnabled(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.explicitAutoIncrementValueEnabled];
    }
    else if (table_1.TableUtil.isTable(t)) {
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        t.explicitAutoIncrementValueEnabled ?
            (t.autoIncrement == undefined ?
                [] :
                [t.autoIncrement]) :
            []);
    }
    else {
        throw new Error(`Expected ITable or ITablePerType`);
    }
}
exports.extractExplicitAutoIncrementValueEnabled = extractExplicitAutoIncrementValueEnabled;
//# sourceMappingURL=extract-explicit-auto-increment-value-enabled.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/predicate/index.js");
function extractInsertAndFetchPrimaryKey(t) {
    if (predicate_1.isTablePerType(t)) {
        return [...t.insertAndFetchPrimaryKey];
    }
    else if (table_1.TableUtil.isTable(t) && t.primaryKey != undefined) {
        return (t.autoIncrement == undefined ?
            t.primaryKey.filter(columnAlias => (!t.generatedColumns.includes(columnAlias) &&
                t.autoIncrement != columnAlias)) :
            []);
    }
    else {
        throw new Error(`Expected TableWithPrimaryKey or ITablePerType`);
    }
}
exports.extractInsertAndFetchPrimaryKey = extractInsertAndFetchPrimaryKey;
//# sourceMappingURL=extract-insert-and-fetch-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function extractParentTables(t) {
    if (table_1.TableUtil.isTable(t)) {
        return [];
    }
    else {
        return [...t.parentTables];
    }
}
exports.extractParentTables = extractParentTables;
//# sourceMappingURL=extract-parent-tables.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function findLastJoinToTable(tpt, toTableAlias) {
    for (let i = tpt.joins.length - 1; i >= 0; --i) {
        if (tpt.joins[i][1] == toTableAlias) {
            return tpt.joins[i];
        }
    }
    throw new Error(`No join to ${toTableAlias} exists in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findLastJoinToTable = findLastJoinToTable;
//# sourceMappingURL=find-last-join-to-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
/**
 * Goes up the inheritance hierarchy, starting from `childTable`,
 * to look for a table with `columnAlias` as a column
 */
function findTableWithColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
        return tpt.childTable;
    }
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parentTable = tpt.parentTables[i];
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return parentTable;
        }
    }
    throw new Error(`No column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findTableWithColumnAlias = findTableWithColumnAlias;
//# sourceMappingURL=find-table-with-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Goes up the inheritance hierarchy, starting from `childTable`,
 * to look for a table with `columnAlias` as a generated column
 */
function findTableWithGeneratedColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.generatedColumns.includes(columnAlias)) {
        return tpt.childTable;
    }
    for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
        const parentTable = tpt.parentTables[i];
        if (parentTable.generatedColumns.includes(columnAlias)) {
            return parentTable;
        }
    }
    throw new Error(`No generated column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
}
exports.findTableWithGeneratedColumnAlias = findTableWithGeneratedColumnAlias;
//# sourceMappingURL=find-table-with-generated-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isGeneratedColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.generatedColumns.includes(columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (parentTable.generatedColumns.includes(columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isGeneratedColumnAlias = isGeneratedColumnAlias;
function generatedColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isGeneratedColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.generatedColumnAliases = generatedColumnAliases;
//# sourceMappingURL=generated-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function implicitAutoIncrement(tpt) {
    return tpt.autoIncrement.filter(columnAlias => {
        return !tpt.explicitAutoIncrementValueEnabled.includes(columnAlias);
    });
}
exports.implicitAutoIncrement = implicitAutoIncrement;
//# sourceMappingURL=implicit-auto-increment.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./column-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-type.js"));
__export(__webpack_require__(/*! ./explicit-default-value-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js"));
__export(__webpack_require__(/*! ./extract-all-tables-with-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias.js"));
__export(__webpack_require__(/*! ./extract-all-tables */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-all-tables.js"));
__export(__webpack_require__(/*! ./extract-auto-increment */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-auto-increment.js"));
__export(__webpack_require__(/*! ./extract-explicit-auto-increment-value-enabled */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled.js"));
__export(__webpack_require__(/*! ./extract-insert-and-fetch-primary-key */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key.js"));
//export * from "./extract-child-column-alias";
__export(__webpack_require__(/*! ./extract-child-table */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-child-table.js"));
__export(__webpack_require__(/*! ./extract-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-column-alias.js"));
//export * from "./extract-parent-column-alias";
__export(__webpack_require__(/*! ./extract-parent-tables */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/extract-parent-tables.js"));
__export(__webpack_require__(/*! ./find-last-join-to-table */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-last-join-to-table.js"));
__export(__webpack_require__(/*! ./find-table-with-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-column-alias.js"));
__export(__webpack_require__(/*! ./find-table-with-generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/find-table-with-generated-column-alias.js"));
__export(__webpack_require__(/*! ./generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js"));
__export(__webpack_require__(/*! ./implicit-auto-increment */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/implicit-auto-increment.js"));
__export(__webpack_require__(/*! ./mutable-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js"));
__export(__webpack_require__(/*! ./non-generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js"));
__export(__webpack_require__(/*! ./nullable-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js"));
__export(__webpack_require__(/*! ./optional-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/optional-column-alias.js"));
__export(__webpack_require__(/*! ./parent-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/parent-column-alias.js"));
__export(__webpack_require__(/*! ./primary-key-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js"));
__export(__webpack_require__(/*! ./required-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/required-column-alias.js"));
__export(__webpack_require__(/*! ./row */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/row.js"));
__export(__webpack_require__(/*! ./super-key-mapper */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/super-key-mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/mutable-column-alias.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function isMutableColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
        !tpt.childTable.mutableColumns.includes(columnAlias)) {
        return false;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
            !parentTable.mutableColumns.includes(columnAlias)) {
            return false;
        }
    }
    return column_alias_1.isColumnAlias(tpt, columnAlias);
}
exports.isMutableColumnAlias = isMutableColumnAlias;
function mutableColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isMutableColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.mutableColumnAliases = mutableColumnAliases;
//# sourceMappingURL=mutable-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/non-generated-column-alias.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
function nonGeneratedColumnAliases(tpt) {
    const generated = generated_column_alias_1.generatedColumnAliases(tpt);
    const result = column_alias_1.columnAliases(tpt)
        .filter(columnAlias => {
        return !generated.includes(columnAlias);
    });
    return result;
}
exports.nonGeneratedColumnAliases = nonGeneratedColumnAliases;
//# sourceMappingURL=non-generated-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function isNullableColumnAlias(tpt, columnAlias) {
    if (column_map_1.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
        !tpt.childTable.nullableColumns.includes(columnAlias)) {
        return false;
    }
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
            !parentTable.nullableColumns.includes(columnAlias)) {
            return false;
        }
    }
    return column_alias_1.isColumnAlias(tpt, columnAlias);
}
exports.isNullableColumnAlias = isNullableColumnAlias;
function nullableColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isNullableColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.nullableColumnAliases = nullableColumnAliases;
//# sourceMappingURL=nullable-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/optional-column-alias.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/optional-column-alias.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const explicit_default_value_column_alias_1 = __webpack_require__(/*! ./explicit-default-value-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js");
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isOptionalColumnAlias(tpt, columnAlias) {
    return (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
        ((nullable_column_alias_1.isNullableColumnAlias(tpt, columnAlias) ||
            explicit_default_value_column_alias_1.isExplicitDefaultValueColumnAlias(tpt, columnAlias)) &&
            !generated_column_alias_1.isGeneratedColumnAlias(tpt, columnAlias)));
}
exports.isOptionalColumnAlias = isOptionalColumnAlias;
function optionalColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isOptionalColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.optionalColumnAliases = optionalColumnAliases;
//# sourceMappingURL=optional-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/parent-column-alias.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/parent-column-alias.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function parentColumnAliases(tpt) {
    const result = [];
    for (const parentTable of tpt.parentTables) {
        result.push(...table_1.TableUtil.columnAlias(parentTable));
    }
    return key_1.KeyUtil.removeDuplicates(result);
}
exports.parentColumnAliases = parentColumnAliases;
function isParentColumnAlias(tpt, columnAlias) {
    for (const parentTable of tpt.parentTables) {
        if (column_map_1.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isParentColumnAlias = isParentColumnAlias;
//# sourceMappingURL=parent-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/primary-key-column-alias.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isPrimaryColumnAlias(tpt, columnAlias) {
    if (tpt.childTable.primaryKey.includes(columnAlias)) {
        return true;
    }
    for (const parentTable of tpt.parentTables) {
        if (parentTable.primaryKey.includes(columnAlias)) {
            return true;
        }
    }
    return false;
}
exports.isPrimaryColumnAlias = isPrimaryColumnAlias;
function primaryKeyColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isPrimaryColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.primaryKeyColumnAliases = primaryKeyColumnAliases;
//# sourceMappingURL=primary-key-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/required-column-alias.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/required-column-alias.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const explicit_default_value_column_alias_1 = __webpack_require__(/*! ./explicit-default-value-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/explicit-default-value-column-alias.js");
const nullable_column_alias_1 = __webpack_require__(/*! ./nullable-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/nullable-column-alias.js");
const generated_column_alias_1 = __webpack_require__(/*! ./generated-column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/generated-column-alias.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
function isRequiredColumnAlias(tpt, columnAlias) {
    return (column_alias_1.isColumnAlias(tpt, columnAlias) &&
        !(generated_column_alias_1.isGeneratedColumnAlias(tpt, columnAlias) ||
            nullable_column_alias_1.isNullableColumnAlias(tpt, columnAlias) ||
            explicit_default_value_column_alias_1.isExplicitDefaultValueColumnAlias(tpt, columnAlias) ||
            tpt.autoIncrement.includes(columnAlias)));
}
exports.isRequiredColumnAlias = isRequiredColumnAlias;
function requiredColumnAliases(tpt) {
    const result = [];
    for (const columnAlias of column_alias_1.columnAliases(tpt)) {
        if (isRequiredColumnAlias(tpt, columnAlias)) {
            result.push(columnAlias);
        }
    }
    return result;
}
exports.requiredColumnAliases = requiredColumnAliases;
//# sourceMappingURL=required-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/row.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/row.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_type_1 = __webpack_require__(/*! ./column-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-type.js");
function rowMapper(tpt) {
    const result = tm.objectFromArray(...column_alias_1.columnAliases(tpt)
        .map(columnAlias => tm.withName(column_type_1.columnMapper(tpt, columnAlias), columnAlias)));
    return result;
}
exports.rowMapper = rowMapper;
//# sourceMappingURL=row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/super-key-mapper.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/super-key-mapper.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-alias.js");
const column_type_1 = __webpack_require__(/*! ./column-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/util/query/column-type.js");
function superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey) {
    const result = tm.objectFromArray(...column_alias_1.columnAliases(tpt).map(columnAlias => {
        const mapper = tm.withName(column_type_1.columnMapper(tpt, columnAlias), columnAlias);
        if (candidateKey.includes(columnAlias)) {
            return mapper;
        }
        else {
            return tm.optional(mapper);
        }
    }));
    return result;
}
function superKeyMapper(tpt) {
    const arr = tpt.childTable.candidateKeys.map(candidateKey => {
        return superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey);
    });
    return tm.unsafeOr(...arr);
}
exports.superKeyMapper = superKeyMapper;
//# sourceMappingURL=super-key-mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/clean-insert-row/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/clean-insert-row/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./missing-required-insert-column */ "./node_modules/@squill/squill/dist/error/clean-insert-row/missing-required-insert-column.js"));
__export(__webpack_require__(/*! ./potential-null-in-required-insert-column */ "./node_modules/@squill/squill/dist/error/clean-insert-row/potential-null-in-required-insert-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/clean-insert-row/missing-required-insert-column.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/clean-insert-row/missing-required-insert-column.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
class MissingRequiredInsertColumnError extends sql_error_1.SqlError {
    constructor(args) {
        super({
            message: args.message,
            sql: undefined,
        });
        Object.setPrototypeOf(this, MissingRequiredInsertColumnError.prototype);
        this.table = args.table;
        this.columnAlias = args.columnAlias;
    }
}
exports.MissingRequiredInsertColumnError = MissingRequiredInsertColumnError;
MissingRequiredInsertColumnError.prototype.name = "MissingRequiredInsertColumnError";
//# sourceMappingURL=missing-required-insert-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/clean-insert-row/potential-null-in-required-insert-column.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/clean-insert-row/potential-null-in-required-insert-column.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
class PotentialNullInRequiredInsertColumnError extends sql_error_1.SqlError {
    constructor(args) {
        super({
            message: args.message,
            sql: undefined,
        });
        Object.setPrototypeOf(this, PotentialNullInRequiredInsertColumnError.prototype);
        this.table = args.table;
        this.columnAlias = args.columnAlias;
    }
}
exports.PotentialNullInRequiredInsertColumnError = PotentialNullInRequiredInsertColumnError;
PotentialNullInRequiredInsertColumnError.prototype.name = "PotentialNullInRequiredInsertColumnError";
//# sourceMappingURL=potential-null-in-required-insert-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/execution/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/execution/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./invalid-sql */ "./node_modules/@squill/squill/dist/error/execution/invalid-sql.js"));
__export(__webpack_require__(/*! ./row-not-found */ "./node_modules/@squill/squill/dist/error/execution/row-not-found.js"));
__export(__webpack_require__(/*! ./too-many-rows-found */ "./node_modules/@squill/squill/dist/error/execution/too-many-rows-found.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/execution/invalid-sql.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/execution/invalid-sql.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
/**
 * This error happens when the database is unable to parse the SQL string.
 *
 * + MySQL      : `ER_SYNTAX_ERROR`, `ER_PARSE_ERROR`
 * + PostgreSQL : `syntax error at`
 */
class InvalidSqlError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, InvalidSqlError.prototype);
    }
}
exports.InvalidSqlError = InvalidSqlError;
InvalidSqlError.prototype.name = "InvalidSqlError";
//# sourceMappingURL=invalid-sql.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/execution/row-not-found.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/execution/row-not-found.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
class RowNotFoundError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, RowNotFoundError.prototype);
        this.sql = args.sql;
    }
}
exports.RowNotFoundError = RowNotFoundError;
RowNotFoundError.prototype.name = "RowNotFoundError";
//# sourceMappingURL=row-not-found.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/execution/too-many-rows-found.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/execution/too-many-rows-found.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
class TooManyRowsFoundError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, TooManyRowsFoundError.prototype);
        this.sql = args.sql;
    }
}
exports.TooManyRowsFoundError = TooManyRowsFoundError;
TooManyRowsFoundError.prototype.name = "TooManyRowsFoundError";
//# sourceMappingURL=too-many-rows-found.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/expr/cannot-count.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/expr/cannot-count.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
class CannotCountError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, CannotCountError.prototype);
    }
}
exports.CannotCountError = CannotCountError;
CannotCountError.prototype.name = "CannotCountError";
//# sourceMappingURL=cannot-count.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/expr/data-out-of-range.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/expr/data-out-of-range.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `MAX_BIGINT_SIGNED + 1`
 * + `MIN_BIGINT_SIGNED - 1`
 * + General overflow errors
 *
 * + MySQL      : `ER_DATA_OUT_OF_RANGE`
 * + PostgreSQL : `out of range`
 */
class DataOutOfRangeError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, DataOutOfRangeError.prototype);
    }
}
exports.DataOutOfRangeError = DataOutOfRangeError;
DataOutOfRangeError.prototype.name = "DataOutOfRangeError";
//# sourceMappingURL=data-out-of-range.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/expr/divide-by-zero.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/expr/divide-by-zero.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `1 / 0`
 * + `0 / 0`
 *
 * + MySQL      : -NA- (Returns `null`)
 * + PostgreSQL : `division by zero`
 */
class DivideByZeroError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, DivideByZeroError.prototype);
    }
}
exports.DivideByZeroError = DivideByZeroError;
DivideByZeroError.prototype.name = "DivideByZeroError";
//# sourceMappingURL=divide-by-zero.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/expr/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/expr/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cannot-count */ "./node_modules/@squill/squill/dist/error/expr/cannot-count.js"));
__export(__webpack_require__(/*! ./data-out-of-range */ "./node_modules/@squill/squill/dist/error/expr/data-out-of-range.js"));
__export(__webpack_require__(/*! ./divide-by-zero */ "./node_modules/@squill/squill/dist/error/expr/divide-by-zero.js"));
__export(__webpack_require__(/*! ./invalid-input */ "./node_modules/@squill/squill/dist/error/expr/invalid-input.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/expr/invalid-input.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/expr/invalid-input.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sql_error_1 = __webpack_require__(/*! ../sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js");
/**
 * This error happens when you do something like,
 * + `'qwerty'::timestamp` (PostgreSQL)
 * + General input errors
 *
 * + MySQL      : `ER_INVALID_JSON_TEXT_IN_PARAM` (`CAST('qwerty' AS JSON)`), etc.
 * + PostgreSQL : `invalid input syntax for type`
 */
class InvalidInputError extends sql_error_1.SqlError {
    constructor(args) {
        super(args);
        Object.setPrototypeOf(this, InvalidInputError.prototype);
    }
}
exports.InvalidInputError = InvalidInputError;
InvalidInputError.prototype.name = "InvalidInputError";
//# sourceMappingURL=invalid-input.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-row */ "./node_modules/@squill/squill/dist/error/clean-insert-row/index.js"));
__export(__webpack_require__(/*! ./execution */ "./node_modules/@squill/squill/dist/error/execution/index.js"));
__export(__webpack_require__(/*! ./expr */ "./node_modules/@squill/squill/dist/error/expr/index.js"));
__export(__webpack_require__(/*! ./sql-error */ "./node_modules/@squill/squill/dist/error/sql-error.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/error/sql-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/error/sql-error.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * All errors in this library should extend this class.
 */
class SqlError extends Error {
    constructor(args) {
        super("innerError" in args ?
            (args.innerError instanceof Object && "message" in args.innerError ?
                args.innerError.message :
                String(args.innerError)) :
            args.message);
        if ("innerError" in args && args.innerError instanceof Object && "stack" in args.innerError) {
            this.stack += `\n${args.innerError.stack}`;
        }
        Object.setPrototypeOf(this, SqlError.prototype);
        this.sql = args.sql;
        this.innerError = ("innerError" in args ?
            args.innerError :
            undefined);
    }
}
exports.SqlError = SqlError;
SqlError.prototype.name = "SqlError";
function isSqlError(mixed) {
    /**
     * @todo Should we check prototype.name or nah?
     */
    return (mixed instanceof Error &&
        (mixed.sql === undefined ||
            typeof mixed.sql == "string") &&
        "innerError" in mixed);
}
exports.isSqlError = isSqlError;
//# sourceMappingURL=sql-error.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/connection-event-emitter-collection.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/connection-event-emitter-collection.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const connection_event_emitter_1 = __webpack_require__(/*! ./connection-event-emitter */ "./node_modules/@squill/squill/dist/event/connection-event-emitter.js");
class ConnectionEventEmitterCollection {
    constructor(pool) {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove events while invoking a handler.
         */
        this.transactionListenerCollections = [
            []
        ];
        this.addTransactionListenerCollectionImpl = (event) => {
            const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
            const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
            this.transactionListenerCollections = [
                ...parentAndAncestors,
                [
                    ...bottom,
                    event
                ]
            ];
        };
        this.onInsert = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsert, this.addTransactionListenerCollectionImpl);
        this.onInsertOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertOne, this.addTransactionListenerCollectionImpl);
        this.onInsertAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertAndFetch, this.addTransactionListenerCollectionImpl);
        this.onInsertSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertSelect, this.addTransactionListenerCollectionImpl);
        this.onReplace = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplace, this.addTransactionListenerCollectionImpl);
        this.onReplaceOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceOne, this.addTransactionListenerCollectionImpl);
        this.onReplaceSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceSelect, this.addTransactionListenerCollectionImpl);
        this.onUpdate = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdate, this.addTransactionListenerCollectionImpl);
        this.onUpdateAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdateAndFetch, this.addTransactionListenerCollectionImpl);
        this.onDelete = new connection_event_emitter_1.ConnectionEventEmitter(pool.onDelete, this.addTransactionListenerCollectionImpl);
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is created
     */
    savepoint() {
        this.transactionListenerCollections = [
            ...this.transactionListenerCollections,
            []
        ];
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is released
     */
    releaseSavepoint() {
        if (this.transactionListenerCollections.length == 1) {
            throw new Error(`Cannot unnest top-level transaction listener collection`);
        }
        const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
        const parent = this.transactionListenerCollections[this.transactionListenerCollections.length - 2];
        const ancestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 2);
        this.transactionListenerCollections = [
            ...ancestors,
            [
                ...parent,
                ...bottom
            ]
        ];
    }
    /**
     * @todo Better name
     *
     * Used whenever a savepoint is rolled back
     */
    rollbackToSavepoint() {
        if (this.transactionListenerCollections.length == 1) {
            throw new Error(`Cannot unnest top-level transaction listener collection`);
        }
        const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
        const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
        this.transactionListenerCollections = parentAndAncestors;
        const syncErrors = [];
        for (const collection of bottom) {
            const invokeResult = collection.invokeOnRollbackListeners();
            syncErrors.push(...invokeResult.syncErrors);
        }
        return { syncErrors };
    }
    /**
     * This should not throw
     *
     * Used when a transaction is committed
     */
    commit() {
        const syncErrors = [];
        const scopes = this.transactionListenerCollections;
        this.transactionListenerCollections = [[]];
        for (const scope of scopes) {
            for (const collection of scope) {
                const invokeResult = collection.invokeOnCommitListeners();
                syncErrors.push(...invokeResult.syncErrors);
            }
        }
        return { syncErrors };
    }
    /**
     * This should not throw
     *
     * Used when a transaction is rolled back
     */
    rollback() {
        const syncErrors = [];
        const scopes = this.transactionListenerCollections;
        this.transactionListenerCollections = [[]];
        for (const scope of scopes) {
            for (const collection of scope) {
                const invokeResult = collection.invokeOnRollbackListeners();
                syncErrors.push(...invokeResult.syncErrors);
            }
        }
        return { syncErrors };
    }
}
exports.ConnectionEventEmitterCollection = ConnectionEventEmitterCollection;
//# sourceMappingURL=connection-event-emitter-collection.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/connection-event-emitter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/connection-event-emitter.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ConnectionEventEmitter {
    constructor(poolEventEmitter, addTransactionListenerCollectionImpl) {
        this.poolEventEmitter = poolEventEmitter;
        this.addEventImpl = addTransactionListenerCollectionImpl;
    }
    /**
     * This may throw
     */
    async invoke(event) {
        const handlers = this.poolEventEmitter.getHandlers();
        if (handlers.length == 0) {
            /**
             * There are no handlers.
             * There's nothing for us to do here.
             */
            return;
        }
        //This should not throw.
        this.addEventImpl(event);
        //This loop may throw.
        for (const handler of handlers) {
            await handler(event);
        }
    }
}
exports.ConnectionEventEmitter = ConnectionEventEmitter;
//# sourceMappingURL=connection-event-emitter.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/delete-event.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/delete-event.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class DeleteEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.whereClause = args.whereClause;
        this.deleteResult = args.deleteResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.DeleteEvent = DeleteEvent;
//# sourceMappingURL=delete-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/event-base.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/event-base.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class EventBase {
    constructor(args) {
        this.onCommitListeners = [];
        this.onRollbackListeners = [];
        this.pool = args.connection.pool;
        this.connection = args.connection;
    }
    /**
     * If the `listener` has already been added, it will be ignored.
     */
    addOnCommitListener(listener) {
        if (this.onCommitListeners.includes(listener)) {
            /**
             * We do not want duplicate listener references.
             */
            return;
        }
        this.onCommitListeners = [...this.onCommitListeners, listener];
    }
    /**
     * If the `listener` has already been added, it will be ignored.
     */
    addOnRollbackListener(listener) {
        if (this.onRollbackListeners.includes(listener)) {
            /**
             * We do not want duplicate listener references.
             */
            return;
        }
        this.onRollbackListeners = [...this.onRollbackListeners, listener];
    }
    /**
     * For now,
     * + This should not throw.
     * + This must not wait for `async` listeners to complete.
     * + This will not catch `async` errors.
     *
     * @returns - All synchronous errors.
     */
    invokeOnCommitListeners() {
        const syncErrors = [];
        for (const listener of this.onCommitListeners) {
            try {
                listener();
            }
            catch (err) {
                syncErrors.push(err);
            }
        }
        return { syncErrors };
    }
    /**
     * For now,
     * + This should not throw.
     * + This must not wait for `async` listeners to complete.
     * + This will not catch `async` errors.
     *
     * @returns - All synchronous errors.
     */
    invokeOnRollbackListeners() {
        const syncErrors = [];
        for (const listener of this.onRollbackListeners) {
            try {
                listener();
            }
            catch (err) {
                syncErrors.push(err);
            }
        }
        return { syncErrors };
    }
}
exports.EventBase = EventBase;
//# sourceMappingURL=event-base.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection-event-emitter-collection */ "./node_modules/@squill/squill/dist/event/connection-event-emitter-collection.js"));
__export(__webpack_require__(/*! ./connection-event-emitter */ "./node_modules/@squill/squill/dist/event/connection-event-emitter.js"));
__export(__webpack_require__(/*! ./delete-event */ "./node_modules/@squill/squill/dist/event/delete-event.js"));
__export(__webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js"));
__export(__webpack_require__(/*! ./insert-and-fetch-event */ "./node_modules/@squill/squill/dist/event/insert-and-fetch-event.js"));
__export(__webpack_require__(/*! ./insert-event */ "./node_modules/@squill/squill/dist/event/insert-event.js"));
__export(__webpack_require__(/*! ./insert-one-event */ "./node_modules/@squill/squill/dist/event/insert-one-event.js"));
__export(__webpack_require__(/*! ./insert-select-event */ "./node_modules/@squill/squill/dist/event/insert-select-event.js"));
__export(__webpack_require__(/*! ./pool-event-emitter */ "./node_modules/@squill/squill/dist/event/pool-event-emitter.js"));
__export(__webpack_require__(/*! ./replace-event */ "./node_modules/@squill/squill/dist/event/replace-event.js"));
__export(__webpack_require__(/*! ./replace-one-event */ "./node_modules/@squill/squill/dist/event/replace-one-event.js"));
__export(__webpack_require__(/*! ./replace-select-event */ "./node_modules/@squill/squill/dist/event/replace-select-event.js"));
__export(__webpack_require__(/*! ./update-and-fetch-event */ "./node_modules/@squill/squill/dist/event/update-and-fetch-event.js"));
__export(__webpack_require__(/*! ./update-event */ "./node_modules/@squill/squill/dist/event/update-event.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/insert-and-fetch-event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/insert-and-fetch-event.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class InsertAndFetchEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.insertResult = args.insertResult;
        this.fetchedRow = args.fetchedRow;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertAndFetchEvent = InsertAndFetchEvent;
//# sourceMappingURL=insert-and-fetch-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/insert-event.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/insert-event.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "./node_modules/@squill/squill/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class InsertEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeysCache = undefined;
        this.fetchPromises = {};
        this.table = args.table;
        this.insertRows = args.insertRows;
        this.insertResult = args.insertResult;
    }
    get candidateKeys() {
        if (this.candidateKeysCache == undefined) {
            const mapper = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
            this.candidateKeysCache = this.insertRows.map(insertRow => {
                const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                return candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            });
        }
        return this.candidateKeysCache;
    }
    async getOrFetch(index) {
        let fetchPromise = this.fetchPromises[index];
        if (fetchPromise == undefined) {
            const candidateKey = this.candidateKeys[index];
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
            }
            fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            this.fetchPromises[index] = fetchPromise;
        }
        return fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertEvent = InsertEvent;
//# sourceMappingURL=insert-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/insert-one-event.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/insert-one-event.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "./node_modules/@squill/squill/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class InsertOneEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeyCache = "uninitialized";
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.insertResult = args.insertResult;
    }
    get candidateKey() {
        if (this.candidateKeyCache == "uninitialized") {
            const candidateKeyResult = tm.tryMapHandled(candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
            this.candidateKeyCache = candidateKeyResult.success ?
                candidateKeyResult.value :
                undefined;
        }
        return this.candidateKeyCache;
    }
    async getOrFetch() {
        if (this.fetchPromise == undefined) {
            const candidateKey = this.candidateKey;
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey from insertRow`);
            }
            this.fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
        }
        return this.fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertOneEvent = InsertOneEvent;
//# sourceMappingURL=insert-one-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/insert-select-event.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/insert-select-event.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class InsertSelectEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.query = args.query;
        this.table = args.table;
        this.insertSelectRow = args.insertSelectRow;
        this.insertResult = args.insertResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.InsertSelectEvent = InsertSelectEvent;
//# sourceMappingURL=insert-select-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/pool-event-emitter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/pool-event-emitter.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class PoolEventEmitter {
    constructor() {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove handlers while invoking a handler.
         */
        this.handlers = [];
    }
    /**
     * If the `handler` has already been added, it will be ignored.
     */
    addHandler(handler) {
        if (this.handlers.includes(handler)) {
            /**
             * We do not want duplicate handler references.
             */
            return;
        }
        this.handlers = [...this.handlers, handler];
    }
    removeHandler(handler) {
        /**
         * We should not have duplicates
         */
        const index = this.handlers.indexOf(handler);
        if (index < 0) {
            return;
        }
        this.handlers = [
            ...this.handlers.slice(0, index),
            ...this.handlers.slice(index + 1),
        ];
    }
    getHandlers() {
        return this.handlers;
    }
}
exports.PoolEventEmitter = PoolEventEmitter;
//# sourceMappingURL=pool-event-emitter.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/replace-event.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/replace-event.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "./node_modules/@squill/squill/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class ReplaceEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeysCache = undefined;
        this.fetchPromises = {};
        this.table = args.table;
        this.insertRows = args.insertRows;
        this.replaceResult = args.replaceResult;
    }
    get candidateKeys() {
        if (this.candidateKeysCache == undefined) {
            const mapper = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
            this.candidateKeysCache = this.insertRows.map(insertRow => {
                const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                return candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            });
        }
        return this.candidateKeysCache;
    }
    async getOrFetch(index) {
        let fetchPromise = this.fetchPromises[index];
        if (fetchPromise == undefined) {
            const candidateKey = this.candidateKeys[index];
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
            }
            fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            this.fetchPromises[index] = fetchPromise;
        }
        return fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceEvent = ReplaceEvent;
//# sourceMappingURL=replace-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/replace-one-event.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/replace-one-event.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../table */ "./node_modules/@squill/squill/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class ReplaceOneEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.candidateKeyCache = "uninitialized";
        this.table = args.table;
        this.insertRow = args.insertRow;
        this.replaceResult = args.replaceResult;
    }
    get candidateKey() {
        if (this.candidateKeyCache == "uninitialized") {
            const candidateKeyResult = tm.tryMapHandled(candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
            this.candidateKeyCache = candidateKeyResult.success ?
                candidateKeyResult.value :
                undefined;
        }
        return this.candidateKeyCache;
    }
    async getOrFetch() {
        if (this.fetchPromise == undefined) {
            const candidateKey = this.candidateKey;
            if (candidateKey == undefined) {
                /**
                 * @todo Custom Error type
                 */
                throw new Error(`Could not derive candidateKey from insertRow`);
            }
            this.fetchPromise = table_1.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
        }
        return this.fetchPromise;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceOneEvent = ReplaceOneEvent;
//# sourceMappingURL=replace-one-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/replace-select-event.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/replace-select-event.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class ReplaceSelectEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.query = args.query;
        this.table = args.table;
        this.replaceSelectRow = args.replaceSelectRow;
        this.replaceResult = args.replaceResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.ReplaceSelectEvent = ReplaceSelectEvent;
//# sourceMappingURL=replace-select-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/update-and-fetch-event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/update-and-fetch-event.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class UpdateAndFetchEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.assignmentMap = args.assignmentMap;
        this.updateResult = args.updateResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.UpdateAndFetchEvent = UpdateAndFetchEvent;
//# sourceMappingURL=update-and-fetch-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/event/update-event.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/event/update-event.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const event_base_1 = __webpack_require__(/*! ./event-base */ "./node_modules/@squill/squill/dist/event/event-base.js");
class UpdateEvent extends event_base_1.EventBase {
    constructor(args) {
        super(args);
        this.table = args.table;
        this.whereClause = args.whereClause;
        this.assignmentMap = args.assignmentMap;
        this.updateResult = args.updateResult;
    }
    isFor(table) {
        return this.table === table;
    }
}
exports.UpdateEvent = UpdateEvent;
//# sourceMappingURL=update-event.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/connection/component/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/connection/component/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/connection/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/connection/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ConnectionComponent = __webpack_require__(/*! ./component */ "./node_modules/@squill/squill/dist/execution/connection/component/index.js");
exports.ConnectionComponent = ConnectionComponent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./connection */ "./node_modules/@squill/squill/dist/execution/connection/index.js"));
const ExecutionUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/execution/util/index.js");
exports.ExecutionUtil = ExecutionUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/execution/util/operation/index.js"));
__export(__webpack_require__(/*! ./operation-delete */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/index.js"));
__export(__webpack_require__(/*! ./operation-insert */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/index.js"));
__export(__webpack_require__(/*! ./operation-insert-select */ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/index.js"));
__export(__webpack_require__(/*! ./operation-update */ "./node_modules/@squill/squill/dist/execution/util/operation-update/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/execution/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-one.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-one.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const impl = __webpack_require__(/*! ./delete */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function deleteOne(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
         * It should execute no other statements.
         */
        const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0))) {
                    throw new error_1.RowNotFoundError({
                        message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                        sql: deleteResult.query.sql,
                    });
                }
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        deleteResult: deleteResult,
                    };
                }
                throw new error_1.TooManyRowsFoundError({
                    message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                    sql: deleteResult.query.sql,
                });
            });
        });
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                connection: fullConnection,
                table,
                whereClause,
                deleteResult,
            }));
        }
        return deleteResult;
    });
}
exports.deleteOne = deleteOne;
//# sourceMappingURL=delete-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-zero-or-one.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-zero-or-one.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const impl = __webpack_require__(/*! ./delete */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function deleteZeroOrOne(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
         * It should execute no other statements.
         */
        const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        deleteResult: deleteResult,
                    };
                }
                throw new error_1.TooManyRowsFoundError({
                    message: `Expected to delete zero or one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                    sql: deleteResult.query.sql,
                });
            });
        });
        if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    deleteResult,
                }));
            }
        }
        return deleteResult;
    });
}
exports.deleteZeroOrOne = deleteZeroOrOne;
//# sourceMappingURL=delete-zero-or-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-delete/delete.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function deleteImplNoEvent(table, connection, whereDelegate) {
    table_1.TableUtil.assertDeleteEnabled(table);
    const whereClause = where_clause_1.WhereClauseUtil.where(from_clause_1.FromClauseUtil.from(from_clause_1.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
    const deleteResult = await connection.delete(table, whereClause);
    return {
        whereClause,
        deleteResult,
    };
}
exports.deleteImplNoEvent = deleteImplNoEvent;
async function del(table, connection, whereDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, deleteResult, } = await deleteImplNoEvent(table, connection, whereDelegate);
        if (tm.BigIntUtil.greaterThan(deleteResult.deletedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    deleteResult,
                }));
            }
        }
        return deleteResult;
    });
}
exports.delete = del;
//# sourceMappingURL=delete.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-delete/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-delete/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./delete-one */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-one.js"));
__export(__webpack_require__(/*! ./delete-zero-or-one */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete-zero-or-one.js"));
__export(__webpack_require__(/*! ./delete */ "./node_modules/@squill/squill/dist/execution/util/operation-delete/delete.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert-select/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-ignore-select */ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-ignore-select.js"));
__export(__webpack_require__(/*! ./insert-select */ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-select.js"));
__export(__webpack_require__(/*! ./replace-select */ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/replace-select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-ignore-select.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-ignore-select.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "./node_modules/@squill/squill/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function insertIgnoreSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    return connection.lock(async (connection) => {
        const insertSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const insertResult = await connection.insertIgnoreSelect(query, table, insertSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsertSelect.invoke(new event_1.InsertSelectEvent({
                connection: fullConnection,
                query,
                table,
                insertSelectRow,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertIgnoreSelect = insertIgnoreSelect;
//# sourceMappingURL=insert-ignore-select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-select.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert-select/insert-select.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "./node_modules/@squill/squill/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function insertSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    return connection.lock(async (connection) => {
        const insertSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const insertResult = await connection.insertSelect(query, table, insertSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsertSelect.invoke(new event_1.InsertSelectEvent({
                connection: fullConnection,
                query,
                table,
                insertSelectRow,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertSelect = insertSelect;
//# sourceMappingURL=insert-select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert-select/replace-select.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert-select/replace-select.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_select_1 = __webpack_require__(/*! ../../../insert-select */ "./node_modules/@squill/squill/dist/insert-select/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function replaceSelect(connection, query, table, rowDelegate) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    return connection.lock(async (connection) => {
        const replaceSelectRow = insert_select_1.InsertSelectUtil.insertSelect(query, table, rowDelegate);
        const replaceResult = await connection.replaceSelect(query, table, replaceSelectRow);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onReplaceSelect.invoke(new event_1.ReplaceSelectEvent({
                connection: fullConnection,
                query,
                table,
                replaceSelectRow,
                replaceResult,
            }));
        }
        return replaceResult;
    });
}
exports.replaceSelect = replaceSelect;
//# sourceMappingURL=replace-select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-and-fetch */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-and-fetch.js"));
__export(__webpack_require__(/*! ./insert-ignore-many */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-many.js"));
__export(__webpack_require__(/*! ./insert-ignore-one */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-one.js"));
__export(__webpack_require__(/*! ./insert-many */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-many.js"));
__export(__webpack_require__(/*! ./insert-one */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-one.js"));
__export(__webpack_require__(/*! ./replace-many */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-many.js"));
__export(__webpack_require__(/*! ./replace-one */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-one.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-and-fetch.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-and-fetch.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_one_1 = __webpack_require__(/*! ./insert-one */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-one.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function insertAndFetchImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertHasCandidateKey(table);
    /**
     * @todo Check if `SERIALIZABLE` is better.
     * Intuitively, `REPEATABLE_READ` makes sense because
     * we're just reading a row we've inserted inside this transaction.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
        return connection.savepoint(async (connection) => {
            if (table.autoIncrement == undefined) {
                const candidateKeyResult = await data_type_1.DataTypeUtil.tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row);
                if (!candidateKeyResult.success) {
                    throw candidateKeyResult.error;
                }
                row = {
                    ...row,
                    ...candidateKeyResult.outputRow,
                };
                const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                const fetchedRow = await table_1.TableUtil.fetchOne(table, connection, () => ExprLib.eqCandidateKey(table, candidateKeyResult.outputRow));
                return {
                    ...insertOneImplResult,
                    fetchedRow,
                };
            }
            else {
                const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                const fetchedRow = await table_1.TableUtil.fetchOne(table, connection, 
                /**
                 * We use this instead of `eqPrimaryKey()` because it's possible
                 * for an `AUTO_INCREMENT` column to not be a primary key
                 * with some databases...
                 *
                 * It's also possible for it to not be a candidate key!
                 */
                () => ExprLib.eqColumns(table, {
                    [table.autoIncrement]: insertOneImplResult.insertResult.autoIncrementId,
                }));
                return {
                    ...insertOneImplResult,
                    fetchedRow,
                };
            }
        });
    });
}
/**
 * Convenience method for
 * ```ts
 *  connection.transactionIfNotInOne(IsolationLevel.REPEATABLE_READ, async (connection) => {
 *      await table.insertOne(connection, ...);
 *      return table.fetchOne(connection, ...);
 *  });
 * ```
 */
async function insertAndFetch(table, connection, row, insertAndFetchOptions) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertHasCandidateKey(table);
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, fetchedRow, } = await insertAndFetchImplNoEvent((insertAndFetchOptions == undefined ?
            table :
            {
                ...table,
                ...insertAndFetchOptions,
            }), connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { insertEvent, insertOneEvent, } = insert_one_1.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
            await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
            await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
            await fullConnection.eventEmitters.onInsertAndFetch.invoke(new event_1.InsertAndFetchEvent({
                connection: fullConnection,
                table,
                insertRow: insertOneEvent.insertRow,
                insertResult: insertOneEvent.insertResult,
                fetchedRow: fetchedRow,
            }));
        }
        return fetchedRow;
    });
}
exports.insertAndFetch = insertAndFetch;
//# sourceMappingURL=insert-and-fetch.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-many.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-many.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
/**
 * Inserts zero-to-many rows
 * ```sql
 *  INSERT IGNORE INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function insertIgnoreMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const insertResult = await connection.insertIgnoreMany(table, insertRows);
        if (!tm.BigIntUtil.equal(insertResult.insertedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onInsert.invoke(new event_1.InsertEvent({
                    connection: fullConnection,
                    table,
                    insertRows,
                    insertResult,
                }));
            }
        }
        return insertResult;
    });
}
exports.insertIgnoreMany = insertIgnoreMany;
//# sourceMappingURL=insert-ignore-many.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-one.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-ignore-one.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const insert_one_1 = __webpack_require__(/*! ./insert-one */ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-one.js");
function isIgnoredResult(result) {
    return tm.BigIntUtil.equal(result.insertedRowCount, tm.BigInt(0));
}
function isInsertOneResult(result) {
    return !isIgnoredResult(result);
}
/**
 * Does not invoke events.
 */
async function insertIgnoreOneImpl(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            insertResult: await connection.insertIgnoreOne(table, row),
        };
    }
    const explicitAutoIncrementValue = row[table.autoIncrement];
    if (explicitAutoIncrementValue === undefined) {
        const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
        if (isIgnoredResult(insertIgnoreResult)) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        if (insertIgnoreResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful insertIgnoreOne() to ${table.alias} should return autoIncrementId`);
    }
    if (typeof explicitAutoIncrementValue != "number" &&
        typeof explicitAutoIncrementValue != "string" &&
        !tm.TypeUtil.isBigInt(explicitAutoIncrementValue)) {
        /**
         * @todo Custom error type
         */
        throw new Error(`Explicit autoIncrement value for ${table.alias} must be bigint|number|string`);
    }
    const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
    if (isIgnoredResult(insertIgnoreResult)) {
        return {
            insertRow: row,
            insertResult: {
                ...insertIgnoreResult,
                [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
            },
        };
    }
    if (insertIgnoreResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            insertResult: {
                ...insertIgnoreResult,
                [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
            },
        };
    }
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        insertResult: {
            ...insertIgnoreResult,
            autoIncrementId: BigInt(explicitAutoIncrementValue),
            [table.autoIncrement]: BigInt(explicitAutoIncrementValue),
        },
    };
}
/**
 * Only inserts zero or one row
 * ```sql
 *  INSERT IGNORE INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 */
async function insertIgnoreOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, } = await insertIgnoreOneImpl(table, connection, row);
        if (isInsertOneResult(insertResult)) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                const { insertEvent, insertOneEvent, } = insert_one_1.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
                await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
                await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
            }
        }
        return insertResult;
    });
}
exports.insertIgnoreOne = insertIgnoreOne;
//# sourceMappingURL=insert-ignore-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-many.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-many.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
/**
 * Inserts zero-to-many rows
 * ```sql
 *  INSERT INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function insertMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const insertResult = await connection.insertMany(table, insertRows);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onInsert.invoke(new event_1.InsertEvent({
                connection: fullConnection,
                table,
                insertRows,
                insertResult,
            }));
        }
        return insertResult;
    });
}
exports.insertMany = insertMany;
//# sourceMappingURL=insert-many.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-one.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/insert-one.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function insertOneImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            insertResult: await connection.insertOne(table, row),
        };
    }
    let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
    if (explicitAutoIncrementBuiltInExpr === undefined) {
        const insertResult = await connection.insertOne(table, row);
        if (insertResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertResult,
                    [table.autoIncrement]: insertResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful insertOne() to ${table.alias} should return autoIncrementId`);
    }
    explicitAutoIncrementBuiltInExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
    const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
    const insertResult = await connection.insertOne(table, {
        ...row,
        [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
    });
    /**
     * We defer to the `autoIncrementId` of the `insertResult`.
     * We assume the `connection` always knows best.
     */
    if (insertResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            insertResult: {
                ...insertResult,
                [table.autoIncrement]: insertResult.autoIncrementId,
            },
        };
    }
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        insertResult: {
            ...insertResult,
            autoIncrementId: autoIncrementBigInt,
            [table.autoIncrement]: autoIncrementBigInt,
        },
    };
}
exports.insertOneImplNoEvent = insertOneImplNoEvent;
function createInsertOneEvents(table, fullConnection, insertRow, insertResult) {
    const augmentedInsertRow = (table.autoIncrement == undefined ?
        insertRow :
        {
            ...insertRow,
            /**
             * The column may be specified to be `string|number|bigint`.
             * So, we need to use the column's mapper,
             * to get the desired data type.
             */
            [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
            /**
             * This **should** be `bigint`
             */
            insertResult.autoIncrementId),
        });
    const insertEvent = new event_1.InsertEvent({
        connection: fullConnection,
        table,
        insertRows: [augmentedInsertRow],
        insertResult,
    });
    const insertOneEvent = new event_1.InsertOneEvent({
        connection: fullConnection,
        table,
        insertRow: augmentedInsertRow,
        insertResult,
    });
    return {
        insertEvent,
        insertOneEvent,
    };
}
exports.createInsertOneEvents = createInsertOneEvents;
/**
 * Only inserts one row
 * ```sql
 *  INSERT INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 */
async function insertOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, insertResult, } = await insertOneImplNoEvent(table, connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { insertEvent, insertOneEvent, } = createInsertOneEvents(table, fullConnection, insertRow, insertResult);
            await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
            await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
        }
        return insertResult;
    });
}
exports.insertOne = insertOne;
//# sourceMappingURL=insert-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-many.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-many.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
/**
 * Inserts/Replaces zero-to-many rows
 * ```sql
 *  REPLACE INTO
 *      myTable (...column_list)
 *  VALUES
 *      ...row_list;
 * ```
 */
async function replaceMany(table, connection, rows) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    if (rows.length == 0) {
        return {
            query: {
                /**
                 * No rows were inserted.
                 * No SQL string was execute.
                 */
                sql: "",
            },
            insertedOrReplacedRowCount: tm.BigInt(0),
            /**
             * Should this be considered a warning?
             * Probably not.
             */
            warningCount: tm.BigInt(0),
            message: "No rows to insert",
        };
    }
    return connection.lock(async (connection) => {
        const insertRows = rows.map(row => insert_1.InsertUtil.cleanInsertRow(table, row));
        const replaceResult = await connection.replaceMany(table, insertRows);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onReplace.invoke(new event_1.ReplaceEvent({
                connection: fullConnection,
                table,
                insertRows,
                replaceResult,
            }));
        }
        return replaceResult;
    });
}
exports.replaceMany = replaceMany;
//# sourceMappingURL=replace-many.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-one.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-insert/replace-one.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const insert_1 = __webpack_require__(/*! ../../../insert */ "./node_modules/@squill/squill/dist/insert/index.js");
const data_type_1 = __webpack_require__(/*! ../../../data-type */ "./node_modules/@squill/squill/dist/data-type/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function replaceOneImplNoEvent(table, connection, row) {
    table_1.TableUtil.assertInsertEnabled(table);
    table_1.TableUtil.assertDeleteEnabled(table);
    /**
     * Should contain only `BuiltInExpr` now
     */
    row = insert_1.InsertUtil.cleanInsertRow(table, row);
    if (table.autoIncrement == undefined) {
        return {
            insertRow: row,
            replaceResult: await connection.replaceOne(table, row),
        };
    }
    let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
    if (explicitAutoIncrementBuiltInExpr === undefined) {
        const replaceResult = await connection.replaceOne(table, row);
        if (replaceResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                replaceResult: {
                    ...replaceResult,
                    [table.autoIncrement]: replaceResult.autoIncrementId,
                },
            };
        }
        /**
         * @todo Custom error type
         */
        throw new Error(`Successful replaceOne() to ${table.alias} should return autoIncrementId`);
    }
    explicitAutoIncrementBuiltInExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
    const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
    const replaceResult = await connection.replaceOne(table, {
        ...row,
        [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
    });
    /**
     * We defer to the `autoIncrementId` of the `replaceResult`.
     * We assume the `connection` always knows best.
     */
    if (replaceResult.autoIncrementId != undefined) {
        return {
            insertRow: row,
            replaceResult: {
                ...replaceResult,
                [table.autoIncrement]: replaceResult.autoIncrementId,
            },
        };
    }
    /**
     * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
     * Use it.
     */
    return {
        insertRow: row,
        replaceResult: {
            ...replaceResult,
            autoIncrementId: autoIncrementBigInt,
            [table.autoIncrement]: autoIncrementBigInt,
        },
    };
}
exports.replaceOneImplNoEvent = replaceOneImplNoEvent;
function createReplaceOneEvents(table, fullConnection, insertRow, replaceResult) {
    const augmentedInsertRow = (table.autoIncrement == undefined ?
        insertRow :
        {
            ...insertRow,
            /**
             * The column may be specified to be `string|number|bigint`.
             * So, we need to use the column's mapper,
             * to get the desired data type.
             */
            [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
            /**
             * This **should** be `bigint`
             */
            replaceResult.autoIncrementId),
        });
    const replaceEvent = new event_1.ReplaceEvent({
        connection: fullConnection,
        table,
        insertRows: [augmentedInsertRow],
        replaceResult,
    });
    const replaceOneEvent = new event_1.ReplaceOneEvent({
        connection: fullConnection,
        table,
        insertRow: augmentedInsertRow,
        replaceResult,
    });
    return {
        replaceEvent,
        replaceOneEvent,
    };
}
exports.createReplaceOneEvents = createReplaceOneEvents;
/**
 * Only inserts/replaces one row
 * ```sql
 *  REPLACE INTO
 *      myTable (...column_list)
 *  VALUES
 *      (...value_list);
 * ```
 *
 * The table must allow both `INSERT` and `DELETE`.
 * Replacing a row is essentially deleting the old row and inserting a new row.
 */
async function replaceOne(table, connection, row) {
    return connection.lock(async (connection) => {
        const { insertRow, replaceResult, } = await replaceOneImplNoEvent(table, connection, row);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            const { replaceEvent, replaceOneEvent, } = createReplaceOneEvents(table, fullConnection, insertRow, replaceResult);
            await fullConnection.eventEmitters.onReplace.invoke(replaceEvent);
            await fullConnection.eventEmitters.onReplaceOne.invoke(replaceOneEvent);
        }
        return replaceResult;
    });
}
exports.replaceOne = replaceOne;
//# sourceMappingURL=replace-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js"));
__export(__webpack_require__(/*! ./update-and-fetch-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-candidate-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-primary-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-by-super-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js"));
__export(__webpack_require__(/*! ./update-and-fetch-zero-or-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js"));
__export(__webpack_require__(/*! ./update-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-one.js"));
__export(__webpack_require__(/*! ./update-zero-or-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-zero-or-one.js"));
__export(__webpack_require__(/*! ./update */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const candidate_key_1 = __webpack_require__(/*! ../../../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    candidateKey = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${table.alias}[candidateKey]`, candidateKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newCandidateKey = {};
    for (const candidateColumnAlias of Object.keys(candidateKey)) {
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, candidateColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, candidateColumnAlias)) ?
            assignmentMap[candidateColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `candidateKey` column's value will not be updated.
             */
            newCandidateKey[candidateColumnAlias] = candidateKey[candidateColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(candidateColumnAlias) < 0) {
                throw new Error(`${table.alias}.${candidateColumnAlias} is not a mutable candidate key column`);
            }
            /**
             * This `candidateKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqCandidateKey(table, candidateKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[candidateColumnAlias] = newCandidateKey[candidateColumnAlias];
        }
    }
    return {
        success: true,
        curCandidateKey: candidateKey,
        assignmentMap,
        newCandidateKey,
    };
}
exports.__updateAndFetchOneByCandidateKeyHelper = __updateAndFetchOneByCandidateKeyHelper;
async function updateAndFetchOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const primary_key_1 = __webpack_require__(/*! ../../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate) {
    primaryKey = primary_key_1.PrimaryKeyUtil.mapper(table)(`${table.alias}[primaryKey]`, primaryKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newPrimaryKey = {};
    for (const primaryColumnAlias of Object.keys(primaryKey)) {
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, primaryColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, primaryColumnAlias)) ?
            assignmentMap[primaryColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `primaryKey` column's value will not be updated.
             */
            newPrimaryKey[primaryColumnAlias] = primaryKey[primaryColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(primaryColumnAlias) < 0) {
                throw new Error(`${table.alias}.${primaryColumnAlias} is not a mutable primary key column`);
            }
            /**
             * This `primaryKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqPrimaryKey(table, primaryKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[primaryColumnAlias] = newPrimaryKey[primaryColumnAlias];
        }
    }
    return {
        success: true,
        curPrimaryKey: primaryKey,
        assignmentMap,
        newPrimaryKey,
    };
}
exports.__updateAndFetchOneByPrimaryKeyHelper = __updateAndFetchOneByPrimaryKeyHelper;
async function updateAndFetchOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
            fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const super_key_1 = __webpack_require__(/*! ../../../super-key */ "./node_modules/@squill/squill/dist/super-key/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate) {
    superKey = super_key_1.SuperKeyUtil.mapper(table)(`${table.alias}[superKey]`, superKey);
    const assignmentMap = assignmentMapDelegate(table.columns);
    const newSuperKey = {};
    for (const superColumnAlias of Object.keys(superKey)) {
        if (superKey[superColumnAlias] === undefined) {
            continue;
        }
        const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, superColumnAlias) &&
            Object.prototype.propertyIsEnumerable.call(assignmentMap, superColumnAlias)) ?
            assignmentMap[superColumnAlias] :
            undefined);
        if (newCustomExpr === undefined) {
            /**
             * This `superKey` column's value will not be updated.
             */
            newSuperKey[superColumnAlias] = superKey[superColumnAlias];
        }
        else {
            if (table.mutableColumns.indexOf(superColumnAlias) < 0) {
                throw new Error(`${table.alias}.${superColumnAlias} is not a mutable super key column`);
            }
            /**
             * This `superKey` column's value will be updated.
             * We need to know what its updated value will be.
             */
            if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                const evaluatedNewValue = await table_1.TableUtil.fetchValue(table, connection, () => ExprLib.eqSuperKey(table, superKey), () => newCustomExpr).catch((err) => {
                    if (err instanceof error_1.RowNotFoundError) {
                        return err;
                    }
                    else {
                        throw err;
                    }
                });
                if (evaluatedNewValue instanceof error_1.RowNotFoundError) {
                    return {
                        success: false,
                        rowNotFoundError: evaluatedNewValue,
                    };
                }
                newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, evaluatedNewValue);
            }
            else {
                newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, newCustomExpr);
            }
            /**
             * If it was an expression, it is now a value.
             */
            assignmentMap[superColumnAlias] = newSuperKey[superColumnAlias];
        }
    }
    return {
        success: true,
        curSuperKey: superKey,
        assignmentMap,
        newSuperKey,
    };
}
exports.__updateAndFetchOneBySuperKeyHelper = __updateAndFetchOneBySuperKeyHelper;
async function updateAndFetchOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
            fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
//# sourceMappingURL=update-and-fetch-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const update_one_1 = __webpack_require__(/*! ./update-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-one.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
/**
 * This should not be called directly by users.
 *
 * A lot can go wrong here...
 */
async function updateAndFetchOneImpl(table, connection, initCallback) {
    return connection.lock(async (connection) => {
        /**
         * `REPEATABLE_READ` should be fine because we're not creating any new rows.
         */
        const { updateWhereClause, updateResult, assignmentMap, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = await initCallback(connection);
                const { whereClause: updateWhereClause, updateResult: updateOneResult, } = await update_one_1.updateOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                const row = await table_1.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                return {
                    updateWhereClause,
                    updateResult: {
                        ...updateOneResult,
                        row,
                    },
                    assignmentMap,
                };
            });
        });
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                connection: fullConnection,
                table,
                whereClause: updateWhereClause,
                assignmentMap,
                updateResult,
            }));
            await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_1.UpdateAndFetchEvent({
                connection: fullConnection,
                table,
                assignmentMap,
                updateResult: updateResult,
            }));
        }
        return updateResult;
    });
}
exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
//# sourceMappingURL=update-and-fetch-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const update_and_fetch_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-impl.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/@squill/squill/dist/execution/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js");
/**
 * Not meant to be called externally
 *
 * @todo Better name
 */
async function __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate) {
    table_1.TableUtil.assertHasCandidateKey(table);
    /**
     * Prefer `primaryKey`
     */
    const candidateKeyColumnAliases = table.primaryKey != undefined ?
        table.primaryKey :
        table.candidateKeys[0];
    const curCandidateKeyOrError = await __1.ExecutionUtil
        .fetchOne(unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .select((columns) => candidateKeyColumnAliases.map(columnAlias => columns[columnAlias])), connection)
        .then((curCandidateKey) => {
        return curCandidateKey;
    }, (err) => {
        if (err instanceof error_1.RowNotFoundError) {
            return err;
        }
        else {
            throw err;
        }
    });
    if (curCandidateKeyOrError instanceof error_1.RowNotFoundError) {
        return {
            success: false,
            rowNotFoundError: curCandidateKeyOrError,
        };
    }
    else {
        return update_and_fetch_one_by_candidate_key_1.__updateAndFetchOneByCandidateKeyHelper(table, connection, curCandidateKeyOrError, assignmentMapDelegate);
    }
}
exports.__updateAndFetchOneHelper = __updateAndFetchOneHelper;
async function updateAndFetchOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
        const helperResult = await __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
        if (!helperResult.success) {
            throw helperResult.rowNotFoundError;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchOne = updateAndFetchOne;
//# sourceMappingURL=update-and-fetch-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const update_and_fetch_one_by_candidate_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-candidate-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-candidate-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_candidate_key_1.__updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const update_and_fetch_one_by_primary_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-primary-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-primary-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_primary_key_1.__updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
            fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const update_and_fetch_one_by_super_key_1 = __webpack_require__(/*! ./update-and-fetch-one-by-super-key */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one-by-super-key.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
async function updateAndFetchZeroOrOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_by_super_key_1.__updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
            fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
//# sourceMappingURL=update-and-fetch-zero-or-one-by-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const update_zero_or_one_1 = __webpack_require__(/*! ./update-zero-or-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-zero-or-one.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
/**
 * This should not be called directly by users.
 *
 * A lot can go wrong here...
 */
async function updateAndFetchZeroOrOneImpl(table, connection, initCallback) {
    return connection.lock(async (connection) => {
        /**
         * `REPEATABLE_READ` should be fine because we're not creating any new rows.
         */
        const updateAndFetchResult = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const initResult = await initCallback(connection);
                if (!initResult.success) {
                    return {
                        success: false,
                        updateResult: {
                            query: {
                                sql: initResult.rowNotFoundError.sql,
                            },
                            //Alias for affectedRows
                            foundRowCount: tm.BigInt(0),
                            //Alias for changedRows
                            updatedRowCount: tm.BigInt(0),
                            /**
                             * May be the duplicate row count, or some other value.
                             */
                            warningCount: tm.BigInt(0),
                            /**
                             * An arbitrary message.
                             * May be an empty string.
                             */
                            message: "",
                            row: undefined,
                        },
                    };
                }
                const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = initResult;
                const { whereClause: updateWhereClause, updateResult: updateZeroOrOneResult, } = await update_zero_or_one_1.updateZeroOrOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                if (tm.BigIntUtil.equal(updateZeroOrOneResult.foundRowCount, tm.BigInt(0))) {
                    const notFoundUpdateResult = updateZeroOrOneResult;
                    return {
                        success: true,
                        updateWhereClause,
                        updateResult: {
                            ...notFoundUpdateResult,
                            row: undefined,
                        },
                        assignmentMap,
                    };
                }
                else {
                    const updateOneResult = updateZeroOrOneResult;
                    const row = await table_1.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                    return {
                        success: true,
                        updateWhereClause,
                        updateResult: {
                            ...updateOneResult,
                            row,
                        },
                        assignmentMap,
                    };
                }
            });
        });
        if (!updateAndFetchResult.success) {
            return updateAndFetchResult.updateResult;
        }
        const { updateWhereClause, updateResult, assignmentMap, } = updateAndFetchResult;
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause: updateWhereClause,
                    assignmentMap,
                    updateResult,
                }));
                await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_1.UpdateAndFetchEvent({
                    connection: fullConnection,
                    table,
                    assignmentMap,
                    updateResult: updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.updateAndFetchZeroOrOneImpl = updateAndFetchZeroOrOneImpl;
//# sourceMappingURL=update-and-fetch-zero-or-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const update_and_fetch_zero_or_one_impl_1 = __webpack_require__(/*! ./update-and-fetch-zero-or-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-zero-or-one-impl.js");
const update_and_fetch_one_1 = __webpack_require__(/*! ./update-and-fetch-one */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-and-fetch-one.js");
async function updateAndFetchZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
        const helperResult = await update_and_fetch_one_1.__updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
        if (!helperResult.success) {
            return helperResult;
        }
        const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
        return {
            success: true,
            updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
            fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
            /**
             * This cast is unsound.
             * What we have is not `AssignmentMapT`.
             *
             * We have a `BuiltInExpr` version of `AssignmentMapT`,
             * with some parts possibly being evaluated to a value expression.
             *
             * However, this will not affect the correctness of
             * our results.
             */
            assignmentMap: assignmentMap,
        };
    });
}
exports.updateAndFetchZeroOrOne = updateAndFetchZeroOrOne;
//# sourceMappingURL=update-and-fetch-zero-or-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-one.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-one.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const impl = __webpack_require__(/*! ./update */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    /**
     * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
     * It should execute no other statements.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
        return connection.savepoint(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                throw new error_1.RowNotFoundError({
                    message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                    sql: updateResult.query.sql,
                });
            }
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            throw new error_1.TooManyRowsFoundError({
                message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                sql: updateResult.query.sql,
            });
        });
    });
}
exports.updateOneImplNoEvent = updateOneImplNoEvent;
async function updateOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        const fullConnection = connection.tryGetFullConnection();
        if (fullConnection != undefined) {
            await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                connection: fullConnection,
                table,
                whereClause,
                assignmentMap,
                updateResult,
            }));
        }
        return updateResult;
    });
}
exports.updateOne = updateOne;
//# sourceMappingURL=update-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update-zero-or-one.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update-zero-or-one.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const impl = __webpack_require__(/*! ./update */ "./node_modules/@squill/squill/dist/execution/util/operation-update/update.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
const isolation_level_1 = __webpack_require__(/*! ../../../isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js");
async function updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    /**
     * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
     * It should execute no other statements.
     */
    return connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
        return connection.savepoint(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero rows of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                    tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                    return {
                        whereClause,
                        assignmentMap,
                        updateResult: updateResult,
                    };
                }
                else {
                    //Should never happen...
                    throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                }
            }
            throw new error_1.TooManyRowsFoundError({
                message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                sql: updateResult.query.sql,
            });
        });
    });
}
exports.updateZeroOrOneImplNoEvent = updateZeroOrOneImplNoEvent;
async function updateZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    assignmentMap,
                    updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.updateZeroOrOne = updateZeroOrOne;
//# sourceMappingURL=update-zero-or-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation-update/update.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation-update/update.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const update_1 = __webpack_require__(/*! ../../../update */ "./node_modules/@squill/squill/dist/update/index.js");
const event_1 = __webpack_require__(/*! ../../../event */ "./node_modules/@squill/squill/dist/event/index.js");
async function updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
    const whereClause = where_clause_1.WhereClauseUtil.where(from_clause_1.FromClauseUtil.from(from_clause_1.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
    const assignmentMap = update_1.UpdateUtil.set(table, assignmentMapDelegate);
    const updateResult = await connection.update(table, whereClause, assignmentMap);
    return {
        whereClause,
        assignmentMap,
        updateResult,
    };
}
exports.updateImplNoEvent = updateImplNoEvent;
async function update(table, connection, whereDelegate, assignmentMapDelegate) {
    return connection.lock(async (connection) => {
        const { whereClause, assignmentMap, updateResult, } = await updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
        if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_1.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    assignmentMap,
                    updateResult,
                }));
            }
        }
        return updateResult;
    });
}
exports.update = update;
//# sourceMappingURL=update.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/assert-exists.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/assert-exists.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function assertExists(query, connection) {
    const result = await impl_1.existsImpl(query, connection);
    if (!result.exists) {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.RowNotFoundError({
                message: `Row does not exist`,
                sql: result.sql,
            });
        }
        else {
            throw new error_1.RowNotFoundError({
                message: `Row of ${query.fromClause.currentJoins[0].tableAlias} does not exist`,
                sql: result.sql,
            });
        }
    }
}
exports.assertExists = assertExists;
//# sourceMappingURL=assert-exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/count.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/count.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const fetch_value_1 = __webpack_require__(/*! ./fetch-value */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value.js");
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const paginate_1 = __webpack_require__(/*! ./paginate */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/index.js");
/**
 * @todo Optimize this further?
 * Or keep trusting DBMS execution engine?
 */
async function count(query, connection) {
    /**
     * The following clauses may have a reference to the `SELECT` clause,
     *
     * + `groupByClause`
     * + `orderByClause`
     * + `compoundQueryClause`
     * + `compoundQueryOrderByClause`
     *
     */
    if (query_base_1.QueryBaseUtil.isAfterSelectClause(query)) {
        return fetch_value_1.fetchValue(unified_query_1.QueryUtil.selectValue(unified_query_1.QueryUtil.newInstance(), () => expr_1.expr({
            /**
             * Should not return a value less than zero
             */
            mapper: tm.mysql.bigIntUnsigned(),
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast_1.parentheses(
        /**
         * @todo **THIS** is not database agnostic. Change it to a proper AST
         * @todo Find other such occurrences,
         * where we assume the implementing DB will be able to execute SQL strings
         *
         * This should be fine for now, since most DB engines should be able to handle this.
         */
        [
            "SELECT COUNT(*) FROM",
            ast_1.parentheses(paginate_1.removePaginateArgs(query), false),
            "AS tmp"
        ], false))), connection);
    }
    if (query_base_1.QueryBaseUtil.isBeforeSelectClause(query) &&
        query_base_1.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
        return fetch_value_1.fetchValue({
            ...query,
            selectClause: select_clause_1.SelectClauseUtil.selectValue(query.fromClause, query.groupByClause, query.selectClause, () => ExprLib.countAll()),
            compoundQueryClause: query.compoundQueryClause,
        }, connection);
    }
    else {
        //This should never happen...
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.CannotCountError({
                message: `Cannot get count`,
                sql: undefined,
            });
        }
        else {
            throw new error_1.CannotCountError({
                message: `Cannot get count of ${query.fromClause.currentJoins[0].tableAlias}`,
                sql: undefined,
            });
        }
    }
}
exports.count = count;
//# sourceMappingURL=count.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const paginate_1 = __webpack_require__(/*! ../paginate */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/index.js");
//In case Symbol.asyncIterator is not defined
if (Symbol.asyncIterator == undefined) {
    Object.defineProperty(Symbol, "asyncIterator", {
        value: Symbol.for("Symbol.asyncIterator")
    });
}
class EmulatedCursorImpl {
    constructor(query, connection, rawArgs) {
        this.buffer = undefined;
        this.query = query;
        this.connection = connection;
        const args = paginate_1.toPaginateArgs(rawArgs);
        this.startPage = args.page;
        this.rowsPerPage = args.rowsPerPage;
        this.rowOffset = args.rowOffset;
        this.BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        this.rowIndex = 0;
        if (tm.BigIntUtil.greaterThan(this.rowsPerPage, Number.MAX_SAFE_INTEGER)) {
            throw new Error(`Cannot safely emulate cursor when buffer size is greater than ${Number.MAX_SAFE_INTEGER}`);
        }
    }
    async getOrFetchBuffer() {
        if (this.buffer == undefined) {
            this.rowIndex = 0;
            this.buffer = await paginate_1.paginate(this.query, this.connection, {
                page: this.startPage,
                rowsPerPage: this.rowsPerPage,
                rowOffset: this.rowOffset,
            });
        }
        return this.buffer;
    }
    async tryGetNextRow() {
        const buffer = await this.getOrFetchBuffer();
        if (this.rowIndex < buffer.rows.length) {
            const row = buffer.rows[this.rowIndex];
            ++this.rowIndex;
            return row;
        }
        else {
            return undefined;
        }
    }
    async tryFetchNextPage() {
        const buffer = await this.getOrFetchBuffer();
        const nextPage = tm.BigIntUtil.add(buffer.info.page, this.BigInt(1));
        if (tm.BigIntUtil.lessThan(nextPage, buffer.info.pagesFound)) {
            this.rowIndex = 0;
            this.buffer = await paginate_1.paginate(this.query, this.connection, {
                page: nextPage,
                rowsPerPage: this.rowsPerPage,
                rowOffset: this.rowOffset,
            });
            return buffer;
        }
        else {
            return undefined;
        }
    }
    async next() {
        /**
         * Try and get the next row of the current page
         */
        const row = await this.tryGetNextRow();
        if (row !== undefined) {
            return {
                done: false,
                value: row,
            };
        }
        /**
         * If we're here, we passed the end of the current page
         */
        {
            await this.tryFetchNextPage();
            const row = await this.tryGetNextRow();
            if (row !== undefined) {
                return {
                    done: false,
                    value: row,
                };
            }
            else {
                /**
                 * We passed the end of the last page
                 */
                return {
                    done: true,
                    /**
                     * The `IteratorResult<>` type really needs to be updated...
                     */
                    value: undefined,
                };
            }
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
exports.EmulatedCursorImpl = EmulatedCursorImpl;
//# sourceMappingURL=emulated-cursor-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const emulated_cursor_impl_1 = __webpack_require__(/*! ./emulated-cursor-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js");
/**
 * Considerations:
 * + MySQL **does not** support cursors at the protocol level
 *   + https://github.com/sidorares/node-mysql2/issues/1014
 *   + https://github.com/sidorares/node-mysql2/pull/822#issuecomment-409415308
 *   + https://github.com/sidorares/node-mysql2/blob/9404163b0dc4bdc24f6dddd18144532f41115842/lib/commands/query.js#L239
 *   + https://github.com/mysqljs/mysql/issues/274
 * + Cursors are useful for processing large amounts of data without loading everything into memory at once
 * + Cursors can prevent out-of-memory exceptions, since data is loaded in batches
 *
 * -----
 *
 * Since cursors are not natively supported (by MySQL), we emulate it using pagination.
 * So, we use the `LIMIT` and `OFFSET` clauses, and load rows in batches as we iterate.
 *
 * -----
 *
 * ### Preventing Duplicate Items
 *
 * ```ts
 *  const cursor = myQuery.emulatedCursor();
 *  for await (const row of cursor) {
 *      console.log(row);
 *      //snip operations on `row`
 *  }
 * ```
 *
 * Given the above, we might be expecting output like,
 * ```ts
 * //batch 1
 * > { rowId : 1 }
 * > { rowId : 2 }
 *
 * //batch 2
 * > { rowId : 3 }
 * > { rowId : 4 }
 *
 * //batch n
 * > etc.
 * ```
 *
 * We might actually get,
 * ```ts
 * //batch 1
 * > { rowId : 1 }
 * > { rowId : 2 }
 *
 * //batch 2
 * > { rowId : 2 } //This is a duplicate item, what gives?
 * > { rowId : 3 }
 *
 * //batch 3
 * > { rowId : 4 }
 * > { rowId : 5 }
 *
 * //batch n
 * > etc.
 * ```
 *
 * This can happen for a variety of reasons,
 * + Missing `ORDER BY` clause
 *   + Without an `ORDER BY` clause, the order that rows are returned in is undefined behaviour.
 *   + Rows are retrieved in batches and a row may appear in multiple batches.
 *   + To fix, add an `ORDER BY` clause
 *
 * + Non-unique ordering
 *   + The `ORDER BY` clause may not guarantee a unique ordering
 *   + To fix, modify the `ORDER BY` clause and guarantee a unique ordering
 *
 * + Not using a transaction
 *   + A different connection may have inserted a row into the table you are iterating over
 *
 *     The new row may have pushed other rows "down" the table,
 *     causing the next retrieved batch to contain rows already seen.
 *
 *   + To fix, use the cursor in a transaction
 *
 * + Modifying the table being iterated over
 *   + `INSERT/DELETE/UPDATE` statements may modify the table you are iterating over.
 *   + Consider buffering mutations into a temporary table first,
 *     then apply the mutations after you are done iterating.
 *   + Consider performing your mutations in a way that does not interfere with your `ORDER BY` clause.
 *
 * -----
 *
 * With an `ORDER BY` clause that guarantees a unique ordering, you can pretend the above `cursor` code is,
 * ```ts
 * declare const cursor : MyRowT[];
 * for (const row of cursor) {
 *      console.log(row);
 *      //snip operations on `row`
 * }
 * ```
 *
 * Modifying the `cursor` array may cause unexpected behaviour during iteration.
 *
 * There are ways to safely iterate and modify an array at the same time,
 * like iterating backwards while adding elements to the end of the array.
 *
 * -----
 *
 * ### Preventing Infinite Loops
 *
 * ```ts
 *  const cursor = myQuery.emulatedCursor();
 *  for await (const row of cursor) {
 *      console.log(row);
 *      const nextRowId = row.rowId+1;
 *      //INSERT INTO myTable (rowId) VALUES(:nextRowId)
 *  }
 * ```
 *
 * Given the above, it is possible for the loop to never terminate.
 * Or, rather, it will terminate after it uses all the disk space it has access to.
 *
 * -----
 *
 * The above code is similar to the following,
 * ```ts
 *  arr = [1];
 *  for (const i of arr) {
 *      console.log(i);
 *      arr.push(i+1);
 *  }
 * ```
 *
 * This will result in an infinite loop (or crash when out of memory).
 */
function emulatedCursor(query, connection, 
/**
 * If set, determines the starting `page` of the cursor.
 * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
 */
rawArgs = {}) {
    return new emulated_cursor_impl_1.EmulatedCursorImpl(query, connection, rawArgs);
}
exports.emulatedCursor = emulatedCursor;
//# sourceMappingURL=emulated-cursor.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./emulated-cursor-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor-impl.js"));
__export(__webpack_require__(/*! ./emulated-cursor */ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/emulated-cursor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/exists.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/exists.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function exists(query, connection) {
    return impl_1.existsImpl(query, connection)
        .then(({ exists }) => exists);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-mapped.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-mapped.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchAllMapped(query, 
/**
 * We need a full `IConnection` to pass to the `MapDelegate`.
 * However, ideally, it would only need to use transaction and `SELECT` statements...
 */
connection) {
    return impl_1.fetchAllMappedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllMapped = fetchAllMapped;
//# sourceMappingURL=fetch-all-mapped.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped-flattened.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped-flattened.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchAllUnmappedFlattened(query, connection) {
    return impl_1.fetchAllUnmappedFlattenedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllUnmappedFlattened = fetchAllUnmappedFlattened;
//# sourceMappingURL=fetch-all-unmapped-flattened.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchAllUnmapped(query, connection) {
    return impl_1.fetchAllUnmappedImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAllUnmapped = fetchAllUnmapped;
//# sourceMappingURL=fetch-all-unmapped.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-all.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
/**
 * Combines `fetchAllUnmappedFlattened()` and `fetchAllMapped()` for convenience.
 */
function fetchAll(query, connection) {
    return impl_1.fetchAllImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchAll = fetchAll;
//# sourceMappingURL=fetch-all.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or-undefined.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or-undefined.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchOneOrUndefined(query, connection) {
    return impl_1.fetchOneOrImpl(query, connection, undefined)
        .then(({ row }) => row);
}
exports.fetchOneOrUndefined = fetchOneOrUndefined;
//# sourceMappingURL=fetch-one-or-undefined.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchOneOr(query, connection, defaultValue) {
    return impl_1.fetchOneOrImpl(query, connection, defaultValue)
        .then(({ row }) => row);
}
exports.fetchOneOr = fetchOneOr;
//# sourceMappingURL=fetch-one-or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-one.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
function fetchOne(query, connection) {
    try {
        const p = impl_1.fetchOneImpl(query, connection);
        const result = p.then(({ row }) => row);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ row }) => row);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-array.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-array.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchValueArray(query, connection) {
    return impl_1.fetchValueArrayImpl(query, connection)
        .then(({ resultSet }) => resultSet);
}
exports.fetchValueArray = fetchValueArray;
//# sourceMappingURL=fetch-value-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or-undefined.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or-undefined.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchValueOrUndefined(query, connection) {
    return impl_1.fetchValueOrImpl(query, connection, undefined)
        .then(({ value }) => value);
}
exports.fetchValueOrUndefined = fetchValueOrUndefined;
//# sourceMappingURL=fetch-value-or-undefined.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
async function fetchValueOr(query, connection, defaultValue) {
    return impl_1.fetchValueOrImpl(query, connection, defaultValue)
        .then(({ value }) => value);
}
exports.fetchValueOr = fetchValueOr;
//# sourceMappingURL=fetch-value-or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/fetch-value.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
function fetchValue(query, connection) {
    try {
        const p = impl_1.fetchValueImpl(query, connection);
        const result = p.then(({ value }) => value);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p.or(defaultValue).then(({ value }) => value);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result
                .or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValue = fetchValue;
//# sourceMappingURL=fetch-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one-or.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one-or.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
/**
 * @todo Better naming
 */
function ensureOneOr(query, fetched, defaultValue) {
    const resultSet = fetched.resultSet;
    if (resultSet.length == 0) {
        return defaultValue;
    }
    else if (resultSet.length == 1) {
        return resultSet[0];
    }
    else {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected zero or one row, found more than that`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected zero or one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                sql: fetched.sql,
            });
        }
    }
}
exports.ensureOneOr = ensureOneOr;
//# sourceMappingURL=ensure-one-or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __webpack_require__(/*! ../../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
/**
 * @todo Better naming
 */
function ensureOne(query, fetched) {
    const resultSet = fetched.resultSet;
    if (resultSet.length == 0) {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.RowNotFoundError({
                message: `Expected one row, found zero`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.RowNotFoundError({
                message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found zero`,
                sql: fetched.sql,
            });
        }
    }
    else if (resultSet.length == 1) {
        return resultSet[0];
    }
    else {
        if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected one row, found more than that`,
                sql: fetched.sql,
            });
        }
        else {
            throw new error_1.TooManyRowsFoundError({
                message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                sql: fetched.sql,
            });
        }
    }
}
exports.ensureOne = ensureOne;
//# sourceMappingURL=ensure-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/exists-impl.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/exists-impl.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
const ExprLib = __webpack_require__(/*! ../../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const fetch_value_impl_1 = __webpack_require__(/*! ./fetch-value-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-impl.js");
async function existsImpl(query, connection) {
    const fetched = await fetch_value_impl_1.fetchValueImpl(unified_query_1.QueryUtil.newInstance()
        .selectValue(() => ExprLib.exists(query)), connection);
    return {
        sql: fetched.sql,
        exists: fetched.value,
    };
}
exports.existsImpl = existsImpl;
//# sourceMappingURL=exists-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-impl.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-impl.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_all_unmapped_flattened_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-flattened-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js");
const fetch_all_mapped_impl_1 = __webpack_require__(/*! ./fetch-all-mapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-mapped-impl.js");
function fetchAllImpl(query, connection) {
    if (query.mapDelegate == undefined) {
        return fetch_all_unmapped_flattened_impl_1.fetchAllUnmappedFlattenedImpl(query, connection);
    }
    else {
        return fetch_all_mapped_impl_1.fetchAllMappedImpl(query, connection);
    }
}
exports.fetchAllImpl = fetchAllImpl;
//# sourceMappingURL=fetch-all-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-mapped-impl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-mapped-impl.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchAllMappedImpl(query, 
/**
 * We need a full `IConnection` to pass to the `MapDelegate`.
 * However, ideally, it would only need to use transaction and `SELECT` statements...
 */
connection) {
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const unmappedResultSet = unmapped.resultSet;
    if (unmappedResultSet.length == 0) {
        return unmapped;
    }
    const mappedResultSet = [];
    for (const unmappedRow of unmappedResultSet) {
        mappedResultSet.push(await query.mapDelegate(unmappedRow, connection, unmappedRow));
    }
    return {
        sql: unmapped.sql,
        resultSet: mappedResultSet,
    };
}
exports.fetchAllMappedImpl = fetchAllMappedImpl;
//# sourceMappingURL=fetch-all-mapped-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../../predicate */ "./node_modules/@squill/squill/dist/execution/util/predicate/index.js");
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchAllUnmappedFlattenedImpl(query, connection) {
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const unmappedResultSet = unmapped.resultSet;
    if (unmappedResultSet.length == 0 || !predicate_1.canFlattenUnmappedRow(query)) {
        return unmapped;
    }
    return {
        sql: unmapped.sql,
        resultSet: unmappedResultSet.map(unmappedRow => {
            const flattened = {};
            for (const tableAlias of Object.keys(unmappedRow)) {
                const table = unmappedRow[tableAlias];
                if (table == undefined) {
                    continue;
                }
                for (const columnAlias of Object.keys(table)) {
                    flattened[columnAlias] = table[columnAlias];
                }
            }
            return flattened;
        }),
    };
}
exports.fetchAllUnmappedFlattenedImpl = fetchAllUnmappedFlattenedImpl;
//# sourceMappingURL=fetch-all-unmapped-flattened-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const constants_1 = __webpack_require__(/*! ../../../../constants */ "./node_modules/@squill/squill/dist/constants.js");
async function fetchAllUnmappedImpl(query, connection) {
    const rawResult = await connection.select(query);
    const hasNullableJoins = (query.fromClause.currentJoins == undefined) ?
        false :
        query.fromClause.currentJoins.some(j => j.nullable);
    const ref = column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause);
    const rows = [];
    for (const rawRow of rawResult.rows) {
        const row = {};
        for (const k of Object.keys(rawRow)) {
            const separatorIndex = k.indexOf(constants_1.SEPARATOR);
            const tableAlias = k.substr(0, separatorIndex);
            const columnAlias = k.substr(separatorIndex + constants_1.SEPARATOR.length);
            try {
                const value = ref[tableAlias][columnAlias].mapper(`${tableAlias}.${columnAlias}`, rawRow[k]);
                let table = row[tableAlias];
                if (table == undefined) {
                    table = {};
                    row[tableAlias] = table;
                }
                table[columnAlias] = value;
            }
            catch (err) {
                Object.defineProperty(err, "sql", {
                    value: rawResult.query.sql,
                    enumerable: false,
                    writable: true,
                });
                throw err;
            }
        }
        if (hasNullableJoins) {
            for (const tableAlias of Object.keys(row)) {
                if (query.fromClause.currentJoins != undefined &&
                    query.fromClause.currentJoins.findIndex(j => j.tableAlias == tableAlias) < 0) {
                    //Probably `$aliased`
                    continue;
                }
                if (query.fromClause.currentJoins != undefined) {
                    const join = query.fromClause.currentJoins.find(j => j.tableAlias == tableAlias);
                    if (join != undefined && !join.nullable) {
                        //This is not a nullable join, do not make it `undefined`,
                        //no matter what.
                        continue;
                    }
                }
                const map = row[tableAlias];
                if (map == undefined) {
                    continue;
                }
                const allNull = Object.keys(map)
                    .every(columnAlias => map[columnAlias] === null);
                if (allNull) {
                    row[tableAlias] = undefined;
                }
            }
        }
        rows.push(row);
    }
    return {
        sql: rawResult.query.sql,
        resultSet: rows,
    };
}
exports.fetchAllUnmappedImpl = fetchAllUnmappedImpl;
//# sourceMappingURL=fetch-all-unmapped-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-impl.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-impl.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const try_set_limit_2_1 = __webpack_require__(/*! ./try-set-limit-2 */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/try-set-limit-2.js");
const fetch_all_impl_1 = __webpack_require__(/*! ./fetch-all-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-impl.js");
const ensure_one_1 = __webpack_require__(/*! ./ensure-one */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one.js");
const ensure_one_or_1 = __webpack_require__(/*! ./ensure-one-or */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one-or.js");
function fetchOneImpl(query, connection) {
    try {
        const limitedQuery = try_set_limit_2_1.trySetLimit2(query);
        const p = fetch_all_impl_1.fetchAllImpl(limitedQuery, connection);
        const result = p
            .then((fetched) => {
            return {
                sql: fetched.sql,
                row: ensure_one_1.ensureOne(limitedQuery, fetched),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    row: ensure_one_or_1.ensureOneOr(limitedQuery, fetched, defaultValue),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOneImpl = fetchOneImpl;
//# sourceMappingURL=fetch-one-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-or-impl.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-or-impl.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_one_impl_1 = __webpack_require__(/*! ./fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-impl.js");
async function fetchOneOrImpl(query, connection, defaultValue) {
    return fetch_one_impl_1.fetchOneImpl(query, connection)
        .or(defaultValue);
}
exports.fetchOneOrImpl = fetchOneOrImpl;
//# sourceMappingURL=fetch-one-or-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-array-impl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-array-impl.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_base_1 = __webpack_require__(/*! ../../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const fetch_all_unmapped_impl_1 = __webpack_require__(/*! ./fetch-all-unmapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js");
async function fetchValueArrayImpl(query, connection) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Expected query with one select item`);
    }
    const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
    const resultSet = unmapped.resultSet;
    if (resultSet.length == 0) {
        return {
            sql: unmapped.sql,
            resultSet: [],
        };
    }
    /**
     * This should always be a `string` if
     * `isOneSelectItem()` and `fetchAllUnmappedImpl()` are working
     * correctly.
     */
    const tableAlias = Object.keys(resultSet[0])[0];
    const columnAlias = Object.keys(resultSet[0][tableAlias])[0];
    return {
        sql: unmapped.sql,
        resultSet: resultSet.map((row) => row[tableAlias][columnAlias]),
    };
}
exports.fetchValueArrayImpl = fetchValueArrayImpl;
//# sourceMappingURL=fetch-value-array-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-impl.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-impl.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const try_set_limit_2_1 = __webpack_require__(/*! ./try-set-limit-2 */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/try-set-limit-2.js");
const fetch_value_array_impl_1 = __webpack_require__(/*! ./fetch-value-array-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-array-impl.js");
const ensure_one_1 = __webpack_require__(/*! ./ensure-one */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one.js");
const ensure_one_or_1 = __webpack_require__(/*! ./ensure-one-or */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one-or.js");
function fetchValueImpl(query, connection) {
    try {
        const limitedQuery = try_set_limit_2_1.trySetLimit2(query);
        const p = fetch_value_array_impl_1.fetchValueArrayImpl(limitedQuery, connection);
        const result = p
            .then((fetched) => {
            return {
                sql: fetched.sql,
                value: ensure_one_1.ensureOne(limitedQuery, fetched),
            };
        });
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = (defaultValue) => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    value: ensure_one_or_1.ensureOneOr(limitedQuery, fetched, defaultValue),
                };
            });
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            return result.or(undefined);
        };
        return result;
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValueImpl = fetchValueImpl;
//# sourceMappingURL=fetch-value-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-or-impl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-or-impl.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fetch_value_impl_1 = __webpack_require__(/*! ./fetch-value-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-impl.js");
async function fetchValueOrImpl(query, connection, defaultValue) {
    return fetch_value_impl_1.fetchValueImpl(query, connection)
        .or(defaultValue);
}
exports.fetchValueOrImpl = fetchValueOrImpl;
//# sourceMappingURL=fetch-value-or-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ensure-one-or */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one-or.js"));
__export(__webpack_require__(/*! ./ensure-one */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/ensure-one.js"));
__export(__webpack_require__(/*! ./exists-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/exists-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-mapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-mapped-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-flattened-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-flattened-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-unmapped-impl.js"));
__export(__webpack_require__(/*! ./fetch-all-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-all-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-or-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-or-impl.js"));
__export(__webpack_require__(/*! ./fetch-one-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-one-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-array-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-array-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-or-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-or-impl.js"));
__export(__webpack_require__(/*! ./fetch-value-impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/fetch-value-impl.js"));
__export(__webpack_require__(/*! ./try-set-limit-2 */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/try-set-limit-2.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/impl/try-set-limit-2.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/impl/try-set-limit-2.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
/**
 * We use `LIMIT 2`,
 * because if we fetch more than one row,
 * we've messed up.
 *
 * But I don't want to fetch 1 million rows if we mess up.
 * This limits our failure.
 *
 * @todo Better naming
 */
function trySetLimit2(query) {
    const limitedQuery = (query.compoundQueryClause == undefined ?
        (query.limitClause == undefined ?
            {
                ...query,
                limitClause: limit_clause_1.LimitClauseUtil.limitNumber(undefined, 2),
            } :
            /**
             * The user already specified a custom limit.
             * We don't want to mess with it.
             *
             * @todo Decide if we **should** mess with it anyway?
             * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
             * But any higher?
             *
             * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
             */
            query) :
        (query.compoundQueryLimitClause == undefined ?
            {
                ...query,
                compoundQueryLimitClause: limit_clause_1.LimitClauseUtil.limitNumber(undefined, 2),
            } :
            /**
             * The user already specified a custom limit.
             * We don't want to mess with it.
             *
             * @todo Decide if we **should** mess with it anyway?
             * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
             * But any higher?
             *
             * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
             */
            query));
    return limitedQuery;
}
exports.trySetLimit2 = trySetLimit2;
//# sourceMappingURL=try-set-limit-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./emulated-cursor */ "./node_modules/@squill/squill/dist/execution/util/operation/emulated-cursor/index.js"));
__export(__webpack_require__(/*! ./impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js"));
__export(__webpack_require__(/*! ./paginate */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/index.js"));
__export(__webpack_require__(/*! ./assert-exists */ "./node_modules/@squill/squill/dist/execution/util/operation/assert-exists.js"));
__export(__webpack_require__(/*! ./count */ "./node_modules/@squill/squill/dist/execution/util/operation/count.js"));
__export(__webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/execution/util/operation/exists.js"));
__export(__webpack_require__(/*! ./fetch-all-mapped */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-mapped.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped-flattened */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped-flattened.js"));
__export(__webpack_require__(/*! ./fetch-all-unmapped */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all-unmapped.js"));
__export(__webpack_require__(/*! ./fetch-all */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-all.js"));
__export(__webpack_require__(/*! ./fetch-one-or-undefined */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or-undefined.js"));
__export(__webpack_require__(/*! ./fetch-one-or */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one-or.js"));
__export(__webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-one.js"));
__export(__webpack_require__(/*! ./fetch-value-array */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-array.js"));
__export(__webpack_require__(/*! ./fetch-value-or-undefined */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or-undefined.js"));
__export(__webpack_require__(/*! ./fetch-value-or */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value-or.js"));
__export(__webpack_require__(/*! ./fetch-value */ "./node_modules/@squill/squill/dist/execution/util/operation/fetch-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/apply-paginate-args.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/paginate/apply-paginate-args.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const paginate_args_1 = __webpack_require__(/*! ./paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate-args.js");
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
function applyPaginateArgs(query, args) {
    const paginateLimitClause = limit_clause_1.LimitClauseUtil.offsetBigInt(limit_clause_1.LimitClauseUtil.limitBigInt(undefined, args.rowsPerPage), paginate_args_1.getPaginationStart(args));
    if (query.compoundQueryClause == undefined) {
        return {
            ...query,
            limitClause: paginateLimitClause,
            compoundQueryLimitClause: undefined,
        };
    }
    else {
        return {
            ...query,
            compoundQueryLimitClause: paginateLimitClause,
        };
    }
}
exports.applyPaginateArgs = applyPaginateArgs;
//# sourceMappingURL=apply-paginate-args.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/paginate/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./apply-paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/apply-paginate-args.js"));
__export(__webpack_require__(/*! ./paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate-args.js"));
__export(__webpack_require__(/*! ./paginate */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate.js"));
__export(__webpack_require__(/*! ./remove-paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/remove-paginate-args.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate-args.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate-args.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
/**
 * We use `BIGINT SIGNED` because PostgreSQL and SQLite do not support
 * `BIGINT UNSIGNED`.
 */
const maybePage = tm.mysql.bigIntSigned().orUndefined();
const maybeRowsPerPage = tm.mysql.bigIntSigned().orUndefined();
const maybeRowOffset = tm.mysql.bigIntSigned().orUndefined();
function toPaginateArgs(rawArgs) {
    const page = maybePage.mapMappable("page", rawArgs.page);
    const rowsPerPage = maybeRowsPerPage.mapMappable("rowsPerPage", rawArgs.rowsPerPage);
    const rowOffset = maybeRowOffset.mapMappable("rowOffset", rawArgs.rowOffset);
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    const args = {
        page: (page == undefined || tm.BigIntUtil.lessThan(page, 0)) ?
            //Default
            BigInt(0) :
            page,
        rowsPerPage: (rowsPerPage == undefined || tm.BigIntUtil.lessThan(rowsPerPage, 1)) ?
            //Default
            BigInt(20) :
            rowsPerPage,
        rowOffset: (rowOffset == undefined || tm.BigIntUtil.lessThan(rowOffset, 0)) ?
            //Default
            BigInt(0) :
            rowOffset,
    };
    const paginationStart = getPaginationStart(args);
    if (tm.BigIntUtil.greaterThan(paginationStart, BigInt("9223372036854775807"))) {
        throw new Error(`Cannot have OFFSET greater than 9223372036854775807`);
    }
    return args;
}
exports.toPaginateArgs = toPaginateArgs;
/**
 * It is possible for this value to be greater than
 * `9223372036854775807n`.
 *
 * When this happens, you will get an error from the RDBMS
 */
function getPaginationStart(args) {
    return tm.BigIntUtil.add(tm.BigIntUtil.mul(args.page, args.rowsPerPage), args.rowOffset);
}
exports.getPaginationStart = getPaginationStart;
function calculatePagesFound(args, rowsFound) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    if (tm.BigIntUtil.lessThan(rowsFound, 0)) {
        /**
         * Should not have negative rows found
         */
        return BigInt(0);
    }
    if (tm.BigIntUtil.lessThanOrEqual(args.rowsPerPage, 0)) {
        /**
         * Avoid divide by zero errors
         */
        return BigInt(0);
    }
    return (tm.BigIntUtil.add(tm.BigIntUtil.div(rowsFound, args.rowsPerPage), (tm.BigIntUtil.equal(tm.BigIntUtil.mod(rowsFound, args.rowsPerPage), BigInt(0)) ?
        BigInt(0) :
        BigInt(1))));
}
exports.calculatePagesFound = calculatePagesFound;
//# sourceMappingURL=paginate-args.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const impl_1 = __webpack_require__(/*! ../impl */ "./node_modules/@squill/squill/dist/execution/util/operation/impl/index.js");
const paginate_args_1 = __webpack_require__(/*! ./paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/paginate-args.js");
const apply_paginate_args_1 = __webpack_require__(/*! ./apply-paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/apply-paginate-args.js");
const count_1 = __webpack_require__(/*! ../count */ "./node_modules/@squill/squill/dist/execution/util/operation/count.js");
const remove_paginate_args_1 = __webpack_require__(/*! ./remove-paginate-args */ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/remove-paginate-args.js");
async function paginate(query, connection, rawArgs) {
    const args = paginate_args_1.toPaginateArgs(rawArgs);
    const paginateQuery = apply_paginate_args_1.applyPaginateArgs(query, args);
    const fetched = await impl_1.fetchAllImpl(paginateQuery, connection);
    const rowsFound = await count_1.count(remove_paginate_args_1.removePaginateArgs(paginateQuery), connection);
    const pagesFound = paginate_args_1.calculatePagesFound(args, rowsFound);
    const info = {
        rowsFound,
        pagesFound,
        page: args.page,
        rowsPerPage: args.rowsPerPage,
        rowOffset: args.rowOffset,
    };
    return {
        info,
        /**
         * @todo Investigate assignability
         */
        rows: fetched.resultSet,
    };
}
exports.paginate = paginate;
//# sourceMappingURL=paginate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/operation/paginate/remove-paginate-args.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/operation/paginate/remove-paginate-args.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removePaginateArgs(query) {
    if (query.compoundQueryClause == undefined) {
        return {
            ...query,
            limitClause: undefined,
            compoundQueryLimitClause: undefined,
        };
    }
    else {
        return {
            ...query,
            compoundQueryLimitClause: undefined,
        };
    }
}
exports.removePaginateArgs = removePaginateArgs;
//# sourceMappingURL=remove-paginate-args.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/predicate/can-flatten-unmapped-row.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/predicate/can-flatten-unmapped-row.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
function canFlattenUnmappedRow(query) {
    if (select_clause_1.SelectClauseUtil.duplicateColumnAlias(query.selectClause).length > 0) {
        /**
         * Cannot flatten if we have duplicate `columnAlias`
         */
        return false;
    }
    if (query.fromClause.currentJoins == undefined) {
        /**
         * No `nullable` joins, we can flatten safely
         */
        return true;
    }
    const hasNullableJoins = query.fromClause.currentJoins.some(j => j.nullable);
    return !hasNullableJoins;
}
exports.canFlattenUnmappedRow = canFlattenUnmappedRow;
//# sourceMappingURL=can-flatten-unmapped-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/execution/util/predicate/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/execution/util/predicate/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./can-flatten-unmapped-row */ "./node_modules/@squill/squill/dist/execution/util/predicate/can-flatten-unmapped-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-column/expr-column-impl.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-column/expr-column-impl.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../column */ "./node_modules/@squill/squill/dist/column/index.js");
class ExprColumn {
    /**
     * You should never need to explicitly instantiate an `ExprColumn`.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.tableAlias = data.tableAlias;
        this.columnAlias = data.columnAlias;
        this.mapper = data.mapper;
        this.isAggregate = data.isAggregate;
        this.unaliasedAst = unaliasedAst;
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC
     * ```
     */
    asc() {
        return column_1.ColumnUtil.asc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn DESC
     * ```
     */
    desc() {
        return column_1.ColumnUtil.desc(this);
    }
    /**
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * ORDER BY
     *  myTable.myColumn ASC,
     *  myTable.myOtherColumn DESC
     * ```
     */
    sort(sortDirection) {
        return column_1.ColumnUtil.sort(this, sortDirection);
    }
}
exports.ExprColumn = ExprColumn;
//# sourceMappingURL=expr-column-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-column/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-column/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./expr-column-impl */ "./node_modules/@squill/squill/dist/expr-column/expr-column-impl.js"));
const ExprColumnUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/expr-column/util/index.js");
exports.ExprColumnUtil = ExprColumnUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-column/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-column/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/expr-column/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-column/util/predicate/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-column/util/predicate/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr-column */ "./node_modules/@squill/squill/dist/expr-column/util/predicate/is-expr-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-column/util/predicate/is-expr-column.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-column/util/predicate/is-expr-column.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function isExprColumn(raw) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(raw, [
        "tableAlias",
        "columnAlias",
        "mapper",
        "isAggregate",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof raw.tableAlias == "string") &&
        (typeof raw.columnAlias == "string") &&
        (typeof raw.mapper == "function") &&
        (typeof raw.isAggregate == "boolean") &&
        (raw.unaliasedAst == undefined ||
            ast_1.AstUtil.isAst(raw.unaliasedAst)));
}
exports.isExprColumn = isExprColumn;
//# sourceMappingURL=is-expr-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-aggregate-operator-0 */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-1 */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-2 */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js"));
__export(__webpack_require__(/*! ./make-aggregate-operator-3 */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-0.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function makeAggregateOperator0(operatorType, mapper, typeHint) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: true,
        }, ast_1.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
    };
    return result;
}
exports.makeAggregateOperator0 = makeAggregateOperator0;
//# sourceMappingURL=make-aggregate-operator-0.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-1.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeAggregateOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator1 = makeAggregateOperator1;
//# sourceMappingURL=make-aggregate-operator-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-2.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeAggregateOperator2(operatorType, mapper, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator2 = makeAggregateOperator2;
//# sourceMappingURL=make-aggregate-operator-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate-factory/make-aggregate-operator-3.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeAggregateOperator3(operatorType, mapper, typeHint) {
    const result = (left, mid, right) => {
        return expr_1.ExprUtil.aggregateIntersect(mapper, [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeAggregateOperator3 = makeAggregateOperator3;
//# sourceMappingURL=make-aggregate-operator-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate/count-all.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate/count-all.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const aggregate_factory_1 = __webpack_require__(/*! ../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns a count of the number of rows
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(*)`
 * + PostgreSQL : `COUNT(*)`
 * + SQLite     : `COUNT(*)`
 *
 * @todo Rename to `count`? or `countRow`?
 * @todo Or add a function `count()` with overloads for `countExpr` and `countAll`?
 */
exports.countAll = aggregate_factory_1.makeAggregateOperator0(operator_type_1.OperatorType.AGGREGATE_COUNT_ALL, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned());
//# sourceMappingURL=count-all.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate/count-expr.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate/count-expr.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const aggregate_factory_1 = __webpack_require__(/*! ../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const countExprImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_COUNT_EXPR, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned());
/**
 * Returns a count of the number of rows with different non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(DISTINCT x)`
 * + PostgreSQL : `COUNT(DISTINCT x)`
 * + SQLite     : `COUNT(DISTINCT x)`
 */
exports.countExprDistinct = (arg) => {
    return countExprImpl(true, arg);
};
/**
 * Returns a count of the number of rows with non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(x)`
 * + PostgreSQL : `COUNT(x)`
 * + SQLite     : `COUNT(x)`
 */
exports.countExprAll = (arg) => {
    return countExprImpl(false, arg);
};
/**
 * Returns a count of the number of rows with non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#count
 *
 * -----
 *
 * + MySQL      : `COUNT(x)`
 * + PostgreSQL : `COUNT(x)`
 * + SQLite     : `COUNT(x)`
 */
exports.countExpr = exports.countExprAll;
//# sourceMappingURL=count-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/aggregate/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/aggregate/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./count-all */ "./node_modules/@squill/squill/dist/expr-library/aggregate/count-all.js"));
__export(__webpack_require__(/*! ./count-expr */ "./node_modules/@squill/squill/dist/expr-library/aggregate/count-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/assert/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/assert/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./throw-if-null */ "./node_modules/@squill/squill/dist/expr-library/assert/throw-if-null.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/assert/throw-if-null.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/assert/throw-if-null.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
function throwIfNull(arg) {
    return expr_1.ExprUtil.intersect(tm.notNull(built_in_expr_1.BuiltInExprUtil.mapper(arg)), [arg], ast_1.OperatorNodeUtil.operatorNode1(operator_type_1.OperatorType.THROW_IF_NULL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg)
    ], undefined));
}
exports.throwIfNull = throwIfNull;
//# sourceMappingURL=throw-if-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/bigint-signed-literal.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/bigint-signed-literal.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr/expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
/**
 * Converts `string|number|bigint|Decimal` to a `BIGINT SIGNED`
 */
function bigIntSignedLiteral(rawBigIntSignedLiteral) {
    const mapper = tm.mysql.bigIntSigned();
    const value = mapper("rawBigIntSignedLiteral", String(rawBigIntSignedLiteral));
    return expr_impl_1.expr({
        mapper,
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        isAggregate: false,
    }, literal_value_node_1.LiteralValueNodeUtil.bigIntSignedLiteralNode(value));
}
exports.bigIntSignedLiteral = bigIntSignedLiteral;
//# sourceMappingURL=bigint-signed-literal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/decimal-literal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/decimal-literal.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr/expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
/**
 *
 * @param rawDecimalLiteral
 *
 * @param precision
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 *
 * @param scale
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
function decimalLiteral(rawDecimalLiteral, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    return expr_impl_1.expr({
        mapper: tm.mysql.decimal(precision, scale),
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        isAggregate: false,
    }, literal_value_node_1.LiteralValueNodeUtil.decimalLiteralNode(rawDecimalLiteral, precision, scale));
}
exports.decimalLiteral = decimalLiteral;
//# sourceMappingURL=decimal-literal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint-signed-literal */ "./node_modules/@squill/squill/dist/expr-library/cast/bigint-signed-literal.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-decimal */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-decimal.js"));
//export * from "./cast-as-n-char";
__export(__webpack_require__(/*! ./decimal-literal */ "./node_modules/@squill/squill/dist/expr-library/cast/decimal-literal.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-bigint-signed */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-binary */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-binary.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-double */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-double.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-json */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-json.js"));
__export(__webpack_require__(/*! ./unsafe-cast-as-var-char */ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-var-char.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-bigint-signed.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Attempts to cast to `BIGINT SIGNED`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS SIGNED INTEGER)`
 *   + Actually gives a signed `bigint`
 *   + Trying to cast `'123e2'` gives `123`
 * + PostgreSQL     : `CAST(x AS bigint)`
 *   + Trying to cast `'123e2'` throws an error
 * + SQLite         : `CAST(x AS BIGINT)`
 *   + Trying to cast `'123e2'` gives `123`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 * + https://github.com/AnyhowStep/tsql/issues/244
 * + https://github.com/AnyhowStep/tsql/issues/245
 */
exports.unsafeCastAsBigIntSigned = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull());
//# sourceMappingURL=unsafe-cast-as-bigint-signed.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-binary.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-binary.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "./node_modules/type-mapping/fluent.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Attempts to cast to `BINARY/bytea/BLOB`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS BINARY)`
 *   + `CAST(1234567890 AS BINARY)` returns `[49,50,51,52,53,54,55,56,57,48]`
 *     + Converts to ASCII string first, then to BINARY
 * + PostgreSQL     : `CAST(x AS bytea)`
 *   + `CAST(1234567890 AS bytea)` throws
 * + SQLite         : `CAST(x AS BLOB)`
 *   + `CAST(1234567890 AS BLOB)` returns `[49,50,51,52,53,54,55,56,57,48]`
 *     + Converts to ASCII string first, then to BLOB
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsBinary = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_BINARY, tm.instanceOfUint8Array().orNull());
//# sourceMappingURL=unsafe-cast-as-binary.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-decimal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-decimal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "./node_modules/type-mapping/fluent.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * @todo Move this elsewhere?
 */
function assertValidDecimalPrecisionAndScale(
/**
 * + PostgreSQL's min precision is `1`
 * + MySQL's max precision is `65`
 */
precision, 
/**
 * + The min scale is `0`.
 * + MySQL's max scale is `30`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    const precisionMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(1)), tm.bigIntLtEq(BigInt(65)));
    precision = precisionMapper("precision", precision);
    const scaleMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(0)), tm.bigIntLtEq(BigInt(30)), tm.bigIntLtEq(precision));
    scale = scaleMapper("scale", scale);
    return {
        precision,
        scale,
    };
}
exports.assertValidDecimalPrecisionAndScale = assertValidDecimalPrecisionAndScale;
function unsafeCastAsDecimal(arg, 
/**
 * + MySQL's max precision is `65`
 * + PostgreSQL's min precision is `1`
 */
precision, 
/**
 * + MySQL's max scale is `30`.
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    const argMapper = built_in_expr_1.BuiltInExprUtil.mapper(arg);
    const decimalDefinition = assertValidDecimalPrecisionAndScale(precision, scale);
    return expr_1.expr({
        mapper: tm.canOutputNull(argMapper) ?
            tm.mysql.decimal(precision, scale).orNull() :
            tm.mysql.decimal(precision, scale),
        usedRef: built_in_expr_1.BuiltInExprUtil.usedRef(arg),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(arg),
    }, ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.CAST_AS_DECIMAL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        built_in_expr_1.BuiltInExprUtil.buildAst(decimalDefinition.precision),
        built_in_expr_1.BuiltInExprUtil.buildAst(decimalDefinition.scale),
    ], undefined));
}
exports.unsafeCastAsDecimal = unsafeCastAsDecimal;
//# sourceMappingURL=unsafe-cast-as-decimal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-double.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-double.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Attempts to cast to `DOUBLE`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL 5.7      : `x + 0e0`
 *   + `('qwerty' + 0e0)` returns `0e0`
 *   + `(TRUE + 0e0)` returns `1e0`
 *   + `(9223372036854775807 + 0e0)` returns `9223372036854776000e0`
 * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
 *   + `CAST('qwerty' AS DOUBLE PRECISION)` throws
 *   + `CAST(TRUE AS DOUBLE PRECISION)` throws
 *   + `CAST(9223372036854775807 AS DOUBLE PRECISION)` returns `9223372036854780000e0`
 * + SQLite         : `CAST(x AS DOUBLE)`
 *   + `CAST('qwerty' AS DOUBLE)` returns `0e0`
 *   + `CAST(TRUE AS DOUBLE)` returns `1e0`
 *   + `CAST(9223372036854775807 AS DOUBLE)` returns `9223372036854776000e0`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsDouble = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_DOUBLE, tm.orNull(tm.toUnsafeNumber()));
//# sourceMappingURL=unsafe-cast-as-double.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-json.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-json.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Attempts to cast to `JSON`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS JSON)`
 *   + `CAST(1 AS JSON)` returns `'1'`
 *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x": "y"}'`
 * + PostgreSQL     : `CAST(x AS JSON)`
 *   + `CAST(1 AS JSON)` throws
 *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x":"y"}'`
 * + SQLite         : `CAST(x AS TEXT)`
 *   + Or implement with user-defined function.
 *   + Or the `JSON()` function?
 *   + https://www.sqlite.org/json1.html#jmini
 *   + SQLite does not have a `JSON` data type; `TEXT` is used for `JSON` values.
 *   + `JSON(1)` returns `'1'`
 *   + `CAST(1 AS TEXT)` returns `'1'`
 *   + `JSON('{  "x"  :  "y"  }')` returns `'{"x":"y"}'`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsJson = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_JSON, tm.orNull(tm.string()));
//# sourceMappingURL=unsafe-cast-as-json.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-var-char.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/cast/unsafe-cast-as-var-char.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Attempts to cast to `VARCHAR`.
 *
 * **Behaviour is not unified.**
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
 * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
 * + https://www.sqlite.org/datatype3.html
 *
 * -----
 *
 * + MySQL          : `CAST(x AS CHAR)`
 *   + `CAST(TRUE AS CHAR)` returns `'1'`
 *   + `CAST(123e0 AS CHAR)` returns `'123'`
 * + PostgreSQL     : `CAST(x AS VARCHAR)`
 *   + `CAST(TRUE AS VARCHAR)` returns `'true'`
 *   + `CAST(CAST(123e0 AS DOUBLE PRECISION) AS VARCHAR)` returns `'123'`
 * + SQLite         : `CAST(x AS VARCHAR)`
 *   + `CAST(TRUE AS VARCHAR)` returns `'1'`
 *   + `CAST(123e0 AS VARCHAR)` returns `'123.0'`
 *
 * -----
 *
 * + https://github.com/AnyhowStep/tsql/issues/15
 */
exports.unsafeCastAsVarChar = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CAST_AS_VARCHAR, tm.orNull(tm.string()));
//# sourceMappingURL=unsafe-cast-as-var-char.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/between.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/between.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
 *
 * This version of the `BETWEEN ... AND` operator prevents `NULL`.
 *
 * For null-safe checks, @see {@link nullSafeBetween}
 *
 */
exports.between = factory_1.makeComparison3(operator_type_1.OperatorType.BETWEEN_AND);
//# sourceMappingURL=between.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/greatest.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/greatest.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
 *
 * This version of the `GREATEST(x, y, ...)` operator prevents `NULL`.
 *
 * No null-safe version is provided in this unification
 * because the different databases treat `NULL` arguments differently.
 *
 * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
 * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
 *
 * -----
 *
 * This version of the `GREATEST(x, y, ...)` operator requires
 * at least 2 arguments because MySQL's requires at least 2.
 *
 * Also, it does not make much sense to get the `GREATEST` of 1 value.
 */
exports.greatest = factory_1.makeComparisonProjection2ToN(operator_type_1.OperatorType.GREATEST);
//# sourceMappingURL=greatest.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/gt-eq.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/gt-eq.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
 *
 * This version of the `>=` operator prevents `NULL`.
 *
 */
exports.gtEq = factory_1.makeComparison2(operator_type_1.OperatorType.GREATER_THAN_OR_EQUAL);
//# sourceMappingURL=gt-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/gt.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/gt.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
 *
 * This version of the `>` operator prevents `NULL`.
 *
 */
exports.gt = factory_1.makeComparison2(operator_type_1.OperatorType.GREATER_THAN);
//# sourceMappingURL=gt.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./between */ "./node_modules/@squill/squill/dist/expr-library/comparison/between.js"));
__export(__webpack_require__(/*! ./greatest */ "./node_modules/@squill/squill/dist/expr-library/comparison/greatest.js"));
__export(__webpack_require__(/*! ./gt-eq */ "./node_modules/@squill/squill/dist/expr-library/comparison/gt-eq.js"));
__export(__webpack_require__(/*! ./gt */ "./node_modules/@squill/squill/dist/expr-library/comparison/gt.js"));
__export(__webpack_require__(/*! ./least */ "./node_modules/@squill/squill/dist/expr-library/comparison/least.js"));
__export(__webpack_require__(/*! ./lt-eq */ "./node_modules/@squill/squill/dist/expr-library/comparison/lt-eq.js"));
__export(__webpack_require__(/*! ./lt */ "./node_modules/@squill/squill/dist/expr-library/comparison/lt.js"));
__export(__webpack_require__(/*! ./not-between */ "./node_modules/@squill/squill/dist/expr-library/comparison/not-between.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/least.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/least.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
 *
 * This version of the `LEAST(x, y, ...)` operator prevents `NULL`.
 *
 * No null-safe version is provided in this unification
 * because the different databases treat `NULL` arguments differently.
 *
 * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
 * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
 *
 * -----
 *
 * This version of the `LEAST(x, y, ...)` operator requires
 * at least 2 arguments because MySQL's requires at least 2.
 *
 * Also, it does not make much sense to get the `LEAST` of 1 value.
 */
exports.least = factory_1.makeComparisonProjection2ToN(operator_type_1.OperatorType.LEAST);
//# sourceMappingURL=least.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/lt-eq.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/lt-eq.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal
 *
 * This version of the `<=` operator prevents `NULL`.
 *
 */
exports.ltEq = factory_1.makeComparison2(operator_type_1.OperatorType.LESS_THAN_OR_EQUAL);
//# sourceMappingURL=lt-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/lt.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/lt.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
 *
 * This version of the `<` operator prevents `NULL`.
 *
 */
exports.lt = factory_1.makeComparison2(operator_type_1.OperatorType.LESS_THAN);
//# sourceMappingURL=lt.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/comparison/not-between.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/comparison/not-between.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
 *
 * This version of the `NOT BETWEEN ... AND` operator prevents `NULL`.
 *
 * For null-safe checks, @see {@link nullSafeNotBetween}
 *
 */
exports.notBetween = factory_1.makeComparison3(operator_type_1.OperatorType.NOT_BETWEEN_AND);
//# sourceMappingURL=not-between.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../../expr/expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
class CaseConditionBuilderImpl {
    constructor(resultMappers, usedRef, ast, isAggregate) {
        this.resultMappers = resultMappers;
        this.usedRef = usedRef;
        this.ast = ast;
        this.isAggregate = isAggregate;
    }
    when(condition, then) {
        return new CaseConditionBuilderImpl([...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(condition, then)), {
            type: "CaseCondition",
            /**
             * https://github.com/microsoft/TypeScript/issues/33573
             */
            branches: this.ast.branches.concat([
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(condition),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ]),
            else: this.ast.else,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(condition) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
    end() {
        return expr_impl_1.expr({
            mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
            usedRef: this.usedRef,
            isAggregate: this.isAggregate,
        }, this.ast);
    }
    else(elseResult) {
        const end = () => {
            return expr_impl_1.expr({
                mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(elseResult)),
                usedRef: used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.usedRef(elseResult)),
                isAggregate: (this.isAggregate ||
                    built_in_expr_1.BuiltInExprUtil.isAggregate(elseResult))
            }, {
                ...this.ast,
                else: built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
            });
        };
        return {
            end,
        };
    }
}
exports.CaseConditionBuilderImpl = CaseConditionBuilderImpl;
//# sourceMappingURL=case-condition-builder-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const uninitialized_case_condition_builder_impl_1 = __webpack_require__(/*! ./uninitialized-case-condition-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js");
function caseCondition() {
    return new uninitialized_case_condition_builder_impl_1.UninitializedCaseConditionBuilderImpl();
}
exports.caseCondition = caseCondition;
//# sourceMappingURL=case-condition.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js"));
__export(__webpack_require__(/*! ./case-condition */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition.js"));
__export(__webpack_require__(/*! ./uninitialized-case-condition-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const case_condition_builder_impl_1 = __webpack_require__(/*! ./case-condition-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/case-condition-builder-impl.js");
class UninitializedCaseConditionBuilderImpl {
    constructor() {
    }
    when(condition, then) {
        return new case_condition_builder_impl_1.CaseConditionBuilderImpl([built_in_expr_1.BuiltInExprUtil.mapper(then)], built_in_expr_1.BuiltInExprUtil.intersectUsedRef(condition, then), {
            type: "CaseCondition",
            branches: [
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(condition),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ],
            else: undefined,
        }, (built_in_expr_1.BuiltInExprUtil.isAggregate(condition) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
}
exports.UninitializedCaseConditionBuilderImpl = UninitializedCaseConditionBuilderImpl;
//# sourceMappingURL=uninitialized-case-condition-builder-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value-builder-impl.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value-builder-impl.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../../expr/expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
class CaseValueBuilderImpl {
    constructor(resultMappers, usedRef, ast, isAggregate) {
        this.resultMappers = resultMappers;
        this.usedRef = usedRef;
        this.ast = ast;
        this.isAggregate = isAggregate;
    }
    when(compareValue, then) {
        return new CaseValueBuilderImpl([...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
            type: "CaseValue",
            value: this.ast.value,
            /**
             * https://github.com/microsoft/TypeScript/issues/33573
             */
            cases: this.ast.cases.concat([
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(compareValue),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ]),
            else: this.ast.else,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(compareValue) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
    end() {
        return expr_impl_1.expr({
            mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
            usedRef: this.usedRef,
            isAggregate: this.isAggregate,
        }, this.ast);
    }
    else(elseResult) {
        const end = () => {
            return expr_impl_1.expr({
                mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_1.BuiltInExprUtil.mapper(elseResult)),
                usedRef: used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.usedRef(elseResult)),
                isAggregate: (this.isAggregate ||
                    built_in_expr_1.BuiltInExprUtil.isAggregate(elseResult))
            }, {
                ...this.ast,
                else: built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
            });
        };
        return {
            end,
        };
    }
}
exports.CaseValueBuilderImpl = CaseValueBuilderImpl;
//# sourceMappingURL=case-value-builder-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const uninitialized_case_value_builder_impl_1 = __webpack_require__(/*! ./uninitialized-case-value-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js");
function caseValue(valueExpr) {
    return new uninitialized_case_value_builder_impl_1.UninitializedCaseValueBuilderImpl(built_in_expr_1.BuiltInExprUtil.usedRef(valueExpr), built_in_expr_1.BuiltInExprUtil.buildAst(valueExpr), built_in_expr_1.BuiltInExprUtil.isAggregate(valueExpr));
}
exports.caseValue = caseValue;
//# sourceMappingURL=case-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-value-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value-builder-impl.js"));
__export(__webpack_require__(/*! ./case-value */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value.js"));
__export(__webpack_require__(/*! ./uninitialized-case-value-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/uninitialized-case-value-builder-impl.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const case_value_builder_impl_1 = __webpack_require__(/*! ./case-value-builder-impl */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/case-value-builder-impl.js");
class UninitializedCaseValueBuilderImpl {
    constructor(usedRef, valueAst, isAggregate) {
        this.usedRef = usedRef;
        this.valueAst = valueAst;
        this.isAggregate = isAggregate;
    }
    when(compareValue, then) {
        return new case_value_builder_impl_1.CaseValueBuilderImpl([built_in_expr_1.BuiltInExprUtil.mapper(then)], used_ref_1.UsedRefUtil.intersect(this.usedRef, built_in_expr_1.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
            type: "CaseValue",
            value: this.valueAst,
            cases: [
                [
                    built_in_expr_1.BuiltInExprUtil.buildAst(compareValue),
                    built_in_expr_1.BuiltInExprUtil.buildAst(then)
                ]
            ],
            else: undefined,
        }, (this.isAggregate ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(compareValue) ||
            built_in_expr_1.BuiltInExprUtil.isAggregate(then)));
    }
}
exports.UninitializedCaseValueBuilderImpl = UninitializedCaseValueBuilderImpl;
//# sourceMappingURL=uninitialized-case-value-builder-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/case.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/case.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const case_value_1 = __webpack_require__(/*! ./case-value */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/index.js");
const case_condition_1 = __webpack_require__(/*! ./case-condition */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/index.js");
function caseConstructor(valueExpr) {
    if (valueExpr === undefined) {
        return case_condition_1.caseCondition();
    }
    else {
        return case_value_1.caseValue(valueExpr);
    }
}
exports.case = caseConstructor;
//# sourceMappingURL=case.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/coalesce.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/coalesce.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const util_1 = __webpack_require__(/*! ../../ast/operator-node/util */ "./node_modules/@squill/squill/dist/ast/operator-node/util/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
function coalesceMapper(...args) {
    const builtInExprMapperArr = [];
    let lastMapperNonNull = false;
    for (const builtInExpr of args) {
        const builtInExprMapper = built_in_expr_1.BuiltInExprUtil.mapper(builtInExpr);
        builtInExprMapperArr.push(builtInExprMapper);
        if (!tm.canOutputNull(builtInExprMapper)) {
            lastMapperNonNull = true;
            break;
        }
    }
    return (lastMapperNonNull ?
        tm.notNull(tm.unsafeOr(...builtInExprMapperArr)) :
        tm.unsafeOr(...builtInExprMapperArr));
}
exports.coalesceMapper = coalesceMapper;
/**
 * Returns the first non-`NULL` value in the list,
 * or `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
 * + https://www.postgresql.org/docs/9.5/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
 * + https://www.sqlite.org/lang_corefunc.html#coalesce
 *
 * -----
 *
 * + MySQL        : `COALESCE(x, ...)`
 * + PostgreSQL   : `COALESCE(x, ...)`
 * + SQLite       : `COALESCE(x, ...)`
 *
 * -----
 *
 * `COALESCE()` with zero args is just the `NULL` constant.
 */
function coalesce(...args) {
    const [arg0, arg1, ...argRest] = args;
    if (arg0 === undefined) {
        /**
         * `COALESCE()` with zero args is just the `NULL` constant.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(null);
    }
    else if (arg1 === undefined) {
        /**
         * `COALESCE(x)` is just `x`
         */
        return expr_1.ExprUtil.fromBuiltInExpr(arg0);
    }
    else {
        return expr_1.ExprUtil.intersect(coalesceMapper(...args), args, util_1.operatorNode2ToN(operator_type_1.OperatorType.COALESCE, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...argRest.map(built_in_expr_1.BuiltInExprUtil.buildAst)
        ], undefined));
    }
}
exports.coalesce = coalesce;
//# sourceMappingURL=coalesce.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/if-is-null.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/if-is-null.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js");
const ifImpl = __webpack_require__(/*! ./if */ "./node_modules/@squill/squill/dist/expr-library/control-flow/if.js");
/**
 * A special compile-time type-narrowing function.
 *
 * Narrows a column from `T|null` to `T` in the else-branch.
 *
 * Translated to SQL, we get,
 * ```sql
 *  IF(
 *      myColumn IS NULL,
 *      thenExpr,
 *      -- The `elseExpr` is free to use `myColumn` as a non-nullable column
 *      -- because we know `myColumn` is NOT NULL in the else-branch.
 *      elseExpr
 *  )
 * ```
 *
 *
 * @param column - The column to narrow from `T|null` to `T`
 * @param then - The result of the expression, if the `column` is `null`
 * @param elseDelegate - The result of the expression, if the `column` is `T`
 */
function ifIsNull(column, then, elseDelegate) {
    return ifImpl.if(null_safe_equation_1.isNull(column), then, elseDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.ifIsNull = ifIsNull;
//# sourceMappingURL=if-is-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/if-null.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/if-null.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//import * as tm from "type-mapping";
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/expr-library/control-flow/coalesce.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Equivalent to `COALESCE()` with two arguments.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
 * + https://www.sqlite.org/lang_corefunc.html#ifnull
 *
 * -----
 *
 * `COALESCE()` is part of the SQL standard.
 * `IFNULL()` is DB-specific.
 *
 * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
 *
 * -----
 *
 * + MySQL        : `IFNULL(x, y)`
 * + PostgreSQL   : `COALESCE(x, y)`
 * + SQLite       : `IFNULL(x, y)`
 *
 * -----
 *
 * @see coalesce
 */
function ifNull(arg0, arg1) {
    return expr_1.ExprUtil.intersect(coalesce_1.coalesceMapper(arg0, arg1), [arg0, arg1], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.IF_NULL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
        built_in_expr_1.BuiltInExprUtil.buildAst(arg1)
    ], undefined));
}
exports.ifNull = ifNull;
//# sourceMappingURL=if-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/if.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/if.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
/**
 * Behaves like an `if-else` statement from most programming languages.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
 *
 * -----
 *
 * + MySQL        : `IF(x, y, z)`
 * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
 * + SQLite       : `CASE WHEN x THEN y ELSE z END`
 *
 * -----
 *
 * @param condition - The boolean expression to evaluate
 * @param then - The result if `condition` is `true`
 * @param elseResult - The result if `condition` is `false`
 *
 * @see caseCondition
 */
function ifConstructor(condition, then, elseResult) {
    return expr_1.ExprUtil.intersect(tm.or(built_in_expr_1.BuiltInExprUtil.mapper(then), built_in_expr_1.BuiltInExprUtil.mapper(elseResult)), [condition, then, elseResult], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.IF, [
        built_in_expr_1.BuiltInExprUtil.buildAst(condition),
        built_in_expr_1.BuiltInExprUtil.buildAst(then),
        built_in_expr_1.BuiltInExprUtil.buildAst(elseResult),
    ], undefined));
}
exports.if = ifConstructor;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-condition */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-condition/index.js"));
__export(__webpack_require__(/*! ./case-value */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case-value/index.js"));
__export(__webpack_require__(/*! ./case */ "./node_modules/@squill/squill/dist/expr-library/control-flow/case.js"));
__export(__webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/expr-library/control-flow/coalesce.js"));
__export(__webpack_require__(/*! ./if-is-null */ "./node_modules/@squill/squill/dist/expr-library/control-flow/if-is-null.js"));
__export(__webpack_require__(/*! ./if-null */ "./node_modules/@squill/squill/dist/expr-library/control-flow/if-null.js"));
__export(__webpack_require__(/*! ./if */ "./node_modules/@squill/squill/dist/expr-library/control-flow/if.js"));
__export(__webpack_require__(/*! ./null-if */ "./node_modules/@squill/squill/dist/expr-library/control-flow/null-if.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/control-flow/null-if.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/control-flow/null-if.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Returns `null` if both arguments are null-safe equal.
 *
 * Otherwise, returns the first argument.
 *
 * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
 * + https://www.sqlite.org/lang_corefunc.html#nullif
 *
 * -----
 *
 * + MySQL        : `NULLIF(x, y)`
 * + PostgreSQL   : `NULLIF(x, y)`
 * + SQLite       : `NULLIF(x, y)`
 *
 * @see nullIfEqual
 */
function nullIf(arg0, arg1) {
    return expr_1.ExprUtil.intersect(tm.orNull(built_in_expr_1.BuiltInExprUtil.mapper(arg0)), [arg0, arg1], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.NULL_IF_EQUAL, [
        built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
        built_in_expr_1.BuiltInExprUtil.buildAst(arg1)
    ], undefined));
}
exports.nullIf = nullIf;
/**
 * Synonym for `NULLIF(x, y)`.
 *
 * Returns `null` if both arguments are null-safe equal.
 *
 * Otherwise, returns the first argument.
 *
 * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
 * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
 * + https://www.sqlite.org/lang_corefunc.html#nullif
 *
 * -----
 *
 * + MySQL        : `NULLIF(x, y)`
 * + PostgreSQL   : `NULLIF(x, y)`
 * + SQLite       : `NULLIF(x, y)`
 *
 * @see nullIf
 */
exports.nullIfEqual = nullIf;
//# sourceMappingURL=null-if.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/custom-factory/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/custom-factory/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-custom-operator-0 */ "./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-0.js"));
__export(__webpack_require__(/*! ./make-custom-operator-1 */ "./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-1.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-0.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-0.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function makeCustomOperator0(ast, mapper) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast);
    };
    return result;
}
exports.makeCustomOperator0 = makeCustomOperator0;
//# sourceMappingURL=make-custom-operator-0.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-1.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/custom-factory/make-custom-operator-1.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
function makeCustomOperator1(astDelegate, mapper) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], astDelegate(arg));
    };
    return result;
}
exports.makeCustomOperator1 = makeCustomOperator1;
//# sourceMappingURL=make-custom-operator-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/current-date.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/current-date.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the current date.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_DATE()`
 * + PostgreSQL     : `CURRENT_DATE()`
 * + SQLite         : `strftime('%Y-%m-%d', 'now')`
 *
 * -----
 *
 * Sets hour, minute, second, millisecond to zero.
 */
exports.currentDate = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_DATE, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=current-date.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/current-timestamp.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/current-timestamp.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the current date-time, accurate to 1-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(0)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
 */
exports.currentTimestamp0 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_0, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.1-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(1)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
 */
exports.currentTimestamp1 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_1, tm.mysql.dateTime(1), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.01-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(2)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
 */
exports.currentTimestamp2 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_2, tm.mysql.dateTime(2), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the current date-time, accurate to 0.001-second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `CURRENT_TIMESTAMP(3)`
 * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
 *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
 *
 *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
 *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
 */
exports.currentTimestamp3 = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_TIMESTAMP_3, tm.mysql.dateTime(3), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=current-timestamp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/extract.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/extract.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Extracts the second from a date-time, including fractional seconds; accurate to 0.001 second.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * Behaviour is not defined when using 0.0001 second precision (or more precise).
 * SQLite may alternate between truncating and rounding.
 *
 * -----
 *
 * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000e0) / 1000e0`
 * ```sql
 *  SELECT
 *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
 *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
 *  > 32.456
 * ```
 * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
 * + SQLite         : `CAST(strftime('%f', datetime) AS DOUBLE)`
 * ```sql
 *  SELECT
 *      strftime('%f', '2010-03-27 14:45:32.456789')
 *  > 32.457
 *  -- The result is rounded, not truncated.
 *  -- If it were truncated, we would get 32.456
 * ```
 * ```sql
 *  SELECT
 *      strftime('%f', '2010-03-27 23:59:59.999999')
 *  > 59.999
 *  -- The result is truncated, not rounded.
 *  -- If it were rounded, we would get 60
 * ```
 *
 * @todo Make behaviour consistent?
 */
exports.extractFractionalSecond3 = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_FRACTIONAL_SECOND_3, tm.mysql.double(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the second from a date-time, truncating fractional seconds.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(SECOND FROM datetime)`
 * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
 */
exports.extractIntegerSecond = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_INTEGER_SECOND, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the minute from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
 */
exports.extractMinute = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_MINUTE, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the hour from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(HOUR FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
 */
exports.extractHour = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_HOUR, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the day (of the month) from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(DAY FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
 */
exports.extractDay = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_DAY, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the month from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(MONTH FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
 */
exports.extractMonth = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_MONTH, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Extracts the year from a date-time.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * MySQL returns a `bigint signed`.
 * PostgreSQL returns a `double precision`.
 * SQLite returns a `text`.
 *
 * This library casts all results to `BIGINT SIGNED`
 *
 * -----
 *
 * + MySQL          : `EXTRACT(YEAR FROM datetime)`
 * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
 * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
 */
exports.extractYear = factory_1.makeOperator1(operator_type_1.OperatorType.EXTRACT_YEAR, 
/**
 * Should not be negative
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=extract.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./current-date */ "./node_modules/@squill/squill/dist/expr-library/date-time/current-date.js"));
//export * from "./current-time";
__export(__webpack_require__(/*! ./current-timestamp */ "./node_modules/@squill/squill/dist/expr-library/date-time/current-timestamp.js"));
__export(__webpack_require__(/*! ./extract */ "./node_modules/@squill/squill/dist/expr-library/date-time/extract.js"));
__export(__webpack_require__(/*! ./last-day */ "./node_modules/@squill/squill/dist/expr-library/date-time/last-day.js"));
//export * from "./local-string-to-timestamp";
__export(__webpack_require__(/*! ./timestamp-add */ "./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-add.js"));
__export(__webpack_require__(/*! ./timestamp-diff */ "./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-diff.js"));
__export(__webpack_require__(/*! ./unix-timestamp-now */ "./node_modules/@squill/squill/dist/expr-library/date-time/unix-timestamp-now.js"));
__export(__webpack_require__(/*! ./utc-string-to-timestamp */ "./node_modules/@squill/squill/dist/expr-library/date-time/utc-string-to-timestamp.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/last-day.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/last-day.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the date of the last day of the month.
 *
 * Sets hour, minute, second, fractional second to zero.
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
 *
 * -----
 *
 * + MySQL          : `LAST_DAY(datetime)`
 * ```sql
 *  SELECT
 *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
 *  > 2010-03-31
 * ```
 * + PostgreSQL     :
 * ```sql
 *  SELECT
 *      (
 *          datetime +
 *          interval '1 month' -
 *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
 *      )::date
 * > 2010-03-31T00:00:00.000Z
 * ```
 * + SQLite         :
 * ```sql
 *  SELECT
 *      strftime(
 *          '%Y-%m-%d',
 *          '2010-03-27 14:45:32.456789',
 *          '+1 month',
 *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
 *      )
 *  > 2010-03-31
 * ```
 */
exports.lastDay = factory_1.makeOperator1(operator_type_1.OperatorType.LAST_DAY, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=last-day.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-add.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-add.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Adds the specified number of milliseconds to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MICROSECOND, x*1000, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      (x/1000e0) || ' second'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of milliseconds to add; following MySQL convention
 * @param right - The date-time to add milliseconds to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMillisecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MILLISECOND, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of seconds to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' second'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of seconds to add; following MySQL convention
 * @param right - The date-time to add seconds to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddSecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_SECOND, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of minutes to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MINUTE, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' minute'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of minutes to add; following MySQL convention
 * @param right - The date-time to add minutes to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMinute = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MINUTE, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of hours to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(HOUR, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' hour'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of hours to add; following MySQL convention
 * @param right - The date-time to add hours to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddHour = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_HOUR, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of days to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(DAY, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' day'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of days to add; following MySQL convention
 * @param right - The date-time to add days to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddDay = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_DAY, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of months to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
 * + SQLite         : Complicated implementation.
 *
 * -----
 *
 * @param left - The number of months to add; following MySQL convention
 * @param right - The date-time to add months to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddMonth = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_MONTH, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Adds the specified number of years to the date-time.
 *
 * May return `null`, or throw on overflow.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
 * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
 * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
 * + SQLite         :
 * ```sql
 *  strftime(
 *      '%Y-%m-%d %H:%M:%f',
 *      datetime,
 *      x || ' year'
 *  );
 * ```
 *
 * -----
 *
 * @param left - The number of years to add; following MySQL convention
 * @param right - The date-time to add years to; following MySQL convention
 *
 * @todo Unify negative overflow behaviour.
 */
exports.timestampAddYear = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPADD_YEAR, tm.mysql.dateTime(3).orNull(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=timestamp-add.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-diff.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/timestamp-diff.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the number of milliseconds between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
 *   + The `TRUNC()` at the end is necessary
 *   + Extracting `SECOND` gives a number with decimal places for milliseconds
 *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in milliseconds
 */
exports.timestampDiffMillisecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_MILLISECOND, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of seconds between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
 *   + The `TRUNC()` at the end is necessary
 *   + Extracting `SECOND` gives a number with decimal places for milliseconds
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in seconds
 */
exports.timestampDiffSecond = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_SECOND, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of minutes between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in minutes
 */
exports.timestampDiffMinute = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_MINUTE, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of hours between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
 * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in hours
 */
exports.timestampDiffHour = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_HOUR, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
/**
 * Returns the number of days between two date-times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
 *
 * -----
 *
 * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
 * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
 * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
 *   + We cast to `BIGINT` to be consistent with MySQL
 *
 * -----
 *
 * @param left - The start date-time
 * @param right - The end date-time
 * @returns - Returns `right - left` in days
 */
exports.timestampDiffDay = factory_1.makeOperator2(operator_type_1.OperatorType.TIMESTAMPDIFF_DAY, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=timestamp-diff.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/unix-timestamp-now.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/unix-timestamp-now.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
 * + https://www.sqlite.org/lang_datefunc.html
 *
 * -----
 *
 * + MySQL          : `UNIX_TIMESTAMP()`
 * + PostgreSQL     :
 * ```sql
 *  FLOOR(
 *      EXTRACT(EPOCH FROM (
 *          CURRENT_TIMESTAMP -
 *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
 *      ))
 *  )
 * ```
 * + SQLite         : `strftime('%s', 'now')`
 */
exports.unixTimestampNow = factory_1.makeOperator0(operator_type_1.OperatorType.UNIX_TIMESTAMP_NOW, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.DATE_TIME);
//# sourceMappingURL=unix-timestamp-now.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/date-time/utc-string-to-timestamp.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/date-time/utc-string-to-timestamp.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 *
 * -----
 *
 * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
 * ```sql
 *  SET @@session.time_zone = 'EST';
 *  SELECT
 *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
 *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
 *  > 1969-12-31 22:00:00.123
 *  > 10800
 * ```
 * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
 * ```sql
 *  SET TIME ZONE 'EST';
 *  SELECT
 *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
 *      FLOOR(EXTRACT(
 *          EPOCH FROM (
 *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
 *          )
 *      ))
 *  > 1970-01-01T03:00:00.123Z
 *  > 10800
 * ```
 * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
 * ```sql
 *  SELECT
 *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
 *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
 *  > 1970-01-01 03:00:00.123
 *  > 10800
 * ```
 *
 * -----
 *
 * Treat `x` as representing a `UTC` timestamp.
 *
 */
exports.utcStringToTimestamp = factory_1.makeOperator1(operator_type_1.OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR, tm.mysql.dateTime(3).orNull());
//# sourceMappingURL=utc-string-to-timestamp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/abs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/abs.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/add.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/add.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.add = factory_1.makeChainableDecimalOperator(operator_type_1.OperatorType.ADDITION, 0, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/avg.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/avg.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/min.js"));
__export(__webpack_require__(/*! ./sum */ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/sum.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/max.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/max.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/min.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/min.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/sum.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/sum.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ../decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const sumImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
exports.sumDistinct = (arg) => {
    return sumImpl(true, arg);
};
exports.sumAll = (arg) => {
    return sumImpl(false, arg);
};
exports.sum = exports.sumAll;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/ceiling.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/ceiling.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `CEILING(CEILING(x)) == CEILING(x)`
 */
exports.ceiling = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CEILING, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=ceiling.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping/fluent */ "./node_modules/type-mapping/fluent.js");
/**
 * We make this precision and scale far larger than what a database
 * can reasonably reach.
 *
 * PostgreSQL has max precision 1,000.
 *
 * Precision 40,000 and scale 20,000 seems like a safe bet, right?
 */
exports.decimalMapper = tm.mysql.decimal(40000, 20000);
//# sourceMappingURL=decimal-mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/exp.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/exp.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
exports.exp = factory_1.makeOperator1(operator_type_1.OperatorType.NATURAL_EXPONENTIATION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=exp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/floor.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/floor.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `FLOOR(FLOOR(x)) == FLOOR(x)`
 */
exports.floor = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.FLOOR, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=floor.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/fractional-div.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/fractional-div.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Performs regular fixed-point division
 */
exports.fractionalDiv = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_DIVISION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=fractional-div.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "./node_modules/@squill/squill/dist/expr-library/decimal/aggregate/index.js"));
__export(__webpack_require__(/*! ./abs */ "./node_modules/@squill/squill/dist/expr-library/decimal/abs.js"));
//export * from "./acos";
__export(__webpack_require__(/*! ./add */ "./node_modules/@squill/squill/dist/expr-library/decimal/add.js"));
//export * from "./asin";
//export * from "./atan";
//export * from "./atan2";
//export * from "./cbrt";
__export(__webpack_require__(/*! ./ceiling */ "./node_modules/@squill/squill/dist/expr-library/decimal/ceiling.js"));
//export * from "./cos";
//export * from "./cot";
//export * from "./degrees";
__export(__webpack_require__(/*! ./exp */ "./node_modules/@squill/squill/dist/expr-library/decimal/exp.js"));
__export(__webpack_require__(/*! ./floor */ "./node_modules/@squill/squill/dist/expr-library/decimal/floor.js"));
__export(__webpack_require__(/*! ./fractional-div */ "./node_modules/@squill/squill/dist/expr-library/decimal/fractional-div.js"));
/**
 * PostgreSQL and SQLite do not support fractional remainder `frem(x, y)`
 */
//export * from "./fractional-remainder";
//export * from "./integer-div";
//export * from "./integer-remainder";
__export(__webpack_require__(/*! ./ln */ "./node_modules/@squill/squill/dist/expr-library/decimal/ln.js"));
__export(__webpack_require__(/*! ./log */ "./node_modules/@squill/squill/dist/expr-library/decimal/log.js"));
__export(__webpack_require__(/*! ./log2 */ "./node_modules/@squill/squill/dist/expr-library/decimal/log2.js"));
__export(__webpack_require__(/*! ./log10 */ "./node_modules/@squill/squill/dist/expr-library/decimal/log10.js"));
__export(__webpack_require__(/*! ./mul */ "./node_modules/@squill/squill/dist/expr-library/decimal/mul.js"));
__export(__webpack_require__(/*! ./neg */ "./node_modules/@squill/squill/dist/expr-library/decimal/neg.js"));
//export * from "./pi";
__export(__webpack_require__(/*! ./power */ "./node_modules/@squill/squill/dist/expr-library/decimal/power.js"));
//export * from "./radians";
__export(__webpack_require__(/*! ./random */ "./node_modules/@squill/squill/dist/expr-library/decimal/random.js"));
//export * from "./round";
__export(__webpack_require__(/*! ./sign */ "./node_modules/@squill/squill/dist/expr-library/decimal/sign.js"));
//export * from "./sin";
__export(__webpack_require__(/*! ./sqrt */ "./node_modules/@squill/squill/dist/expr-library/decimal/sqrt.js"));
__export(__webpack_require__(/*! ./sub */ "./node_modules/@squill/squill/dist/expr-library/decimal/sub.js"));
//export * from "./tan";
//export * from "./truncate";
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/ln.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/ln.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LN(0)` === `NULL`
 * + PostgreSQL : `LN(0)` throws error
 */
exports.ln = factory_1.makeOperator1(operator_type_1.OperatorType.LN, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=ln.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/log.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/log.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG(0, 0)` === `NULL`
 * + PostgreSQL : `LOG(0, 0)` throws error
 */
exports.log = factory_1.makeOperator2(operator_type_1.OperatorType.LOG, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/log10.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/log10.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG10(0)` === `NULL`
 * + PostgreSQL : `LOG(10, 0)` throws error
 */
exports.log10 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG10, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log10.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/log2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/log2.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `LOG2(0)` === `NULL`
 * + PostgreSQL : `LOG(2, 0)` throws error
 */
exports.log2 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG2, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=log2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/mul.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/mul.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.mul = factory_1.makeChainableDecimalOperator(operator_type_1.OperatorType.MULTIPLICATION, 1, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/neg.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/neg.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/power.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/power.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
exports.power = factory_1.makeOperator2(operator_type_1.OperatorType.POWER, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=power.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/random.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/random.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.random = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/sign.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/sign.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
 */
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/sqrt.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/sqrt.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + MySQL      : `SQRT(-5)` === `null`
 * + PostgreSQL : `SQRT(-5)` throws error
 */
exports.sqrt = factory_1.makeOperator1(operator_type_1.OperatorType.SQUARE_ROOT, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sqrt.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/decimal/sub.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/decimal/sub.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decimal_mapper_1 = __webpack_require__(/*! ./decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, decimal_mapper_1.decimalMapper, type_hint_1.TypeHint.DECIMAL);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/abs.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/abs.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the absolute value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_corefunc.html#abs
 *
 * -----
 *
 * + MySQL        : `ABS(x)`
 * + PostgreSQL   : `ABS(x)`
 * + SQLite       : `ABS(x)`
 *   + `ABS(Infinity)  = Infinity`
 *   + `ABS(-Infinity) = Infinity`
 *
 * -----
 *
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/acos.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/acos.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the arc cosine.
 *
 * If the argument is not in [-1, 1], may throw, or return `null`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ACOS(x)`
 * + PostgreSQL     : `ACOS(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * + MySQL      : `ACOS(1.5)` === `NULL`
 * + PostgreSQL : `ACOS(1.5)` throws error
 */
exports.acos = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_COSINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=acos.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/add.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/add.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the addition of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
 *
 * -----
 *
 * + MySQL        : `+`
 *   + `1e308+1e308` throws
 *   + `(-1e308)+(-1e308)` throws
 * + PostgreSQL   : `+`
 *   + `CAST(1e308 AS double precision)+CAST(1e308 AS double precision)` throws
 *   + `CAST(-1e308 AS double precision)+CAST(-1e308 AS double precision)` throws
 * + SQLite       : `+`
 *   + `1e308+1e308 = Infinity`
 *   + `(-1e308)+(-1e308) = -Infinity`
 *
 * -----
 *
 * In SQLite, addition with doubles may return `null`,
 * ```sql
 *  SELECT 1e999 + -1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.add = factory_1.makeChainableOperator(operator_type_1.OperatorType.ADDITION, 0, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/avg.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/avg.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(DISTINCT x)`
 * + PostgreSQL : `AVG(DISTINCT x)`
 * + SQLite     : `AVG(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/min.js"));
__export(__webpack_require__(/*! ./stddev-pop */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-pop.js"));
__export(__webpack_require__(/*! ./stddev-samp */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-samp.js"));
__export(__webpack_require__(/*! ./sum */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/sum.js"));
__export(__webpack_require__(/*! ./var-pop */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-pop.js"));
__export(__webpack_require__(/*! ./var-samp */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-samp.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/max.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/max.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/min.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/min.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-pop.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-pop.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the population standard deviation of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
 *
 * -----
 *
 * + MySQL      : `STDDEV_POP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `STDDEV_POP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The population standard deviation is,
 * ```sql
 *  SQRT(
 *      -- SUM() and AVG() should ignore rows with `NULL` values
 *      SUM(
 *          POW((x - AVG(x), 2)
 *      ) /
 *      COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
 *  )
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.stdDevPop = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=stddev-pop.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-samp.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/stddev-samp.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the sample standard deviation of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * It returns `NULL` if there is only one non-`NULL` value.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
 *
 * -----
 *
 * + MySQL      : `STDDEV_SAMP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `STDDEV_SAMP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The sample standard deviation is,
 * ```sql
 *  SQRT(
 *      -- SUM() and AVG() should ignore rows with `NULL` values
 *      SUM(
 *          POW((x - AVG(x), 2)
 *      ) /
 *      (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
 *  )
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.stdDevSamp = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=stddev-samp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/sum.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/sum.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const sumImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(DISTINCT x)`
 * + PostgreSQL : `SUM(DISTINCT x)`
 * + SQLite     : `SUM(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sumDistinct = (arg) => {
    return sumImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(x)`
 * + SQLite     : `SUM(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sumAll = (arg) => {
    return sumImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(x)`
 * + SQLite     : `SUM(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 */
exports.sum = exports.sumAll;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-pop.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-pop.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the population variance of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 *
 * -----
 *
 * + MySQL      : `VAR_POP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `VAR_POP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The population variance is,
 * ```sql
 *  -- SUM() and AVG() should ignore rows with `NULL` values
 *  SUM(
 *      POW((x - AVG(x), 2)
 *  ) /
 *  COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.varPop = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_POPULATION_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=var-pop.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-samp.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/aggregate/var-samp.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the sample variance of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * It returns `NULL` if there is only one non-`NULL` value.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 *
 * -----
 *
 * + MySQL      : `VAR_SAMP(x)`
 *   + Always returns `double`
 * + PostgreSQL : `VAR_SAMP(x)`
 *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
 * + SQLite     : None. Implement with user-defined function.
 *
 * Should only be provided for `double` because MySQL treats all `x` as `double`.
 *
 * -----
 *
 * The sample variance is,
 * ```sql
 *  -- SUM() and AVG() should ignore rows with `NULL` values
 *  SUM(
 *      POW((x - AVG(x), 2)
 *  ) /
 *  (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
 * ```
 *
 * Of course, you can't use the above expression because you cannot nest aggregate functions.
 * (Cannot use `AVG()` inside of `SUM()`)
 */
exports.varSamp = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_SAMPLE_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=var-samp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/asin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/asin.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the arc sine.
 *
 * If the argument is not in [-1, 1], may throw, or return `null`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ASIN(x)`
 * + PostgreSQL     : `ASIN(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * + MySQL      : `ASIN(1.5)` === `NULL`
 * + PostgreSQL : `ASIN(1.5)` throws error
 */
exports.asin = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_SINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=asin.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/atan.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/atan.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the arc tangent.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ATAN(x)`
 * + PostgreSQL     : `ATAN(x)`
 * + SQLite         : None, implement with user-defined function
 */
exports.atan = factory_1.makeOperator1(operator_type_1.OperatorType.ARC_TANGENT, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=atan.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/atan2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/atan2.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Similar to calculating the arc tangent of `Y / X`,
 * except that the signs of both arguments are used
 * to determine the quadrant of the result.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `ATAN2(y, x)`
 * + PostgreSQL     : `ATAN2(y, x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * @param left  - The Y of the vector
 * @param right - The X of the vector
 */
exports.atan2 = factory_1.makeOperator2(operator_type_1.OperatorType.ARC_TANGENT_2, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=atan2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/cbrt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/cbrt.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the cube root
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_pow
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `IF(x >= 0, POWER(x, 1.0/3.0), -POWER(-(x), 1.0/3.0))`
 *   + The `.0` parts are important!
 *   + MySQL's `POWER()` function throws on negative numbers
 * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
 * + SQLite       : Requres creating a `CBRT(x)` user-defined function
 *
 * -----
 *
 * MySQL
 * ```sql
 * SELECT POWER(27, 1.0/3.0)
 * > 3
 * ```
 *
 * PostgreSQL
 * ```sql
 * SELECT POWER(27, 1.0/3.0)
 * > 2.99999999999999999997
 *
 * SELECT CBRT(27)
 * > 3
 * ```
 */
exports.cbrt = factory_1.makeOperator1(operator_type_1.OperatorType.CUBE_ROOT, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cbrt.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/ceiling.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/ceiling.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the ceiling of the number
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceiling
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `CEIL(x)/CEILING(x)`
 * + PostgreSQL   : `CEIL(x)/CEILING(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * ```sql
 *  SELECT CEILING(1.1)
 *  > 2
 *
 *  SELECT CEILING(-1.1)
 *  > -1
 * ```
 *
 * -----
 *
 * This function is idempotent.
 * `CEILING(CEILING(x)) == CEILING(x)`
 */
exports.ceiling = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.CEILING, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=ceiling.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/cos.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/cos.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the cosine
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `COS(x)`
 * + PostgreSQL     : `COS(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COS(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The cosine
 */
exports.cos = factory_1.makeOperator1(operator_type_1.OperatorType.COSINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cos.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/cot.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/cot.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the cotangent
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `COT(x)`
 * + PostgreSQL     : `COT(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COT(1e999)`
 *
 * -----
 *
 * + MySQL      : `COT(0)` throws error
 * + PostgreSQL : `COT(0)` === `NULL`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The cotangent
 */
exports.cot = factory_1.makeOperator1(operator_type_1.OperatorType.COTANGENT, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=cot.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/degrees.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/degrees.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Converts from radians to degrees.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `DEGREES(x)`
 * + PostgreSQL     : `DEGREES(x)`
 * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
 *
 * -----
 *
 * @param arg - radians
 * @returns degrees
 */
exports.degrees = factory_1.makeOperator1(operator_type_1.OperatorType.DEGREES, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=degrees.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/exp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/exp.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * The natural exponential function
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://en.wikipedia.org/wiki/Exponential_function
 *
 * -----
 *
 * + MySQL          : `EXP(x)`
 * + PostgreSQL     : `EXP(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * @param arg - The power value
 * @returns e^arg
 */
exports.exp = factory_1.makeOperator1(operator_type_1.OperatorType.NATURAL_EXPONENTIATION, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=exp.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/floor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/floor.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the floor of the number
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `FLOOR(x)`
 * + PostgreSQL   : `FLOOR(x)`
 * + SQLite         : None, implement with user-defined function
 *
 * -----
 *
 * ```sql
 *  SELECT FLOOR(1.1)
 *  > 1
 *
 *  SELECT FLOOR(-1.1)
 *  > -2
 * ```
 *
 * -----
 *
 * This function is idempotent.
 * `FLOOR(FLOOR(x)) == FLOOR(x)`
 */
exports.floor = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.FLOOR, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=floor.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/fractional-div.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/fractional-div.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Performs regular floating-point division
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `/`
 * + PostgreSQL   : `/`
 * + SQLite       : `/`
 *
 * -----
 *
 * `1e0/0e0`,
 *
 * + MySQL      : `NULL`
 * + PostgreSQL : throws
 * + SQLite     : `NULL`
 *
 * -----
 *
 * `1e308/0.1e0`,
 *
 * + MySQL      : throws
 * + PostgreSQL : throws
 * + SQLite     : `Infinity`
 *
 * -----
 *
 * `1e308/-0.1e0`,
 *
 * + MySQL      : throws
 * + PostgreSQL : throws
 * + SQLite     : `-Infinity`
 *
 * -----
 *
 * MySQL,
 * ```sql
 *  SELECT
 *      3.141592653539793e0 /
 *      6.233523257997525e0;
 *  > 0.5039834654517689
 * ```
 * PostgreSQL,
 * ```sql
 *  SELECT
 *      CAST(3.141592653539793e0 AS DOUBLE PRECISION) /
 *      CAST(6.233523257997525e0 AS DOUBLE PRECISION);
 *  > 0.503983465451769
 * ```
 *
 * SQLite,
 * ```sql
 *  SELECT
 *      3.141592653539793e0 /
 *      6.233523257997525e0;
 *  > 0.5039834654517689
 * ```
 */
exports.fractionalDiv = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_DIVISION, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=fractional-div.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/fractional-remainder.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/fractional-remainder.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the remainder after fractional division.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_mod
 * + https://stackoverflow.com/questions/53486669/modulo-operation-on-floating-point-numbers-on-postgresql
 *
 * -----
 *
 * + MySQL      : `dividend % divisor`
 * + PostgreSQL : See algorithm below
 * + SQLite     : See algorithm below
 *
 * ```sql
 *  IF(
 *      dividend >= 0,
 *      dividend - FLOOR(dividend / divisor) * divisor,
 *      -((-dividend) - FLOOR((-dividend) / divisor) * divisor)
 *  )
 * ```
 */
exports.fractionalRemainder = factory_1.makeOperator2(operator_type_1.OperatorType.FRACTIONAL_REMAINDER, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=fractional-remainder.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "./node_modules/@squill/squill/dist/expr-library/double/aggregate/index.js"));
__export(__webpack_require__(/*! ./abs */ "./node_modules/@squill/squill/dist/expr-library/double/abs.js"));
__export(__webpack_require__(/*! ./acos */ "./node_modules/@squill/squill/dist/expr-library/double/acos.js"));
__export(__webpack_require__(/*! ./add */ "./node_modules/@squill/squill/dist/expr-library/double/add.js"));
__export(__webpack_require__(/*! ./asin */ "./node_modules/@squill/squill/dist/expr-library/double/asin.js"));
__export(__webpack_require__(/*! ./atan */ "./node_modules/@squill/squill/dist/expr-library/double/atan.js"));
__export(__webpack_require__(/*! ./atan2 */ "./node_modules/@squill/squill/dist/expr-library/double/atan2.js"));
__export(__webpack_require__(/*! ./cbrt */ "./node_modules/@squill/squill/dist/expr-library/double/cbrt.js"));
__export(__webpack_require__(/*! ./ceiling */ "./node_modules/@squill/squill/dist/expr-library/double/ceiling.js"));
__export(__webpack_require__(/*! ./cos */ "./node_modules/@squill/squill/dist/expr-library/double/cos.js"));
__export(__webpack_require__(/*! ./cot */ "./node_modules/@squill/squill/dist/expr-library/double/cot.js"));
__export(__webpack_require__(/*! ./degrees */ "./node_modules/@squill/squill/dist/expr-library/double/degrees.js"));
__export(__webpack_require__(/*! ./exp */ "./node_modules/@squill/squill/dist/expr-library/double/exp.js"));
__export(__webpack_require__(/*! ./floor */ "./node_modules/@squill/squill/dist/expr-library/double/floor.js"));
__export(__webpack_require__(/*! ./fractional-div */ "./node_modules/@squill/squill/dist/expr-library/double/fractional-div.js"));
__export(__webpack_require__(/*! ./fractional-remainder */ "./node_modules/@squill/squill/dist/expr-library/double/fractional-remainder.js"));
/**
 * MySQL's `DIV` is just too... Unintuitive.
 * One would think it converts operands to int before performing int-div.
 * Instead, it performs fractional-div, then converts result to int.
 *
 * If you really want integer-div, just cast and divide yourself.
 */
//export * from "./integer-div";
/**
 * For the same reason that integer-div is removed.
 */
//export * from "./integer-remainder";
__export(__webpack_require__(/*! ./ln */ "./node_modules/@squill/squill/dist/expr-library/double/ln.js"));
__export(__webpack_require__(/*! ./log */ "./node_modules/@squill/squill/dist/expr-library/double/log.js"));
__export(__webpack_require__(/*! ./log2 */ "./node_modules/@squill/squill/dist/expr-library/double/log2.js"));
__export(__webpack_require__(/*! ./log10 */ "./node_modules/@squill/squill/dist/expr-library/double/log10.js"));
__export(__webpack_require__(/*! ./mul */ "./node_modules/@squill/squill/dist/expr-library/double/mul.js"));
__export(__webpack_require__(/*! ./neg */ "./node_modules/@squill/squill/dist/expr-library/double/neg.js"));
__export(__webpack_require__(/*! ./pi */ "./node_modules/@squill/squill/dist/expr-library/double/pi.js"));
__export(__webpack_require__(/*! ./power */ "./node_modules/@squill/squill/dist/expr-library/double/power.js"));
__export(__webpack_require__(/*! ./radians */ "./node_modules/@squill/squill/dist/expr-library/double/radians.js"));
__export(__webpack_require__(/*! ./random */ "./node_modules/@squill/squill/dist/expr-library/double/random.js"));
//export * from "./round";
__export(__webpack_require__(/*! ./sign */ "./node_modules/@squill/squill/dist/expr-library/double/sign.js"));
__export(__webpack_require__(/*! ./sin */ "./node_modules/@squill/squill/dist/expr-library/double/sin.js"));
__export(__webpack_require__(/*! ./sqrt */ "./node_modules/@squill/squill/dist/expr-library/double/sqrt.js"));
__export(__webpack_require__(/*! ./sub */ "./node_modules/@squill/squill/dist/expr-library/double/sub.js"));
__export(__webpack_require__(/*! ./tan */ "./node_modules/@squill/squill/dist/expr-library/double/tan.js"));
//export * from "./truncate";
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/ln.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/ln.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the natural logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `LN(x)`
 * + PostgreSQL     : `LN(x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LN(0)` === `NULL`
 * + PostgreSQL : `LN(0)` throws error
 *
 * -----
 *
 * + MySQL      : `LN(-1)` === `NULL`
 * + PostgreSQL : `LN(-1)` throws error
 */
exports.ln = factory_1.makeOperator1(operator_type_1.OperatorType.LN, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=ln.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/log.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/log.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the logarithm to the specified `base`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `LOG(base, x)`
 * + PostgreSQL     : `LOG(base, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG(0, 0)` === `NULL`
 * + PostgreSQL : `LOG(0, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG(1, 5)` === `NULL`
 * + PostgreSQL : `LOG(1, 5)` throws error
 *
 * -----
 *
 * @param left  - The base
 * @param right - The anti-logarithm
 * @returns log_{base}(anti-logarithm) = logarithm
 */
exports.log = factory_1.makeOperator2(operator_type_1.OperatorType.LOG, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/log10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/log10.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the base-10 logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
 *
 * -----
 *
 * + MySQL          : `LOG10(x)`
 * + PostgreSQL     : `LOG(10.0, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG10(0)` === `NULL`
 * + PostgreSQL : `LOG(10, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG10(-1)` === `NULL`
 * + PostgreSQL : `LOG(10, -1)` throws error
 */
exports.log10 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG10, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log10.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/log2.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/log2.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the base-2 logarithm
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
 *
 * -----
 *
 * + MySQL          : `LOG2(x)`
 * + PostgreSQL     : `LOG(2.0, x)`
 * + SQLite         : None, implment with user-defined function
 *
 * -----
 *
 * + MySQL      : `LOG2(0)` === `NULL`
 * + PostgreSQL : `LOG(2, 0)` throws error
 *
 * -----
 *
 * + MySQL      : `LOG2(-1)` === `NULL`
 * + PostgreSQL : `LOG(2, -1)` throws error
 */
exports.log2 = factory_1.makeOperator1(operator_type_1.OperatorType.LOG2, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=log2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/mul.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/mul.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the multiplication of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
 *
 * -----
 *
 * + MySQL        : `*`
 *   + `1e308*1e308` throws
 *   + `1e308*-1e308` throws
 * + PostgreSQL   : `*`
 *   + `CAST(1e308 AS double precision)*CAST(1e308 AS double precision)` throws
 *   + `CAST(1e308 AS double precision)*CAST(-1e308 AS double precision)` throws
 * + SQLite       : `*`
 *   + `1e308*1e308 = Infinity`
 *   + `1e308*-1e308 = -Infinity`
 *
 * -----
 *
 * In SQLite, multiplication with doubles may return `null`,
 * ```sql
 *  SELECT 0e0 * 1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.mul = factory_1.makeChainableOperator(operator_type_1.OperatorType.MULTIPLICATION, 1, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/neg.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/neg.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the unary minus of the double value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
 *
 * -----
 *
 * + MySQL        : `-`
 * + PostgreSQL   : `-`
 * + SQLite       : `-`
 *
 * -----
 *
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/pi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/pi.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the value of pi
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 * + https://en.wikipedia.org/wiki/Pi
 *
 * -----
 *
 * + MySQL          : `PI()`; MySQL's understanding of pi is... terrible
 *   + https://github.com/AnyhowStep/tsql/issues/252
 *   + The MySQL adapter library **should not** use `PI()`, it should use `3.141592653589793` instead
 * + PostgreSQL     : `PI()` Returns `3.14159265358979`
 * + SQLite         : None, implement using `3.141592653589793`
 *
 * -----
 *
 * In JS, `Math.PI` is `3.141592653589793`
 */
exports.pi = factory_1.makeOperator0(operator_type_1.OperatorType.PI, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=pi.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/power.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/power.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns `base^exponent`
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `POWER(base, exponent)`
 * + PostgreSQL   : `^` or `POWER(base, exponent)` (Let's not use the ugly `^` operator)
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `POWER(-1, 0.5)`
 *
 * -----
 *
 * If base is negative, and exponent is fractional,
 * + MySQL throws
 * + PostgreSQL throws
 * + SQLite reutrns `null` (`extension-functions.c`)
 *
 * -----
 *
 * If base is zero, and exponent is negative,
 * + MySQL throws
 * + PostgreSQL throws
 * + SQLite reutrns `Infinity` (`extension-functions.c`)
 *
 * -----
 *
 * @param left  - The base
 * @param right - The exponent
 * @returns base^exponent
 *
 * @todo Decide if we should make SQLite throw instead of return `null`
 */
exports.power = factory_1.makeOperator2(operator_type_1.OperatorType.POWER, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=power.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/radians.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/radians.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Converts from degrees to radians.
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `RADIANS(x)`
 * + PostgreSQL     : `RADIANS(x)`
 * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
 *
 * -----
 *
 * @param arg - degrees
 * @returns radians
 */
exports.radians = factory_1.makeOperator1(operator_type_1.OperatorType.RADIANS, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=radians.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/random.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/random.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns a random floating point number in the range, `[0.0, 1.0)`
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#random
 *
 * -----
 *
 * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
 * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
 * + SQLite         : Incompatible.
 *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
 *   See algorithm below to emulate.
 *   Or just use a user-defined function...
 *
 * -----
 *
 * SQLite emulation,
 * ```sql
 *  COALESCE(
 *      NULLIF(
 *          ABS(RANDOM()+0e0) / 9223372036854775809e0,
 *          1
 *      ),
 *      0.999999999999999
 *  )
 * ```
 */
exports.random = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/sign.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/sign.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * + If the argument is negative, returns -1
 * + If the argument is positive, returns  1
 * + If the argument is zero, returns 0
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
 *
 * -----
 *
 * + MySQL          : `SIGN(x)`
 * + PostgreSQL     : `SIGN(x)`
 * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
 *
 * -----
 *
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
*/
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, tm.mysql.double(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/sin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/sin.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the sine
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `SIN(x)`
 * + PostgreSQL     : `SIN(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `SIN(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The sine
 */
exports.sin = factory_1.makeOperator1(operator_type_1.OperatorType.SINE, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sin.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/sqrt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/sqrt.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the square root
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
 *
 * -----
 *
 * + MySQL        : `SQRT(x)`
 * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
 * + SQLite       : Requres creating a `SQRT(x)` user-defined function
 *
 * -----
 *
 * + MySQL      : `SQRT(-5)` === `null`
 * + PostgreSQL : `SQRT(-5)` throws error
 */
exports.sqrt = factory_1.makeOperator1(operator_type_1.OperatorType.SQUARE_ROOT, tm.orNull(tm.toUnsafeNumber()), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sqrt.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/sub.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/sub.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the subtraction of the double values
 *
 * The precision of the result is not guaranteed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
 *
 * -----
 *
 * + MySQL        : `-`
 *   + `-1e308 - 1e308` throws
 *   + `1e308 - -1e308` throws
 * + PostgreSQL   : `-`
 *   + `CAST(-1e308 AS DOUBLE PRECISION) - CAST(1e308 AS DOUBLE PRECISION)` throws
 *   + `CAST(1e308 AS DOUBLE PRECISION) - CAST(-1e308 AS DOUBLE PRECISION)` throws
 * + SQLite       : `-`
 *   + `-1e308 - 1e308 = -Infinity`
 *   + `1e308 - -1e308 = Infinity`
 *
 * -----
 *
 * In SQLite, subtraction with doubles may return `null`,
 * ```sql
 *  SELECT 1e999 - 1e999;
 *  > null
 * ```
 *
 * This particular function will be emulated in SQLite such that
 * it'll throw an error, instead of returning `null`.
 */
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, tm.toUnsafeNumber(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/double/tan.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/double/tan.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Returns the tangent
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
 * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
 *
 * -----
 *
 * + MySQL          : `TAN(x)`
 * + PostgreSQL     : `TAN(x)`
 * + SQLite         : None, implement with user-defined function
 *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `TAN(1e999)`
 *
 * -----
 *
 * @param arg - Radians
 * @returns The tangent
 */
exports.tan = factory_1.makeOperator1(operator_type_1.OperatorType.TANGENT, tm.mysql.double().orNull(), type_hint_1.TypeHint.DOUBLE);
//# sourceMappingURL=tan.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/eq-primary-key.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/eq-primary-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const primary_key_1 = __webpack_require__(/*! ../../primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js");
const eq_1 = __webpack_require__(/*! ./eq */ "./node_modules/@squill/squill/dist/expr-library/equation/eq.js");
const logical_1 = __webpack_require__(/*! ../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
/**
 * Convenience function for,
 * ```ts
 *  tsql.and(
 *      tsql.eq(primaryKeyColumn0, value0),
 *      tsql.eq(primaryKeyColumn1, value1),
 *      tsql.eq(primaryKeyColumn2, value2)
 *      //etc.
 *  );
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 * -----
 *
 * Uses `eq()` internally because the primary key of a table
 * cannot have nullable columns.
 *
 * @todo Change this to use `nullSafeEq()` jusssst in case people start using
 * nullable columns in PKs for whatever reason?
 *
 * @param table - The table with a primary key
 * @param primaryKeyInput - The primary key values to compare against
 */
function eqPrimaryKey(table, primaryKeyInput) {
    const primaryKey = primary_key_1.PrimaryKeyUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.primaryKey`, primaryKeyInput);
    /**
     * We `.sort()` the keys so our resulting SQL is deterministic,
     * regardless of how `primaryKey` was constructed.
     */
    const arr = Object.keys(primaryKey).sort().map((columnAlias) => {
        /**
         * We use `eq` because the primary key of a table cannot have
         * nullable columns... Right?
         *
         * @todo Decide if we should use null-safe equality anyway,
         * just to be super safe
         */
        const expr = eq_1.eq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], primaryKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
}
exports.eqPrimaryKey = eqPrimaryKey;
//# sourceMappingURL=eq-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/eq.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/eq.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
 *
 * This version of the `=` operator prevents `NULL`.
 *
 * For null-safe equality, @see {@link nullSafeEq}
 */
exports.eq = factory_1.makeEquation2(operator_type_1.OperatorType.EQUAL);
//# sourceMappingURL=eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/in-array.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/in-array.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const inArrayImpl = factory_1.makeEquation2ToN(operator_type_1.OperatorType.IN_ARRAY);
/**
 * The `IN` operator has two overloads.
 * + `x IN (y0, y1, y2, y3, ...)`
 * + `x IN (SELECT y FROM ...)`
 *
 * This implementation is for the first overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
 *
 * The array cannot contain `null` because,
 * + `x IN (NULL)` is `NULL`
 * + `1 IN (NULL, 2)` is `NULL`
 * + `1 IN (NULL, 2, 1)` is `true`
 *
 * -----
 *
 * Calling `inArray()` with an empty array will always
 * return `false` because a value is never in an array of zero elements.
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 */
function inArray(arg0, args) {
    const [arg1, ...rest] = args;
    if (arg1 == undefined) {
        /**
         * Calling `inArray()` with an empty array will always
         * return `false` because a value is never in an array of zero elements.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(false);
    }
    else {
        return inArrayImpl(arg0, arg1, ...rest);
    }
}
exports.inArray = inArray;
//# sourceMappingURL=in-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/in-query.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/in-query.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * The `IN` operator has two overloads.
 * + `x IN (y0, y1, y2, y3, ...)`
 * + `x IN (SELECT y FROM ...)`
 *
 * This implementation is for the second overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
 *
 * The query argument cannot `SELECT` `null` because,
 * + `x IN (SELECT NULL)` is `NULL`
 * + `x IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
 *   + At least one row has a `NULL` value
 *   + No rows have the value `x`
 * + `x IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
 *   + No rows have the value `x`
 * + `1 IN (SELECT NULL UNION SELECT 1)` is `true`
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 *
 * -----
 *
 * ### Problems with MySQL
 *
 * The following produced an error,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 IN (SELECT id FROM myTable LIMIT 1);
 * ```
 *
 * The following is a workaround,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
 * ```
 */
function inQuery(builtInExpr, query) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Query must SELECT one item`);
    }
    if (tm.canOutputNull(query.selectClause[0].mapper)) {
        throw new Error(`Query must not SELECT nullable value`);
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr),
    }, ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.IN_QUERY, [
        built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        built_in_expr_1.BuiltInExprUtil.buildAst(query)
    ], undefined));
}
exports.inQuery = inQuery;
//# sourceMappingURL=in-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./eq-primary-key */ "./node_modules/@squill/squill/dist/expr-library/equation/eq-primary-key.js"));
__export(__webpack_require__(/*! ./eq */ "./node_modules/@squill/squill/dist/expr-library/equation/eq.js"));
__export(__webpack_require__(/*! ./in-array */ "./node_modules/@squill/squill/dist/expr-library/equation/in-array.js"));
__export(__webpack_require__(/*! ./in-query */ "./node_modules/@squill/squill/dist/expr-library/equation/in-query.js"));
__export(__webpack_require__(/*! ./not-eq */ "./node_modules/@squill/squill/dist/expr-library/equation/not-eq.js"));
__export(__webpack_require__(/*! ./not-in-array */ "./node_modules/@squill/squill/dist/expr-library/equation/not-in-array.js"));
__export(__webpack_require__(/*! ./not-in-query */ "./node_modules/@squill/squill/dist/expr-library/equation/not-in-query.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/not-eq.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/not-eq.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
 *
 * This version of the `<>` operator prevents `NULL`.
 *
 * For null-safe inequality, @see {@link nullSafeNotEq}
 *
 */
exports.notEq = factory_1.makeEquation2(operator_type_1.OperatorType.NOT_EQUAL);
//# sourceMappingURL=not-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/not-in-array.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/not-in-array.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Refactor `inArray()` and `notInArray()` so they can share code.
 * Something like a `makeInArray()` factory function.
 */
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const notInArrayImpl = factory_1.makeEquation2ToN(operator_type_1.OperatorType.NOT_IN_ARRAY);
/**
 * The `NOT IN` operator has two overloads.
 * + `x NOT IN (y0, y1, y2, y3, ...)`
 * + `x NOT IN (SELECT y FROM ...)`
 *
 * This implementation is for the first overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
 *
 * The array cannot contain `null` because,
 * + `x NOT IN (NULL)` is `NULL`
 * + `1 NOT IN (NULL, 2)` is `NULL`
 * + `1 NOT IN (NULL, 2, 1)` is `false`
 *
 * -----
 *
 * Calling `notInArray()` with an empty array will always
 * return `true` because a value is always **not** in an array of zero elements.
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 */
function notInArray(arg0, args) {
    const [arg1, ...rest] = args;
    if (arg1 == undefined) {
        /**
         * Calling `notInArray()` with an empty array will always
         * return `true` because a value is always **not** in an array of zero elements.
         */
        return expr_1.ExprUtil.fromBuiltInExpr(true);
    }
    else {
        return notInArrayImpl(arg0, arg1, ...rest);
    }
}
exports.notInArray = notInArray;
//# sourceMappingURL=not-in-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/equation/not-in-query.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/equation/not-in-query.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Refactor `inQuery()` and `notInQuery()` so they can share code.
 * Something like a `makeInQuery()` factory function.
 */
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * The `NOT IN` operator has two overloads.
 * + `x NOT IN (y0, y1, y2, y3, ...)`
 * + `x NOT IN (SELECT y FROM ...)`
 *
 * This implementation is for the second overload.
 *
 * -----
 *
 * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
 *
 * The query argument cannot `SELECT` `null` because,
 * + `x NOT IN (SELECT NULL)` is `NULL`
 * + `x NOT IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
 *   + At least one row has a `NULL` value
 *   + No rows have the value `x`
 * + `x NOT IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
 *   + No rows have the value `x`
 * + `1 NOT IN (SELECT NULL UNION SELECT 1)` is `false`
 *
 * -----
 *
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
 *
 * > To comply with the SQL standard,
 * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
 * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
 *
 * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
 *
 * -----
 *
 * ### Problems with MySQL
 *
 * The following produced an error,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 NOT IN (SELECT id FROM myTable LIMIT 1);
 * ```
 *
 * The following is a workaround,
 * ```sql
 * CREATE TABLE myTable (id INT);
 * INSERT INTO myTable VALUES (1);
 * SELECT 1 NOT IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
 * ```
 */
function notInQuery(builtInExpr, query) {
    if (!query_base_1.QueryBaseUtil.isOneSelectItem(query)) {
        throw new Error(`Query must SELECT one item`);
    }
    if (tm.canOutputNull(query.selectClause[0].mapper)) {
        throw new Error(`Query must not SELECT nullable value`);
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
        isAggregate: built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr),
    }, ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.NOT_IN_QUERY, [
        built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        built_in_expr_1.BuiltInExprUtil.buildAst(query)
    ], undefined));
}
exports.notInQuery = notInQuery;
//# sourceMappingURL=not-in-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./make-any-operator-1 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-any-operator-1.js"));
__export(__webpack_require__(/*! ./make-chainable-decimal-operator */ "./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-decimal-operator.js"));
__export(__webpack_require__(/*! ./make-chainable-operator */ "./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-operator.js"));
__export(__webpack_require__(/*! ./make-comparison-1-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-1-to-n.js"));
__export(__webpack_require__(/*! ./make-comparison-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2-to-n.js"));
__export(__webpack_require__(/*! ./make-comparison-2 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2.js"));
__export(__webpack_require__(/*! ./make-comparison-3 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-3.js"));
__export(__webpack_require__(/*! ./make-comparison-projection-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-projection-2-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-1-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-1-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2-to-n.js"));
__export(__webpack_require__(/*! ./make-equation-2 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2.js"));
__export(__webpack_require__(/*! ./make-null-safe-comparison-1 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-1.js"));
__export(__webpack_require__(/*! ./make-null-safe-comparison-2 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-2.js"));
__export(__webpack_require__(/*! ./make-null-safe-equation-1 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-1.js"));
__export(__webpack_require__(/*! ./make-null-safe-equation-2 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-2.js"));
__export(__webpack_require__(/*! ./make-operator-0 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-0.js"));
__export(__webpack_require__(/*! ./make-operator-1-double-elimination */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-double-elimination.js"));
__export(__webpack_require__(/*! ./make-operator-1-idempotent */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-idempotent.js"));
__export(__webpack_require__(/*! ./make-operator-1-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-to-n.js"));
__export(__webpack_require__(/*! ./make-operator-1 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1.js"));
__export(__webpack_require__(/*! ./make-operator-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2-to-n.js"));
__export(__webpack_require__(/*! ./make-operator-2 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2.js"));
__export(__webpack_require__(/*! ./make-operator-3 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-any-operator-1.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-any-operator-1.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeAnyOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeAnyOperator1 = makeAnyOperator1;
//# sourceMappingURL=make-any-operator-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-decimal-operator.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-decimal-operator.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../decimal/decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
function tryGetFlattenableElements(
/**
 * In this specific instance, we could probably have `BuiltInExpr<Decimal>`.
 * Can't accept arbitrary `Decimal` types because they may have invalid precision/scale.
 */
builtInExpr, operatorType, _identityElement, identityAst, identityParseResult) {
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return ast_1.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
            if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_1.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                /**
                 * Eliminate all identity elements
                 */
                return [];
            }
            else if (ast_1.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                return ast.operands;
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * We should not see any `Decimal` built-ins because JS does not have them.
     */
    const builtInExprParseResult = tm.FixedPointUtil.tryParse(String(builtInExpr));
    if (builtInExprParseResult != undefined &&
        tm.FixedPointUtil.isEqual(builtInExprParseResult, identityParseResult, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL)) {
        /**
         * Eliminate all identity elements
         */
        return [];
    }
    return undefined;
}
function makeChainableDecimalOperator(operatorType, rawIdentityElement, mapper, 
/**
 * For now, the typeHint should always be `DECIMAL`
 */
typeHint) {
    const identityElement = decimal_mapper_1.decimalMapper("rawIdentityElement", rawIdentityElement);
    const identityParseResult = tm.FixedPointUtil.tryParse(rawIdentityElement.toString());
    if (identityParseResult == undefined) {
        throw new Error(`Invalid identity element ${rawIdentityElement}`);
    }
    let identityAst = undefined;
    const result = (...arr) => {
        if (identityAst == undefined) {
            const newIdentityAst = literal_value_node_1.LiteralValueNodeUtil.decimalLiteralNode(identityElement, 65, 30);
            if (!literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                throw new Error(`Invalid identity element`);
            }
            identityAst = newIdentityAst;
        }
        let operands = undefined;
        for (const builtInExpr of arr) {
            const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst, identityParseResult);
            if (flattenableElements != undefined) {
                /**
                 * Looks like we should flatten this `builtInExpr`
                 */
                if (flattenableElements.length == 0) {
                    continue;
                }
                else {
                    if (operands == undefined) {
                        operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                    }
                    else {
                        operands.push(...flattenableElements);
                    }
                }
            }
            else {
                /**
                 * Can't flatten this `builtInExpr`
                 */
                if (operands == undefined) {
                    operands = [built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr)];
                }
                else {
                    operands.push(built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr));
                }
            }
        }
        return expr_1.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
            /**
             * By convention, applying the operator to zero operands gives you the identity element
             */
            identityAst :
            (operands.length == 1) ?
                /**
                 * By convention, applying the operator on one operand does not do anything to the operand
                 */
                operands[0] :
                ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
    };
    return result;
}
exports.makeChainableDecimalOperator = makeChainableDecimalOperator;
//# sourceMappingURL=make-chainable-decimal-operator.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-operator.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-chainable-operator.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const literal_value_node_1 = __webpack_require__(/*! ../../ast/literal-value-node */ "./node_modules/@squill/squill/dist/ast/literal-value-node/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
function tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst) {
    if (expr_1.ExprUtil.isExpr(builtInExpr)) {
        return ast_1.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
            if (literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_1.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                /**
                 * Eliminate all identity elements
                 */
                return [];
            }
            else if (ast_1.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                return ast.operands;
            }
            else {
                return undefined;
            }
        });
    }
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr) &&
        built_in_value_expr_1.BuiltInValueExprUtil.isEqual(builtInExpr, identityElement)) {
        /**
         * Eliminate all identity elements
         */
        return [];
    }
    return undefined;
}
function makeChainableOperator(operatorType, identityElement, mapper, typeHint) {
    let identityAst = undefined;
    const result = (...arr) => {
        if (identityAst == undefined) {
            const newIdentityAst = built_in_expr_1.BuiltInExprUtil.buildAst(identityElement);
            if (!literal_value_node_1.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                throw new Error(`Invalid identity element`);
            }
            identityAst = newIdentityAst;
        }
        let operands = undefined;
        for (const builtInExpr of arr) {
            const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst);
            if (flattenableElements != undefined) {
                /**
                 * Looks like we should flatten this `builtInExpr`
                 */
                if (flattenableElements.length == 0) {
                    continue;
                }
                else {
                    if (operands == undefined) {
                        operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                    }
                    else {
                        operands.push(...flattenableElements);
                    }
                }
            }
            else {
                /**
                 * Can't flatten this `builtInExpr`
                 */
                if (operands == undefined) {
                    operands = [built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr)];
                }
                else {
                    operands.push(built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr));
                }
            }
        }
        return expr_1.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
            /**
             * By convention, applying the operator to zero operands gives you the identity element
             */
            identityAst :
            (operands.length == 1) ?
                /**
                 * By convention, applying the operator on one operand does not do anything to the operand
                 */
                operands[0] :
                ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
    };
    return result;
}
exports.makeChainableOperator = makeChainableOperator;
//# sourceMappingURL=make-chainable-operator.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-1-to-n.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-1-to-n.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const make_operator_1_to_n_1 = __webpack_require__(/*! ./make-operator-1-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-to-n.js");
function makeComparison1ToN(operatorType, typeHint) {
    return make_operator_1_to_n_1.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeComparison1ToN = makeComparison1ToN;
//# sourceMappingURL=make-comparison-1-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2-to-n.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2-to-n.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const make_operator_2_to_n_1 = __webpack_require__(/*! ./make-operator-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2-to-n.js");
function makeComparison2ToN(operatorType, typeHint) {
    return make_operator_2_to_n_1.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeComparison2ToN = makeComparison2ToN;
//# sourceMappingURL=make-comparison-2-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-2.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeComparison2(operatorType, typeHint) {
    const result = (left, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeComparison2 = makeComparison2;
//# sourceMappingURL=make-comparison-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-3.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-3.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making ternary comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeComparison3(operatorType, typeHint) {
    const result = (left, mid, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("MHS", mid);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeComparison3 = makeComparison3;
//# sourceMappingURL=make-comparison-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-projection-2-to-n.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-comparison-projection-2-to-n.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * @todo Better name?
 *
 * Called `Projection` because it picks one of its arguments as the return value.
 * Similar to picking columns in a query.
 */
function makeComparisonProjection2ToN(operatorType, typeHint) {
    const result = (arg0, arg1, ...args) => {
        const arr = [arg0, arg1, ...args];
        return expr_1.ExprUtil.intersect(tm.unsafeOr(...arr.map(built_in_expr_1.BuiltInExprUtil.mapper)), arr, ast_1.OperatorNodeUtil.operatorNode2ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeComparisonProjection2ToN = makeComparisonProjection2ToN;
//# sourceMappingURL=make-comparison-projection-2-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-1-to-n.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-equation-1-to-n.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const make_operator_1_to_n_1 = __webpack_require__(/*! ./make-operator-1-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-to-n.js");
function makeEquation1ToN(operatorType, typeHint) {
    return make_operator_1_to_n_1.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeEquation1ToN = makeEquation1ToN;
//# sourceMappingURL=make-equation-1-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2-to-n.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2-to-n.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const make_operator_2_to_n_1 = __webpack_require__(/*! ./make-operator-2-to-n */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2-to-n.js");
function makeEquation2ToN(operatorType, typeHint) {
    return make_operator_2_to_n_1.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
}
exports.makeEquation2ToN = makeEquation2ToN;
//# sourceMappingURL=make-equation-2-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-equation-2.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making comparison operators.
 *
 * These do not allow `null` to be used in comparisons.
 */
function makeEquation2(operatorType, typeHint) {
    const result = (left, right) => {
        built_in_expr_1.BuiltInExprUtil.assertNonNull("LHS", left);
        built_in_expr_1.BuiltInExprUtil.assertNonNull("RHS", left);
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeEquation2 = makeEquation2;
//# sourceMappingURL=make-equation-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-1.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-1.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making null-safe unary comparison operators.
 */
function makeNullSafeComparison1(operatorType, typeHint) {
    const result = (builtInExpr) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeComparison1 = makeNullSafeComparison1;
//# sourceMappingURL=make-null-safe-comparison-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-2.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-comparison-2.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making null-safe comparison operators.
 *
 * These allow `null` in comparisons.
 */
function makeNullSafeComparison(operatorType, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeComparison = makeNullSafeComparison;
//# sourceMappingURL=make-null-safe-comparison-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-1.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-1.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making null-safe unary equation operators.
 */
function makeNullSafeEquation1(operatorType, typeHint) {
    const result = (builtInExpr) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeEquation1 = makeNullSafeEquation1;
//# sourceMappingURL=make-null-safe-equation-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-2.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-null-safe-equation-2.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Factory for making null-safe equation operators.
 *
 * These allow `null` in equations.
 */
function makeNullSafeEquation2(operatorType, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeNullSafeEquation2 = makeNullSafeEquation2;
//# sourceMappingURL=make-null-safe-equation-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-0.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-0.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function makeOperator0(operatorType, mapper, typeHint) {
    const result = () => {
        return expr_1.expr({
            mapper,
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, ast_1.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
    };
    return result;
}
exports.makeOperator0 = makeOperator0;
//# sourceMappingURL=make-operator-0.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-double-elimination.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-double-elimination.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const util_1 = __webpack_require__(/*! ../../ast/util */ "./node_modules/@squill/squill/dist/ast/util/index.js");
/**
 * Makes a double elimination unary operator.
 *
 * A double elimination function `f` has the following property,
 * `f(f(x)) == x`
 */
function makeOperator1DoubleElimination(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], util_1.tryExtractAstOr(built_in_expr_1.BuiltInExprUtil.buildAst(arg), operand => (ast_1.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType ?
            operand.operands[0] :
            undefined), operand => ast_1.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
    };
    return result;
}
exports.makeOperator1DoubleElimination = makeOperator1DoubleElimination;
//# sourceMappingURL=make-operator-1-double-elimination.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-idempotent.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-idempotent.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const util_1 = __webpack_require__(/*! ../../ast/util */ "./node_modules/@squill/squill/dist/ast/util/index.js");
/**
 * Makes an idempotent unary operator.
 *
 * An idempotent function `f` has the following property,
 * `f(f(x)) == f(x)`
 */
function makeOperator1Idempotent(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], util_1.tryExtractAstOr(built_in_expr_1.BuiltInExprUtil.buildAst(arg), operand => ast_1.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType, operand => ast_1.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
    };
    return result;
}
exports.makeOperator1Idempotent = makeOperator1Idempotent;
//# sourceMappingURL=make-operator-1-idempotent.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-to-n.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1-to-n.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeOperator1ToN(operatorType, mapper, typeHint) {
    const result = (arg0, ...args) => {
        return expr_1.ExprUtil.intersect(mapper, [arg0, ...args], ast_1.OperatorNodeUtil.operatorNode1ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeOperator1ToN = makeOperator1ToN;
//# sourceMappingURL=make-operator-1-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-1.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeOperator1(operatorType, mapper, typeHint) {
    const result = (arg) => {
        return expr_1.ExprUtil.intersect(mapper, [arg], ast_1.OperatorNodeUtil.operatorNode1(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg),
        ], typeHint));
    };
    return result;
}
exports.makeOperator1 = makeOperator1;
//# sourceMappingURL=make-operator-1.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2-to-n.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2-to-n.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeOperator2ToN(operatorType, mapper, typeHint) {
    const result = (arg0, arg1, ...args) => {
        return expr_1.ExprUtil.intersect(mapper, [arg0, arg1, ...args], ast_1.OperatorNodeUtil.operatorNode2ToN(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_1.BuiltInExprUtil.buildAst(arg1),
            ...args.map(built_in_expr_1.BuiltInExprUtil.buildAst),
        ], typeHint));
    };
    return result;
}
exports.makeOperator2ToN = makeOperator2ToN;
//# sourceMappingURL=make-operator-2-to-n.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-2.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeOperator2(operatorType, mapper, typeHint) {
    const result = (left, right) => {
        return expr_1.ExprUtil.intersect(mapper, [left, right], ast_1.OperatorNodeUtil.operatorNode2(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeOperator2 = makeOperator2;
//# sourceMappingURL=make-operator-2.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-3.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/factory/make-operator-3.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function makeOperator3(operatorType, mapper, typeHint) {
    const result = (left, mid, right) => {
        return expr_1.ExprUtil.intersect(mapper, [left, mid, right], ast_1.OperatorNodeUtil.operatorNode3(operatorType, [
            built_in_expr_1.BuiltInExprUtil.buildAst(left),
            built_in_expr_1.BuiltInExprUtil.buildAst(mid),
            built_in_expr_1.BuiltInExprUtil.buildAst(right),
        ], typeHint));
    };
    return result;
}
exports.makeOperator3 = makeOperator3;
//# sourceMappingURL=make-operator-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "./node_modules/@squill/squill/dist/expr-library/aggregate/index.js"));
__export(__webpack_require__(/*! ./aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js"));
__export(__webpack_require__(/*! ./assert */ "./node_modules/@squill/squill/dist/expr-library/assert/index.js"));
__export(__webpack_require__(/*! ./cast */ "./node_modules/@squill/squill/dist/expr-library/cast/index.js"));
__export(__webpack_require__(/*! ./comparison */ "./node_modules/@squill/squill/dist/expr-library/comparison/index.js"));
__export(__webpack_require__(/*! ./control-flow */ "./node_modules/@squill/squill/dist/expr-library/control-flow/index.js"));
__export(__webpack_require__(/*! ./custom-factory */ "./node_modules/@squill/squill/dist/expr-library/custom-factory/index.js"));
__export(__webpack_require__(/*! ./date-time */ "./node_modules/@squill/squill/dist/expr-library/date-time/index.js"));
__export(__webpack_require__(/*! ./equation */ "./node_modules/@squill/squill/dist/expr-library/equation/index.js"));
__export(__webpack_require__(/*! ./factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js"));
__export(__webpack_require__(/*! ./information */ "./node_modules/@squill/squill/dist/expr-library/information/index.js"));
__export(__webpack_require__(/*! ./logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js"));
__export(__webpack_require__(/*! ./logical-3 */ "./node_modules/@squill/squill/dist/expr-library/logical-3/index.js"));
__export(__webpack_require__(/*! ./null-safe-equation */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js"));
__export(__webpack_require__(/*! ./string */ "./node_modules/@squill/squill/dist/expr-library/string/index.js"));
__export(__webpack_require__(/*! ./subquery */ "./node_modules/@squill/squill/dist/expr-library/subquery/index.js"));
const decimal = __webpack_require__(/*! ./decimal */ "./node_modules/@squill/squill/dist/expr-library/decimal/index.js");
exports.decimal = decimal;
const double = __webpack_require__(/*! ./double */ "./node_modules/@squill/squill/dist/expr-library/double/index.js");
exports.double = double;
const integer = __webpack_require__(/*! ./integer */ "./node_modules/@squill/squill/dist/expr-library/integer/index.js");
exports.integer = integer;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/information/current-schema.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/information/current-schema.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * Returns the default (current) schema name as a string.
 * If there is no default schema, returns `NULL`.
 *
 * -----
 *
 * MySQL does not make a distinction between "database" and "schema".
 * PostgreSQL does.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
 * + https://www.postgresql.org/docs/9.2/functions-info.html
 * + https://www.sqlite.org/lang_attach.html
 *
 * -----
 *
 * + MySQL      : `DATABASE()`
 * + PostgreSQL : `CURRENT_SCHEMA`
 * + SQLite     : `'main'` should always be the current database.
 *   + There's also `'temp'`, I guess
 */
exports.currentSchema = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_SCHEMA, tm.orNull(tm.string()));
//# sourceMappingURL=current-schema.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/information/current-user.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/information/current-user.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * On MySQL,
 * > Returns the user name and host name combination for the MySQL account
 * > that the server used to authenticate the current client.
 * > This account determines your access privileges.
 *
 * -----
 *
 * On PostgreSQL,
 * > the user identifier that is applicable for permission checking.
 * > The SQL standard draws a distinction between current_role and current_user,
 * > but PostgreSQL does not, since it unifies users and roles into a single kind of entity.
 *
 * -----
 *
 * SQLite does not have the concept of users.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
 * + https://www.postgresql.org/docs/9.2/functions-info.html
 * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
 *
 * -----
 *
 * + MySQL      : `CURRENT_USER`
 *   + MySQL has a `USER()` function that does something different.
 * + PostgreSQL : `CURRENT_USER`
 * + SQLite     : None. It does not make sense to ask what the current user is.
 */
exports.currentUser = factory_1.makeOperator0(operator_type_1.OperatorType.CURRENT_USER, tm.orNull(tm.string()));
//# sourceMappingURL=current-user.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/information/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/information/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./current-schema */ "./node_modules/@squill/squill/dist/expr-library/information/current-schema.js"));
__export(__webpack_require__(/*! ./current-user */ "./node_modules/@squill/squill/dist/expr-library/information/current-user.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/abs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/abs.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * This function is idempotent.
 * `ABS(ABS(x)) == ABS(x)`
 *
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT ABS(-9223372036854775808)
 * ```
 * The above throws an error on MySQL, PostgreSQL and SQLite.
 */
exports.abs = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.ABSOLUTE_VALUE, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/add.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/add.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807+9223372036854775807;
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT -9223372036854775808+-9223372036854775808
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615+18446744073709551615
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is adding two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is adding two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 + -9223372036854775808 + -9223372036854775808
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL` and the result is correctly `-1`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE` and the result is **incorrectly** `0`.
 *
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintAdd()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.add = factory_1.makeChainableOperator(operator_type_1.OperatorType.ADDITION, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/avg.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/avg.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../../decimal/decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
/**
 * The return type being `DECIMAL` is intentional.
 */
const avgImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(DISTINCT x)`
 * + PostgreSQL : `AVG(DISTINCT x)`
 * + SQLite     : `AVG(DISTINCT x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avgDistinct = (arg) => {
    return avgImpl(true, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avgAll = (arg) => {
    return avgImpl(false, arg);
};
/**
 * Returns the average value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#avg
 *
 * -----
 *
 * + MySQL      : `AVG(x)`
 * + PostgreSQL : `AVG(x)`
 * + SQLite     : `AVG(x)`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 * + MySQL tends to return fewer decimal places.
 * + PostgreSQL tends to return more decimal places.
 * + SQLite uses double precision arithmetic, rather than fixed precision.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.avg = exports.avgAll;
//# sourceMappingURL=avg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./avg */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/avg.js"));
__export(__webpack_require__(/*! ./max */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/max.js"));
__export(__webpack_require__(/*! ./min */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/min.js"));
__export(__webpack_require__(/*! ./sum-as-bigint */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-bigint.js"));
__export(__webpack_require__(/*! ./sum-as-decimal */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-decimal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/max.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/max.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the max value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
 *
 * -----
 *
 * + MySQL      : `MAX(x)`
 * + PostgreSQL : `MAX(x)`
 * + SQLite     : `MAX(x)`
 */
exports.max = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MAX, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/min.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/min.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns the min value of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_corefunc.html#minoreunc
 *
 * -----
 *
 * + MySQL      : `MIN(x)`
 * + PostgreSQL : `MIN(x)`
 * + SQLite     : `MIN(x)`
 */
exports.min = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_MIN, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-bigint.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-bigint.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const sumAsBigIntSignedImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(DISTINCT x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(DISTINCT x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(DISTINCT x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSignedDistinct = (arg) => {
    return sumAsBigIntSignedImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSignedAll = (arg) => {
    return sumAsBigIntSignedImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `CAST(SUM(x) AS SIGNED)`
 *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
 * + PostgreSQL : `SUM(x)`
 *   + Throws on integer overflow
 * + SQLite     : `SUM(x)`
 *   + Throws on integer overflow
 *
 */
exports.sumAsBigIntSigned = exports.sumAsBigIntSignedAll;
//# sourceMappingURL=sum-as-bigint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-decimal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/aggregate/sum-as-decimal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
const decimal_mapper_1 = __webpack_require__(/*! ../../decimal/decimal-mapper */ "./node_modules/@squill/squill/dist/expr-library/decimal/decimal-mapper.js");
/**
 * The return type being `DECIMAL` is intentional.
 */
const sumAsDecimalImpl = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_SUM_AS_DECIMAL, decimal_mapper_1.decimalMapper.orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(DISTINCT x)`
 * + PostgreSQL : `SUM(DISTINCT CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(DISTINCT CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimalDistinct = (arg) => {
    return sumAsDecimalImpl(true, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimalAll = (arg) => {
    return sumAsDecimalImpl(false, arg);
};
/**
 * Returns the total sum of non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#sumunc
 *
 * -----
 *
 * + MySQL      : `SUM(x)`
 * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
 * + SQLite     : `SUM(CAST(x AS NUMERIC))`
 *
 * -----
 *
 * No guarantees are made about the precision of the return type.
 *
 * @todo Some kind of `DECIMAL` polyfill for SQLite.
 */
exports.sumAsDecimal = exports.sumAsDecimalAll;
//# sourceMappingURL=sum-as-decimal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-and.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-and.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.bitwiseAnd = factory_1.makeChainableOperator(operator_type_1.OperatorType.BITWISE_AND, tm.BigInt(-1), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-and.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-left-shift.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-left-shift.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Performs a **signed** bitwise left-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x << y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `<<`
 * + SQLite       : `<<`
 *
 * -----
 *
 * If the RHS is negative, the behaviour is cannot be unified.
 *
 * + MySQL      : `2 << -1` is `0`
 * + PostgreSQL : `2 << -1` is `0`
 * + SQLite     : `2 << -1` is `1`
 * + JavaScript : `2 << -1` is `0`
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; undefined behaviour if negative
 *
 * @see bitwiseLeftShift
 */
exports.bitwiseLeftShiftUnsafe = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_LEFT_SHIFT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Performs a **signed** bitwise left-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x << y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `<<`
 * + SQLite       : `<<`
 *
 * -----
 *
 * If the RHS is negative, this throws.
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; throws if negative
 *
 * @see bitwiseLeftShiftUnsafe
 */
function bitwiseLeftShift(left, right) {
    tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
    return expr_1.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.BITWISE_LEFT_SHIFT, [
        built_in_expr_1.BuiltInExprUtil.buildAst(left),
        built_in_expr_1.BuiltInExprUtil.buildAst(right),
    ], type_hint_1.TypeHint.BIGINT_SIGNED));
}
exports.bitwiseLeftShift = bitwiseLeftShift;
//# sourceMappingURL=bitwise-left-shift.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-not.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-not.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `~(~(x)) == x`
 */
exports.bitwiseNot = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.BITWISE_NOT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-not.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-or.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-or.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.bitwiseOr = factory_1.makeChainableOperator(operator_type_1.OperatorType.BITWISE_OR, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-right-shift.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-right-shift.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Performs a **signed** bitwise right-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x >> y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `>>`
 * + SQLite       : `>>`
 *
 * -----
 *
 * If the RHS is negative, the behaviour is cannot be unified.
 *
 * + MySQL      : `2 >> -1` is `0`
 * + PostgreSQL : `2 >> -1` is `0`
 * + SQLite     : `2 >> -1` is `4`
 * + JavaScript : `2 >> -1` is `0`
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; undefined behaviour if negative
 *
 * @see bitwiseRightShift
 */
exports.bitwiseRightShiftUnsafe = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_RIGHT_SHIFT, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
/**
 * Performs a **signed** bitwise right-shift.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
 * + https://www.postgresql.org/docs/9.0/functions-math.html
 * + https://www.sqlite.org/lang_expr.html#binaryops
 *
 * -----
 *
 * + MySQL        : `CAST(x >> y AS SIGNED)`
 *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
 * + PostgreSQL   : `>>`
 * + SQLite       : `>>`
 *
 * -----
 *
 * If the RHS is negative, this throws.
 *
 * -----
 *
 * @param left  - The value to perform the shift on
 * @param right - The amount of bits to shift; throws if negative
 *
 * @see bitwiseRightShiftUnsafe
 */
function bitwiseRightShift(left, right) {
    tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
    return expr_1.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_1.OperatorNodeUtil.operatorNode2(operator_type_1.OperatorType.BITWISE_RIGHT_SHIFT, [
        built_in_expr_1.BuiltInExprUtil.buildAst(left),
        built_in_expr_1.BuiltInExprUtil.buildAst(right),
    ], type_hint_1.TypeHint.BIGINT_SIGNED));
}
exports.bitwiseRightShift = bitwiseRightShift;
//# sourceMappingURL=bitwise-right-shift.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-xor.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-xor.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
exports.bitwiseXor = factory_1.makeOperator2(operator_type_1.OperatorType.BITWISE_XOR, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bitwise-xor.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/bitwise/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bitwise-and */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-and.js"));
__export(__webpack_require__(/*! ./bitwise-left-shift */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-left-shift.js"));
__export(__webpack_require__(/*! ./bitwise-not */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-not.js"));
__export(__webpack_require__(/*! ./bitwise-or */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-or.js"));
__export(__webpack_require__(/*! ./bitwise-right-shift */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-right-shift.js"));
__export(__webpack_require__(/*! ./bitwise-xor */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/bitwise-xor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "./node_modules/@squill/squill/dist/expr-library/integer/aggregate/index.js"));
__export(__webpack_require__(/*! ./bitwise */ "./node_modules/@squill/squill/dist/expr-library/integer/bitwise/index.js"));
__export(__webpack_require__(/*! ./abs */ "./node_modules/@squill/squill/dist/expr-library/integer/abs.js"));
__export(__webpack_require__(/*! ./add */ "./node_modules/@squill/squill/dist/expr-library/integer/add.js"));
__export(__webpack_require__(/*! ./integer-div */ "./node_modules/@squill/squill/dist/expr-library/integer/integer-div.js"));
__export(__webpack_require__(/*! ./integer-remainder */ "./node_modules/@squill/squill/dist/expr-library/integer/integer-remainder.js"));
__export(__webpack_require__(/*! ./mul */ "./node_modules/@squill/squill/dist/expr-library/integer/mul.js"));
__export(__webpack_require__(/*! ./neg */ "./node_modules/@squill/squill/dist/expr-library/integer/neg.js"));
__export(__webpack_require__(/*! ./random-bigint-signed */ "./node_modules/@squill/squill/dist/expr-library/integer/random-bigint-signed.js"));
__export(__webpack_require__(/*! ./sign */ "./node_modules/@squill/squill/dist/expr-library/integer/sign.js"));
__export(__webpack_require__(/*! ./sub */ "./node_modules/@squill/squill/dist/expr-library/integer/sub.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/integer-div.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/integer-div.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * Treats both arguments as integers and performs integer division
 *
 * -----
 *
 * ### Divide by zero
 *
 * ```sql
 *  SELECT 9223372036854775807 DIV 0; -- MySQL
 *  SELECT 9223372036854775807 / 0; -- PostgreSQL, SQLite
 * ```
 * The above gives `NULL` for MySQL and SQLite.
 * The above throws an error for PostgreSQL.
 */
exports.integerDiv = factory_1.makeOperator2(operator_type_1.OperatorType.INTEGER_DIVISION, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=integer-div.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/integer-remainder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/integer-remainder.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * The remainder after performing integer division.
 *
 * Integer division is defined as,
 * `dividend / divisor`
 *
 * ```ts
 * result = sign(dividend) * abs(remainder)
 * ```
 *
 * If the dividend is positive, the result is positive.
 * If the dividend is negative, the result is negative.
 *
 * ```ts
 * integerRemainder( 5,  3); //2
 * integerRemainder( 5, -3); //2
 * integerRemainder(-5,  3); //-2
 * integerRemainder(-5, -3); //-2
 * ```
 *
 * -----
 *
 * ### Divide by zero
 *
 * ```sql
 *  SELECT 9223372036854775807 % 0
 * ```
 * The above gives `NULL` for MySQL and SQLite.
 * The above throws an error for PostgreSQL.
 */
exports.integerRemainder = factory_1.makeOperator2(operator_type_1.OperatorType.INTEGER_REMAINDER, tm.mysql.bigIntSigned().orNull(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=integer-remainder.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/mul.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/mul.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807*9223372036854775807;
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT 9223372036854775807*-9223372036854775808
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615*18446744073709551615
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is multiplying two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is multiplying two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 * -9223372036854775808
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
 *
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintMul()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.mul = factory_1.makeChainableOperator(operator_type_1.OperatorType.MULTIPLICATION, tm.BigInt(1), tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=mul.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/neg.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/neg.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function has the double elimination property.
 * `NEG(NEG(x)) == x`
 *
 * -----
 *
 * ### `BIGINT SIGNED` too large (from database)
 *
 * Be careful, however,
 * ```sql
 *  CREATE TABLE a (id BIGINT);
 *  INSERT INTO a (id) VALUES (-9223372036854775808);
 *
 *  SELECT
 *      -- 9223372036854775808 is too big
 *      -- to fit in signed bigint
 *      -id
 *  FROM
 *      a
 * ```
 *
 * The above will throw an error on both MySQL and PostgreSQL
 * because `9223372036854775808` is not a valid signed bigint value.
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * ### Double Unary Minus Elimination on Negative `BIGINT SIGNED` Literal
 *
 * The following will not throw an error but will silently
 * cast the result,
 * ```sql
 *  SELECT -(-9223372036854775808);
 * ```
 * Both **do not** error in MySQL and PostgreSQL.
 * PostgreSQL seems to perform double unary minus elimination and treats the result as a `DECIMAL` literal.
 * MySQL seems to perform double unary minus elimination and treats the result as an `BIGINT UNSIGNED` literal.
 *
 * SQLite casts to `DOUBLE`
 *
 * -----
 *
 * ```sql
 *  SELECT -(
 *      CAST(-9223372036854775808 AS BIGINT)
 *  ); -- PostgreSQL
 *
 *  SELECT -(-9223372036854775808 + 0); -- PostgreSQL
 *
 *  SELECT -(
 *      CAST(-9223372036854775808 AS BIGINT SIGNED)
 *  ); -- MySQL
 * ```
 * The above throws an error on PostgreSQL.
 * The above silently casts to an `BIGINT UNSIGNED` on MySQL.
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * ```sql
 *  SELECT
 *      CAST(-(-9223372036854775808) AS BIGINT); -- PostgreSQL
 *
 *  SELECT
 *      CAST(-(-9223372036854775808) AS BIGINT SIGNED); -- MySQL
 * ```
 * The above throws an error on PostgreSQL.
 * The above silently casts to an `BIGINT UNSIGNED`
 *
 * SQLite casts to `DOUBLE`.
 *
 * -----
 *
 * MySQL seems to treat `BIGINT SIGNED` values from **columns** and **literals** differently!
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small.
 *
 * MySQL-specific,
 * ```sql
 *  CREATE TABLE a (id  BIGINT UNSIGNED);
 *  INSERT INTO a (id) VALUES (9223372036854775809);
 *  SELECT -id FROM a;
 * ```
 *
 * `-9223372036854775809` is too small to fit in `BIGINT SIGNED`. This will throw an error.
 *
 * -----
 *
 * ```sql
 *  SELECT -CAST(9223372036854775809 AS UNSIGNED);
 * ```
 * The above gives you a `DECIMAL` type with value `-9223372036854775809` in MySQL.
 * PostgreSQL and SQLite do not have `BIGINT UNSIGNED`.
 *
 * -----
 *
 * MySQL and PostgreSQL query builders should perform the unary minus on the library
 * level as much as possible. However, it is not always feasible...
 *
 * PostgreSQL should perform bigint unary minus with `-CAST(x AS BIGINT)` to avoid implicit conversions.
 *
 * MySQL should just use `CAST(-x AS SIGNED)`.
 *
 * However, on MySQL,
 * `CAST(-18446744073709551615 AS SIGNED)` === `-9223372036854775808` (signed bigint minimum value)
 *
 * It would be nice if it threw an error instead.
 * It throws an error on PostgreSQL.
 *
 * SQLite should have a special `bigintNeg()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.neg = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.UNARY_MINUS, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=neg.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/random-bigint-signed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/random-bigint-signed.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns a random `BIGINT SIGNED` in the range,
 * [-9223372036854775808, 9223372036854775807]
 *
 * -----
 *
 * MySQL,
 * ```sql
 *  CAST(
 *      CAST(RAND() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
 *      AS SIGNED
 *  )
 * ```
 *
 * PostgreSQL,
 * ```sql
 *  CAST(
 *      CAST(RANDOM() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
 *      AS BIGINT
 *  )
 * ```
 *
 * SQLite,
 * ```sql
 *  RANDOM()
 * ```
 */
exports.randomBigIntSigned = factory_1.makeOperator0(operator_type_1.OperatorType.RANDOM, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=random-bigint-signed.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/sign.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/sign.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * This function is idempotent.
 * `SIGN(SIGN(x)) == SIGN(x)`
 *
 * Will return -1, 0, 1
 */
exports.sign = factory_1.makeOperator1Idempotent(operator_type_1.OperatorType.SIGN, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/integer/sub.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/integer/sub.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * -----
 *
 * ### `BIGINT SIGNED` too large
 *
 * ```sql
 *  SELECT 9223372036854775807- (-9223372036854775808);
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT SIGNED` too small
 *
 * ```sql
 *  SELECT -9223372036854775808 - 9223372036854775807
 * ```
 * The above throws an error on both MySQL and PostgreSQL.
 * SQLite casts to a `DOUBLE`.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too large
 *
 * ```sql
 *  SELECT 18446744073709551615 - (-9223372036854775808)
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is subtracting two `DECIMAL`s.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is subtracting two `DOUBLE`s.
 *
 * -----
 *
 * ### `BIGINT UNSIGNED` too small
 *
 * ```sql
 *  SELECT 18446744073709551615 - 9223372036854775807 - 9223372036854775807 - 9223372036854775807
 * ```
 * MySQL throws an error.
 * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
 * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
 * -----
 *
 * ### Ensuring consistent behaviour
 *
 * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * MySQL's behaviour is perfect for `BIGINT SIGNED`.
 *
 * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
 * It is fine to use it as an auto-increment identifier in MySQL.
 * Just don't perform math on it.
 *
 * SQLite should have a special `bigintSub()` polyfill that does not cast to `DOUBLE`
 * and throws an error on overflow.
 */
exports.sub = factory_1.makeOperator2(operator_type_1.OperatorType.SUBTRACTION, tm.mysql.bigIntSigned(), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=sub.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/and-3.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/and-3.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
 *
 * This version of the `AND` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link and}
 */
exports.and3 = factory_1.makeChainableOperator(operator_type_1.OperatorType.AND, true, tm.mysql.boolean().orNull());
//# sourceMappingURL=and-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./and-3 */ "./node_modules/@squill/squill/dist/expr-library/logical-3/and-3.js"));
__export(__webpack_require__(/*! ./is-false */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-false.js"));
__export(__webpack_require__(/*! ./is-not-false */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-false.js"));
__export(__webpack_require__(/*! ./is-not-true */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-true.js"));
__export(__webpack_require__(/*! ./is-not-unknown */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-unknown.js"));
__export(__webpack_require__(/*! ./is-true */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-true.js"));
__export(__webpack_require__(/*! ./is-unknown */ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-unknown.js"));
__export(__webpack_require__(/*! ./not-3 */ "./node_modules/@squill/squill/dist/expr-library/logical-3/not-3.js"));
__export(__webpack_require__(/*! ./or-3 */ "./node_modules/@squill/squill/dist/expr-library/logical-3/or-3.js"));
__export(__webpack_require__(/*! ./xor-3 */ "./node_modules/@squill/squill/dist/expr-library/logical-3/xor-3.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-false.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-false.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `FALSE`.
 *
 * ```sql
 * mysql> SELECT (1 IS FALSE), (0 IS FALSE), (NULL IS FALSE);
 *         -> 0, 1, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS FALSE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isFalse = factory_1.makeOperator1(operator_type_1.OperatorType.IS_FALSE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-false.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-false.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-false.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `FALSE`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT FALSE), (0 IS NOT FALSE), (NULL IS NOT FALSE);
 *         -> 1, 0, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS NOT FALSE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotFalse = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_FALSE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-false.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-true.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-true.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `TRUE`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT TRUE), (0 IS NOT TRUE), (NULL IS NOT TRUE);
 *         -> 0, 1, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(1 IS NOT TRUE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotTrue = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_TRUE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-true.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-unknown.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-not-unknown.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
 *
 * Tests whether a value is not `UNKNOWN`.
 * Basically an alias for `IS NOT NULL`
 *
 * ```sql
 * mysql> SELECT (1 IS NOT UNKNOWN), (0 IS NOT UNKNOWN), (NULL IS NOT UNKNOWN);
 *         -> 1, 1, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS NOT UNKNOWN)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isNotUnknown = factory_1.makeOperator1(operator_type_1.OperatorType.IS_NOT_UNKNOWN, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-not-unknown.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-true.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-true.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `TRUE`.
 *
 * ```sql
 * mysql> SELECT (1 IS TRUE), (0 IS TRUE), (NULL IS TRUE);
 *         -> 1, 0, 0
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(1 IS TRUE)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isTrue = factory_1.makeOperator1(operator_type_1.OperatorType.IS_TRUE, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-true.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/is-unknown.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/is-unknown.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
 *
 * Tests whether a value is `UNKNOWN`.
 * Basically an alias for `IS NULL`
 *
 * ```sql
 * mysql> SELECT (1 IS UNKNOWN), (0 IS UNKNOWN), (NULL IS UNKNOWN);
 *         -> 0, 0, 1
 * ```
 *
 * -----
 *
 * PostgreSQL does not allow `(0 IS UNKNOWN)` because PostgreSQL
 * has an actual `boolean` type.
 */
/**
 * @todo Monitor this PR,
 * https://github.com/microsoft/TypeScript/issues/33561
 */
exports.isUnknown = factory_1.makeOperator1(operator_type_1.OperatorType.IS_UNKNOWN, tm.mysql.boolean(), type_hint_1.TypeHint.BOOLEAN);
//# sourceMappingURL=is-unknown.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/not-3.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/not-3.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
 *
 * This version of the `NOT` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link not}
 */
exports.not3 = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.NOT, tm.mysql.boolean().orNull());
//# sourceMappingURL=not-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/or-3.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/or-3.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
 *
 * This version of the `OR` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link or}
 */
exports.or3 = factory_1.makeChainableOperator(operator_type_1.OperatorType.OR, false, tm.mysql.boolean().orNull());
//# sourceMappingURL=or-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical-3/xor-3.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical-3/xor-3.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
 *
 * This version of the `XOR` operator allows `NULL`.
 *
 * For two-valued logic, @see {@link xor}
 */
exports.xor3 = factory_1.makeOperator2(operator_type_1.OperatorType.XOR, tm.mysql.boolean().orNull());
//# sourceMappingURL=xor-3.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/and.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/and.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
 *
 * This version of the `AND` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link and3}
 */
exports.and = factory_1.makeChainableOperator(operator_type_1.OperatorType.AND, true, tm.mysql.boolean());
//# sourceMappingURL=and.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./and */ "./node_modules/@squill/squill/dist/expr-library/logical/and.js"));
__export(__webpack_require__(/*! ./is-not-null-and */ "./node_modules/@squill/squill/dist/expr-library/logical/is-not-null-and.js"));
__export(__webpack_require__(/*! ./is-null-or */ "./node_modules/@squill/squill/dist/expr-library/logical/is-null-or.js"));
__export(__webpack_require__(/*! ./not */ "./node_modules/@squill/squill/dist/expr-library/logical/not.js"));
__export(__webpack_require__(/*! ./or */ "./node_modules/@squill/squill/dist/expr-library/logical/or.js"));
__export(__webpack_require__(/*! ./xor */ "./node_modules/@squill/squill/dist/expr-library/logical/xor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/is-not-null-and.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/is-not-null-and.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js");
const and_1 = __webpack_require__(/*! ./and */ "./node_modules/@squill/squill/dist/expr-library/logical/and.js");
function isNotNullAnd(column, builtInExprDelegate) {
    return and_1.and(null_safe_equation_1.isNotNull(column), builtInExprDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.isNotNullAnd = isNotNullAnd;
//# sourceMappingURL=is-not-null-and.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/is-null-or.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/is-null-or.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const null_safe_equation_1 = __webpack_require__(/*! ../null-safe-equation */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js");
const or_1 = __webpack_require__(/*! ./or */ "./node_modules/@squill/squill/dist/expr-library/logical/or.js");
function isNullOr(column, builtInExprDelegate) {
    return or_1.or(null_safe_equation_1.isNull(column), builtInExprDelegate({
        [column.columnAlias]: column_1.ColumnUtil.toNonNullable(column)
    }));
}
exports.isNullOr = isNullOr;
//# sourceMappingURL=is-null-or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/not.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/not.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
 *
 * This version of the `NOT` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link not3}
 */
exports.not = factory_1.makeOperator1DoubleElimination(operator_type_1.OperatorType.NOT, tm.mysql.boolean());
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/or.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/or.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
 *
 * This version of the `OR` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link or3}
 */
exports.or = factory_1.makeChainableOperator(operator_type_1.OperatorType.OR, false, tm.mysql.boolean());
//# sourceMappingURL=or.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/logical/xor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/logical/xor.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
 *
 * This version of the `XOR` operator forbids `NULL`.
 *
 * For three-valued logic, @see {@link xor3}
 */
exports.xor = factory_1.makeOperator2(operator_type_1.OperatorType.XOR, tm.mysql.boolean());
//# sourceMappingURL=xor.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js ***!
  \**************************************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns) {
    const candidateKeys = table_1.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
    const srcColumnAliases = srcColumns.map(column => column.columnAlias);
    const dstCandidateKey = candidateKeys.find(candidateKey => key_1.KeyUtil.isEqual(candidateKey, srcColumnAliases));
    if (dstCandidateKey == undefined) {
        throw new Error(`${column_map_1.ColumnMapUtil.tableAlias(src.columns)} (${srcColumnAliases.join(",")}) cannot be used to compare with candidate keys of ${column_map_1.ColumnMapUtil.tableAlias(dst.columns)}`);
    }
    column_map_1.ColumnMapUtil.assertIsNullSafeComparable(column_map_1.ColumnMapUtil.fromColumnArray(srcColumns), type_util_1.pickOwnEnumerable(dst.columns, dstCandidateKey));
    return dstCandidateKey;
}
exports.assertNullSafeComparableToCandidateKeysOfTable = assertNullSafeComparableToCandidateKeysOfTable;
//# sourceMappingURL=assert-null-safe-comparable-to-candidate-keys-of-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const logical_1 = __webpack_require__(/*! ../../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const assert_null_safe_comparable_to_candidate_keys_of_table_1 = __webpack_require__(/*! ./assert-null-safe-comparable-to-candidate-keys-of-table */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js");
const null_safe_eq_1 = __webpack_require__(/*! ../null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js");
exports.eqCandidateKeyOfTable = ((src, dst, eqCandidateKeyOfTableDelegate) => {
    const candidateKeys = table_1.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
    const columnAliases = [];
    for (const key of candidateKeys) {
        columnAliases.push(...key);
    }
    const columns = type_util_1.pickOwnEnumerable(src.columns, columnAliases);
    const srcColumns = eqCandidateKeyOfTableDelegate(columns);
    const dstCandidateKey = assert_null_safe_comparable_to_candidate_keys_of_table_1.assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns);
    /**
     * No need to `.sort()`, just use `candidateKey` and the order
     * the user set.
     */
    const arr = dstCandidateKey.map((columnAlias) => {
        /**
         * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
         */
        const expr = null_safe_eq_1.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-candidate-key-of-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-null-safe-comparable-to-candidate-keys-of-table */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table.js"));
__export(__webpack_require__(/*! ./eq-candidate-key-of-table */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const candidate_key_1 = __webpack_require__(/*! ../../candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
exports.eqCandidateKey = ((table, candidateKeyInput) => {
    const candidateKey = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.candidateKey`, candidateKeyInput);
    /**
     * We `.sort()` the keys so our resulting SQL is deterministic,
     * regardless of how `candidateKey` was constructed.
     */
    const arr = Object.keys(candidateKey).sort().map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], candidateKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-columns.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-columns.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const partial_row_1 = __webpack_require__(/*! ../../partial-row */ "./node_modules/@squill/squill/dist/partial-row/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
exports.eqColumns = ((table, columnsInput) => {
    const columns = partial_row_1.PartialRowUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.columns`, columnsInput);
    const arr = Object.keys(columns)
        .filter((columnAlias) => {
        return columns[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `columns` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], columns[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const logical_1 = __webpack_require__(/*! ../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js");
exports.eqPrimaryKeyOfTable = ((src, dst) => {
    table_1.TableUtil.assertHasNullSafeComparablePrimaryKey(dst, src.columns);
    /**
     * No need to `.sort()`, just use `primaryKey` and the order
     * the user set.
     */
    const arr = dst.primaryKey.map((columnAlias) => {
        /**
         * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
         */
        const expr = null_safe_eq_1.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-primary-key-of-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-super-key.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-super-key.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logical_1 = __webpack_require__(/*! ../logical */ "./node_modules/@squill/squill/dist/expr-library/logical/index.js");
const super_key_1 = __webpack_require__(/*! ../../super-key */ "./node_modules/@squill/squill/dist/super-key/index.js");
const column_map_1 = __webpack_require__(/*! ../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const null_safe_eq_1 = __webpack_require__(/*! ./null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
exports.eqSuperKey = ((table, superKeyInput) => {
    const superKey = super_key_1.SuperKeyUtil.mapper(table)(`${column_map_1.ColumnMapUtil.tableAlias(table.columns)}.superKey`, superKeyInput);
    const arr = Object.keys(superKey)
        .filter((columnAlias) => {
        return superKey[columnAlias] !== undefined;
    })
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `superKey` was constructed.
         */
        .sort()
        .map((columnAlias) => {
        const expr = null_safe_eq_1.nullSafeEq(table.columns[columnAlias], built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
        return expr;
    });
    const result = logical_1.and(...arr);
    return result;
});
//# sourceMappingURL=eq-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./eq-candidate-key-of-table */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key-of-table/index.js"));
__export(__webpack_require__(/*! ./eq-candidate-key */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-candidate-key.js"));
__export(__webpack_require__(/*! ./eq-columns */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-columns.js"));
__export(__webpack_require__(/*! ./eq-primary-key-of-table */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-primary-key-of-table.js"));
__export(__webpack_require__(/*! ./eq-super-key */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/eq-super-key.js"));
__export(__webpack_require__(/*! ./is-not-null */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-not-null.js"));
__export(__webpack_require__(/*! ./is-null */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-null.js"));
__export(__webpack_require__(/*! ./not-null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/not-null-safe-eq.js"));
__export(__webpack_require__(/*! ./null-safe-eq */ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-not-null.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-not-null.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
 *
 * Tests whether a value is not `NULL`.
 *
 * ```sql
 * mysql> SELECT (1 IS NOT NULL), (0 IS NOT NULL), (NULL IS NOT NULL);
 *         -> 1, 1, 0
 * ```
 */
exports.isNotNull = factory_1.makeNullSafeEquation1(operator_type_1.OperatorType.IS_NOT_NULL);
//# sourceMappingURL=is-not-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-null.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/is-null.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null
 *
 * Tests whether a value is NULL.
 *
 * ```sql
 * mysql> SELECT (1 IS NULL), (0 IS NULL), (NULL IS NULL);
 *         -> 0, 0, 1
 * ```
 */
exports.isNull = factory_1.makeNullSafeEquation1(operator_type_1.OperatorType.IS_NULL);
//# sourceMappingURL=is-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/not-null-safe-eq.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/not-null-safe-eq.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
 *
 * This operator allows `NULL`.
 *
 * This operator performs an equality comparison like the `=` operator,
 * but returns
 * + `false` rather than `NULL` if both operands are `NULL`, and
 * + `true` rather than `NULL` if one operand is `NULL`.
 *
 * For regular equality, @see {@link eq}
 */
exports.notNullSafeEq = factory_1.makeNullSafeEquation2(operator_type_1.OperatorType.NOT_NULL_SAFE_EQUAL);
//# sourceMappingURL=not-null-safe-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/null-safe-equation/null-safe-eq.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
/**
 * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
 *
 * This operator allows `NULL`.
 *
 * This operator performs an equality comparison like the `=` operator,
 * but returns
 * + `true` rather than `NULL` if both operands are `NULL`, and
 * + `false` rather than `NULL` if one operand is `NULL`.
 *
 * For regular equality, @see {@link eq}
 */
exports.nullSafeEq = factory_1.makeNullSafeEquation2(operator_type_1.OperatorType.NULL_SAFE_EQUAL);
//# sourceMappingURL=null-safe-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/aggregate/group-concat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/aggregate/group-concat.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const aggregate_factory_1 = __webpack_require__(/*! ../../aggregate-factory */ "./node_modules/@squill/squill/dist/expr-library/aggregate-factory/index.js");
/**
 * Returns a string result with the concatenated non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
 *
 * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
 * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
 * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
 *   + The order of the concatenated elements is arbitrary.
 *   + Uses comma as separator
 *
 * -----
 *
 * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
 * for the DB-unified implementation.
 *
 * Unless we modify the SQLite implementation with a user-defined function?
 *
 * -----
 *
 * @param arg - The expression to aggregate
 *
 * @todo Investigate replacing SQLite `GROUP_CONCAT()` with user-defined function
 */
exports.groupConcatDistinct = aggregate_factory_1.makeAggregateOperator1(operator_type_1.OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string result with the concatenated non-`NULL` values from a group.
 *
 * It returns `NULL` if there are no non-`NULL` values.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
 * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
 * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
 *
 * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
 * + PostgreSQL : `STRING_AGG(expr, separator)`
 * + SQLite     : `GROUP_CONCAT(expr, separator)`
 *   + The order of the concatenated elements is arbitrary.
 *
 * @param left  - The expression to aggregate
 * @param right - The separator between expressions
 */
exports.groupConcatAll = aggregate_factory_1.makeAggregateOperator2(operator_type_1.OperatorType.AGGREGATE_GROUP_CONCAT_ALL, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=group-concat.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/aggregate/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/aggregate/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./group-concat */ "./node_modules/@squill/squill/dist/expr-library/string/aggregate/group-concat.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/ascii.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/ascii.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the numeric value of the leftmost character of the string.
 *
 * -----
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `ASCII(x)`
 * + PostgreSQL     : `ASCII(x)`
 * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  ASCII(CHAR(128 USING latin1))
 *  > 128
 *
 *  ASCII(CHAR(128 USING utf32))
 *  > 0
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/2
 */
exports.ascii = factory_1.makeOperator1(operator_type_1.OperatorType.ASCII, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=ascii.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/bin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/bin.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns a binary string representation of a `bigint` value
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
 *
 * -----
 *
 * + MySQL          : `BIN(x)`
 * + PostgreSQL     : None. Implement with,
 * ```sql
 *  REGEXP_REPLACE(
 *      (x)::bit(64)::varchar(64),
 *      '^0+(\d+)$',
 *      '\1'
 *  )
 * ```
 * + SQLite         : None. Implement with,
 * ```ts
 * //x >= 0
 * (x).toString(2)
 * //x < 0
 * (2n**64n + BigInt(x)).toString(2)
 * ```
 */
exports.bin = factory_1.makeOperator1(operator_type_1.OperatorType.BIN, tm.match(/^[01]+$/), type_hint_1.TypeHint.BIGINT_SIGNED);
//# sourceMappingURL=bin.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/bit-length.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/bit-length.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the length of the string in bits.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `BIT_LENGTH(x)`
 * + PostgreSQL     : `BIT_LENGTH(x)`
 * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  BIT_LENGTH(CHAR(128 USING latin1))
 *  > 8
 *
 *  BIT_LENGTH(CHAR(128 USING utf32))
 *  > 32
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/3
 */
exports.bitLength = factory_1.makeOperator1(operator_type_1.OperatorType.BIT_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=bit-length.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/char-length.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/char-length.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the length of the string, measured in characters.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#length
 * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
 *
 * -----
 *
 * + MySQL          : `CHAR_LENGTH(x)`
 *   + `CHAR_LENGTH('cafe')` returns 6
 * + PostgreSQL     : `CHAR_LENGTH(x)`
 *   + `CHAR_LENGTH('cafe')` returns 8
 * + SQLite         : `LENGTH(x)`
 *   + `LENGTH('cafe')` returns 6
 *
 * -----
 *
 * Surrogate pairs may cause results to differ across databases.
 */
exports.charLength = factory_1.makeOperator1(operator_type_1.OperatorType.CHAR_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=char-length.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/concat-ws.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/concat-ws.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Concatenate With Separator.
 * The first argument is the separator for the rest of the arguments.
 * The separator is added between the strings to be concatenated.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `CONCAT_WS(separator, x, ...)`
 *   + If the separator is `NULL`, the result is `NULL`
 *   + Ignores `NULL` arguments after the separator
 * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
 *   + If the separator is `NULL`, the result is `NULL`
 *   + Ignores `NULL` arguments after the separator
 * + SQLite         : None. Implement with user-defined function.
 */
exports.concatWs = factory_1.makeOperator2ToN(operator_type_1.OperatorType.CONCAT_WS, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=concat-ws.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/concat.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/concat.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string that results from concatenating the arguments.
 * May have one or more arguments.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
 *   + MySQL actually treats `||` as the boolean `OR` operator.
 * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
 *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
 *     + This is different from MySQL's `CONCAT()`
 * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
 *   + SQLite uses an operator, not a function, to concatenate strings
 *   + https://www.sqlite.org/lang_expr.html#collateop
 *
 * -----
 *
 * The SQL standard says,
 * > `<concatenation operator>` is an operator, `||`,
 * > that returns the character string made by joining its character string operands in the order given.
 *
 * MySQL actually treats `||` as the boolean `OR` operator.
 *
 * -----
 *
 * @see nullSafeConcat
 */
exports.concat = factory_1.makeOperator1ToN(operator_type_1.OperatorType.CONCAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/escape-like-pattern.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/escape-like-pattern.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const like_1 = __webpack_require__(/*! ./like */ "./node_modules/@squill/squill/dist/expr-library/string/like.js");
//TODO-FEATURE Create a version using MySQL/PostgreSQL/SQLite queries
//REGEXP_REPLACE(pattern, '(\\%|\\_)', '\\$1', 1, 0, 'm') or something
/**
 * With `LIKE` you can use the following two wildcard characters in the pattern:
 *
 * + `%` matches any number of characters, even zero characters.
 * + `_` matches exactly one character.
 *
 * This function just prepends `escapeChar` to each of the above characters.
 * It also prepends `escapeChar` to itself.
 */
function escapeLikePattern(pattern, escapeChar) {
    like_1.assertValidLikeEscapeChar(escapeChar);
    /**
     * Escape occurrences of the `escapeChar`
     */
    pattern = pattern.split(escapeChar).join(escapeChar + escapeChar);
    /**
     * Escape wildcard characters
     */
    return pattern.replace(/(\%|\_)/g, s => escapeChar + s);
}
exports.escapeLikePattern = escapeLikePattern;
//# sourceMappingURL=escape-like-pattern.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/from-base64.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/from-base64.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Takes a base-64 encoded string,
 * and returns the decoded result as a `BLOB/bytea`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `FROM_BASE64(x)`
 *   + `FROM_BASE64('~')` === `NULL`
 * + PostgreSQL     : `DECODE(x, 'base64')`
 *   + `DECODE('~', 'base64')` throws an error
 * + SQLite         : None, implement with user-defined function `atob()`
 *   + `atob('~')` throws an error
 *
 * -----
 *
 * If the input is not a valid base-64 string, some databases throw an error.
 * Others return `NULL`.
 */
exports.fromBase64 = factory_1.makeOperator1(operator_type_1.OperatorType.FROM_BASE64, tm.orNull(tm.instanceOfUint8Array()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=from-base64.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/hex.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/hex.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Converts each byte of the input to two hexadecimal digits.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#hex
 *
 * -----
 *
 * + MySQL          : `HEX(x)`
 * + PostgreSQL     : `ENCODE(x, 'hex')`
 * + SQLite         : `HEX(x)`
 */
exports.hex = factory_1.makeOperator1(operator_type_1.OperatorType.HEX, tm.string(), type_hint_1.TypeHint.BUFFER);
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/in-str.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/in-str.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the position of the first occurrence of the substring in the target.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
 * + https://www.sqlite.org/lang_corefunc.html#instr
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `INSTR(str, substr)`
 * + PostgreSQL     : `STRPOS(str, substr)`
 * + SQLite         : `INSTR(str, substr)`
 *
 * -----
 *
 * @param left - The target of the search
 * @param right - The substring to look for
 *
 * -----
 *
 * If the substring is not found, it returns `0`.
 * Remember that string indices are one-based; not zero-based.
 *
 * @see position
 */
exports.inStr = factory_1.makeOperator2(operator_type_1.OperatorType.IN_STR, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=in-str.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate */ "./node_modules/@squill/squill/dist/expr-library/string/aggregate/index.js"));
__export(__webpack_require__(/*! ./ascii */ "./node_modules/@squill/squill/dist/expr-library/string/ascii.js"));
__export(__webpack_require__(/*! ./bin */ "./node_modules/@squill/squill/dist/expr-library/string/bin.js"));
__export(__webpack_require__(/*! ./bit-length */ "./node_modules/@squill/squill/dist/expr-library/string/bit-length.js"));
__export(__webpack_require__(/*! ./char-length */ "./node_modules/@squill/squill/dist/expr-library/string/char-length.js"));
__export(__webpack_require__(/*! ./concat-ws */ "./node_modules/@squill/squill/dist/expr-library/string/concat-ws.js"));
__export(__webpack_require__(/*! ./concat */ "./node_modules/@squill/squill/dist/expr-library/string/concat.js"));
__export(__webpack_require__(/*! ./escape-like-pattern */ "./node_modules/@squill/squill/dist/expr-library/string/escape-like-pattern.js"));
__export(__webpack_require__(/*! ./from-base64 */ "./node_modules/@squill/squill/dist/expr-library/string/from-base64.js"));
__export(__webpack_require__(/*! ./hex */ "./node_modules/@squill/squill/dist/expr-library/string/hex.js"));
__export(__webpack_require__(/*! ./in-str */ "./node_modules/@squill/squill/dist/expr-library/string/in-str.js"));
__export(__webpack_require__(/*! ./l-pad */ "./node_modules/@squill/squill/dist/expr-library/string/l-pad.js"));
__export(__webpack_require__(/*! ./l-trim */ "./node_modules/@squill/squill/dist/expr-library/string/l-trim.js"));
__export(__webpack_require__(/*! ./like */ "./node_modules/@squill/squill/dist/expr-library/string/like.js"));
__export(__webpack_require__(/*! ./lower */ "./node_modules/@squill/squill/dist/expr-library/string/lower.js"));
__export(__webpack_require__(/*! ./not-like */ "./node_modules/@squill/squill/dist/expr-library/string/not-like.js"));
__export(__webpack_require__(/*! ./null-safe-concat */ "./node_modules/@squill/squill/dist/expr-library/string/null-safe-concat.js"));
__export(__webpack_require__(/*! ./octet-length */ "./node_modules/@squill/squill/dist/expr-library/string/octet-length.js"));
__export(__webpack_require__(/*! ./position */ "./node_modules/@squill/squill/dist/expr-library/string/position.js"));
//export * from "./quote";
__export(__webpack_require__(/*! ./r-pad */ "./node_modules/@squill/squill/dist/expr-library/string/r-pad.js"));
__export(__webpack_require__(/*! ./r-trim */ "./node_modules/@squill/squill/dist/expr-library/string/r-trim.js"));
__export(__webpack_require__(/*! ./repeat */ "./node_modules/@squill/squill/dist/expr-library/string/repeat.js"));
__export(__webpack_require__(/*! ./replace */ "./node_modules/@squill/squill/dist/expr-library/string/replace.js"));
__export(__webpack_require__(/*! ./reverse */ "./node_modules/@squill/squill/dist/expr-library/string/reverse.js"));
__export(__webpack_require__(/*! ./to-base64 */ "./node_modules/@squill/squill/dist/expr-library/string/to-base64.js"));
__export(__webpack_require__(/*! ./trim */ "./node_modules/@squill/squill/dist/expr-library/string/trim.js"));
__export(__webpack_require__(/*! ./unhex */ "./node_modules/@squill/squill/dist/expr-library/string/unhex.js"));
__export(__webpack_require__(/*! ./upper */ "./node_modules/@squill/squill/dist/expr-library/string/upper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/l-pad.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/l-pad.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Returns a string, left-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 *   + `LPAD('123', 5, '')`   === `NULL`
 *   + `LPAD('123', 2, '')`   === `'12'`
 *   + `LPAD('123', -2, 'a')` === `NULL`
 * + PostgreSQL     : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 *   + `LPAD('123', 5, '')`   === `'123'`
 *   + `LPAD('123', 2, '')`   === `'12'`
 *   + `LPAD('123', -2, 'a')` === `''`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the desired length is negative, or padding string is empty,
 * the behaviour cannot be unified.
 *
 * MySQL seems to return `NULL`.
 *
 * -----
 *
 * @param left  - The string to pad
 * @param mid   - The desired length of the output
 * @param right - The padding
 *
 * @see lPad
 */
exports.lPadUnsafe = factory_1.makeOperator3(operator_type_1.OperatorType.LPAD, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string, left-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 * + PostgreSQL     : `LPAD(str, len, padstr)`
 *   + `LPAD('123', 4, '98')` === `'9123'`
 *   + `LPAD('123', 2, '98')` === `'12'`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * This function does not allow negative `desiredLength`, or empty `padding`.
 *
 * -----
 *
 * @param str           - The string to pad
 * @param desiredLength - The desired length of the output; must not be negative
 * @param padding       - The padding; must not be empty
 *
 * @see lPadUnsafe
 */
function lPad(str, desiredLength, padding) {
    desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
    padding = tm.stringLength({ min: 1 })(`padding`, padding);
    return expr_1.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.LPAD, [
        built_in_expr_1.BuiltInExprUtil.buildAst(str),
        built_in_expr_1.BuiltInExprUtil.buildAst(desiredLength),
        built_in_expr_1.BuiltInExprUtil.buildAst(padding),
    ], type_hint_1.TypeHint.STRING));
}
exports.lPad = lPad;
//# sourceMappingURL=l-pad.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/l-trim.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/l-trim.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with leading **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#ltrim
 *
 * -----
 *
 * + MySQL          : `LTRIM(x)`
 * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
 * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
 *
 * -----
 *
 * Does not remove other leading whitespace. Only removes leading spaces.
 */
exports.lTrim = factory_1.makeOperator1(operator_type_1.OperatorType.LTRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=l-trim.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/like.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/like.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const make_operator_3_1 = __webpack_require__(/*! ../factory/make-operator-3 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-3.js");
function assertValidLikeEscapeChar(escapeChar) {
    tm.stringExactLength(1)("escapeChar", escapeChar);
}
exports.assertValidLikeEscapeChar = assertValidLikeEscapeChar;
const likeEscapeImpl = make_operator_3_1.makeOperator3(operator_type_1.OperatorType.LIKE_ESCAPE, tm.mysql.boolean(), type_hint_1.TypeHint.STRING);
/**
 * + The escape character must always be specified, with this unified library.
 * + The escape character must be of length `1`.
 *
 * -----
 *
 * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
 *
 * -----
 *
 * This library requires the escape character to always be specified
 * because different databases have different defaults.
 *
 * Forcing an explicit escape character helps keep behaviour more consistent
 * across databases.
 *
 * Default escape characters per database,
 * + MySQL      : backslash (`\`)
 * + PostgreSQL : backslash (`\`)
 * + SQLite     : no-escape-character
 *
 * -----
 *
 * This library requires the escape character to have length `1` because
 * specifying the empty string has different behaviour on different databases,
 * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
 * + PostgreSQL : no-escape-character
 * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
 *
 * @param str - The target of the search
 * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
 * @param escapeChar - The escape character to use on the `pattern`
 */
function like(str, pattern, escapeChar) {
    assertValidLikeEscapeChar(escapeChar);
    return likeEscapeImpl(str, pattern, escapeChar);
}
exports.like = like;
//# sourceMappingURL=like.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/lower.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/lower.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with all characters changed to lowercase
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#lower
 *
 * -----
 *
 * + MySQL          : `LOWER(x)`
 * + PostgreSQL     : `LOWER(x)`
 * + SQLite         : `LOWER(x)`
 */
exports.lower = factory_1.makeOperator1(operator_type_1.OperatorType.LOWER, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=lower.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/not-like.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/not-like.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const make_operator_3_1 = __webpack_require__(/*! ../factory/make-operator-3 */ "./node_modules/@squill/squill/dist/expr-library/factory/make-operator-3.js");
const like_1 = __webpack_require__(/*! ./like */ "./node_modules/@squill/squill/dist/expr-library/string/like.js");
const notLikeEscapeImpl = make_operator_3_1.makeOperator3(operator_type_1.OperatorType.NOT_LIKE_ESCAPE, tm.mysql.boolean(), type_hint_1.TypeHint.STRING);
/**
 * + The escape character must always be specified, with this unified library.
 * + The escape character must be of length `1`.
 *
 * -----
 *
 * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
 *
 * -----
 *
 * This library requires the escape character to always be specified
 * because different databases have different defaults.
 *
 * Forcing an explicit escape character helps keep behaviour more consistent
 * across databases.
 *
 * Default escape characters per database,
 * + MySQL      : backslash (`\`)
 * + PostgreSQL : backslash (`\`)
 * + SQLite     : no-escape-character
 *
 * -----
 *
 * This library requires the escape character to have length `1` because
 * specifying the empty string has different behaviour on different databases,
 * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
 * + PostgreSQL : no-escape-character
 * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
 *
 * @param str - The target of the search
 * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
 * @param escapeChar - The escape character to use on the `pattern`
 */
function notLike(str, pattern, escapeChar) {
    like_1.assertValidLikeEscapeChar(escapeChar);
    return notLikeEscapeImpl(str, pattern, escapeChar);
}
exports.notLike = notLike;
//# sourceMappingURL=not-like.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/null-safe-concat.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/null-safe-concat.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string that results from concatenating the arguments.
 * May have one or more arguments.
 * `NULL` values are treated as empty strings.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
 * + PostgreSQL     : `CONCAT(x, ...)`
 *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
 *     + This is different from MySQL's `CONCAT()`
 * + SQLite         : `COALESCE(x, '') || ... || ...`
 *
 * -----
 *
 * The SQL standard says,
 * > `<concatenation operator>` is an operator, `||`,
 * > that returns the character string made by joining its character string operands in the order given.
 *
 * MySQL actually treats `||` as the boolean `OR` operator.
 *
 * -----
 *
 * @see concat
 */
exports.nullSafeConcat = factory_1.makeOperator1ToN(operator_type_1.OperatorType.NULL_SAFE_CONCAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=null-safe-concat.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/octet-length.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/octet-length.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the length of the string, measured in bytes.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `OCTET_LENGTH(x)`
 * + PostgreSQL     : `OCTET_LENGTH(x)`
 * + SQLite         : `LENGTH(CAST(x AS BLOB))`
 *
 * -----
 *
 * The character set of the string can affect the result of this function.
 * For example, on MySQL 5.7,
 * ```sql
 *  OCTET_LENGTH(CHAR(128 USING latin1))
 *  > 1
 *
 *  OCTET_LENGTH(CHAR(128 USING utf32))
 *  > 4
 * ```
 *
 * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/4
 */
exports.octetLength = factory_1.makeOperator1(operator_type_1.OperatorType.OCTET_LENGTH, 
/**
 * Should not return a value less than zero
 */
tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=octet-length.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/position.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/position.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the position of the first occurrence of the substring in the target.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 *
 * -----
 *
 * + MySQL          : `POSITION(substr IN str)`
 * + PostgreSQL     : `POSITION(substr IN str)`
 * + SQLite         : `INSTR(str, substr)`
 *
 * -----
 *
 * @param left  - The substring to look for
 * @param right - The target of the search
 *
 * -----
 *
 * If the substring is not found, it returns `0`.
 * Remember that string indices are one-based; not zero-based.
 *
 * @see inStr
 * @todo Remove `inStr()` and keep `position()`?
 */
exports.position = factory_1.makeOperator2(operator_type_1.OperatorType.POSITION, tm.mysql.bigIntUnsigned(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=position.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/r-pad.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/r-pad.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const ast_1 = __webpack_require__(/*! ../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Returns a string, right-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 *   + `RPAD('123', 5, '')`   === `NULL`
 *   + `RPAD('123', 2, '')`   === `'12'`
 *   + `RPAD('123', -2, 'a')` === `NULL`
 * + PostgreSQL     : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 *   + `RPAD('123', 5, '')`   === `'123'`
 *   + `RPAD('123', 2, '')`   === `'12'`
 *   + `RPAD('123', -2, 'a')` === `''`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the desired length is negative, or padding string is empty,
 * the behaviour cannot be unified.
 *
 * MySQL seems to return `NULL`.
 *
 * -----
 *
 * @param left  - The string to pad
 * @param mid   - The desired length of the output
 * @param right - The padding
 *
 * @see rPad
 */
exports.rPadUnsafe = factory_1.makeOperator3(operator_type_1.OperatorType.RPAD, tm.orNull(tm.string()), type_hint_1.TypeHint.STRING);
/**
 * Returns a string, right-padded to the specified length.
 *
 * If input string is longer than the specified length,
 * the return value is shortened to the specified length.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 * + PostgreSQL     : `RPAD(str, len, padstr)`
 *   + `RPAD('123', 4, '98')` === `'1239'`
 *   + `RPAD('123', 2, '98')` === `'12'`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * This function does not allow negative `desiredLength`, or empty `padding`.
 *
 * -----
 *
 * @param str           - The string to pad
 * @param desiredLength - The desired length of the output; must not be negative
 * @param padding       - The padding; must not be empty
 *
 * @see rPadUnsafe
 */
function rPad(str, desiredLength, padding) {
    desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
    padding = tm.stringLength({ min: 1 })(`padding`, padding);
    return expr_1.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_1.OperatorNodeUtil.operatorNode3(operator_type_1.OperatorType.RPAD, [
        built_in_expr_1.BuiltInExprUtil.buildAst(str),
        built_in_expr_1.BuiltInExprUtil.buildAst(desiredLength),
        built_in_expr_1.BuiltInExprUtil.buildAst(padding),
    ], type_hint_1.TypeHint.STRING));
}
exports.rPad = rPad;
//# sourceMappingURL=r-pad.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/r-trim.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/r-trim.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with trailing **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#rtrim
 *
 * -----
 *
 * + MySQL          : `RTRIM(x)`
 * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
 * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
 *
 * -----
 *
 * Does not remove other trailing whitespace. Only removes trailing spaces.
 */
exports.rTrim = factory_1.makeOperator1(operator_type_1.OperatorType.RTRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=r-trim.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/repeat.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/repeat.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Repeats a string the specified amount of times.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `REPEAT(x, count)`
 * + PostgreSQL     : `REPEAT(x, count)`
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the specified amount is zero or less, it returns an empty string.
 *
 * -----
 *
 * @param left  - The string to repeat
 * @param right - The amount of times to repeat the string
 */
exports.repeat = factory_1.makeOperator2(operator_type_1.OperatorType.REPEAT, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/replace.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/replace.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string `str`
 * with all occurrences of the string `from`
 * replaced by the string `to`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#replace
 *
 * -----
 *
 * + MySQL          : `REPLACE(str, from, to)`
 * + PostgreSQL     : `REPLACE(str, from, to)`
 * + SQLite         : `REPLACE(str, from, to)`
 *
 * -----
 *
 * @param left  - The string to transform
 * @param mid   - The string to look for
 * @param right - The replacement string
 */
exports.replace = factory_1.makeOperator3(operator_type_1.OperatorType.REPLACE, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/reverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/reverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with the order of the characters reversed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `REVERSE(x)`
 * + PostgreSQL     : `REVERSE(x)`
 * + SQLite         : None. Implement with user-defined function.
 */
exports.reverse = factory_1.makeOperator1(operator_type_1.OperatorType.REVERSE, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/to-base64.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/to-base64.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Converts the argument to base-64 encoded form.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `TO_BASE64(x)`
 * + PostgreSQL     : `ENCODE(x, 'base64')`
 * + SQLite         : None, implement with user-defined function `btoa()`
 */
exports.toBase64 = factory_1.makeOperator1(operator_type_1.OperatorType.TO_BASE64, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=to-base64.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/trim.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/trim.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with leading and trailing **space** characters removed.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
 * + https://www.sqlite.org/lang_corefunc.html#trim
 *
 * -----
 *
 * + MySQL          : `TRIM(x)`
 * + PostgreSQL     : `TRIM(x)`
 * + SQLite         : `TRIM(x)`
 *
 * -----
 *
 * Does not remove other leading and trailing whitespace.
 * Only removes leading and trailing spaces.
 */
exports.trim = factory_1.makeOperator1(operator_type_1.OperatorType.TRIM, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=trim.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/unhex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/unhex.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Takes a hex encoded string,
 * and returns the decoded result as a `BLOB/bytea`.
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
 * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
 *
 * -----
 *
 * + MySQL          : `UNHEX(x)`
 *   + `UNHEX('~')` === `NULL`
 * + PostgreSQL     : `DECODE(x, 'hex')`
 *   + `DECODE('~', 'hex')` throws an error
 * + SQLite         : None. Implement with user-defined function.
 *
 * -----
 *
 * If the input is not a valid hex string, some databases throw an error.
 * Others return `NULL`.
 */
exports.unhex = factory_1.makeOperator1(operator_type_1.OperatorType.UNHEX, tm.orNull(tm.instanceOfUint8Array()), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=unhex.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/string/upper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/string/upper.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const factory_1 = __webpack_require__(/*! ../factory */ "./node_modules/@squill/squill/dist/expr-library/factory/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const type_hint_1 = __webpack_require__(/*! ../../type-hint */ "./node_modules/@squill/squill/dist/type-hint.js");
/**
 * Returns the string with all characters changed to uppercase
 *
 * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
 * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
 * + https://www.sqlite.org/lang_corefunc.html#upper
 *
 * -----
 *
 * + MySQL          : `UPPER(x)`
 * + PostgreSQL     : `UPPER(x)`
 * + SQLite         : `UPPER(x)`
 */
exports.upper = factory_1.makeOperator1(operator_type_1.OperatorType.UPPER, tm.string(), type_hint_1.TypeHint.STRING);
//# sourceMappingURL=upper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/subquery/exists.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/subquery/exists.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const query_base_1 = __webpack_require__(/*! ../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const util_1 = __webpack_require__(/*! ../../ast/operator-node/util */ "./node_modules/@squill/squill/dist/ast/operator-node/util/index.js");
const operator_type_1 = __webpack_require__(/*! ../../operator-type */ "./node_modules/@squill/squill/dist/operator-type.js");
const used_ref_1 = __webpack_require__(/*! ../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function exists(query) {
    if (!query_base_1.QueryBaseUtil.isAfterFromClause(query) && !query_base_1.QueryBaseUtil.isAfterSelectClause(query)) {
        throw new Error(`Query must be after FROM/SELECT clause`);
    }
    /**
     * Hack for MySQL 5.7 and SQLite < 3.30 thinking the following is `true`,
     * ```sql
     *  EXISTS(SELECT 'hello' LIMIT 0);
     * ```
     */
    if (query.compoundQueryClause == undefined) {
        if ((query.compoundQueryLimitClause != undefined &&
            Number(query.compoundQueryLimitClause.maxRowCount) == 0) ||
            (query.limitClause != undefined &&
                Number(query.limitClause.maxRowCount) == 0)) {
            return expr_1.expr({
                mapper: tm.mysql.boolean(),
                usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
                isAggregate: false,
            }, built_in_expr_1.BuiltInExprUtil.buildAst(false));
        }
    }
    else {
        if (query.compoundQueryLimitClause != undefined &&
            Number(query.compoundQueryLimitClause.maxRowCount) == 0) {
            return expr_1.expr({
                mapper: tm.mysql.boolean(),
                usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
                isAggregate: false,
            }, built_in_expr_1.BuiltInExprUtil.buildAst(false));
        }
    }
    return expr_1.expr({
        mapper: tm.mysql.boolean(),
        usedRef: used_ref_1.UsedRefUtil.fromFromClause(query.fromClause),
        isAggregate: false,
    }, util_1.operatorNode1(operator_type_1.OperatorType.EXISTS, [query], undefined));
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-library/subquery/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-library/subquery/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/expr-library/subquery/exists.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprSelectItemUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/expr-select-item/util/index.js");
exports.ExprSelectItemUtil = ExprSelectItemUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/util/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/util/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/expr-select-item/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/expr-select-item/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/util/operation/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/util/operation/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./with-type */ "./node_modules/@squill/squill/dist/expr-select-item/util/operation/with-type.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/util/operation/with-type.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/util/operation/with-type.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function withType({ tableAlias, alias, usedRef, unaliasedAst, isAggregate, }, newMapper) {
    const result = {
        mapper: newMapper,
        tableAlias,
        alias,
        usedRef,
        isAggregate,
        unaliasedAst,
    };
    return result;
}
exports.withType = withType;
//# sourceMappingURL=with-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/util/predicate/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/util/predicate/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/util/predicate/is-expr-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr-select-item/util/predicate/is-expr-select-item.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr-select-item/util/predicate/is-expr-select-item.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Does not actually check,
 * + `x.usedRef` is `IUsedRef`
 * + `x.unaliasedAst` is `Ast`
 *
 * @todo Consider adding checks for increased type safety.
 */
function isExprSelectItem(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "mapper",
        "tableAlias",
        "alias",
        "usedRef",
        "isAggregate",
        "unaliasedAst",
    ])) {
        return false;
    }
    return ((typeof x.mapper == "function") &&
        (typeof x.tableAlias == "string") &&
        (typeof x.alias == "string") //&&
    //UsedRefUtil.isUsedRef(x.usedRef) &&
    //(typeof x.isAggregate == "boolean") &&
    //AstUtil.isAst(x.ast)
    );
}
exports.isExprSelectItem = isExprSelectItem;
//# sourceMappingURL=is-expr-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/expr-impl.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/expr-impl.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = __webpack_require__(/*! ../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
const ExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/expr/util/index.js");
/**
 * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
 *
 * This hack should only really be reserved for types that are more likely
 * to trigger max depth/max count errors.
 */
class ExprImpl {
    constructor(data, ast) {
        this.mapper = data.mapper;
        this.usedRef = data.usedRef;
        this.isAggregate = data.isAggregate;
        //Gotta' play it safe.
        //We want to preserve the order of operations.
        this.ast = ast_1.parentheses(ast);
    }
    /**
     * If you are running into "max instantiation depth" errors,
     * consider adding explicit `TableExpr<>` type annotations.
     *
     * If that doesn't help,
     * consider using `ExprUtil.as()` instead.
     *
     * Also, consider reading this to understand my frustration,
     * https://github.com/microsoft/TypeScript/issues/29511
     *
     * @param alias
     */
    as(alias) {
        return ExprUtil.as(this, alias);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() ASC
     * ```
     */
    asc() {
        return ExprUtil.asc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  RAND() DESC
     * ```
     */
    desc() {
        return ExprUtil.desc(this);
    }
    /**
     * ```sql
     * ORDER BY
     *  (myTable.myColumn IS NOT NULL) ASC,
     *  RAND() DESC
     * ```
     */
    sort(sortDirection) {
        return ExprUtil.sort(this, sortDirection);
    }
}
exports.ExprImpl = ExprImpl;
function expr(data, ast) {
    return new ExprImpl(data, ast);
}
exports.expr = expr;
//# sourceMappingURL=expr-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js"));
const ExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/expr/util/index.js");
exports.ExprUtil = ExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/constructor/from-built-in-expr.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/constructor/from-built-in-expr.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function fromBuiltInExpr(builtInExpr) {
    if (builtInExpr instanceof expr_impl_1.ExprImpl) {
        return builtInExpr;
    }
    const mapper = built_in_expr_1.BuiltInExprUtil.mapper(builtInExpr);
    const usedRef = built_in_expr_1.BuiltInExprUtil.usedRef(builtInExpr);
    const isAggregate = built_in_expr_1.BuiltInExprUtil.isAggregate(builtInExpr);
    const ast = built_in_expr_1.BuiltInExprUtil.buildAst(builtInExpr);
    return expr_impl_1.expr({
        mapper,
        usedRef,
        isAggregate,
    }, ast);
}
exports.fromBuiltInExpr = fromBuiltInExpr;
function fromRawExprNoUsedRefInput(mapper, value) {
    if (built_in_expr_1.BuiltInExprUtil.isAnyNonValueExpr(value)) {
        /**
         * Cannot map a `NonValueExpr`
         */
        return fromBuiltInExpr(value);
    }
    else {
        return fromBuiltInExpr(built_in_expr_1.BuiltInExprUtil.fromValueExpr(mapper, value));
    }
}
exports.fromRawExprNoUsedRefInput = fromRawExprNoUsedRefInput;
//# sourceMappingURL=from-built-in-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/constructor/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/constructor/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-built-in-expr */ "./node_modules/@squill/squill/dist/expr/util/constructor/from-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/expr/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/expr/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/expr/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/operation/aggregate-intersect.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/operation/aggregate-intersect.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
function aggregateIntersect(mapper, args, ast) {
    /**
     * @todo Set the `name` parameter?
     */
    built_in_expr_1.BuiltInExprUtil.assertAllNonAggregate(``, args);
    return expr_impl_1.expr({
        mapper,
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(...args),
        isAggregate: true,
    }, ast);
}
exports.aggregateIntersect = aggregateIntersect;
//# sourceMappingURL=aggregate-intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/operation/as.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/operation/as.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(/*! ../../../constants */ "./node_modules/@squill/squill/dist/constants.js");
const aliased_expr_1 = __webpack_require__(/*! ../../../aliased-expr */ "./node_modules/@squill/squill/dist/aliased-expr/index.js");
function as(expr, alias) {
    const result = new aliased_expr_1.AliasedExpr({
        mapper: expr.mapper,
        tableAlias: constants_1.ALIASED,
        alias,
        usedRef: expr.usedRef,
        isAggregate: expr.isAggregate,
    }, expr.ast);
    return result;
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/operation/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/operation/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aggregate-intersect */ "./node_modules/@squill/squill/dist/expr/util/operation/aggregate-intersect.js"));
__export(__webpack_require__(/*! ./as */ "./node_modules/@squill/squill/dist/expr/util/operation/as.js"));
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/expr/util/operation/intersect.js"));
__export(__webpack_require__(/*! ./sort */ "./node_modules/@squill/squill/dist/expr/util/operation/sort.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/operation/intersect.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/operation/intersect.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_impl_1 = __webpack_require__(/*! ../../expr-impl */ "./node_modules/@squill/squill/dist/expr/expr-impl.js");
function intersect(mapper, args, ast) {
    return expr_impl_1.expr({
        mapper,
        usedRef: built_in_expr_1.BuiltInExprUtil.intersectUsedRef(...args),
        isAggregate: args.some(built_in_expr_1.BuiltInExprUtil.isAggregate),
    }, ast);
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/operation/sort.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/operation/sort.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
function asc(expr) {
    return [expr, sort_direction_1.SortDirection.ASC];
}
exports.asc = asc;
function desc(expr) {
    return [expr, sort_direction_1.SortDirection.DESC];
}
exports.desc = desc;
function sort(expr, sortDirection) {
    return [expr, sortDirection];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/predicate/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/predicate/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-expr */ "./node_modules/@squill/squill/dist/expr/util/predicate/is-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/expr/util/predicate/is-expr.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/expr/util/predicate/is-expr.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Does not actually check,
 * + `x.usedRef` is `IUsedRef`
 * + `x.ast` is `Ast`
 *
 * @todo Consider adding checks for increased type safety.
 */
function isExpr(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "mapper",
        "usedRef",
        "isAggregate",
        "ast"
    ])) {
        return false;
    }
    return ((typeof x.mapper == "function") //&&
    //UsedRefUtil.isUsedRef(x.usedRef) &&
    //AstUtil.isAst(x.ast) &&
    //(typeof x.isAggregate == "boolean")
    );
}
exports.isExpr = isExpr;
//# sourceMappingURL=is-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/Formatter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/Formatter.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "./node_modules/@squill/squill/dist/formatter/TokenType.js");
const Indentation_1 = __webpack_require__(/*! ./Indentation */ "./node_modules/@squill/squill/dist/formatter/Indentation.js");
const InlineBlock_1 = __webpack_require__(/*! ./InlineBlock */ "./node_modules/@squill/squill/dist/formatter/InlineBlock.js");
const Params_1 = __webpack_require__(/*! ./Params */ "./node_modules/@squill/squill/dist/formatter/Params.js");
/* eslint-disable local/no-method */
class Formatter {
    /**
     * @param {Object} cfg
     *   @param {Object} cfg.indent
     *   @param {Object} cfg.params
     * @param {Tokenizer} tokenizer
     */
    constructor(cfg, tokenizer) {
        this.cfg = (cfg == undefined) ?
            {} :
            cfg;
        this.indentation = new Indentation_1.Indentation(this.cfg.indent);
        this.inlineBlock = new InlineBlock_1.InlineBlock();
        this.params = new Params_1.Params(this.cfg.params);
        this.tokenizer = tokenizer;
        this.previousReservedWord = undefined;
        this.tokens = [];
        this.index = 0;
    }
    /**
     * Formats whitespaces in a SQL string to make it easier to read.
     *
     * @param {String} query The SQL query string
     * @return {String} formatted query
     */
    format(query) {
        this.tokens = this.tokenizer.tokenize(query);
        const formattedQuery = this.getFormattedQueryFromTokens();
        return formattedQuery.trim();
    }
    getFormattedQueryFromTokens() {
        let formattedQuery = "";
        this.tokens.forEach((token, index) => {
            this.index = index;
            if (token.type === TokenType_1.TokenType.WHITESPACE) {
                // ignore (we do our own whitespace formatting)
            }
            else if (token.type === TokenType_1.TokenType.LINE_COMMENT) {
                formattedQuery = this.formatLineComment(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.BLOCK_COMMENT) {
                formattedQuery = this.formatBlockComment(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_TOPLEVEL) {
                formattedQuery = this.formatToplevelReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_NEWLINE) {
                formattedQuery = this.formatNewlineReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED_PRE_NEWLINE) {
                formattedQuery = this.formatPreNewlineReservedWord(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.RESERVED) {
                formattedQuery = this.formatWithSpaces(token, formattedQuery);
                this.previousReservedWord = token;
            }
            else if (token.type === TokenType_1.TokenType.OPEN_PAREN) {
                formattedQuery = this.formatOpeningParentheses(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.CLOSE_PAREN) {
                formattedQuery = this.formatClosingParentheses(token, formattedQuery);
            }
            else if (token.type === TokenType_1.TokenType.PLACEHOLDER) {
                formattedQuery = this.formatPlaceholder(token, formattedQuery);
            }
            else if (token.value === ",") {
                formattedQuery = this.formatComma(token, formattedQuery);
            }
            else if (token.value === ":") {
                formattedQuery = this.formatWithSpaceAfter(token, formattedQuery);
            }
            else if (token.value === "." || token.value === ";") {
                formattedQuery = this.formatWithoutSpaces(token, formattedQuery);
            }
            else {
                formattedQuery = this.formatWithSpaces(token, formattedQuery);
            }
        });
        return formattedQuery;
    }
    formatLineComment(token, query) {
        return this.addNewline(query + token.value);
    }
    formatBlockComment(token, query) {
        return this.addNewline(this.addNewline(query) + this.indentComment(token.value));
    }
    indentComment(comment) {
        return comment.replace(/\n/g, "\n" + this.indentation.getIndent());
    }
    formatToplevelReservedWord(token, query) {
        this.indentation.decreaseTopLevel();
        query = this.addNewline(query);
        this.indentation.increaseToplevel();
        query += this.equalizeWhitespace(token.value);
        return this.addNewline(query);
    }
    formatNewlineReservedWord(token, query) {
        //Different from original implementation. I think this looks nicer.
        if (query.length > 0 && !query.endsWith(" ")) {
            query += " ";
        }
        return this.addNewline(query + this.equalizeWhitespace(token.value));
    }
    formatPreNewlineReservedWord(token, query) {
        //The original formatNewlineReservedWord() implementation
        //Useful for WHEN clause of CASE
        return this.addNewline(query) + this.equalizeWhitespace(token.value) + " ";
    }
    // Replace any sequence of whitespace characters with single space
    equalizeWhitespace(string) {
        return string.replace(/\s+/g, " ");
    }
    // Opening parentheses increase the block indent level and start a new line
    formatOpeningParentheses(token, query) {
        // Take out the preceding space unless there was whitespace there in the original query
        // or another opening parens or line comment
        const preserveWhitespaceFor = [
            TokenType_1.TokenType.WHITESPACE,
            TokenType_1.TokenType.OPEN_PAREN,
            TokenType_1.TokenType.LINE_COMMENT,
        ];
        if (!this.hasPreviousToken() || !preserveWhitespaceFor.includes(this.previousToken().type)) {
            query = query.trimRight();
        }
        query += token.value;
        this.inlineBlock.beginIfPossible(this.tokens, this.index);
        if (!this.inlineBlock.isActive()) {
            this.indentation.increaseBlockLevel();
            query = this.addNewline(query);
        }
        return query;
    }
    // Closing parentheses decrease the block indent level
    formatClosingParentheses(token, query) {
        if (this.inlineBlock.isActive()) {
            this.inlineBlock.end();
            return this.formatWithSpaceAfter(token, query);
        }
        else {
            this.indentation.decreaseBlockLevel();
            return this.formatWithSpaces(token, this.addNewline(query));
        }
    }
    formatPlaceholder(token, query) {
        return query + this.params.get(token) + " ";
    }
    // Commas start a new line (unless within inline parentheses or SQL "LIMIT" clause)
    formatComma(token, query) {
        query = this.trimTrailingWhitespace(query) + token.value + " ";
        if (this.inlineBlock.isActive()) {
            return query;
        }
        else if (this.previousReservedWord != undefined && /^LIMIT$/i.test(this.previousReservedWord.value)) {
            return query;
        }
        else {
            return this.addNewline(query);
        }
    }
    formatWithSpaceAfter(token, query) {
        return this.trimTrailingWhitespace(query) + token.value + " ";
    }
    formatWithoutSpaces(token, query) {
        return this.trimTrailingWhitespace(query) + token.value;
    }
    formatWithSpaces(token, query) {
        if (token.value == "HACKED_AND_NO_NEW_LINE") {
            return query + "AND" + " ";
        }
        return query + token.value + " ";
    }
    addNewline(query) {
        return query.trimRight() + "\n" + this.indentation.getIndent();
    }
    trimTrailingWhitespace(query) {
        if (this.hasPreviousNonWhitespaceToken() && this.previousNonWhitespaceToken().type === TokenType_1.TokenType.LINE_COMMENT) {
            return query.trimRight() + "\n";
        }
        else {
            return query.trimRight();
        }
    }
    hasPreviousNonWhitespaceToken() {
        let n = 1;
        while (this.hasPreviousToken(n) && this.previousToken(n).type === TokenType_1.TokenType.WHITESPACE) {
            n++;
        }
        return this.hasPreviousToken(n);
    }
    previousNonWhitespaceToken() {
        let n = 1;
        while (this.previousToken(n).type === TokenType_1.TokenType.WHITESPACE) {
            n++;
        }
        return this.previousToken(n);
    }
    hasPreviousToken(offset = 1) {
        return (this.index - offset) >= 0;
    }
    previousToken(offset = 1) {
        const result = this.tokens[this.index - offset];
        if (result == undefined) {
            throw new Error(`No previous token. index ${this.index}, offset ${offset}`);
        }
        return result;
    }
}
exports.Formatter = Formatter;
//# sourceMappingURL=Formatter.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/Indentation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/Indentation.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function last(arr) {
    if (arr.length == 0) {
        return undefined;
    }
    else {
        return arr[arr.length - 1];
    }
}
//Poor man's enum?
const INDENT_TYPE_TOP_LEVEL = "top-level";
const INDENT_TYPE_BLOCK_LEVEL = "block-level";
/* eslint-disable local/no-method */
/**
 * Manages indentation levels.
 *
 * There are two types of indentation levels:
 *
 * - BLOCK_LEVEL : increased by open-parenthesis
 * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
 */
class Indentation {
    /**
     * @param {String} indent Indent value, default is "  " (2 spaces)
     */
    constructor(indent) {
        this.indent = (indent == undefined) ? "  " : indent;
        this.indentTypes = [];
    }
    /**
     * Returns current indentation string.
     * @return {String}
     */
    getIndent() {
        return this.indent.repeat(this.indentTypes.length);
    }
    /**
     * Increases indentation by one top-level indent.
     */
    increaseToplevel() {
        this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
    }
    /**
     * Increases indentation by one block-level indent.
     */
    increaseBlockLevel() {
        this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
    }
    /**
     * Decreases indentation by one top-level indent.
     * Does nothing when the previous indent is not top-level.
     */
    decreaseTopLevel() {
        if (last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            this.indentTypes.pop();
        }
    }
    /**
     * Decreases indentation by one block-level indent.
     * If there are top-level indents within the block-level indent,
     * throws away these as well.
     */
    decreaseBlockLevel() {
        while (this.indentTypes.length > 0) {
            const type = this.indentTypes.pop();
            if (type !== INDENT_TYPE_TOP_LEVEL) {
                break;
            }
        }
    }
}
exports.Indentation = Indentation;
//# sourceMappingURL=Indentation.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/InlineBlock.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/InlineBlock.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "./node_modules/@squill/squill/dist/formatter/TokenType.js");
const INLINE_MAX_LENGTH = 50;
/* eslint-disable local/no-method */
/**
 * Bookkeeper for inline blocks.
 *
 * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.
 * These blocks are formatted on a single line, unlike longer parenthized
 * expressions where open-parenthesis causes newline and increase of indentation.
 */
class InlineBlock {
    constructor() {
        this.level = 0;
    }
    /**
     * Begins inline block when lookahead through upcoming tokens determines
     * that the block would be smaller than INLINE_MAX_LENGTH.
     * @param  {Object[]} tokens Array of all tokens
     * @param  {Number} index Current token position
     */
    beginIfPossible(tokens, index) {
        if (this.level === 0 && this.isInlineBlock(tokens, index)) {
            this.level = 1;
        }
        else if (this.level > 0) {
            this.level++;
        }
        else {
            this.level = 0;
        }
    }
    /**
     * Finishes current inline block.
     * There might be several nested ones.
     */
    end() {
        this.level--;
    }
    /**
     * True when inside an inline block
     * @return {Boolean}
     */
    isActive() {
        return this.level > 0;
    }
    // Check if this should be an inline parentheses block
    // Examples are "NOW()", "COUNT(*)", "int(10)", key(`somecolumn`), DECIMAL(7,2)
    isInlineBlock(tokens, index) {
        let length = 0;
        let level = 0;
        for (let i = index; i < tokens.length; i++) {
            const token = tokens[i];
            length += token.value.length;
            // Overran max length
            if (length > INLINE_MAX_LENGTH) {
                return false;
            }
            if (token.type === TokenType_1.TokenType.OPEN_PAREN) {
                level++;
            }
            else if (token.type === TokenType_1.TokenType.CLOSE_PAREN) {
                level--;
                if (level === 0) {
                    return true;
                }
            }
            if (this.isForbiddenToken(token)) {
                return false;
            }
        }
        return false;
    }
    // Reserved words that cause newlines, comments and semicolons
    // are not allowed inside inline parentheses block
    isForbiddenToken({ type, value }) {
        return type === TokenType_1.TokenType.RESERVED_TOPLEVEL ||
            type === TokenType_1.TokenType.RESERVED_NEWLINE ||
            type === TokenType_1.TokenType.RESERVED_PRE_NEWLINE ||
            //TokenType.COMMENT does not exist.
            //This is effectively, type === undefined
            //This is why plain JS sucks.
            //type === TokenType.COMMENT ||
            type === TokenType_1.TokenType.BLOCK_COMMENT ||
            value === ";";
    }
}
exports.InlineBlock = InlineBlock;
//# sourceMappingURL=InlineBlock.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/Params.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/Params.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable local/no-method */
/**
 * Handles placeholder replacement with given params.
 */
class Params {
    /**
     * @param {Object} params
     */
    constructor(params) {
        this.params = params;
        this.index = 0;
    }
    /**
     * Returns param value that matches given placeholder with param key.
     * @param {Object} token
     * @param {String} token.key Placeholder key
     * @param {String} token.value Placeholder value
     * @return {String} param or token.value when params are missing
     */
    get({ key, value }) {
        if (this.params == undefined) {
            return value;
        }
        if (key != undefined) {
            if (Array.isArray(this.params)) {
                throw new Error(`Cannot use array params with named placeholders`);
            }
            else {
                return this.params[key];
            }
        }
        else {
            if (Array.isArray(this.params)) {
                return this.params[this.index++];
            }
            else {
                throw new Error(`Cannot use object params with index placeholders`);
            }
        }
    }
}
exports.Params = Params;
//# sourceMappingURL=Params.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/SqlFormatter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/SqlFormatter.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Formatter_1 = __webpack_require__(/*! ./Formatter */ "./node_modules/@squill/squill/dist/formatter/Formatter.js");
const Tokenizer_1 = __webpack_require__(/*! ./Tokenizer */ "./node_modules/@squill/squill/dist/formatter/Tokenizer.js");
const reservedWords = [
    "ACCESSIBLE", "ACTION", "AGAINST", "AGGREGATE", "ALGORITHM", "ALL", "ALTER", "ANALYSE", "ANALYZE", "AS", "ASC", "AUTOCOMMIT",
    "AUTO_INCREMENT",
    "BACKUP", "BEGIN", "BETWEEN", "BINLOG", "BOTH",
    "CASCADE", "CASE", "CHANGE", "CHANGED", "CHARACTER SET", "CHARSET", "CHECK", "CHECKSUM", "COLLATE", "COLLATION", "COLUMN", "COLUMNS",
    "COMMENT", "COMMIT", "COMMITTED", "COMPRESSED", "CONCURRENT", "CONSTRAINT", "CONTAINS", "CONVERT", "CREATE", "CROSS",
    "CURRENT_TIMESTAMP",
    "DATABASE", "DATABASES", "DAY", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "DEFAULT", "DEFINER", "DELAYED", "DELETE", "DESC", "DESCRIBE",
    "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DO", "DROP", "DUMPFILE", "DUPLICATE", "DYNAMIC",
    "ENCLOSED", "END", "ENGINE", "ENGINES", "ENGINE_TYPE", "ESCAPE", "ESCAPED", "EVENTS", "EXEC", "EXECUTE", "EXISTS", "EXPLAIN",
    "EXTENDED",
    "FAST", "FETCH", "FIELDS", "FILE", "FIRST", "FIXED", "FLUSH", "FOR", "FORCE", "FOREIGN", "FULL", "FULLTEXT", "FUNCTION",
    "GLOBAL", "GRANT", "GRANTS", "GROUP_CONCAT",
    "HEAP", "HIGH_PRIORITY", "HOSTS", "HOUR", "HOUR_MINUTE", "HOUR_SECOND",
    "IDENTIFIED", "IF", "IFNULL", "IGNORE", "IN", "INDEX", "INDEXES", "INFILE", "INSERT", "INSERT_ID", "INSERT_METHOD", "INTERVAL",
    "INTO", "INVOKER", "IS", "ISOLATION",
    "KEY", "KEYS", "KILL",
    "LAST_INSERT_ID", "LEADING", "LEVEL", "LIKE", "LINEAR", "LINES", "LOAD", "LOCAL", "LOCK", "LOCKS", "LOGS", "LOW_PRIORITY",
    "MARIA", "MASTER", "MASTER_CONNECT_RETRY", "MASTER_HOST", "MASTER_LOG_FILE", "MATCH", "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", "MERGE", "MINUTE", "MINUTE_SECOND",
    "MIN_ROWS", "MODE", "MODIFY", "MONTH", "MRG_MYISAM", "MYISAM",
    "NAMES", "NATURAL", "NOT", "NOW()", "NULL",
    "ON DELETE", "ON UPDATE", "ONLY", "OPEN", "OPTIMIZE", "OPTION", "OPTIONALLY", "OUTFILE",
    "PACK_KEYS", "PAGE", "PARTIAL", "PARTITION", "PARTITIONS", "PASSWORD", "PRIMARY", "PRIVILEGES", "PROCEDURE", "PROCESS", "PROCESSLIST",
    "PURGE",
    "QUICK",
    "RAID0", "RAID_CHUNKS", "RAID_CHUNKSIZE", "RAID_TYPE", "RANGE", "READ", "READ_ONLY", "READ_WRITE", "REFERENCES", "REGEXP", "RELOAD",
    "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLICATION", "RESET", "RESTORE", "RESTRICT", "RETURN", "RETURNS", "REVOKE", "RLIKE",
    "ROLLBACK", "ROW", "ROWS", "ROW_FORMAT",
    "SECOND", "SECURITY", "SEPARATOR", "SERIALIZABLE", "SESSION", "SHARE", "SHOW", "SHUTDOWN", "SLAVE", "SONAME", "SOUNDS", "SQL",
    "SQL_AUTO_IS_NULL", "SQL_BIG_RESULT", "SQL_BIG_SELECTS", "SQL_BIG_TABLES", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS",
    "SQL_LOG_BIN", "SQL_LOG_OFF", "SQL_LOG_UPDATE", "SQL_LOW_PRIORITY_UPDATES", "SQL_MAX_JOIN_SIZE", "SQL_NO_CACHE",
    "SQL_QUOTE_SHOW_CREATE", "SQL_SAFE_UPDATES", "SQL_SELECT_LIMIT", "SQL_SLAVE_SKIP_COUNTER", "SQL_SMALL_RESULT", "SQL_WARNINGS",
    "START", "STARTING", "STATUS", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRING", "STRIPED", "SUPER",
    "TABLE", "TABLES", "TEMPORARY", "TERMINATED", "THEN", "TO", "TRAILING", "TRANSACTIONAL", "TRUE", "TRUNCATE", "TYPE", "TYPES",
    "UNCOMMITTED", "UNIQUE", "UNLOCK", "UNSIGNED", "USAGE", "USE", "USING",
    "VARIABLES", "VIEW", "WITH", "WORK", "WRITE",
    "YEAR_MONTH",
    //This will be rendered as `AND` but without a new line
    "HACKED_AND_NO_NEW_LINE"
];
const reservedToplevelWords = [
    "ADD", "AFTER", "ALTER COLUMN", "ALTER TABLE",
    "DELETE FROM",
    "EXCEPT",
    "FETCH FIRST", "FROM",
    "GROUP BY", "GO",
    "HAVING",
    "INSERT INTO", "INSERT", "INTERSECT",
    "LIMIT",
    "MODIFY",
    "ORDER BY",
    /*New reserved top-level word*/ "SELECT DISTINCT SQL_CALC_FOUND_ROWS",
    /*New reserved top-level word*/ "SELECT DISTINCT",
    /*New reserved top-level word*/ "SELECT SQL_CALC_FOUND_ROWS",
    "SELECT", "SET CURRENT SCHEMA", "SET SCHEMA", "SET",
    "UNION ALL", /*New reserved top-level word*/ "UNION DISTINCT", "UNION", "UPDATE",
    "VALUES",
    "WHERE",
    //Originally in reservedNewlineWords
    //But I think this is better to me
    "CROSS APPLY", "CROSS JOIN",
    "INNER JOIN",
    "JOIN",
    "LEFT JOIN", "LEFT OUTER JOIN",
    "OUTER APPLY", "OUTER JOIN",
    "RIGHT JOIN", "RIGHT OUTER JOIN",
    //Originally in reservedWords
    //But I think this is better to me
    "ON",
    "OFFSET",
];
const reservedNewlineWords = [
    "AND",
    "OR",
    "XOR"
];
const reservedPreNewlineWords = [
    "WHEN",
    "ELSE",
];
exports.defaultTokenizerConfig = {
    reservedWords,
    reservedToplevelWords,
    reservedNewlineWords,
    reservedPreNewlineWords,
    stringTypes: [/*`""`,*/ "N''", /*"''",*/ "``", "[]", "X''", "pascal-double", "pascal-single"],
    openParens: ["(", "CASE"],
    closeParens: [")", "END"],
    indexedPlaceholderTypes: ["?"],
    namedPlaceholderTypes: ["@", ":"],
    lineCommentTypes: ["#", "--"],
    specialWordChars: undefined,
};
/* eslint-disable local/no-method */
class SqlFormatter {
    /**
     * @param {Object} cfg Different set of configurations
     */
    constructor(cfg, tokenizerConfig) {
        this.cfg = cfg;
        /**
         * @todo Not use this hack.
         * We want to ignore properties set to `undefined`.
         */
        this.tokenizerConfig = { ...tokenizerConfig };
        for (const key of Object.keys(this.tokenizerConfig)) {
            if (this.tokenizerConfig[key] === undefined) {
                delete this.tokenizerConfig[key];
            }
        }
    }
    /**
     * Format the whitespace in a Standard SQL string to make it easier to read
     *
     * @param {String} query The Standard SQL string
     * @return {String} formatted string
     */
    format(query) {
        if (this.tokenizer == undefined) {
            this.tokenizer = new Tokenizer_1.Tokenizer({
                ...exports.defaultTokenizerConfig,
                ...this.tokenizerConfig,
            });
        }
        return new Formatter_1.Formatter(this.cfg, this.tokenizer).format(query);
    }
}
exports.SqlFormatter = SqlFormatter;
//# sourceMappingURL=SqlFormatter.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/TokenType.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/TokenType.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TokenType;
(function (TokenType) {
    TokenType["WHITESPACE"] = "whitespace";
    TokenType["WORD"] = "word";
    TokenType["STRING"] = "string";
    TokenType["RESERVED"] = "reserved";
    TokenType["RESERVED_TOPLEVEL"] = "reserved-toplevel";
    TokenType["RESERVED_NEWLINE"] = "reserved-newline";
    TokenType["RESERVED_PRE_NEWLINE"] = "reserved-pre-newline";
    TokenType["OPERATOR"] = "operator";
    TokenType["OPEN_PAREN"] = "open-paren";
    TokenType["CLOSE_PAREN"] = "close-paren";
    TokenType["LINE_COMMENT"] = "line-comment";
    TokenType["BLOCK_COMMENT"] = "block-comment";
    TokenType["NUMBER"] = "number";
    TokenType["PLACEHOLDER"] = "placeholder";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
//# sourceMappingURL=TokenType.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/Tokenizer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/Tokenizer.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TokenType_1 = __webpack_require__(/*! ./TokenType */ "./node_modules/@squill/squill/dist/formatter/TokenType.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
const reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(str) {
    return (str != "" && reHasRegExpChar.test(str))
        ? str.replace(reRegExpChar, '\\$&')
        : str;
}
/* eslint-disable local/no-method */
class Tokenizer {
    /**
     * @param {Object} cfg
     *  @param {String[]} cfg.reservedWords Reserved words in SQL
     *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately
     *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline
     *  @param {String[]} cfg.stringTypes String types to enable: "", '', ``, [], N''
     *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [
     *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]
     *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?
     *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :
     *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --
     *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #
     */
    constructor(cfg) {
        this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
        this.WHITESPACE_REGEX = /^(\s+)/;
        //The original NUMBER_REGEX was this -> /^((-\s*)?[0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\b/;
        this.NUMBER_REGEX = /^(([-+])?([0-9]*\.?[0-9]+)([eE]([-+])?([0-9]+))?)\b/;
        //Added <=> as the NULL-safe equality operator
        this.OPERATOR_REGEX = /^(<=>|!=|<>|==|<=|>=|!<|!>|\|\||::|->>|->|~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|.)/;
        this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
        this.LINE_COMMENT_REGEX = this.createLineCommentRegex(cfg.lineCommentTypes);
        this.RESERVED_TOPLEVEL_REGEX = this.createReservedWordRegex(cfg.reservedToplevelWords);
        this.RESERVED_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedNewlineWords);
        this.RESERVED_PRE_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedPreNewlineWords);
        this.RESERVED_PLAIN_REGEX = this.createReservedWordRegex(cfg.reservedWords);
        this.WORD_REGEX = this.createWordRegex(cfg.specialWordChars);
        this.STRING_REGEX = this.createStringRegex(cfg.stringTypes);
        this.OPEN_PAREN_REGEX = this.createParenRegex(cfg.openParens);
        this.CLOSE_PAREN_REGEX = this.createParenRegex(cfg.closeParens);
        this.INDEXED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.indexedPlaceholderTypes, "[0-9]*");
        this.IDENT_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, "[a-zA-Z0-9._$]+");
        this.STRING_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, this.createStringPattern(cfg.stringTypes));
    }
    createLineCommentRegex(lineCommentTypes) {
        return new RegExp(`^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join("|")}).*?(?:\n|$))`);
    }
    createReservedWordRegex(reservedWords) {
        const reservedWordsPattern = reservedWords.join("|").replace(/ /g, "\\s+");
        return new RegExp(`^(${reservedWordsPattern})\\b`, "i");
    }
    createWordRegex(specialChars = []) {
        return new RegExp(`^([\\w${specialChars.join("")}]+)`);
    }
    createStringRegex(stringTypes) {
        return new RegExp("^(" + this.createStringPattern(stringTypes) + ")");
    }
    // This enables the following string patterns:
    // 1. backtick quoted string using `` to escape
    // 2. square bracket quoted string (SQL Server) using ]] to escape
    // 3. double quoted string using "" or \" to escape
    // 4. single quoted string using '' or \' to escape
    // 5. national character quoted string using N'' or N\' to escape
    // 6. double quoted string using "" to escape (should not be used with number 3)
    // 7. single quoted string using '' to escape (should not be used with number 4)
    createStringPattern(stringTypes) {
        const patterns = {
            "``": "((`[^`]*($|`))+)",
            "[]": "((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)",
            "\"\"": "((\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*(\"|$))+)",
            "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
            "N''": "((N'[^N'\\\\]*(?:\\\\.[^N'\\\\]*)*('|$))+)",
            "X''": "((X'[^X'\\\\]*(?:\\\\.[^X'\\\\]*)*('|$))+)",
            "pascal-double": `(("[^"]*($|"))+)`,
            "pascal-single": "(('[^']*($|'))+)",
        };
        return stringTypes.map(t => patterns[t]).join("|");
    }
    createParenRegex(parens) {
        return new RegExp("^(" + parens.map(p => this.escapeParen(p)).join("|") + ")", "i");
    }
    escapeParen(paren) {
        if (paren.length === 1) {
            // A single punctuation character
            return escapeRegExp(paren);
        }
        else {
            // longer word
            return "\\b" + paren + "\\b";
        }
    }
    createPlaceholderRegex(types, pattern) {
        if (types.length == 0) {
            return undefined;
        }
        const typesRegex = types.map(escapeRegExp).join("|");
        return new RegExp(`^((?:${typesRegex})(?:${pattern}))`);
    }
    /**
     * Takes a SQL string and breaks it into tokens.
     * Each token is an object with type and value.
     *
     * @param {String} input The SQL string
     * @return {Object[]} tokens An array of tokens.
     *  @return {String} token.type
     *  @return {String} token.value
     */
    tokenize(input) {
        const tokens = [];
        let token;
        // Keep processing the string until it is empty
        while (input.length > 0) {
            // Get the next token and the token type
            token = this.getNextToken(input, token);
            if (token == undefined) {
                throw new Error(`No token found`);
            }
            // Advance the string
            input = input.substring(token.value.length);
            tokens.push(token);
        }
        return tokens;
    }
    getNextToken(input, previousToken) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getWhitespaceToken(input) ||
            this.getCommentToken(input) ||
            this.getStringToken(input) ||
            this.getOpenParenToken(input) ||
            this.getCloseParenToken(input) ||
            this.getPlaceholderToken(input) ||
            this.getNumberToken(input) ||
            this.getReservedWordToken(input, previousToken) ||
            this.getWordToken(input) ||
            this.getOperatorToken(input);
    }
    getWhitespaceToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.WHITESPACE,
            regex: this.WHITESPACE_REGEX
        });
    }
    getCommentToken(input) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getLineCommentToken(input) || this.getBlockCommentToken(input);
    }
    getLineCommentToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.LINE_COMMENT,
            regex: this.LINE_COMMENT_REGEX
        });
    }
    getBlockCommentToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.BLOCK_COMMENT,
            regex: this.BLOCK_COMMENT_REGEX
        });
    }
    getStringToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.STRING,
            regex: this.STRING_REGEX
        });
    }
    getOpenParenToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.OPEN_PAREN,
            regex: this.OPEN_PAREN_REGEX
        });
    }
    getCloseParenToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.CLOSE_PAREN,
            regex: this.CLOSE_PAREN_REGEX
        });
    }
    getPlaceholderToken(input) {
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.getIdentNamedPlaceholderToken(input) ||
            this.getStringNamedPlaceholderToken(input) ||
            this.getIndexedPlaceholderToken(input);
    }
    getIdentNamedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.IDENT_NAMED_PLACEHOLDER_REGEX,
            parseKey: (v) => v.slice(1)
        });
    }
    getStringNamedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.STRING_NAMED_PLACEHOLDER_REGEX,
            parseKey: (v) => this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) })
        });
    }
    getIndexedPlaceholderToken(input) {
        return this.getPlaceholderTokenWithKey({
            input,
            regex: this.INDEXED_PLACEHOLDER_REGEX,
            parseKey: (v) => v.slice(1)
        });
    }
    getPlaceholderTokenWithKey({ input, regex, parseKey }) {
        const token = this.getTokenOnFirstMatch({ input, regex, type: TokenType_1.TokenType.PLACEHOLDER });
        if (token == undefined) {
            return undefined;
        }
        token.key = parseKey(token.value);
        return token;
    }
    getEscapedPlaceholderKey({ key, quoteChar }) {
        return key.replace(new RegExp(escapeRegExp("\\") + quoteChar, "g"), quoteChar);
    }
    // Decimal, binary, or hex numbers
    getNumberToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.NUMBER,
            regex: this.NUMBER_REGEX
        });
    }
    // Punctuation and symbols
    getOperatorToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.OPERATOR,
            regex: this.OPERATOR_REGEX
        });
    }
    getReservedWordToken(input, previousToken) {
        // A reserved word cannot be preceded by a "."
        // this makes it so in "mytable.from", "from" is not considered a reserved word
        if (previousToken != undefined && previousToken.value === ".") {
            return;
        }
        return (
        //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        this.getToplevelReservedToken(input) ||
            this.getNewlineReservedToken(input) ||
            this.getPreNewlineReservedToken(input) ||
            this.getPlainReservedToken(input));
    }
    getToplevelReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_TOPLEVEL,
            regex: this.RESERVED_TOPLEVEL_REGEX
        });
    }
    getNewlineReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_NEWLINE,
            regex: this.RESERVED_NEWLINE_REGEX
        });
    }
    getPreNewlineReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED_PRE_NEWLINE,
            regex: this.RESERVED_PRE_NEWLINE_REGEX
        });
    }
    getPlainReservedToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.RESERVED,
            regex: this.RESERVED_PLAIN_REGEX
        });
    }
    getWordToken(input) {
        return this.getTokenOnFirstMatch({
            input,
            type: TokenType_1.TokenType.WORD,
            regex: this.WORD_REGEX
        });
    }
    getTokenOnFirstMatch({ input, type, regex }) {
        const matches = (regex == undefined) ?
            undefined :
            input.match(regex);
        if (matches == undefined) {
            return undefined;
        }
        const value = matches[1];
        if (value == undefined) {
            throw new Error(`No value found; is the regex missing a capture group?`);
        }
        return { type, value };
    }
}
exports.Tokenizer = Tokenizer;
//# sourceMappingURL=Tokenizer.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/formatter/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/formatter/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./Formatter */ "./node_modules/@squill/squill/dist/formatter/Formatter.js"));
__export(__webpack_require__(/*! ./Indentation */ "./node_modules/@squill/squill/dist/formatter/Indentation.js"));
__export(__webpack_require__(/*! ./InlineBlock */ "./node_modules/@squill/squill/dist/formatter/InlineBlock.js"));
__export(__webpack_require__(/*! ./Params */ "./node_modules/@squill/squill/dist/formatter/Params.js"));
__export(__webpack_require__(/*! ./SqlFormatter */ "./node_modules/@squill/squill/dist/formatter/SqlFormatter.js"));
__export(__webpack_require__(/*! ./Tokenizer */ "./node_modules/@squill/squill/dist/formatter/Tokenizer.js"));
__export(__webpack_require__(/*! ./TokenType */ "./node_modules/@squill/squill/dist/formatter/TokenType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FromClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/from-clause/util/index.js");
exports.FromClauseUtil = FromClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/constructor/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/constructor/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./new-instance */ "./node_modules/@squill/squill/dist/from-clause/util/constructor/new-instance.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/constructor/new-instance.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/constructor/new-instance.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function newInstance() {
    const result = {
        outerQueryJoins: undefined,
        currentJoins: undefined,
    };
    return result;
}
exports.newInstance = newInstance;
//# sourceMappingURL=new-instance.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/from-clause/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/from-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/from-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/correlate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/correlate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function correlate(fromClause) {
    return {
        outerQueryJoins: (fromClause.outerQueryJoins == undefined && fromClause.currentJoins == undefined ?
            undefined :
            [
                ...(fromClause.outerQueryJoins == undefined ?
                    [] :
                    fromClause.outerQueryJoins),
                ...(fromClause.currentJoins == undefined ?
                    [] :
                    fromClause.currentJoins),
            ]),
        currentJoins: undefined,
    };
}
exports.correlate = correlate;
//# sourceMappingURL=correlate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/cross-join.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/cross-join.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
function crossJoin(fromClause, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.CROSS, undefined)),
    };
    return result;
}
exports.crossJoin = crossJoin;
//# sourceMappingURL=cross-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/from.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/from.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
function from(fromClause, aliasedTable) {
    predicate_1.assertBeforeFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: [
            join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.FROM, undefined)
        ],
    };
    return result;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./correlate */ "./node_modules/@squill/squill/dist/from-clause/util/operation/correlate.js"));
__export(__webpack_require__(/*! ./cross-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/cross-join.js"));
__export(__webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/from-clause/util/operation/from.js"));
__export(__webpack_require__(/*! ./inner-join-using-candidate-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./inner-join-using-primary-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./inner-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join.js"));
__export(__webpack_require__(/*! ./left-join-using-candidate-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./left-join-using-primary-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./left-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join.js"));
__export(__webpack_require__(/*! ./require-nullable-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-nullable-outer-query-joins.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins-impl */ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins-impl.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins.js"));
__export(__webpack_require__(/*! ./where-eq-candidate-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-columns */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-columns.js"));
__export(__webpack_require__(/*! ./where-eq-inner-query-primary-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-candidate-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-primary-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-primary-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-super-key */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-super-key.js"));
__export(__webpack_require__(/*! ./where-eq */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq.js"));
__export(__webpack_require__(/*! ./where-is-not-null */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-not-null.js"));
__export(__webpack_require__(/*! ./where-is-null */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-null.js"));
__export(__webpack_require__(/*! ./where-null-safe-eq */ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-null-safe-eq.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-candidate-key.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-candidate-key.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const inner_join_1 = __webpack_require__(/*! ./inner-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .innerJoin(
 *      otherTable,
 *      () => tsql.eqCandidateKeyOfTable(
 *          myTable,
 *          otherTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      )
 *  )
 * ```
 *
 * ```sql
 *  INNER JOIN
 *      otherTable
 *  ON
 *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
 *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
 *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
 *      --snip
 * ```
 */
function innerJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = inner_join_1.innerJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
    });
    return result;
}
exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
//# sourceMappingURL=inner-join-using-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-primary-key.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join-using-primary-key.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const inner_join_1 = __webpack_require__(/*! ./inner-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .innerJoin(
 *      otherTable,
 *      () => tsql.eqPrimaryKeyOfTable(
 *          myTable,
 *          otherTable
 *      )
 *  )
 * ```
 *
 * ```sql
 *  INNER JOIN
 *      otherTable
 *  ON
 *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
 *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
 *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
 *      --snip
 * ```
 */
function innerJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = inner_join_1.innerJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
    });
    return result;
}
exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
//# sourceMappingURL=inner-join-using-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/inner-join.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "./node_modules/@squill/squill/dist/on-clause/index.js");
/**
 * ```sql
 *  INNER JOIN
 *      myTable
 *  ON
 *      --condition
 * ```
 */
function innerJoin(fromClause, aliasedTable, onDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, false, join_1.JoinType.INNER, on_clause_1.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
    };
    return result;
}
exports.innerJoin = innerJoin;
//# sourceMappingURL=inner-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-candidate-key.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-candidate-key.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const left_join_1 = __webpack_require__(/*! ./left-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .leftJoin(
 *      otherTable,
 *      () => tsql.eqCandidateKeyOfTable(
 *          myTable,
 *          otherTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      )
 *  )
 * ```
 *
 * ```sql
 *  LEFT JOIN
 *      otherTable
 *  ON
 *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
 *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
 *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
 *      --snip
 * ```
 */
function leftJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = left_join_1.leftJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
    });
    return result;
}
exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
//# sourceMappingURL=left-join-using-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-primary-key.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/left-join-using-primary-key.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const left_join_1 = __webpack_require__(/*! ./left-join */ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Shorthand for,
 * ```ts
 *  //snip
 *  .leftJoin(
 *      otherTable,
 *      () => tsql.eqPrimaryKeyOfTable(
 *          myTable,
 *          otherTable
 *      )
 *  )
 * ```
 *
 * ```sql
 *  LEFT JOIN
 *      otherTable
 *  ON
 *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
 *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
 *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
 *      --snip
 * ```
 */
function leftJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = left_join_1.leftJoin(fromClause, aliasedTable, () => {
        /**
         * @todo Investigate assignability
         */
        return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
    });
    return result;
}
exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
//# sourceMappingURL=left-join-using-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/left-join.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/left-join.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "./node_modules/@squill/squill/dist/on-clause/index.js");
/**
 * ```sql
 *  LEFT JOIN
 *      myTable
 *  ON
 *      --condition
 * ```
 */
function leftJoin(fromClause, aliasedTable, onDelegate) {
    predicate_1.assertAfterFromClause(fromClause);
    predicate_1.assertValidCurrentJoinBase(fromClause, aliasedTable);
    const result = {
        outerQueryJoins: fromClause.outerQueryJoins,
        currentJoins: join_1.JoinArrayUtil.append(fromClause.currentJoins, join_1.JoinUtil.fromAliasedTable(aliasedTable, true, join_1.JoinType.LEFT, on_clause_1.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
    };
    return result;
}
exports.leftJoin = leftJoin;
//# sourceMappingURL=left-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-nullable-outer-query-joins.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/require-nullable-outer-query-joins.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const require_outer_query_joins_impl_1 = __webpack_require__(/*! ./require-outer-query-joins-impl */ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins-impl.js");
function requireNullableOuterQueryJoins(fromClause, ...aliasedTables) {
    return require_outer_query_joins_impl_1.requireOuterQueryJoinsImpl(fromClause, true, ...aliasedTables);
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
//# sourceMappingURL=require-nullable-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins-impl.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins-impl.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js");
function requireOuterQueryJoinsImpl(fromClause, nullable, ...aliasedTables) {
    if (aliasedTables.length == 0) {
        return fromClause;
    }
    predicate_1.assertValidOuterQueryJoins(fromClause, aliasedTables);
    const required = aliasedTables.map(aliasedTable => (join_1.JoinUtil.fromAliasedTable(aliasedTable, nullable, 
    /**
     * The `JoinType` does not matter for outer query joins.
     */
    join_1.JoinType.FROM, 
    /**
     * The `ON` clause doesn't matter, either.
     */
    undefined)));
    const outerQueryJoins = (fromClause.outerQueryJoins == undefined ?
        required :
        join_1.JoinArrayUtil.append(fromClause.outerQueryJoins, ...required));
    const result = {
        outerQueryJoins,
        currentJoins: fromClause.currentJoins,
    };
    return result;
}
exports.requireOuterQueryJoinsImpl = requireOuterQueryJoinsImpl;
//# sourceMappingURL=require-outer-query-joins-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const require_outer_query_joins_impl_1 = __webpack_require__(/*! ./require-outer-query-joins-impl */ "./node_modules/@squill/squill/dist/from-clause/util/operation/require-outer-query-joins-impl.js");
function requireOuterQueryJoins(fromClause, ...aliasedTables) {
    return require_outer_query_joins_impl_1.requireOuterQueryJoinsImpl(fromClause, false, ...aliasedTables);
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
//# sourceMappingURL=require-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-candidate-key.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-candidate-key.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqCandidateKey(
 *          myTable,
 *          myCandidateKey
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 * -----
 *
 * Excess properties are especially dangerous for this function.
 *
 * If your `candidateKeyInput` is actually a super key of two candidate keys,
 * then the candidate key this function compares against is arbitrary.
 *
 * The extra properties will be discarded.
 *
 * If you want to compare against a super key, use `whereEqSuperKey()` instead.
 *
 */
function whereEqCandidateKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqCandidateKeyDelegate = args[0];
    const candidateKey = args[1];
    const table = whereEqCandidateKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqCandidateKey(table, candidateKey)),
    };
    return result;
}
exports.whereEqCandidateKey = whereEqCandidateKey;
//# sourceMappingURL=where-eq-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-columns.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-columns.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqColumns(
 *          myTable,
 *          myColumns
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqColumns(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqColumnsDelegate = args[0];
    const columns = args[1];
    /**
     * @todo Investigate assignability
     */
    const table = whereEqColumnsDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqColumns(table, 
        /**
         * @todo Investigate assignability
         */
        columns)),
    };
    return result;
}
exports.whereEqColumns = whereEqColumns;
//# sourceMappingURL=where-eq-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-inner-query-primary-key.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKeyOfTable(
 *          outerQueryTable,
 *          currentQueryTable
 *      ));
 * ```
 * -----
 *
 * + The `outerQueryTable` does not need to have keys.
 * + The `currentQueryTable` must have a primary key.
 * + The `outerQueryTable` must have columns comparable to columns of `currentQueryTable`'s primary key.
 */
function whereEqInnerQueryPrimaryKey(fromClause, whereClause, srcDelegate, dstDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.outerQueryJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.currentJoins, src.columns)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
    };
    return result;
}
exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
//# sourceMappingURL=where-eq-inner-query-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-candidate-key.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqCandidateKeyOfTable(
 *          currentQueryTable,
 *          outerQueryTable,
 *          columns => [
 *              columns.candidateKey0,
 *              columns.candidateKey1,
 *              //etc.
 *          ]
 *      ));
 * ```
 * -----
 *
 * + The `currentQueryTable` does not need to have keys.
 * + The `outerQueryTable` must have at least one candidate key.
 * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s candidate key.
 */
function whereEqOuterQueryCandidateKey(fromClause, whereClause, 
/**
 * @todo Remove this
 */
eqCandidateKeyOfTable, srcDelegate, dstDelegate, eqCandidateKeyOfTableDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.outerQueryJoins)));
    ;
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => eqCandidateKeyOfTable(src, dst, eqCandidateKeyOfTableDelegate)),
    };
    return result;
}
exports.whereEqOuterQueryCandidateKey = whereEqOuterQueryCandidateKey;
//# sourceMappingURL=where-eq-outer-query-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-outer-query-primary-key.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKeyOfTable(
 *          currentQueryTable,
 *          outerQueryTable
 *      ));
 * ```
 * -----
 *
 * + The `currentQueryTable` does not need to have keys.
 * + The `outerQueryTable` must have a primary key.
 * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s primary key.
 */
function whereEqOuterQueryPrimaryKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for
 * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
srcDelegate, dstDelegate) {
    const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
    const dst = dstDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.outerQueryJoins, src.columns)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
    };
    return result;
}
exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
//# sourceMappingURL=where-eq-outer-query-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-primary-key.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-primary-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqPrimaryKey(
 *          myTable,
 *          myPrimaryKey
 *      ));
 * ```
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqPrimaryKey(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqPrimaryKeyDelegate = args[0];
    const primaryKey = args[1];
    const table = whereEqPrimaryKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithPrimaryKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eqPrimaryKey(table, 
        /**
         * @todo Investigate assignability
         */
        primaryKey)),
    };
    return result;
}
exports.whereEqPrimaryKey = whereEqPrimaryKey;
//# sourceMappingURL=where-eq-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-super-key.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq-super-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const join_map_1 = __webpack_require__(/*! ../../../join-map */ "./node_modules/@squill/squill/dist/join-map/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .where(() => tsql.eqSuperKey(
 *          myTable,
 *          mySuperKey
 *      ));
 * ```
 *
 * -----
 *
 * It is recommended to **only** use this with **object literals**.
 * Excess property checks are disabled for non-object literals.
 * Even if they were enabled, it is possible to slip in extra properties.
 *
 * Extra properties are ignored during run-time but may indicate lapses in logic.
 *
 */
function whereEqSuperKey(fromClause, whereClause, 
/**
 * @todo Remove this
 */
eqSuperKey, 
/**
 * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqSuperKeyDelegate = args[0];
    const superKey = args[1];
    const table = whereEqSuperKeyDelegate(join_map_1.JoinMapUtil.fromJoinArray(join_1.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
    const result = {
        fromClause,
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => eqSuperKey(table, superKey)),
    };
    return result;
}
exports.whereEqSuperKey = whereEqSuperKey;
//# sourceMappingURL=where-eq-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-eq.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
/**
 * Narrows a column's type based on equality to a value
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn = 1
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `1`.
 */
function whereEq(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereEqDelegate = args[0];
    const value = args[1];
    const columns = column_ref_1.ColumnRefUtil.extractNonNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereEqDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
            /**
             * Cast to the type of `ValueT`
             */
            /*
            tm.or(
                BuiltInExprUtil.mapper(value),
                tm.pipe(
                    column.mapper,
                    BuiltInExprUtil.mapper(value)
                )
            )*/
            column.mapper),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.eq(column, built_in_expr_1.BuiltInExprUtil.fromValueExpr(column, value))),
    };
    return result;
}
exports.whereEq = whereEq;
//# sourceMappingURL=where-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-not-null.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-not-null.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
/**
 * Narrows a column's type to **exclude** `null`
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn IS NOT NULL
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set **WILL NOT** be `null`.
 */
function whereIsNotNull(fromClause, whereClause, whereIsNotNullDelegate) {
    const columns = column_ref_1.ColumnRefUtil.extractNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereIsNotNullDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.excludeLiteral(column.mapper, null)),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.isNotNull(column)),
    };
    return result;
}
exports.whereIsNotNull = whereIsNotNull;
//# sourceMappingURL=where-is-not-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-null.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-is-null.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
/**
 * Narrows a column's type to `null`
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn IS NULL
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `null`.
 */
function whereIsNull(fromClause, whereClause, whereIsNullDelegate) {
    const columns = column_ref_1.ColumnRefUtil.extractNullable(column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
    const column = whereIsNullDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.null()),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.isNull(column)),
    };
    return result;
}
exports.whereIsNull = whereIsNull;
//# sourceMappingURL=where-is-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/operation/where-null-safe-eq.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/operation/where-null-safe-eq.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
/**
 * Narrows a column's type based on null-safe equality to a value
 *
 * Given the below expression,
 * ```sql
 *  SELECT
 *      myTable.myColumn
 *  FROM
 *      myTable
 *  WHERE
 *      myTable.myColumn <=> 1
 * ```
 *
 * We know, without even executing the query,
 * that the type of `myTable.myColumn` for all rows
 * in the result set will be `1`.
 */
function whereNullSafeEq(fromClause, whereClause, 
/**
 * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const whereNullSafeEqDelegate = args[0];
    const value = args[1];
    const columns = column_ref_1.ColumnRefUtil.fromColumnArray(column_1.ColumnUtil.fromJoinArray(fromClause.currentJoins));
    const column = whereNullSafeEqDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
    const result = {
        fromClause: {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_1.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
            /**
             * Cast to the type of `ValueT`
             */
            /*
            tm.or(
                BuiltInExprUtil.mapper(value),
                tm.pipe(
                    column.mapper,
                    BuiltInExprUtil.mapper(value)
                )
            )*/
            column.mapper),
        },
        whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
        /**
         * @todo Investigate assignability
         */
        () => ExprLib.nullSafeEq(column, built_in_expr_1.BuiltInExprUtil.fromValueExpr(column_1.ColumnUtil.toNullable(column), value))),
    };
    return result;
}
exports.whereNullSafeEq = whereNullSafeEq;
//# sourceMappingURL=where-null-safe-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/allowed-used-ref.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/allowed-used-ref.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function allowedJoinArray(fromClause, aliasedTable) {
    return [
        ...((fromClause.outerQueryJoins != undefined) ?
            fromClause.outerQueryJoins :
            []),
        ...((aliasedTable.isLateral && fromClause.currentJoins != undefined) ?
            fromClause.currentJoins :
            []),
    ];
}
exports.allowedJoinArray = allowedJoinArray;
function allowedColumnRef(fromClause, aliasedTable) {
    return column_ref_1.ColumnRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedColumnRef = allowedColumnRef;
function allowedColumnIdentifierRef(fromClause, aliasedTable) {
    return column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
function allowedUsedRef(fromClause, aliasedTable) {
    return used_ref_1.UsedRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-after-from-clause.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-after-from-clause.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertAfterFromClause(fromClause) {
    if (fromClause.currentJoins == undefined) {
        throw new Error(`Must be after FROM clause`);
    }
}
exports.assertAfterFromClause = assertAfterFromClause;
//# sourceMappingURL=assert-after-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-before-from-clause.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-before-from-clause.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertBeforeFromClause(fromClause) {
    if (fromClause.currentJoins != undefined) {
        throw new Error(`Must be before FROM clause`);
    }
}
exports.assertBeforeFromClause = assertBeforeFromClause;
//# sourceMappingURL=assert-before-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-no-used-ref.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-no-used-ref.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNoUsedRef(aliasedTable) {
    if (Object.keys(aliasedTable.usedRef.columns).length > 0) {
        throw new Error(`Derived table ${aliasedTable.alias} must not reference outer query tables or tables in the same FROM/JOIN clause`);
    }
}
exports.assertNoUsedRef = assertNoUsedRef;
//# sourceMappingURL=assert-no-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-current-joins.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-current-joins.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotInCurrentJoins(fromClause, aliasedTable) {
    if (fromClause.currentJoins != undefined) {
        if (fromClause.currentJoins.some(j => j.tableAlias == aliasedTable.alias)) {
            throw new Error(`Table alias ${aliasedTable.alias} already used in current query JOINs`);
        }
    }
}
exports.assertNotInCurrentJoins = assertNotInCurrentJoins;
//# sourceMappingURL=assert-not-in-current-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotInOuterQueryJoins(fromClause, aliasedTable) {
    if (fromClause.outerQueryJoins != undefined) {
        if (fromClause.outerQueryJoins.some(j => j.tableAlias == aliasedTable.alias)) {
            throw new Error(`Table alias ${aliasedTable.alias} already used in outer query JOINs`);
        }
    }
}
exports.assertNotInOuterQueryJoins = assertNotInOuterQueryJoins;
//# sourceMappingURL=assert-not-in-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-lateral.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-lateral.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNotLateral(aliasedTable) {
    if (aliasedTable.isLateral) {
        throw new Error(`${aliasedTable.alias} cannot be LATERAL; does your DBMS support it?`);
    }
}
exports.assertNotLateral = assertNotLateral;
//# sourceMappingURL=assert-not-lateral.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-current-join-base.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-current-join-base.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_not_in_current_joins_1 = __webpack_require__(/*! ./assert-not-in-current-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-current-joins.js");
const assert_not_in_outer_query_joins_1 = __webpack_require__(/*! ./assert-not-in-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js");
const allowed_used_ref_1 = __webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/allowed-used-ref.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function assertValidCurrentJoinBase(fromClause, aliasedTable) {
    assert_not_in_current_joins_1.assertNotInCurrentJoins(fromClause, aliasedTable);
    assert_not_in_outer_query_joins_1.assertNotInOuterQueryJoins(fromClause, aliasedTable);
    used_ref_1.UsedRefUtil.assertAllowed(allowed_used_ref_1.allowedUsedRef(fromClause, aliasedTable), aliasedTable.usedRef);
}
exports.assertValidCurrentJoinBase = assertValidCurrentJoinBase;
//# sourceMappingURL=assert-valid-current-join-base.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_not_in_current_joins_1 = __webpack_require__(/*! ./assert-not-in-current-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-current-joins.js");
const assert_not_in_outer_query_joins_1 = __webpack_require__(/*! ./assert-not-in-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js");
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "./node_modules/@squill/squill/dist/aliased-table/index.js");
function assertValidOuterQueryJoins(fromClause, aliasedTables) {
    for (const aliasedTable of aliasedTables) {
        assert_not_in_current_joins_1.assertNotInCurrentJoins(fromClause, aliasedTable);
        assert_not_in_outer_query_joins_1.assertNotInOuterQueryJoins(fromClause, aliasedTable);
    }
    aliased_table_1.AliasedTableArrayUtil.assertNoDuplicateTableAlias(aliasedTables);
}
exports.assertValidOuterQueryJoins = assertValidOuterQueryJoins;
//# sourceMappingURL=assert-valid-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/allowed-used-ref.js"));
__export(__webpack_require__(/*! ./assert-after-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-after-from-clause.js"));
__export(__webpack_require__(/*! ./assert-before-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-before-from-clause.js"));
__export(__webpack_require__(/*! ./assert-no-used-ref */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-no-used-ref.js"));
__export(__webpack_require__(/*! ./assert-not-in-current-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-current-joins.js"));
__export(__webpack_require__(/*! ./assert-not-in-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-in-outer-query-joins.js"));
__export(__webpack_require__(/*! ./assert-not-lateral */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-not-lateral.js"));
__export(__webpack_require__(/*! ./assert-valid-current-join-base */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-current-join-base.js"));
__export(__webpack_require__(/*! ./assert-valid-outer-query-joins */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/assert-valid-outer-query-joins.js"));
__export(__webpack_require__(/*! ./is-after-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-after-from-clause.js"));
__export(__webpack_require__(/*! ./is-before-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-before-from-clause.js"));
__export(__webpack_require__(/*! ./is-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-from-clause.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-after-from-clause.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/is-after-from-clause.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_from_clause_1 = __webpack_require__(/*! ./is-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-from-clause.js");
function isAfterFromClause(x) {
    return is_from_clause_1.isFromClause(x) && (x.currentJoins != undefined);
}
exports.isAfterFromClause = isAfterFromClause;
//# sourceMappingURL=is-after-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-before-from-clause.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/is-before-from-clause.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_from_clause_1 = __webpack_require__(/*! ./is-from-clause */ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-from-clause.js");
function isBeforeFromClause(x) {
    return is_from_clause_1.isFromClause(x) && (x.currentJoins == undefined);
}
exports.isBeforeFromClause = isBeforeFromClause;
//# sourceMappingURL=is-before-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/predicate/is-from-clause.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/predicate/is-from-clause.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Only checks that the properties exist.
 * Does not actually check that they are the right data type!
 *
 * @todo Consider adding checks for increased type safety.
 */
function isFromClause(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "outerQueryJoins",
        "currentJoins",
    ])) {
        return false;
    }
    return true;
}
exports.isFromClause = isFromClause;
//# sourceMappingURL=is-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/query/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/query/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./outer-query-table-alias */ "./node_modules/@squill/squill/dist/from-clause/util/query/outer-query-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/from-clause/util/query/outer-query-table-alias.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/from-clause/util/query/outer-query-table-alias.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function outerQueryTableAlias(fromClause) {
    if (fromClause.outerQueryJoins == undefined) {
        return [];
    }
    else {
        return fromClause.outerQueryJoins.map(join => join.tableAlias);
    }
}
exports.outerQueryTableAlias = outerQueryTableAlias;
//# sourceMappingURL=outer-query-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupByClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/group-by-clause/util/index.js");
exports.GroupByClauseUtil = GroupByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/group-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/group-by-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/group-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/operation/group-by.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/operation/group-by.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/group-by-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
/**
 * Returns the MySQL equivalent of `...groupByClause, ...groupByDelegate(columns)`
 *
 * -----
 *
 * Consider the following,
 * ```sql
 *  SELECT 1 AS a GROUP BY a
 * ```
 *
 * + The above works on PostgreSQL 9.4
 * + The above **does not** work on MySQL 5.7
 * -----
 *
 * We only allow `GROUP BY` after the `FROM` clause because
 * it isn't very useful without a `FROM` clause.
 *
 * @param fromClause
 * @param selectClause
 * @param groupByClause
 * @param groupByDelegate
 */
function groupBy(fromClause, groupByClause, groupByDelegate) {
    from_clause_1.FromClauseUtil.assertAfterFromClause(fromClause);
    const columns = query_1.allowedColumnIdentifierRef(fromClause);
    const groupBy = groupByDelegate(column_identifier_ref_1.ColumnIdentifierRefUtil.tryFlatten(columns));
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(columns, groupBy);
    return (groupByClause == undefined ?
        groupBy :
        [...groupByClause, ...groupBy]);
}
exports.groupBy = groupBy;
//# sourceMappingURL=group-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/operation/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/operation/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./group-by */ "./node_modules/@squill/squill/dist/group-by-clause/util/operation/group-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/predicate/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/predicate/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-non-empty */ "./node_modules/@squill/squill/dist/group-by-clause/util/predicate/is-non-empty.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/predicate/is-non-empty.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/predicate/is-non-empty.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertNonEmpty(groupByClause) {
    if (groupByClause.length == 0) {
        throw new Error(`GROUP BY clause cannot be empty`);
    }
}
exports.assertNonEmpty = assertNonEmpty;
//# sourceMappingURL=is-non-empty.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/query/allowed-used-ref.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/query/allowed-used-ref.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function allowedColumnIdentifierRef(fromClause) {
    return column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(fromClause.currentJoins);
}
exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/group-by-clause/util/query/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/group-by-clause/util/query/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/group-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const HavingClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/having-clause/util/index.js");
exports.HavingClauseUtil = HavingClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/having-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/having-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/operation/having.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/operation/having.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/having-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const group_by_clause_1 = __webpack_require__(/*! ../../../group-by-clause */ "./node_modules/@squill/squill/dist/group-by-clause/index.js");
/**
 * Returns the MySQL equivalent of `havingClause AND havingDelegate(columns)`
 *
 * -----
 *
 * For now, this is basically the same as `WhereClauseUtil.where<>()`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 *
 * -----
 *
 * @param fromClause
 * @param havingClause
 * @param havingDelegate
 */
function having(fromClause, groupByClause, havingClause, havingDelegate) {
    group_by_clause_1.GroupByClauseUtil.assertNonEmpty(groupByClause);
    const columns = query_1.allowedColumnRef(fromClause);
    const operand = havingDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    if (built_in_expr_1.BuiltInExprUtil.isAggregate(operand)) {
        used_ref_1.UsedRefUtil.assertAllowed({ columns }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    }
    else {
        used_ref_1.UsedRefUtil.assertAllowed({
            columns: query_1.allowedNonAggregateColumnRef(fromClause, groupByClause),
        }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    }
    return (havingClause == undefined ?
        expr_1.ExprUtil.fromBuiltInExpr(operand) :
        ExprLib.and(havingClause, operand));
}
exports.having = having;
//# sourceMappingURL=having.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./having */ "./node_modules/@squill/squill/dist/having-clause/util/operation/having.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause) {
    const outer = column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    return column_ref_1.ColumnRefUtil.intersect(outer, inner);
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause) {
    return used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/query/allowed-used-ref.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/query/allowed-used-ref.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
/**
 * For now, this is basically the same as `WhereClauseUtil.AllowedColumnRef<>`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 */
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
/**
 * For now, this is basically the same as `WhereClauseUtil.AllowedUsedRef<>`.
 *
 * They will diverge when,
 * + The `HAVING` clause enforces proper `GROUP BY` interactions.
 */
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/having-clause/util/query/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/having-clause/util/query/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "./node_modules/@squill/squill/dist/having-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/having-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@squill/squill/dist/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./aliased-expr */ "./node_modules/@squill/squill/dist/aliased-expr/index.js"));
__export(__webpack_require__(/*! ./aliased-table */ "./node_modules/@squill/squill/dist/aliased-table/index.js"));
__export(__webpack_require__(/*! ./ast */ "./node_modules/@squill/squill/dist/ast/index.js"));
__export(__webpack_require__(/*! ./built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js"));
__export(__webpack_require__(/*! ./built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js"));
__export(__webpack_require__(/*! ./candidate-key */ "./node_modules/@squill/squill/dist/candidate-key/index.js"));
__export(__webpack_require__(/*! ./column */ "./node_modules/@squill/squill/dist/column/index.js"));
__export(__webpack_require__(/*! ./column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js"));
__export(__webpack_require__(/*! ./column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js"));
__export(__webpack_require__(/*! ./column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js"));
__export(__webpack_require__(/*! ./column-map */ "./node_modules/@squill/squill/dist/column-map/index.js"));
__export(__webpack_require__(/*! ./column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js"));
__export(__webpack_require__(/*! ./compound-query */ "./node_modules/@squill/squill/dist/compound-query/index.js"));
__export(__webpack_require__(/*! ./compound-query-clause */ "./node_modules/@squill/squill/dist/compound-query-clause/index.js"));
__export(__webpack_require__(/*! ./compound-query-order-by-clause */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/index.js"));
__export(__webpack_require__(/*! ./custom-expr */ "./node_modules/@squill/squill/dist/custom-expr/index.js"));
__export(__webpack_require__(/*! ./data-type */ "./node_modules/@squill/squill/dist/data-type/index.js"));
__export(__webpack_require__(/*! ./derived-table */ "./node_modules/@squill/squill/dist/derived-table/index.js"));
__export(__webpack_require__(/*! ./derived-table-select-item */ "./node_modules/@squill/squill/dist/derived-table-select-item/index.js"));
__export(__webpack_require__(/*! ./design-pattern-log */ "./node_modules/@squill/squill/dist/design-pattern-log/index.js"));
__export(__webpack_require__(/*! ./design-pattern-table-per-type */ "./node_modules/@squill/squill/dist/design-pattern-table-per-type/index.js"));
__export(__webpack_require__(/*! ./event */ "./node_modules/@squill/squill/dist/event/index.js"));
__export(__webpack_require__(/*! ./execution */ "./node_modules/@squill/squill/dist/execution/index.js"));
__export(__webpack_require__(/*! ./expr */ "./node_modules/@squill/squill/dist/expr/index.js"));
__export(__webpack_require__(/*! ./expr-column */ "./node_modules/@squill/squill/dist/expr-column/index.js"));
__export(__webpack_require__(/*! ./expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js"));
__export(__webpack_require__(/*! ./expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js"));
__export(__webpack_require__(/*! ./from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js"));
__export(__webpack_require__(/*! ./group-by-clause */ "./node_modules/@squill/squill/dist/group-by-clause/index.js"));
__export(__webpack_require__(/*! ./having-clause */ "./node_modules/@squill/squill/dist/having-clause/index.js"));
__export(__webpack_require__(/*! ./insert */ "./node_modules/@squill/squill/dist/insert/index.js"));
__export(__webpack_require__(/*! ./insert-select */ "./node_modules/@squill/squill/dist/insert-select/index.js"));
__export(__webpack_require__(/*! ./join */ "./node_modules/@squill/squill/dist/join/index.js"));
__export(__webpack_require__(/*! ./join-map */ "./node_modules/@squill/squill/dist/join-map/index.js"));
__export(__webpack_require__(/*! ./key */ "./node_modules/@squill/squill/dist/key/index.js"));
__export(__webpack_require__(/*! ./limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js"));
__export(__webpack_require__(/*! ./map-delegate */ "./node_modules/@squill/squill/dist/map-delegate/index.js"));
__export(__webpack_require__(/*! ./mapper-map */ "./node_modules/@squill/squill/dist/mapper-map/index.js"));
__export(__webpack_require__(/*! ./on-clause */ "./node_modules/@squill/squill/dist/on-clause/index.js"));
__export(__webpack_require__(/*! ./order */ "./node_modules/@squill/squill/dist/order/index.js"));
__export(__webpack_require__(/*! ./order-by-clause */ "./node_modules/@squill/squill/dist/order-by-clause/index.js"));
__export(__webpack_require__(/*! ./partial-row */ "./node_modules/@squill/squill/dist/partial-row/index.js"));
__export(__webpack_require__(/*! ./primary-key */ "./node_modules/@squill/squill/dist/primary-key/index.js"));
__export(__webpack_require__(/*! ./query-base */ "./node_modules/@squill/squill/dist/query-base/index.js"));
__export(__webpack_require__(/*! ./row */ "./node_modules/@squill/squill/dist/row/index.js"));
__export(__webpack_require__(/*! ./schema-validation */ "./node_modules/@squill/squill/dist/schema-validation/index.js"));
__export(__webpack_require__(/*! ./select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js"));
__export(__webpack_require__(/*! ./select-item */ "./node_modules/@squill/squill/dist/select-item/index.js"));
__export(__webpack_require__(/*! ./sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js"));
__export(__webpack_require__(/*! ./super-key */ "./node_modules/@squill/squill/dist/super-key/index.js"));
__export(__webpack_require__(/*! ./sqlstring */ "./node_modules/@squill/squill/dist/sqlstring/index.js"));
__export(__webpack_require__(/*! ./table */ "./node_modules/@squill/squill/dist/table/index.js"));
__export(__webpack_require__(/*! ./table-where */ "./node_modules/@squill/squill/dist/table-where/index.js"));
__export(__webpack_require__(/*! ./type-map */ "./node_modules/@squill/squill/dist/type-map/index.js"));
__export(__webpack_require__(/*! ./type-ref */ "./node_modules/@squill/squill/dist/type-ref/index.js"));
__export(__webpack_require__(/*! ./unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js"));
__export(__webpack_require__(/*! ./update */ "./node_modules/@squill/squill/dist/update/index.js"));
__export(__webpack_require__(/*! ./used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js"));
__export(__webpack_require__(/*! ./value-expr */ "./node_modules/@squill/squill/dist/value-expr/index.js"));
__export(__webpack_require__(/*! ./where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js"));
__export(__webpack_require__(/*! ./async-queue */ "./node_modules/@squill/squill/dist/async-queue.js"));
__export(__webpack_require__(/*! ./constants */ "./node_modules/@squill/squill/dist/constants.js"));
__export(__webpack_require__(/*! ./error */ "./node_modules/@squill/squill/dist/error/index.js"));
__export(__webpack_require__(/*! ./isolation-level */ "./node_modules/@squill/squill/dist/isolation-level.js"));
__export(__webpack_require__(/*! ./operator-type */ "./node_modules/@squill/squill/dist/operator-type.js"));
__export(__webpack_require__(/*! ./transaction-access-mode */ "./node_modules/@squill/squill/dist/transaction-access-mode.js"));
__export(__webpack_require__(/*! ./type-hint */ "./node_modules/@squill/squill/dist/type-hint.js"));
const DateTimeUtil = __webpack_require__(/*! ./date-time-util */ "./node_modules/@squill/squill/dist/date-time-util/index.js");
exports.DateTimeUtil = DateTimeUtil;
const FormatUtil = __webpack_require__(/*! ./formatter */ "./node_modules/@squill/squill/dist/formatter/index.js");
exports.FormatUtil = FormatUtil;
const PromiseUtil = __webpack_require__(/*! ./promise-util */ "./node_modules/@squill/squill/dist/promise-util/index.js");
exports.PromiseUtil = PromiseUtil;
const TupleUtil = __webpack_require__(/*! ./tuple-util */ "./node_modules/@squill/squill/dist/tuple-util/index.js");
exports.TupleUtil = TupleUtil;
const TypeUtil = __webpack_require__(/*! ./type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
exports.TypeUtil = TypeUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InsertSelectUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/insert-select/util/index.js");
exports.InsertSelectUtil = InsertSelectUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/constructor/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/constructor/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./insert-select */ "./node_modules/@squill/squill/dist/insert-select/util/constructor/insert-select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/constructor/insert-select.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/constructor/insert-select.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/insert-select/util/operation/index.js");
function insertSelect(query, table, delegate) {
    const columns = column_ref_1.ColumnRefUtil.tryFlatten(column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause));
    const row = delegate(columns);
    return operation_1.cleanInsertSelectRow(query, table, row);
}
exports.insertSelect = insertSelect;
//# sourceMappingURL=insert-select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/insert-select/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/insert-select/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-column.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-column.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function cleanInsertSelectColumn(allowedColumnRef, table, row, columnAlias, required) {
    const customExpr = (
    /**
     * This is just safer.
     *
     * But how regularly should we access properties of mapped types this way?
     * All the time?
     * If so, why?
     *
     * Sometimes?
     * If so, what's the criteria?
     *
     * @todo Figure this out
     */
    (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
        row[columnAlias] :
        undefined);
    if (customExpr === undefined) {
        if (required) {
            throw new error_1.MissingRequiredInsertColumnError({
                message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                table,
                columnAlias
            });
        }
        else {
            return undefined;
        }
    }
    if (column_1.ColumnUtil.isColumn(customExpr)) {
        if (!column_identifier_ref_1.ColumnIdentifierRefUtil.hasColumnIdentifier(allowedColumnRef, customExpr)) {
            throw new Error(`Invalid SELECT alias ${customExpr.tableAlias}.${customExpr.columnAlias}`);
        }
        return customExpr;
    }
    else if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
        return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
    }
    else if (built_in_expr_1.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
        /**
         * Can't really perform many checks here.
         * We can, however, check for `NULL`s.
         */
        if (query_base_1.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
            !tm.canOutputNull(table.columns[columnAlias].mapper)) {
            throw new error_1.PotentialNullInRequiredInsertColumnError({
                message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                table,
                columnAlias
            });
        }
        return customExpr;
    }
    else {
        /**
         * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
         */
        if (expr_1.ExprUtil.isExpr(customExpr) ||
            expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
            /**
             * @todo Should we validate these?
             * How would one even do that?
             */
            return customExpr;
        }
        /**
         * Maybe a custom data type?
         */
        return built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
    }
}
exports.cleanInsertSelectColumn = cleanInsertSelectColumn;
//# sourceMappingURL=clean-insert-select-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-row.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-row.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const clean_insert_select_column_1 = __webpack_require__(/*! ./clean-insert-select-column */ "./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-column.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
/**
 * + Removes excess properties.
 * + Removes properties with value `undefined`.
 * + Checks required properties are there.
 */
function cleanInsertSelectRow(query, table, row) {
    const allowedColumnRef = column_ref_1.ColumnRefUtil.fromSelectClause(query.selectClause);
    const result = {};
    for (const requiredColumnAlias of table_1.TableUtil.requiredColumnAlias(table)) {
        result[requiredColumnAlias] = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, requiredColumnAlias, true);
    }
    for (const optionalColumnAlias of table_1.TableUtil.optionalColumnAlias(table)) {
        const value = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, optionalColumnAlias, false);
        if (value === undefined) {
            continue;
        }
        result[optionalColumnAlias] = value;
    }
    return result;
}
exports.cleanInsertSelectRow = cleanInsertSelectRow;
//# sourceMappingURL=clean-insert-select-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert-select/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert-select/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-select-column */ "./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-column.js"));
__export(__webpack_require__(/*! ./clean-insert-select-row */ "./node_modules/@squill/squill/dist/insert-select/util/operation/clean-insert-select-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InsertUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/insert/util/index.js");
exports.InsertUtil = InsertUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert/util/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert/util/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/insert/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-column.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-column.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const built_in_value_expr_1 = __webpack_require__(/*! ../../../built-in-value-expr */ "./node_modules/@squill/squill/dist/built-in-value-expr/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const error_1 = __webpack_require__(/*! ../../../error */ "./node_modules/@squill/squill/dist/error/index.js");
function cleanInsertColumn(table, row, columnAlias, required) {
    const customExpr = (
    /**
     * This is just safer.
     *
     * But how regularly should we access properties of mapped types this way?
     * All the time?
     * If so, why?
     *
     * Sometimes?
     * If so, what's the criteria?
     *
     * @todo Figure this out
     */
    (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
        row[columnAlias] :
        undefined);
    if (customExpr === undefined) {
        if (required) {
            throw new error_1.MissingRequiredInsertColumnError({
                message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                table,
                columnAlias
            });
        }
        else {
            return undefined;
        }
    }
    if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
        return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
    }
    else if (built_in_expr_1.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
        /**
         * Can't really perform many checks here.
         * We can, however, check for `NULL`s.
         */
        if (query_base_1.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
            !tm.canOutputNull(table.columns[columnAlias].mapper)) {
            throw new error_1.PotentialNullInRequiredInsertColumnError({
                message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                table,
                columnAlias
            });
        }
        return customExpr;
    }
    else {
        /**
         * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
         */
        if (expr_1.ExprUtil.isExpr(customExpr) ||
            expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
            /**
             * @todo Should we validate these?
             * How would one even do that?
             */
            return customExpr;
        }
        /**
         * Maybe a custom data type?
         */
        return built_in_expr_1.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
    }
}
exports.cleanInsertColumn = cleanInsertColumn;
//# sourceMappingURL=clean-insert-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-row.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-row.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
const clean_insert_column_1 = __webpack_require__(/*! ./clean-insert-column */ "./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-column.js");
/**
 * + Removes excess properties.
 * + Removes properties with value `undefined`.
 * + Checks required properties are there.
 */
function cleanInsertRow(table, row) {
    const result = {};
    for (const requiredColumnAlias of table_1.TableUtil.requiredColumnAlias(table)) {
        result[requiredColumnAlias] = clean_insert_column_1.cleanInsertColumn(table, row, requiredColumnAlias, true);
    }
    for (const optionalColumnAlias of table_1.TableUtil.optionalColumnAlias(table)) {
        const value = clean_insert_column_1.cleanInsertColumn(table, row, optionalColumnAlias, false);
        if (value === undefined) {
            continue;
        }
        result[optionalColumnAlias] = value;
    }
    return result;
}
exports.cleanInsertRow = cleanInsertRow;
//# sourceMappingURL=clean-insert-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/insert/util/operation/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/insert/util/operation/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-insert-column */ "./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-column.js"));
__export(__webpack_require__(/*! ./clean-insert-row */ "./node_modules/@squill/squill/dist/insert/util/operation/clean-insert-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/isolation-level.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/isolation-level.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Isolation levels ranked from weakest to strongest,
 * 1. `READ_UNCOMMITTED`
 * 2. `READ_COMMITTED`
 * 3. `REPEATABLE_READ`
 * 4. `SERIALIZABLE`
 *
 * https://github.com/AnyhowStep/tsql/issues/14
 */
var IsolationLevel;
(function (IsolationLevel) {
    IsolationLevel["READ_UNCOMMITTED"] = "READ_UNCOMMITTED";
    IsolationLevel["READ_COMMITTED"] = "READ_COMMITTED";
    IsolationLevel["REPEATABLE_READ"] = "REPEATABLE_READ";
    IsolationLevel["SERIALIZABLE"] = "SERIALIZABLE";
})(IsolationLevel = exports.IsolationLevel || (exports.IsolationLevel = {}));
var IsolationLevelUtil;
(function (IsolationLevelUtil) {
    const isolationLevelStrengths = {
        [IsolationLevel.READ_UNCOMMITTED]: 0,
        [IsolationLevel.READ_COMMITTED]: 1,
        [IsolationLevel.REPEATABLE_READ]: 2,
        [IsolationLevel.SERIALIZABLE]: 3,
    };
    /**
     * Is isolation level `a` weaker than `b`?
     */
    function isWeakerThan(a, b) {
        return isolationLevelStrengths[a] < isolationLevelStrengths[b];
    }
    IsolationLevelUtil.isWeakerThan = isWeakerThan;
})(IsolationLevelUtil = exports.IsolationLevelUtil || (exports.IsolationLevelUtil = {}));
//# sourceMappingURL=isolation-level.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join-map/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join-map/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const JoinMapUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/join-map/util/index.js");
exports.JoinMapUtil = JoinMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join-map/util/constructor/from-join-array.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join-map/util/constructor/from-join-array.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromJoinArray(joins) {
    const result = {};
    for (const join of joins) {
        result[join.tableAlias] = join;
    }
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join-map/util/constructor/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join-map/util/constructor/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/join-map/util/constructor/from-join-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join-map/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join-map/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/join-map/util/constructor/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/join/array-util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/join/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/operation/append.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/operation/append.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function append(arr, ...join) {
    return [...arr, ...join];
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/operation/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/operation/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "./node_modules/@squill/squill/dist/join/array-util/operation/append.js"));
__export(__webpack_require__(/*! ./replace-column */ "./node_modules/@squill/squill/dist/join/array-util/operation/replace-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/operation/replace-column.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/operation/replace-column.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const JoinUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/join/util/index.js");
function replaceColumn(joins, tableAlias, columnAlias, mapper) {
    return joins.map(join => JoinUtil.replaceColumn(join, tableAlias, columnAlias, mapper));
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-candidate-key.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/query/extract-with-candidate-key.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function extractWithCandidateKey(joins) {
    return joins.filter((join) => (join.candidateKeys.length > 0));
}
exports.extractWithCandidateKey = extractWithCandidateKey;
//# sourceMappingURL=extract-with-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = __webpack_require__(/*! ../../../table */ "./node_modules/@squill/squill/dist/table/index.js");
function extractWithNullSafeComparablePrimaryKey(joins, columnMap) {
    return joins.filter((join) => {
        if (join.primaryKey == undefined) {
            return false;
        }
        return table_1.TableUtil.hasNullSafeComparablePrimaryKey({
            columns: join.columns,
            primaryKey: join.primaryKey,
        }, columnMap);
    });
}
exports.extractWithNullSafeComparablePrimaryKey = extractWithNullSafeComparablePrimaryKey;
//# sourceMappingURL=extract-with-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-primary-key.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/query/extract-with-primary-key.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function extractWithPrimaryKey(joins) {
    return joins.filter((join) => (join.primaryKey != undefined));
}
exports.extractWithPrimaryKey = extractWithPrimaryKey;
//# sourceMappingURL=extract-with-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/array-util/query/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/array-util/query/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-with-candidate-key */ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-candidate-key.js"));
__export(__webpack_require__(/*! ./extract-with-primary-key */ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-primary-key.js"));
__export(__webpack_require__(/*! ./extract-with-null-safe-comparable-primary-key */ "./node_modules/@squill/squill/dist/join/array-util/query/extract-with-null-safe-comparable-primary-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./join-impl */ "./node_modules/@squill/squill/dist/join/join-impl.js"));
__export(__webpack_require__(/*! ./join */ "./node_modules/@squill/squill/dist/join/join.js"));
const JoinArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/join/array-util/index.js");
exports.JoinArrayUtil = JoinArrayUtil;
const JoinUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/join/util/index.js");
exports.JoinUtil = JoinUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/join-impl.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/join-impl.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Join {
    constructor(data, joinType, onClause, tableAst) {
        this.tableAlias = data.tableAlias;
        this.columns = data.columns;
        this.nullable = data.nullable;
        this.originalColumns = data.originalColumns;
        this.primaryKey = data.primaryKey;
        this.candidateKeys = data.candidateKeys;
        this.deleteEnabled = data.deleteEnabled;
        this.mutableColumns = data.mutableColumns;
        this.joinType = joinType;
        this.onClause = onClause;
        this.tableAst = tableAst;
    }
}
exports.Join = Join;
//# sourceMappingURL=join-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/join.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/join.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
var JoinType;
(function (JoinType) {
    JoinType["FROM"] = "FROM";
    JoinType["INNER"] = "INNER";
    JoinType["LEFT"] = "LEFT";
    /**
     * @todo Remove this?
     */
    JoinType["RIGHT"] = "RIGHT";
    JoinType["CROSS"] = "CROSS";
})(JoinType = exports.JoinType || (exports.JoinType = {}));
;
exports.JoinTypeValues = tm.EnumUtil.getValues(JoinType);
//# sourceMappingURL=join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/util/constructor/from-aliased-table.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/util/constructor/from-aliased-table.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const join_impl_1 = __webpack_require__(/*! ../../join-impl */ "./node_modules/@squill/squill/dist/join/join-impl.js");
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "./node_modules/@squill/squill/dist/aliased-table/index.js");
function fromAliasedTable(aliasedTable, nullable, joinType, onClause) {
    const result = new join_impl_1.Join({
        tableAlias: aliasedTable.alias,
        nullable,
        columns: aliasedTable.columns,
        originalColumns: aliasedTable.columns,
        primaryKey: aliased_table_1.AliasedTableUtil.primaryKey(aliasedTable),
        candidateKeys: aliased_table_1.AliasedTableUtil.candidateKeys(aliasedTable),
        deleteEnabled: aliased_table_1.AliasedTableUtil.deleteEnabled(aliasedTable),
        mutableColumns: aliased_table_1.AliasedTableUtil.mutableColumns(aliasedTable),
    }, joinType, onClause, aliasedTable.unaliasedAst);
    return result;
}
exports.fromAliasedTable = fromAliasedTable;
//# sourceMappingURL=from-aliased-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/util/constructor/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/util/constructor/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-aliased-table */ "./node_modules/@squill/squill/dist/join/util/constructor/from-aliased-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/join/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/join/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/util/operation/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/util/operation/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./replace-column */ "./node_modules/@squill/squill/dist/join/util/operation/replace-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/join/util/operation/replace-column.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/join/util/operation/replace-column.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const join_impl_1 = __webpack_require__(/*! ../../join-impl */ "./node_modules/@squill/squill/dist/join/join-impl.js");
function replaceColumn(join, tableAlias, columnAlias, mapper) {
    if (join.tableAlias == tableAlias &&
        Object.prototype.hasOwnProperty.call(join.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(join.columns, columnAlias)) {
        const { tableAlias, nullable, columns, originalColumns, primaryKey, candidateKeys, deleteEnabled, mutableColumns, } = join;
        const result = new join_impl_1.Join({
            tableAlias,
            nullable,
            columns: column_map_1.ColumnMapUtil.replaceColumn(columns, columnAlias, mapper),
            originalColumns,
            primaryKey,
            candidateKeys,
            deleteEnabled,
            mutableColumns,
        }, join.joinType, join.onClause, join.tableAst);
        return result;
    }
    else {
        return join;
    }
}
exports.replaceColumn = replaceColumn;
//# sourceMappingURL=replace-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/key/array-util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/key/array-util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/key/array-util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/operation/append.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/operation/append.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/array-util/operation/remove-duplicates.js");
function append(arr, key) {
    return remove_duplicates_1.removeDuplicates([...arr, key]);
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/operation/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/operation/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "./node_modules/@squill/squill/dist/key/array-util/operation/append.js"));
__export(__webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/array-util/operation/remove-duplicates.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/operation/remove-duplicates.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/operation/remove-duplicates.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/key/array-util/predicate/index.js");
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function removeDuplicates(arr) {
    const result = [];
    for (const key of arr) {
        if (!predicate_1.hasKey(result, key)) {
            result.push(KeyUtil.removeDuplicates(key));
        }
    }
    return result;
}
exports.removeDuplicates = removeDuplicates;
//# sourceMappingURL=remove-duplicates.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-key.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/has-key.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function hasKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isEqual(k, key)) {
            return true;
        }
    }
    return false;
}
exports.hasKey = hasKey;
//# sourceMappingURL=has-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-sub-key.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/has-sub-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function hasSubKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isSubKey(k, key)) {
            return true;
        }
    }
    return false;
}
exports.hasSubKey = hasSubKey;
//# sourceMappingURL=has-sub-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-super-key.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/has-super-key.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function hasSuperKey(arr, key) {
    for (const k of arr) {
        if (KeyUtil.isSubKey(key, k)) {
            return true;
        }
    }
    return false;
}
exports.hasSuperKey = hasSuperKey;
//# sourceMappingURL=has-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./has-key */ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-key.js"));
__export(__webpack_require__(/*! ./has-sub-key */ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-sub-key.js"));
__export(__webpack_require__(/*! ./has-super-key */ "./node_modules/@squill/squill/dist/key/array-util/predicate/has-super-key.js"));
__export(__webpack_require__(/*! ./is-key-array */ "./node_modules/@squill/squill/dist/key/array-util/predicate/is-key-array.js"));
__export(__webpack_require__(/*! ./is-disjoint */ "./node_modules/@squill/squill/dist/key/array-util/predicate/is-disjoint.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/is-disjoint.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/is-disjoint.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function isDisjoint(arrayA, arrayB) {
    for (const a of arrayA) {
        for (const b of arrayB) {
            if (KeyUtil.isEqual(a, b)) {
                return false;
            }
        }
    }
    return true;
}
exports.isDisjoint = isDisjoint;
//# sourceMappingURL=is-disjoint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/predicate/is-key-array.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/predicate/is-key-array.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function isKeyArray(raw) {
    if (!Array.isArray(raw)) {
        return false;
    }
    for (const item of raw) {
        if (!KeyUtil.isKey(item)) {
            return false;
        }
    }
    return true;
}
exports.isKeyArray = isKeyArray;
//# sourceMappingURL=is-key-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/query/find-sub-key.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/query/find-sub-key.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function findSubKeys(arr, key) {
    const result = [];
    for (const k of arr) {
        if (KeyUtil.isSubKey(k, key)) {
            result.push(k);
        }
    }
    return result;
}
exports.findSubKeys = findSubKeys;
//# sourceMappingURL=find-sub-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/query/find-super-key.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/query/find-super-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyUtil = __webpack_require__(/*! ../../util */ "./node_modules/@squill/squill/dist/key/util/index.js");
function findSuperKeys(arr, key) {
    const result = [];
    for (const k of arr) {
        if (KeyUtil.isSubKey(key, k)) {
            result.push(k);
        }
    }
    return result;
}
exports.findSuperKeys = findSuperKeys;
//# sourceMappingURL=find-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/array-util/query/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/array-util/query/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./find-sub-key */ "./node_modules/@squill/squill/dist/key/array-util/query/find-sub-key.js"));
__export(__webpack_require__(/*! ./find-super-key */ "./node_modules/@squill/squill/dist/key/array-util/query/find-super-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const KeyArrayUtil = __webpack_require__(/*! ./array-util */ "./node_modules/@squill/squill/dist/key/array-util/index.js");
exports.KeyArrayUtil = KeyArrayUtil;
const KeyUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/key/util/index.js");
exports.KeyUtil = KeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/constructor/from-column-array.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/constructor/from-column-array.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operation_1 = __webpack_require__(/*! ../operation */ "./node_modules/@squill/squill/dist/key/util/operation/index.js");
function fromColumnArray(columns) {
    const result = operation_1.removeDuplicates(columns.map(c => c.columnAlias));
    return result;
}
exports.fromColumnArray = fromColumnArray;
//# sourceMappingURL=from-column-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/constructor/from-column.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/constructor/from-column.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = [column.columnAlias];
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/constructor/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/constructor/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-array */ "./node_modules/@squill/squill/dist/key/util/constructor/from-column-array.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/key/util/constructor/from-column.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/key/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/key/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/key/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/append.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/append.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js");
function append(key, str) {
    return remove_duplicates_1.removeDuplicates([...key, str]);
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/concat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/concat.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js");
function concat(a, b) {
    return remove_duplicates_1.removeDuplicates([...a, ...b]);
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./append */ "./node_modules/@squill/squill/dist/key/util/operation/append.js"));
__export(__webpack_require__(/*! ./concat */ "./node_modules/@squill/squill/dist/key/util/operation/concat.js"));
__export(__webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js"));
__export(__webpack_require__(/*! ./remove */ "./node_modules/@squill/squill/dist/key/util/operation/remove.js"));
__export(__webpack_require__(/*! ./subtract */ "./node_modules/@squill/squill/dist/key/util/operation/subtract.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function removeDuplicates(key) {
    const result = [];
    for (const str of key) {
        if (!result.includes(str)) {
            result.push(str);
        }
    }
    return result;
}
exports.removeDuplicates = removeDuplicates;
//# sourceMappingURL=remove-duplicates.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/remove.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/remove.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js");
function remove(key, str) {
    const result = remove_duplicates_1.removeDuplicates(key.filter(s => s != str));
    return result;
}
exports.remove = remove;
//# sourceMappingURL=remove.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/operation/subtract.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/operation/subtract.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const remove_duplicates_1 = __webpack_require__(/*! ./remove-duplicates */ "./node_modules/@squill/squill/dist/key/util/operation/remove-duplicates.js");
function subtract(a, b) {
    const result = remove_duplicates_1.removeDuplicates(a.filter(s => !b.includes(s)));
    return result;
}
exports.subtract = subtract;
//# sourceMappingURL=subtract.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/predicate/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/predicate/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-key */ "./node_modules/@squill/squill/dist/key/util/predicate/is-key.js"));
__export(__webpack_require__(/*! ./is-equal */ "./node_modules/@squill/squill/dist/key/util/predicate/is-equal.js"));
__export(__webpack_require__(/*! ./is-sub-key */ "./node_modules/@squill/squill/dist/key/util/predicate/is-sub-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/predicate/is-equal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/predicate/is-equal.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_sub_key_1 = __webpack_require__(/*! ./is-sub-key */ "./node_modules/@squill/squill/dist/key/util/predicate/is-sub-key.js");
function isEqual(a, b) {
    return (is_sub_key_1.isSubKey(a, b) &&
        is_sub_key_1.isSubKey(b, a));
}
exports.isEqual = isEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/predicate/is-key.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/predicate/is-key.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isKey(raw) {
    if (!(Array.isArray(raw))) {
        return false;
    }
    for (const item of raw) {
        if (typeof item != "string") {
            return false;
        }
    }
    return true;
}
exports.isKey = isKey;
//# sourceMappingURL=is-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/key/util/predicate/is-sub-key.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/key/util/predicate/is-sub-key.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isSubKey(a, b) {
    return a.every(aKey => b.includes(aKey));
}
exports.isSubKey = isSubKey;
//# sourceMappingURL=is-sub-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LimitClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/limit-clause/util/index.js");
exports.LimitClauseUtil = LimitClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./limit-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-bigint.js"));
__export(__webpack_require__(/*! ./limit-number */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-number.js"));
__export(__webpack_require__(/*! ./limit */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit.js"));
__export(__webpack_require__(/*! ./offset-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js"));
__export(__webpack_require__(/*! ./offset-number */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-number.js"));
__export(__webpack_require__(/*! ./offset */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-bigint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-bigint.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js");
function limitBigInt(limitClause, maxRowCount) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    if (tm.BigIntUtil.lessThan(maxRowCount, 0)) {
        throw new Error(`Cannot LIMIT fewer than zero rows`);
    }
    if (tm.BigIntUtil.greaterThan(maxRowCount, offset_bigint_1.ALL_ROW_COUNT)) {
        throw new Error(`Cannot LIMIT more than ${offset_bigint_1.ALL_ROW_COUNT} rows`);
    }
    if (limitClause == undefined) {
        return {
            maxRowCount,
            offset: BigInt(0),
        };
    }
    else {
        return {
            maxRowCount,
            offset: limitClause.offset,
        };
    }
}
exports.limitBigInt = limitBigInt;
//# sourceMappingURL=limit-bigint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-number.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-number.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const limit_bigint_1 = __webpack_require__(/*! ./limit-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-bigint.js");
function limitNumber(limitClause, maxRowCount) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return limit_bigint_1.limitBigInt(limitClause, 
    /**
     * Will throw a run-time error if `maxRowCount` is not an integer.
     */
    BigInt(maxRowCount));
}
exports.limitNumber = limitNumber;
//# sourceMappingURL=limit-number.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/limit.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_bigint_1 = __webpack_require__(/*! ./limit-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-bigint.js");
const limit_number_1 = __webpack_require__(/*! ./limit-number */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/limit-number.js");
function limit(limitClause, maxRowCount) {
    if (typeof maxRowCount == "number") {
        return limit_number_1.limitNumber(limitClause, maxRowCount);
    }
    else {
        return limit_bigint_1.limitBigInt(limitClause, maxRowCount);
    }
}
exports.limit = limit;
//# sourceMappingURL=limit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
exports.ALL_ROW_COUNT = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
exports.MAX_OFFSET = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
function offsetBigInt(limitClause, offset) {
    if (tm.BigIntUtil.lessThan(offset, 0)) {
        throw new Error(`Cannot OFFSET fewer than zero rows`);
    }
    if (tm.BigIntUtil.greaterThan(offset, exports.MAX_OFFSET)) {
        throw new Error(`Cannot OFFSET more than ${exports.MAX_OFFSET} rows`);
    }
    if (limitClause == undefined) {
        return {
            maxRowCount: exports.ALL_ROW_COUNT,
            offset,
        };
    }
    else {
        return {
            maxRowCount: limitClause.maxRowCount,
            offset,
        };
    }
}
exports.offsetBigInt = offsetBigInt;
//# sourceMappingURL=offset-bigint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-number.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-number.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js");
function offsetNumber(limitClause, offset) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return offset_bigint_1.offsetBigInt(limitClause, 
    /**
     * Will throw a run-time error if `offset` is not an integer.
     */
    BigInt(offset));
}
exports.offsetNumber = offsetNumber;
//# sourceMappingURL=offset-number.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/limit-clause/util/operation/offset.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const offset_bigint_1 = __webpack_require__(/*! ./offset-bigint */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-bigint.js");
const offset_number_1 = __webpack_require__(/*! ./offset-number */ "./node_modules/@squill/squill/dist/limit-clause/util/operation/offset-number.js");
function offset(limitClause, offset) {
    if (typeof offset == "number") {
        return offset_number_1.offsetNumber(limitClause, offset);
    }
    else {
        return offset_bigint_1.offsetBigInt(limitClause, offset);
    }
}
exports.offset = offset;
//# sourceMappingURL=offset.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/map-delegate/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/map-delegate/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MapDelegateUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/map-delegate/util/index.js");
exports.MapDelegateUtil = MapDelegateUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/map-delegate/util/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/map-delegate/util/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/map-delegate/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/map-delegate/util/operation/compose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/map-delegate/util/operation/compose.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function compose(cur, nxt) {
    return async (row, connection, originalRow) => {
        const tmp = await cur(row, connection, originalRow);
        const result = await nxt(tmp, connection, originalRow);
        return result;
    };
}
exports.compose = compose;
//# sourceMappingURL=compose.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/map-delegate/util/operation/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/map-delegate/util/operation/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compose */ "./node_modules/@squill/squill/dist/map-delegate/util/operation/compose.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/mapper-map/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/mapper-map/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MapperMapUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/mapper-map/util/index.js");
exports.MapperMapUtil = MapperMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/mapper-map/util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/mapper-map/util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/mapper-map/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/mapper-map/util/query/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/mapper-map/util/query/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./nullable-key */ "./node_modules/@squill/squill/dist/mapper-map/util/query/nullable-key.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/mapper-map/util/query/nullable-key.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/mapper-map/util/query/nullable-key.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
function nullableKeys(map) {
    const columnAliases = Object.keys(map);
    return columnAliases.filter(columnAlias => tm.canOutputNull(map[columnAlias]));
}
exports.nullableKeys = nullableKeys;
//# sourceMappingURL=nullable-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OnClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/on-clause/util/index.js");
exports.OnClauseUtil = OnClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/on-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/on-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/on-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/operation/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/operation/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./on */ "./node_modules/@squill/squill/dist/on-clause/util/operation/on.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/operation/on.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/operation/on.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/on-clause/util/query/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/on-clause/util/predicate/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
function on(fromClause, aliasedTable, onDelegate) {
    const columns = query_1.allowedColumnRef(fromClause, aliasedTable);
    const rawOnClause = onDelegate(columns);
    predicate_1.assertValidUsedRef(fromClause, aliasedTable, rawOnClause);
    return expr_1.ExprUtil.fromBuiltInExpr(rawOnClause);
}
exports.on = on;
//# sourceMappingURL=on.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function assertNoOuterQueryUsedRef(fromClause, rawOnClause) {
    const outerQueryTableAliases = from_clause_1.FromClauseUtil.outerQueryTableAlias(fromClause);
    const usedOuterQueryTableAliases = Object.keys(built_in_expr_1.BuiltInExprUtil.usedRef(rawOnClause).columns)
        .filter(usedTableAlias => {
        return outerQueryTableAliases.includes(usedTableAlias);
    });
    if (usedOuterQueryTableAliases.length > 0) {
        throw new Error(`ON clause must not reference outer query tables ${usedOuterQueryTableAliases.join(",")}`);
    }
}
exports.assertNoOuterQueryUsedRef = assertNoOuterQueryUsedRef;
//# sourceMappingURL=assert-no-outer-query-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-valid-used-ref.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-valid-used-ref.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/on-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function assertValidUsedRef(fromClause, aliasedTable, rawOnClause) {
    used_ref_1.UsedRefUtil.assertAllowed(query_1.allowedUsedRef(fromClause, aliasedTable), built_in_expr_1.BuiltInExprUtil.usedRef(rawOnClause));
}
exports.assertValidUsedRef = assertValidUsedRef;
//# sourceMappingURL=assert-valid-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/predicate/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/predicate/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-no-outer-query-used-ref */ "./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-no-outer-query-used-ref.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref */ "./node_modules/@squill/squill/dist/on-clause/util/predicate/assert-valid-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/query/allowed-used-ref.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/query/allowed-used-ref.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const join_1 = __webpack_require__(/*! ../../../join */ "./node_modules/@squill/squill/dist/join/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function allowedColumnRef(fromClause, aliasedTable) {
    return column_ref_1.ColumnRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
    /**
     * We don't care about the `JoinType` for this temporary array
     */
    join_1.JoinType.FROM, 
    /**
     * We don't care about the `ON` clause either
     */
    undefined)));
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause, aliasedTable) {
    /**
     * @todo Investigate assignability
     */
    return used_ref_1.UsedRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
    /**
     * We don't care about the `JoinType` for this temporary array
     */
    join_1.JoinType.FROM, 
    /**
     * We don't care about the `ON` clause either
     */
    undefined)));
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/on-clause/util/query/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/on-clause/util/query/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/on-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/operator-type.js":
/*!***********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/operator-type.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * It's called `OperatorType` but also contains function names.
 * A function is just an operator with different syntax.
 *
 * -----
 *
 * **EVERY** new `OperatorType` added is a **BREAKING CHANGE**.
 * Make sure to bump the **MAJOR** version number.
 */
var OperatorType;
(function (OperatorType) {
    /*
        Comparison Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `BETWEEN ... AND ...`
     * + PostgreSQL   : `BETWEEN ... AND ...`
     * + SQLite       : `BETWEEN ... AND ...`
     */
    OperatorType["BETWEEN_AND"] = "BETWEEN_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
     * + https://www.postgresql.org/docs/9.5/functions-conditional.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `COALESCE(x, ...)`
     * + PostgreSQL   : `COALESCE(x, ...)`
     * + SQLite       : `COALESCE(x, ...)`
     */
    OperatorType["COALESCE"] = "COALESCE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `=`
     * + PostgreSQL   : `=`
     * + SQLite       : `=`
     */
    OperatorType["EQUAL"] = "EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<=>`
     * + PostgreSQL   : `IS NOT DISTINCT FROM`
     * + SQLite       : `IS`
     */
    OperatorType["NULL_SAFE_EQUAL"] = "NULL_SAFE_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `>`
     * + PostgreSQL   : `>`
     * + SQLite       : `>`
     */
    OperatorType["GREATER_THAN"] = "GREATER_THAN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `>=`
     * + PostgreSQL   : `>=`
     * + SQLite       : `>=`
     */
    OperatorType["GREATER_THAN_OR_EQUAL"] = "GREATER_THAN_OR_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL        : `GREATEST(x, y, ...)` //Requires 2 args
     *   + `NULL` values cause return value of `NULL`
     * + PostgreSQL   : `GREATEST(x, ...)`    //Requires 1 arg
     *   + Ignores `NULL` values
     * + SQLite       : `MAX(x, ...)`         //Requires 1 arg
     *   + `NULL` values cause return value of `NULL`
     */
    OperatorType["GREATEST"] = "GREATEST";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `IN`
     * + PostgreSQL   : `IN`
     * + SQLite       : `IN`
     */
    OperatorType["IN_ARRAY"] = "IN_ARRAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `IN`
     * + PostgreSQL   : `IN`
     * + SQLite       : `IN`
     */
    OperatorType["IN_QUERY"] = "IN_QUERY";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_interval
     */
    //INTERVAL = "INTERVAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS TRUE`
     * + PostgreSQL   : `IS TRUE`
     * + SQLite       : `<NULL_SAFE_EQUAL> TRUE`
     */
    OperatorType["IS_TRUE"] = "IS_TRUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS FALSE`
     * + PostgreSQL   : `IS FALSE`
     * + SQLite       : `<NULL_SAFE_EQUAL> FALSE`
     */
    OperatorType["IS_FALSE"] = "IS_FALSE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * This does not refer to the TypeScript `unknown`.
     * It refers to the three-valued logic `unknown`.
     *
     * It generally has a value equivalent to `NULL`.
     *
     * -----
     *
     * + MySQL        : `IS UNKNOWN`
     * + PostgreSQL   : `IS UNKNOWN`
     * + SQLite       : `<NULL_SAFE_EQUAL> UNKNOWN`
     */
    OperatorType["IS_UNKNOWN"] = "IS_UNKNOWN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT TRUE`
     * + PostgreSQL   : `IS NOT TRUE`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> TRUE`
     */
    OperatorType["IS_NOT_TRUE"] = "IS_NOT_TRUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT FALSE`
     * + PostgreSQL   : `IS NOT FALSE`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> FALSE`
     */
    OperatorType["IS_NOT_FALSE"] = "IS_NOT_FALSE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * This does not refer to the TypeScript `unknown`.
     * It refers to the three-valued logic `unknown`.
     *
     * It generally has a value equivalent to `NULL`.
     *
     * -----
     *
     * + MySQL        : `IS NOT UNKNOWN`
     * + PostgreSQL   : `IS NOT UNKNOWN`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> UNKNOWN`
     */
    OperatorType["IS_NOT_UNKNOWN"] = "IS_NOT_UNKNOWN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NOT NULL`
     * + PostgreSQL   : `IS NOT NULL`
     * + SQLite       : `<NOT_NULL_SAFE_EQUAL> NULL`
     */
    OperatorType["IS_NOT_NULL"] = "IS_NOT_NULL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     * + https://www.postgresql.org/docs/9.0/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `IS NULL`
     * + PostgreSQL   : `IS NULL`
     * + SQLite       : `<NULL_SAFE_EQUAL> NULL`
     */
    OperatorType["IS_NULL"] = "IS_NULL";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_isnull
     */
    //ISNULL = "ISNULL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL        : `LEAST(x, y, ...)` //Requires 2 args
     * + PostgreSQL   : `LEAST(x, ...)`    //Requires 1 arg
     * + SQLite       : `MIN(x, ...)`         //Requires 1 arg
     */
    OperatorType["LEAST"] = "LEAST";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<`
     * + PostgreSQL   : `<`
     * + SQLite       : `<`
     */
    OperatorType["LESS_THAN"] = "LESS_THAN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<=`
     * + PostgreSQL   : `<=`
     * + SQLite       : `<=`
     */
    OperatorType["LESS_THAN_OR_EQUAL"] = "LESS_THAN_OR_EQUAL";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `LIKE`
     * + PostgreSQL   : `LIKE`
     * + SQLite       : `LIKE`
     */
    /*
     * The `LIKE` operator has different default escape behaviours across databases.
     * By default, SQLite does not have an escape character.
     * By default, MySQL's is the backslash.
     */
    //LIKE = "LIKE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `LIKE ... ESCAPE ...`
     * + PostgreSQL   : `LIKE ... ESCAPE ...`
     * + SQLite       : `LIKE ... ESCAPE ...`
     */
    OperatorType["LIKE_ESCAPE"] = "LIKE_ESCAPE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#between
     *
     * -----
     *
     * + MySQL        : `NOT BETWEEN ... AND ...`
     * + PostgreSQL   : `NOT BETWEEN ... AND ...`
     * + SQLite       : `NOT BETWEEN ... AND ...`
     */
    OperatorType["NOT_BETWEEN_AND"] = "NOT_BETWEEN_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `<>`
     * + PostgreSQL   : `<>`
     * + SQLite       : `<>`
     */
    OperatorType["NOT_EQUAL"] = "NOT_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     * + https://www.postgresql.org/docs/9.1/functions-comparison.html
     * + https://www.sqlite.org/lang_expr.html#isisnot
     *
     * -----
     *
     * + MySQL        : `<NOT> (x <NULL_SAFE_EQUAL>)`
     * + PostgreSQL   : `IS DISTINCT FROM`
     * + SQLite       : `IS NOT`
     */
    OperatorType["NOT_NULL_SAFE_EQUAL"] = "NOT_NULL_SAFE_EQUAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `NOT IN`
     * + PostgreSQL   : `NOT IN`
     * + SQLite       : `NOT IN`
     */
    OperatorType["NOT_IN_ARRAY"] = "NOT_IN_ARRAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
     * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
     * + https://www.sqlite.org/lang_expr.html#in_op
     *
     * -----
     *
     * + MySQL        : `NOT IN`
     * + PostgreSQL   : `NOT IN`
     * + SQLite       : `NOT IN`
     */
    OperatorType["NOT_IN_QUERY"] = "NOT_IN_QUERY";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `NOT LIKE`
     * + PostgreSQL   : `NOT LIKE`
     * + SQLite       : `NOT LIKE`
     */
    /*
     * The `LIKE` operator has different default escape behaviours across databases.
     * By default, SQLite does not have an escape character.
     * By default, MySQL's is the backslash.
     */
    //NOT_LIKE = "NOT_LIKE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
     * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
     * + https://www.sqlite.org/lang_expr.html#like
     *
     * -----
     *
     * + MySQL        : `NOT LIKE ... ESCAPE ...`
     * + PostgreSQL   : `NOT LIKE ... ESCAPE ...`
     * + SQLite       : `NOT LIKE ... ESCAPE ...`
     */
    OperatorType["NOT_LIKE_ESCAPE"] = "NOT_LIKE_ESCAPE";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#function_strcmp
     */
    //STRCMP = "STRCMP",
    /*
        Logical Operators
        https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `AND`
     * + PostgreSQL   : `AND`
     * + SQLite       : `AND`
     */
    OperatorType["AND"] = "AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `NOT`
     * + PostgreSQL   : `NOT`
     * + SQLite       : `NOT`
     */
    OperatorType["NOT"] = "NOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     * + https://www.postgresql.org/docs/9.1/functions-logical.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `OR`
     * + PostgreSQL   : `OR`
     * + SQLite       : `OR`
     */
    OperatorType["OR"] = "OR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * -----
     *
     * + MySQL        : `XOR`
     * + PostgreSQL   : `<NOT_EQUAL>`
     * + SQLite       : `<NOT_EQUAL>`
     */
    OperatorType["XOR"] = "XOR";
    /*
        Control Flow Functions
        https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * -----
     *
     * + MySQL        : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     * + PostgreSQL   : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     * + SQLite       : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
     */
    /**
     * This is handled using `CaseValueNode`
     */
    //CASE = "CASE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * -----
     *
     * + MySQL        : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     * + PostgreSQL   : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     * + SQLite       : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
     */
    /**
     * This is handled using `CaseConditionNode`
     */
    //CASE_WHEN = "CASE_WHEN",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
     *
     * -----
     *
     * + MySQL        : `IF(x, y, z)`
     * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
     * + SQLite       : `CASE WHEN x THEN y ELSE z END`
     */
    OperatorType["IF"] = "IF";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#ifnull
     *
     * `COALESCE()` is part of the SQL standard.
     * `IFNULL()` is DB-specific.
     *
     * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
     *
     * -----
     *
     * + MySQL        : `IFNULL(x, y)`
     * + PostgreSQL   : `COALESCE(x, y)`
     * + SQLite       : `IFNULL(x, y)`
     */
    OperatorType["IF_NULL"] = "IF_NULL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * -----
     *
     * This is the same as `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`
     */
    OperatorType["NULL_IF_EQUAL"] = "NULL_IF_EQUAL";
    /*
        String Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `ASCII(x)`
     * + PostgreSQL     : `ASCII(x)`
     * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
     */
    OperatorType["ASCII"] = "ASCII";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
     *
     * -----
     *
     * + MySQL          : `BIN(x)`
     * + PostgreSQL     : None. Implement with,
     * ```sql
     *  REGEXP_REPLACE(
     *      (x)::bit(64)::varchar(64),
     *      '^0+(\d+)$',
     *      '\1'
     *  )
     * ```
     * + SQLite         : None. Implement with,
     * ```ts
     * //x >= 0
     * (x).toString(2)
     * //x < 0
     * (2n**64n + BigInt(x)).toString(2)
     * ```
     */
    OperatorType["BIN"] = "BIN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `BIT_LENGTH(x)`
     * + PostgreSQL     : `BIT_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
     */
    OperatorType["BIT_LENGTH"] = "BIT_LENGTH";
    /*
     * Appears to be MySQL and SQLite-specific,
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char
     * + https://www.sqlite.org/lang_corefunc.html#char
     *
     * They have different implementations, however.
     */
    //CHAR = "CHAR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#length
     * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
     *
     * -----
     *
     * + MySQL          : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafe')` returns 6
     * + PostgreSQL     : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafe')` returns 8
     * + SQLite         : `LENGTH(x)`
     *   + `LENGTH('cafe')` returns 6
     */
    OperatorType["CHAR_LENGTH"] = "CHAR_LENGTH";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
     *   + MySQL actually treats `||` as the boolean `OR` operator.
     * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + SQLite uses an operator, not a function, to concatenate strings
     *   + https://www.sqlite.org/lang_expr.html#collateop
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     */
    OperatorType["CONCAT"] = "CONCAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
     * + PostgreSQL     : `CONCAT(x, ...)`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `COALESCE(x, '') || ... || ...`
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     */
    OperatorType["NULL_SAFE_CONCAT"] = "NULL_SAFE_CONCAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["CONCAT_WS"] = "CONCAT_WS";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_elt
     */
    //ELT = "ELT",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_export-set
     */
    //EXPORT_SET = "EXPORT_SET",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_field
     */
    //FIELD = "FIELD",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_find-in-set
     *
     * ```sql
     * FIND_IN_SET(str, strlist)
     * ```
     *
     * There is a way to emulate it with PostgreSQL,
     * https://stackoverflow.com/questions/35169412/mysql-find-in-set-equivalent-to-postgresql
     *
     * ```sql
     *  array_position(
     *      string_to_array(strlist, ','),
     *      str
     *  )
     * ```
     *
     * @todo Decide if we should add this
     */
    //FIND_IN_SET = "FIND_IN_SET",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `FROM_BASE64(x)`
     *   + `FROM_BASE64('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'base64')`
     *   + `DECODE('~', 'base64')` throws an error
     * + SQLite         : None, implement with user-defined function `atob()`
     *   + `atob('~')` throws an error
     */
    OperatorType["FROM_BASE64"] = "FROM_BASE64";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#hex
     *
     * -----
     *
     * + MySQL          : `HEX(x)`
     * + PostgreSQL     : `ENCODE(x, 'hex')`
     * + SQLite         : `HEX(x)`
     */
    OperatorType["HEX"] = "HEX";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_insert
     */
    //INSERT = "INSERT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
     * + https://www.sqlite.org/lang_corefunc.html#instr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `INSTR(str, substr)`
     * + PostgreSQL     : `STRPOS(str, substr)`
     * + SQLite         : `INSTR(str, substr)`
     */
    OperatorType["IN_STR"] = "IN_STR";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_left
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
     */
    //LEFT = "LEFT",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#length
     *
     * -----
     *
     * + MySQL          : `LENGTH(x)`
     * + PostgreSQL     : `LENGTH(x)`
     * + SQLite         : None. The `LENGTH(x)` implementation is incompatible.
     *
     * -----
     *
     * ```sql
     *  SELECT
     *      -- '\u00c7'
     *      LENGTH('') AS one_length,
     *      CHAR_LENGTH('') AS one_char_length,
     *      -- '\u0043\u0327'
     *      LENGTH('C') AS two_length,
     *      CHAR_LENGTH('C') AS two_char_length
     * ```
     *
     * MySQL        : `2,1,3,2`
     * PostgreSQL   : `2,2,3,3`
     * SQLite       : `1,X,2,X` (`X` because SQLite does not have `CHAR_LENGTH()`)
     *
     * |                            | MySQL `LENGTH()` | MySQL `CHAR_LENGTH()` | PostgreSQL `LENGTH()` | PostgreSQL `CHAR_LENGTH()` | SQLite `LENGTH()` |
     * |----------------------------|------------------|-----------------------|-----------------------|----------------------------|-------------------|
     * | MySQL      `LENGTH()`      | X                |                       | X                     | X                          |                   |
     * | MySQL      `CHAR_LENGTH()` |                  | X                     |                       |                            | X                 |
     * | PostgreSQL `LENGTH()`      | X                |                       | X                     | X                          |                   |
     * | PostgreSQL `CHAR_LENGTH()` | X                |                       | X                     | X                          |                   |
     * | SQLite     `LENGTH()`      |                  | X                     |                       |                            | X                 |
     *
     * https://news.ycombinator.com/item?id=17311196
     *
     * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/3
     * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/4
     *
     * -----
     *
     * TL;DR,
     * We cannot provide `LENGTH` as a DB-unified operator because of the inconsistencies
     *
     * -----
     *
     * See, `OCTET_LENGTH` instead.
     * All three databases can be made to agree on the behaviour of `OCTET_LENGTH`
     */
    //LENGTH = "LENGTH",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file
     */
    //LOAD_FILE = "LOAD_FILE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_locate
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LOCATE(substr, str)/LOCATE(substr, str, pos)`
     * + PostgreSQL     : `STRPOS(str, substr)`, the 3-arg version is more complicated.
     *
     *   Tentatively, `STRPOS(SUBSTR(str, pos), substr) + pos` or something like that.
     *
     * + SQLite         : None. Implement with user-defined function.
     * @todo
     */
    //LOCATE = "LOCATE",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#lower
     *
     * -----
     *
     * + MySQL          : `LOWER(x)`
     * + PostgreSQL     : `LOWER(x)`
     * + SQLite         : `LOWER(x)`
     */
    OperatorType["LOWER"] = "LOWER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["LPAD"] = "LPAD";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#ltrim
     *
     * -----
     *
     * + MySQL          : `LTRIM(x)`
     * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
     * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
     */
    OperatorType["LTRIM"] = "LTRIM";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_make-set
     */
    //MAKE_SET = "MAKE_SET",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_oct
     */
    //OCT = "OCT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `OCTET_LENGTH(x)`
     * + PostgreSQL     : `OCTET_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB))`
     */
    OperatorType["OCTET_LENGTH"] = "OCTET_LENGTH";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ord
     */
    //ORD = "ORD",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `POSITION(substr IN str)`
     * + PostgreSQL     : `POSITION(substr IN str)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["POSITION"] = "POSITION";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_quote
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#quote
     *
     * -----
     *
     * + MySQL          : `QUOTE(x)`
     * + PostgreSQL     : `QUOTE_NULLABLE(x)`
     * + SQLite         : `QUOTE(x)`
     *
     * SQLite seems to not return just strings...
     * SQLite can return string|Uint8Array|number|bigint|...
     * So, we can't unify this.
     */
    //QUOTE = "QUOTE",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#function_regexp-like
     *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax
     *   + http://userguide.icu-project.org/strings/regexp
     * + `~`/`~*`/`!~`/`!~*`
     *   + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-POSIX-REGEXP
     * + TODO: Find out difference between POSIX regex and ICU regex
     */
    //REGEXP = "REGEXP",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REPEAT(x, count)`
     * + PostgreSQL     : `REPEAT(x, count)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["REPEAT"] = "REPEAT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#replace
     *
     * -----
     *
     * + MySQL          : `REPLACE(str, from, to)`
     * + PostgreSQL     : `REPLACE(str, from, to)`
     * + SQLite         : `REPLACE(str, from, to)`
     */
    OperatorType["REPLACE"] = "REPLACE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REVERSE(x)`
     * + PostgreSQL     : `REVERSE(x)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["REVERSE"] = "REVERSE";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_right
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
     */
    //RIGHT = "RIGHT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["RPAD"] = "RPAD";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#rtrim
     *
     * -----
     *
     * + MySQL          : `RTRIM(x)`
     * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
     * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
     */
    OperatorType["RTRIM"] = "RTRIM";
    /*
     * Appears to be PostgreSQL-specific,
     * https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP
     */
    //SIMILAR_TO = "SIMILAR_TO",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_soundex
     * + https://www.sqlite.org/lang_corefunc.html#soundex
     * + https://www.postgresql.org/docs/9.1/fuzzystrmatch.html
     *
     * -----
     *
     * + MySQL          : `SOUNDEX(x)`
     * + PostgreSQL     : `SOUNDEX(x)`
     * + SQLite         : `SOUNDEX(x)`
     */
    //SOUNDEX = "SOUNDEX",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#operator_sounds-like
     */
    //SOUNDS_LIKE = "SOUNDS_LIKE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_space
     *
     * -----
     *
     * `SPACE(n)` is the same as `REPEAT(' ', n)`
     */
    //SPACE = "SPACE",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#substr
     *
     * -----
     *
     * + MySQL          : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'o'`
     *   + `SUBSTR('hello', -1, -2)` === `''`
     *   + `SUBSTR('hello', -2, 2)` === `'lo'`
     * + PostgreSQL     : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'hello'`
     *   + `SUBSTR('hello', -1, -2)` throws an error
     *   + `SUBSTR('hello', -2, 2)` === `''`
     * + SQLite         : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
     *   + `SUBSTR('hello', -1)` === `'o'`
     *   + `SUBSTR('hello', -1, -2)` === `'ll'`
     *   + `SUBSTR('hello', -2, 2)` === `'lo'`
     *
     * -----
     *
     * Behaviour varies too much.
     */
    //SUBSTR = "SUBSTR",
    /*
     * Appears to be MySQl-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substring-index
     */
    //SUBSTRING_INDEX = "SUBSTRING_INDEX",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `TO_BASE64(x)`
     * + PostgreSQL     : `ENCODE(x, 'base64')`
     * + SQLite         : None, implement with user-defined function `btoa()`
     */
    OperatorType["TO_BASE64"] = "TO_BASE64";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#trim
     *
     * -----
     *
     * + MySQL          : `TRIM(x)`
     * + PostgreSQL     : `TRIM(x)`
     * + SQLite         : `TRIM(x)`
     */
    OperatorType["TRIM"] = "TRIM";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `UNHEX(x)`
     *   + `UNHEX('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'hex')`
     *   + `DECODE('~', 'hex')` throws an error
     * + SQLite         : None. Implement with user-defined function.
     */
    OperatorType["UNHEX"] = "UNHEX";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#upper
     *
     * -----
     *
     * + MySQL          : `UPPER(x)`
     * + PostgreSQL     : `UPPER(x)`
     * + SQLite         : `UPPER(x)`
     */
    OperatorType["UPPER"] = "UPPER";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_weight-string
     */
    //WEIGHT_STIRNG = "WEIGHT_STIRNG",
    /*
        Arithmetic Operators
        https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_div
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS
     *
     * -----
     *
     * Interestingly enough,
     * MySQL uses `SIGNED` and `UNSIGNED` for integer type names when casting.
     * PostgreSQL uses `INTEGER`
     *
     * -----
     *
     * + MySQL        : `DIV`
     * + PostgreSQL   : `CAST(TRUNC(CAST(x AS NUMERIC) / CAST(y AS NUMERIC), 0) AS BIGINT)`
     * + SQLite       : `CAST(x/y AS BIGINT)`
     *   + SQLite does not have `DECIMAL` data type support...
     *
     */
    OperatorType["INTEGER_DIVISION"] = "INTEGER_DIVISION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `/`
     * + PostgreSQL   : `/`
     * + SQLite       : `/`
     */
    OperatorType["FRACTIONAL_DIVISION"] = "FRACTIONAL_DIVISION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     */
    OperatorType["SUBTRACTION"] = "SUBTRACTION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * @todo Find out if they behave the same
     *
     * + MySQL        : `%`
     *   + `1%0` === `NULL`
     * + PostgreSQL   : `mod(x, y)` (The `%` operator does not handle negative values)
     *   + `mod(1, 0)` throws error
     * + SQLite       : `%`
     *   + `1%0` === `NULL`
     */
    OperatorType["INTEGER_REMAINDER"] = "INTEGER_REMAINDER";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * + MySQL        : `%`
     * + PostgreSQL   : Not supported
     * + SQLite       : Not supported
     */
    OperatorType["FRACTIONAL_REMAINDER"] = "FRACTIONAL_REMAINDER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
     *
     * -----
     *
     * + MySQL        : `+`
     * + PostgreSQL   : `+`
     * + SQLite       : `+`
     */
    OperatorType["ADDITION"] = "ADDITION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
     *
     * -----
     *
     * + MySQL        : `*`
     * + PostgreSQL   : `*`
     * + SQLite       : `*`
     */
    OperatorType["MULTIPLICATION"] = "MULTIPLICATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     */
    OperatorType["UNARY_MINUS"] = "UNARY_MINUS";
    /*
        Mathematical Functions
        https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_corefunc.html#abs
     *
     * -----
     *
     * + MySQL        : `ABS(x)`
     * + PostgreSQL   : `@` or `ABS(x)` (Let's not use the ugly `@` operator)
     * + SQLite       : `ABS(x)`
     */
    OperatorType["ABSOLUTE_VALUE"] = "ABSOLUTE_VALUE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ACOS(x)`
     * + PostgreSQL     : `ACOS(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_COSINE"] = "ARC_COSINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ASIN(x)`
     * + PostgreSQL     : `ASIN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_SINE"] = "ARC_SINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN(x)`
     * + PostgreSQL     : `ATAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_TANGENT"] = "ARC_TANGENT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN2(y, x)`
     * + PostgreSQL     : `ATAN2(y, x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["ARC_TANGENT_2"] = "ARC_TANGENT_2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceil
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL        : `CEIL(x)/CEILING(x)`
     * + PostgreSQL   : `CEIL(x)/CEILING(x)`
     * + SQLite       : None, use the following instead,
     *   + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
     * ```sql
     *  (
     *      CASE
     *          WHEN x = CAST(x AS INT) THEN
     *              CAST(x AS INT)
     *          ELSE
     *              1 + CAST(x AS INT)
     *      END
     *  )
     * ```
     *
     */
    OperatorType["CEILING"] = "CEILING";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_conv
     */
    //CONV = "CONV"
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COS(x)`
     * + PostgreSQL     : `COS(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["COSINE"] = "COSINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COT(x)`
     * + PostgreSQL     : `COT(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["COTANGENT"] = "COTANGENT";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_crc32
     */
    //CRC32 = "CRC32",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `DEGREES(x)`
     * + PostgreSQL     : `DEGREES(x)`
     * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
     */
    OperatorType["DEGREES"] = "DEGREES";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `EXP(x)`
     * + PostgreSQL     : `EXP(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["NATURAL_EXPONENTIATION"] = "NATURAL_EXPONENTIATION";
    /*
     * Appears to be PostgreSQL-specific,
     * + Factorial; `x !` / `!! x`
     * + https://www.postgresql.org/docs/8.2/functions-math.html
     */
    //FACTORIAL = "FACTORIAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL        : `FLOOR(x)`
     * + PostgreSQL   : `FLOOR(x)`
     * + SQLite       : None, use the following instead,
     *   + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
     * ```sql
     *  (
     *      CASE
     *          WHEN x >= 0 THEN
     *              CAST(x AS INT)
     *          WHEN x = CAST(x AS INT) THEN
     *              CAST(x AS INT)
     *          ELSE
     *              CAST(x - 1.0 AS INT)
     *      END
     *  )
     * ```
     */
    OperatorType["FLOOR"] = "FLOOR";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_format
     */
    //FORMAT = "FORMAT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LN(x)`
     * + PostgreSQL     : `LN(x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LN"] = "LN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LOG(base, x)`
     * + PostgreSQL     : `LOG(base, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG"] = "LOG";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
     *
     * -----
     *
     * + MySQL          : `LOG2(x)`
     * + PostgreSQL     : `LOG(2.0, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG2"] = "LOG2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
     *
     * -----
     *
     * + MySQL          : `LOG10(x)`
     * + PostgreSQL     : `LOG(10.0, x)`
     * + SQLite         : None, implment with user-defined function
     */
    OperatorType["LOG10"] = "LOG10";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `PI()` Returns `3.141592653589793`
     * + PostgreSQL     : `PI()` Returns `3.14159265358979`
     * + SQLite         : None, implement using `3.141592653589793`
     *
     * -----
     *
     * In JS, `Math.PI` is `3.141592653589793`
     */
    OperatorType["PI"] = "PI";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * + MySQL        : `POWER(x, y)`
     * + PostgreSQL   : `^` or `POWER(x, y)` (Let's not use the ugly `^` operator)
     * + SQLite       : Requres creating a `POWER(x, y)` user-defined function
     */
    OperatorType["POWER"] = "POWER";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `RADIANS(x)`
     * + PostgreSQL     : `RADIANS(x)`
     * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
     */
    OperatorType["RADIANS"] = "RADIANS";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#random
     *
     * -----
     *
     * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
     * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
     * + SQLite         : Incompatible.
     *
     *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
     *
     *   Therefore, one should use, `ABS(RANDOM()) / 9223372036854775808`
     */
    OperatorType["RANDOM"] = "RANDOM";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_round
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#round
     *
     * -----
     *
     * + MySQL          : `ROUND(x)` or `ROUND(x, y)`
     * + PostgreSQL     : `ROUND(x)` or `ROUND(x, y)`
     * + SQLite         : `ROUND(x)` or `ROUND(x, y)`
     */
    //ROUND = "ROUND",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `SIGN(x)`
     * + PostgreSQL     : `SIGN(x)`
     * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
     */
    OperatorType["SIGN"] = "SIGN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `SIN(x)`
     * + PostgreSQL     : `SIN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["SINE"] = "SINE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `SQRT(x)`
     * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
     * + SQLite       : Requres creating a `SQRT(x)` user-defined function
     */
    OperatorType["SQUARE_ROOT"] = "SQUARE_ROOT";
    /**
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `POWER(x, 1.0/3.0)` The `.0` parts are important!
     * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
     * + SQLite       : Requres creating a `CBRT(x)` user-defined function
     *
     * -----
     *
     * MySQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 3
     * ```
     *
     * PostgreSQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 2.99999999999999999997
     * ```
     */
    OperatorType["CUBE_ROOT"] = "CUBE_ROOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `TAN(x)`
     * + PostgreSQL     : `TAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    OperatorType["TANGENT"] = "TANGENT";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_truncate
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     *
     * -----
     *
     * + MySQL          : `TRUNCATE(x, d)`
     * + PostgreSQL     : `TRUNC(x, d)`
     * + SQLite         : None, implement with `Math.trunc(x * Math.pow(10, d)) / Math.pow(10, d)`
     */
    //TRUNCATE = "TRUNCATE",
    /*
        Date and Time Functions
        https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
    */
    /**
     * @todo
     */
    /*
     * + MySQL          :
     * ```sql
     *  SELECT
     *      adddate(date('2010-01-01'), interval 1 hour),
     *      adddate(date('2010-01-01'), interval 1 day);
     *  > 2010-01-01 01:00:00
     *  > 2010-01-02
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      date '2010-01-01' + interval '1 hour',
     *      date '2010-01-01' + interval '1 day',
     *      time '10:23:45.123' + interval '1 hour',
     *      time '10:23:45.123' + interval '1 day'
     *  > 2010-01-01T01:00:00.000Z
     *  > 2010-01-02T00:00:00.000Z
     *  > 11:23:45.123
     *  > 10:23:45.123
     * ```
     */
    //ADDDATE = "ADDDATE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_addtime
     *
     * It has... Weird behaviour.
     */
    //ADDTIME = "ADDTIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_DATE()`
     * + PostgreSQL     : `CURRENT_DATE()`
     * + SQLite         : `strftime('%Y-%m-%d', 'now')`
     */
    OperatorType["CURRENT_DATE"] = "CURRENT_DATE";
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(0)`
     * + PostgreSQL     : `CURRENT_TIME(0)`
     * + SQLite         : `strftime('%H:%M:%S', 'now')`
     */
    //CURRENT_TIME_0 = "CURRENT_TIME_0",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(1)`
     * + PostgreSQL     : `CURRENT_TIME(1)`
     * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 10)`
     */
    //CURRENT_TIME_1 = "CURRENT_TIME_1",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(2)`
     * + PostgreSQL     : `CURRENT_TIME(2)`
     * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 11)`
     */
    //CURRENT_TIME_2 = "CURRENT_TIME_2",
    /* *
     * Cannot use JS `Date` to represent SQL `TIME`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIME(3)`
     * + PostgreSQL     : `CURRENT_TIME(3)`
     * + SQLite         : `strftime('%H:%M:%f', 'now')`
     */
    //CURRENT_TIME_3 = "CURRENT_TIME_3",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(0)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(0),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(0))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(0),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(0)
     *      ))
     *  > 2019-09-07T23:58:20.000Z
     *  > 1567900700
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%S', 'now'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%S', 'now'));
     *  > 2019-09-07 23:59:35
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_0"] = "CURRENT_TIMESTAMP_0";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(1)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(1),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(1))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.8
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(1),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(1)
     *      ))
     *  > 2019-09-07T23:58:20.400Z
     *  > 1567900700
     * ```
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
     * ```sql
     *  SELECT
     *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21),
     *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21));
     *  > 2019-09-07 23:59:35.3
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_1"] = "CURRENT_TIMESTAMP_1";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(2)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(2),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(2))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.83
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(2),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(2)
     *      ))
     *  > 2019-09-07T23:58:20.470Z
     *  > 1567900700
     * ```
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
     * ```sql
     *  SELECT
     *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22),
     *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22));
     *  > 2019-09-07 23:59:35.32
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_2"] = "CURRENT_TIMESTAMP_2";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(3)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(3),
     *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))),
     *      UNIX_TIMESTAMP()
     *  > 2019-09-07 19:55:03.836
     *  > 1567900503
     *  > 1567900503
     * ```
     * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      CURRENT_TIMESTAMP(3),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM CURRENT_TIMESTAMP(3)
     *      ))
     *  > 2019-09-07T23:58:20.477Z
     *  > 1567900700
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', 'now'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', 'now'));
     *  > 2019-09-07 23:59:35.327
     *  > 1567900775
     * ```
     */
    OperatorType["CURRENT_TIMESTAMP_3"] = "CURRENT_TIMESTAMP_3";
    /**
     *
     * -----
     *
     * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
     *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
     *  > 1969-12-31 22:00:00.123
     *  > 10800
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
     *          )
     *      ))
     *  > 1970-01-01T03:00:00.123Z
     *  > 10800
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
     *  > 1970-01-01 03:00:00.123
     *  > 10800
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `UTC` timestamp.
     *
     */
    OperatorType["UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR"] = "UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR";
    /*
     *
     * -----
     *
     * + MySQL          : `TIMESTAMP(x)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      TIMESTAMP('1970-01-01 00:00:00.123'),
     *      FLOOR(UNIX_TIMESTAMP(TIMESTAMP('1970-01-01 00:00:00.123')));
     *  > 1970-01-01 00:00:00.123
     *  > 18000
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE current_setting('TIMEZONE')`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE'),
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE')
     *          )
     *      ))
     *  > 1970-01-01T05:00:00.123Z
     *  > 18000
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x, 'utc')`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'));
     *  > 1970-01-01 05:00:00.123
     *  > 18000
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `local` timestamp.
     *
     */
    //LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR = "LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000.0) / 1000.0`
     * ```sql
     *  SELECT
     *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
     *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
     *  > 32.4560
     * ```
     * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
     * + SQLite         : `strftime('%f', datetime)`
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 14:45:32.456789')
     *  > 32.457
     *  -- The result is rounded, not truncated.
     *  -- If it were truncated, we would get 32.456
     * ```
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 23:59:59.999999')
     *  > 59.999
     *  -- The result is truncated, not rounded.
     *  -- If it were rounded, we would get 60
     * ```
     *
     * @todo Make behaviour consistent?
     */
    OperatorType["EXTRACT_FRACTIONAL_SECOND_3"] = "EXTRACT_FRACTIONAL_SECOND_3";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime)`
     * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_INTEGER_SECOND"] = "EXTRACT_INTEGER_SECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_MINUTE"] = "EXTRACT_MINUTE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(HOUR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_HOUR"] = "EXTRACT_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(DAY FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_DAY"] = "EXTRACT_DAY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MONTH FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_MONTH"] = "EXTRACT_MONTH";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `EXTRACT(YEAR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
     */
    OperatorType["EXTRACT_YEAR"] = "EXTRACT_YEAR";
    /**
     * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
     *
     * -----
     *
     * + MySQL          : `LAST_DAY(datetime)`
     * ```sql
     *  SELECT
     *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
     *  > 2010-03-31
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SELECT
     *      (
     *          datetime +
     *          interval '1 month' -
     *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
     *      )::date
     * > 2010-03-31T00:00:00.000Z
     * ```
     * + SQLite         :
     * ```sql
     *  SELECT
     *      strftime(
     *          '%Y-%m-%d',
     *          '2010-03-27 14:45:32.456789',
     *          '+1 month',
     *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
     *      )
     *  > 2010-03-31
     * ```
     */
    OperatorType["LAST_DAY"] = "LAST_DAY";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MICROSECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x/1000.0, ' millisecond')::interval`
     *
     *   1 millisecond is 1000 microseconds
     *
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      -- 1 second is 1,000,000 microseconds
     *      (x/1000000.0) || ' second'
     *  );
     * ```
     *
     * However, SQLite only displays up to millisecond precision (3 decimal places for seconds).
     * JS' `Date` also only has up to millisecond precision.
     */
    //TIMESTAMPADD_MICROSECOND = "TIMESTAMPADD_MICROSECOND",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x/1000.0, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      (x/1000e0) || ' second'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MILLISECOND"] = "TIMESTAMPADD_MILLISECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' second'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_SECOND"] = "TIMESTAMPADD_SECOND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0, datetime)`
     *   + `TIMESTAMPADD(MINUTE, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' minute'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MINUTE"] = "TIMESTAMPADD_MINUTE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0*60.0, datetime)`
     *   + `TIMESTAMPADD(HOUR, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' hour'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_HOUR"] = "TIMESTAMPADD_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x*24.0*60.0*60.0, datetime)`
     *   + `TIMESTAMPADD(DAY, x, datetime)` ignores the fractional part of `x`.
     *   + We convert `x` to seconds as a workaround.
     * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' day'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_DAY"] = "TIMESTAMPADD_DAY";
    /**
     * Seems to be a MySQL and PostgreSQL thing.
     * SQLite does not have `week` intervals.
     *
     * Could probably be emulated with `7 day` being `1 week`
     */
    //TIMESTAMPADD_WEEK = "TIMESTAMPADD_WEEK",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' month'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_MONTH"] = "TIMESTAMPADD_MONTH";
    /**
     * Seems to be a MySQL thing.
     * PostgreSQL and SQLite do not have `quarter` intervals.
     *
     * Could probably be emulated with `3 month` being `1 quarter`
     */
    //TIMESTAMPADD_QUARTER = "TIMESTAMPADD_QUARTER",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' year'
     *  );
     * ```
     */
    OperatorType["TIMESTAMPADD_YEAR"] = "TIMESTAMPADD_YEAR";
    /*
     * SQLite does not have microsecond precision.
     */
    //TIMESTAMPDIFF_MICROSECOND = "TIMESTAMPDIFF_MICROSECOND",
    /**
     * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_MILLISECOND"] = "TIMESTAMPDIFF_MILLISECOND";
    /**
     * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_SECOND"] = "TIMESTAMPDIFF_SECOND";
    /**
     * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_MINUTE"] = "TIMESTAMPDIFF_MINUTE";
    /**
     * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_HOUR"] = "TIMESTAMPDIFF_HOUR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
     * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     */
    OperatorType["TIMESTAMPDIFF_DAY"] = "TIMESTAMPDIFF_DAY";
    /*
     * Seems to be MySQL-specific
     */
    //TIMESTAMPDIFF_WEEK = "TIMESTAMPDIFF_WEEK",
    /*
     * + MySQL          : `TIMESTAMPDIFF(MONTH, from, to)`
     * + PostgreSQL     :
     * ```sql
     * EXTRACT(YEAR FROM AGE(to, from))*12 +
     * EXTRACT(MONTH FROM AGE(to, from))
     * ```
     * + SQLite         : @todo? Doesn't seem possible to compute properly
     */
    //TIMESTAMPDIFF_MONTH = "TIMESTAMPDIFF_MONTH",
    /*
     * Seems to be MySQL-specific
     */
    //TIMESTAMPDIFF_QUARTER = "TIMESTAMPDIFF_QUARTER",
    /*
     * + MySQL          : `TIMESTAMPDIFF(YEAR, from, to)`
     * + PostgreSQL     :
     * ```sql
     * EXTRACT(YEAR FROM AGE(to, from))
     * ```
     * + SQLite         : @todo? Doesn't seem possible to compute properly
     */
    //TIMESTAMPDIFF_YEAR = "TIMESTAMPDIFF_YEAR",
    /*
     * The different databases implement this differently,
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-format
     * + https://www.postgresql.org/docs/9.4/functions-formatting.html
     * + https://www.sqlite.org/lang_datefunc.html
     */
    //TIME_FORMAT = "TIME_FORMAT",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-to-sec
     */
    //TIME_TO_SEC = "TIME_TO_SEC",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days
     */
    //TO_DAYS = "TO_DAYS",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-seconds
     */
    //TO_SECONDS = "TO_SECONDS",
    /*
     * @todo
     *
     * I don't think this can easily be made portable across different database systems
     * **AND** made to behave consistently across different session time zone settings.
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP(datetime)`
     *   + The return value is an integer if no argument is given or the argument does not include a fractional seconds part,
     *   + or `DECIMAL` if an argument is given that includes a fractional seconds part.
     *   + returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
     *   + The server interprets date as a value in the session time zone and converts it to an internal Unix timestamp value in UTC.
     * +
     */
    //UNIX_TIMESTAMP_AT_DATETIME = "UNIX_TIMESTAMP_AT_DATETIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP()`
     * + PostgreSQL     :
     * ```sql
     *  FLOOR(
     *      EXTRACT(EPOCH FROM (
     *          CURRENT_TIMESTAMP -
     *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
     *      ))
     *  )
     * ```
     * + SQLite         : `strftime('%s', 'now')`
     */
    OperatorType["UNIX_TIMESTAMP_NOW"] = "UNIX_TIMESTAMP_NOW";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-date
     */
    //UTC_DATE = "UTC_DATE",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-time
     */
    //UTC_TIME = "UTC_TIME",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     *
     * Also, it does not play well with the other MySQL date-time functions.
     * Do not implement in base package unless a **VERY** good reason exists.
     */
    //UTC_TIMESTAMP = "UTC_TIMESTAMP",
    /*
     * Wtf is this, even?
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_week
     */
    //WEEK = "WEEK",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekday
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `WEEKDAY(date)`           ; `0=Monday, 1=Tuesday, ..., 6=Sunday`
     * + PostgreSQL     : `EXTRACT(DOW FROM date)`  ; `0=Sunday, 1=Monday , ..., 6=Saturday`
     * + SQLite         : `strftime('%w', date)`    ; `0=Sunday, 1=Monday , ..., 6=Saturday`
     *
     * -----
     *
     * Implementations are incompatible.
     * Can possibly use a different name and unify their implementations, however.
     */
    //WEEKDAY = "WEEKDAY",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekofyear
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `WEEKOFYEAR(date)`        ; `1-53`
     * + PostgreSQL     : `EXTRACT(WEEK FROM date)` ; `@todo`
     * + SQLite         : `strftime('%W', date)`    ; `0-53`
     *
     * -----
     *
     * Implementations are incompatible.
     * Can possibly use a different name and unify their implementations, however.
     */
    //WEEKOFYEAR = "WEEKOFYEAR",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_year
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `YEAR(date)`
     * + PostgreSQL     : `EXTRACT(YEAR FROM date)`
     * + SQLite         : `strftime('%Y', date)`
     *
     * @todo How is this different from `EXTRACT(YEAR FROM date)`?
     */
    //YEAR = "YEAR",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_yearweek
     */
    //YEARWEEK = "YEARWEEK",
    /*
        Cast Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html
    */
    /**
     * @todo
     */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS BINARY)`
     * + PostgreSQL     : `CAST(x AS bytea)`
     * + SQLite         : `CAST(x AS BLOB)`
     */
    OperatorType["CAST_AS_BINARY"] = "CAST_AS_BINARY";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS CHAR) [charset_info]`
     * + PostgreSQL     : `CAST(x AS VARCHAR) [charset_info]`
     * + SQLite         : `CAST(x AS VARCHAR) [charset_info]`
     */
    OperatorType["CAST_AS_VARCHAR"] = "CAST_AS_VARCHAR";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS DATE)`
     * + PostgreSQL     : `CAST(x AS DATE)`
     * + SQLite         :
     *   **DO NOT** use `CAST(x AS DATE)`!
     * ```sql
     * SELECT CAST('2010-10-27 12:00:00' AS DATE)
     * > 2019
     * ```
     *
     * The above happens because `DATE` has `NUMERIC` affinity.
     * And so, the cast is the same as saying `CAST(x AS DECIMAL)`
     *
     * -----
     *
     * Actually, don't even use `CAST_AS_DATE`.
     * Just use one of the two `TIMESTAMP` constructors.
     */
    //CAST_AS_DATE = "CAST_AS_DATE",
    /*
     * Actually, don't even use `CAST_AS_DATETIME`.
     * Just use one of the two `TIMESTAMP` constructors.
     */
    //CAST_AS_DATETIME = "CAST_AS_DATETIME",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS DECIMAL(precision, scale))`
     *   + Max precision : 65
     *   + Max scale     : 30
     * + PostgreSQL     : `CAST(x AS DECIMAL(precision, scale))`
     *   + Max precision : 1000
     *   + Max scale     : 1000
     * + SQLite         : `CAST(x AS DECIMAL(precision, scale))`
     * ```sql
     * SELECT CAST('1e308' AS DECIMAL)
     * > 1e+308
     * ```
     *
     * For SQLite, this doesn't even cast to an arbitrary precision number.
     * SQLite does not support arbitrary precision numbers.
     * You will get a `double` instead.
     *
     * -----
     *
     * Precision and scale cannot be omitted.
     *
     * When omitted, MySQL defaults to `DECIMAL(10, 0)`
     * When omitted, PostgreSQL defaults to a precision and scale that will contain `x`
     *
     * -----
     *
     * ### Notes about MySQL's `DECIMAL`
     *
     * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1253-L1313
     * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1576-L1598
     *
     * ```js
     * DIG_PER_DEC1 = 9
     * dig2bytes = [0,1,1,2,2,3,3,4,4,4]
     * precision = 65
     * scale = 30
     * //typedef int32 decimal_digit_t;
     * //typedef decimal_digit_t dec1;
     * dec1 = 4
     * function sizeof (arg) { return arg }
     * var
     *      intg = precision - scale,
     *      intg0  = Math.floor(intg / DIG_PER_DEC1),
     *      frac0  = Math.floor(scale / DIG_PER_DEC1),
     *      intg0x = intg - intg0 * DIG_PER_DEC1,
     *      frac0x = scale - frac0 * DIG_PER_DEC1;
     * result = intg0 * sizeof(dec1) + dig2bytes[intg0x] + frac0 * sizeof(dec1) + dig2bytes[frac0x]
     * ```
     *
     * http://ftp.nchu.edu.tw/MySQL/doc/refman/5.0/en/precision-math-decimal-changes.html
     *
     * -----
     *
     * ```js
     * DIG_PER_DEC1 = 9;
     * dig2bytes = [0, 1, 1, 2, 2, 3, 3, 4, 4, 4];
     *
     * res = {};
     *
     * for (let precision = 1; precision < 73; precision++) {
     *      for (let scale = 0; scale <= precision; scale++) {
     *          const intg = precision - scale;
     *          const intg0 = Math.floor(intg / DIG_PER_DEC1);
     *          const frac0 = Math.floor(scale / DIG_PER_DEC1);
     *          const intg0x = intg - intg0 * DIG_PER_DEC1;
     *          const frac0x = scale - frac0 * DIG_PER_DEC1;
     *          const result = (
     *              intg0 * 4 + dig2bytes[intg0x] + frac0 * 4 + dig2bytes[frac0x]
     *          );
     *          res[`${precision}.${scale}`] = result;
     *      }
     * }
     * console.log(res);
     * ```
     *
     * -----
     *
     * ### Notes about PostgreSQL's `DECIMAL`
     *
     * https://doxygen.postgresql.org/numeric_8h.html#a12ab0e498cc609664248b5c9bb6c0a43
     *
     * @karanlyons said,
     * > 511 bytes for 1000 digits in postgres.
     * >
     * > And I think they use the extra byte for some additional bookeeping of the sign, etc.
     * >
     * > So 512, which makes sense!
     * >
     * > <3 u pg.
     * >
     * > Postgres source code is way better to read.
     * >
     * > It helps that theyre not insane.
     * >
     * > ~~That extra byte is actually for the type header I think, not internal bookkeeping of the number itself.~~
     * >
     * > The extra byte is for the `typmod` I think, which is 32 bits encoding the precision and scale in the upper 16 and lower 16.
     * >
     * > https://doxygen.postgresql.org/backend_2utils_2adt_2numeric_8c_source.html#l00703
     * >
     * > https://doxygen.postgresql.org/structNumericVar.html
     */
    OperatorType["CAST_AS_DECIMAL"] = "CAST_AS_DECIMAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL 5.7      : `x + 0e0`
     * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
     * + SQLite         : `CAST(x AS DOUBLE)`
     */
    OperatorType["CAST_AS_DOUBLE"] = "CAST_AS_DOUBLE";
    /*
     * Can't do it in MySQL 5.7.
     */
    //CAST_AS_FLOAT = "CAST_AS_FLOAT",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS JSON)`
     * + PostgreSQL     : `CAST(x AS JSON)`
     * + SQLite         : `CAST(x AS TEXT)`; Or implement with user-defined function.
     *
     *   SQLite does not have a `JSON` data type
     */
    OperatorType["CAST_AS_JSON"] = "CAST_AS_JSON";
    /* *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     * + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS NCHAR)`
     * + PostgreSQL     : `CAST(x AS VARCHAR) utf8`
     *   + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
     *   + `utf8` is the charset of MySQL's `NCHAR`
     * + SQLite         : `CAST(x AS TEXT)`
     *   + SQLite does not have character sets
     */
    //CAST_AS_N_CHAR = "CAST_AS_N_CHAR",
    /*
     * The behaviour is too unpredictable on MySQL.
     * > Produces a result of type REAL.
     * This is actually FLOAT if REAL_AS_FLOAT SQL mode is enabled; otherwise the result is of type DOUBLE.
     */
    //CAST_AS_REAL = "CAST_AS_REAL",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS SIGNED INTEGER)`
     *   + Actually gives a signed `bigint`
     *   + Trying to cast `'123e2'` gives `123`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + Trying to cast `'123e2'` throws an error
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + Trying to cast `'123e2'` gives `123`
     */
    OperatorType["CAST_AS_BIGINT_SIGNED"] = "CAST_AS_BIGINT_SIGNED";
    /*
     * Use one of the `TIMESTAMP` constructors instead
     */
    //CAST_AS_TIME = "CAST_AS_TIME",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS UNSIGNED INTEGER)`
     *   + Actually gives an unsigned `bigint`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + PostgreSQL does not have unsigned types!
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + SQLite does not have unsigned types!
     *
     * -----
     *
     * ~~Even though **ONLY** MySQL supports `UNSIGNED` types,~~
     * ~~we're still adding this because it's too useful to give up.~~
     * Support for `BIGINT UNSIGNED` has been dropped.
     *
     * It means that trying to use `BIGINT UNSIGNED` with other databases
     * will produce varying behaviours, though...
     *
     * For example, the range of `BIGINT SIGNED` is much smaller than
     * `BIGINT UNSIGNED` if we are only looking at the non-negative range.
     *
     * Math with `BIGINT UNSIGNED` fails if the result becomes negative.
     * `BIGINT SIGNED` has no such inhibitions.
     */
    //CAST_AS_UNSIGNED_BIG_INTEGER = "CAST_AS_UNSIGNED_BIG_INTEGER",
    /*
        Bit Functions and Operators
        https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x & y AS SIGNED)`
     * + PostgreSQL   : `&`
     * + SQLite       : `&`
     */
    OperatorType["BITWISE_AND"] = "BITWISE_AND";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(~x AS SIGNED)`
     *   + `~1337` === `18446744073709550278`
     *   + `CAST(~1337 AS SIGNED)` === `-1338`
     * + PostgreSQL   : `~x`
     *   + `~1337` === `-1338`
     * + SQLite       : `~x`
     *   + `~1337` === `-1338`
     */
    OperatorType["BITWISE_NOT"] = "BITWISE_NOT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x | y AS SIGNED)`
     * + PostgreSQL   : `|`
     * + SQLite       : `|`
     */
    OperatorType["BITWISE_OR"] = "BITWISE_OR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x ^ y AS SIGNED)`
     * + PostgreSQL   : `#`
     * + SQLite       : None, use `(~(a&b))&(a|b)` instead
     *   + https://stackoverflow.com/questions/16440831/bitwise-xor-in-sqlite-bitwise-not-not-working-as-i-expect
     *   + https://www.mail-archive.com/sqlite-users@mailinglists.sqlite.org/msg02250.html
     */
    OperatorType["BITWISE_XOR"] = "BITWISE_XOR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     */
    OperatorType["BITWISE_LEFT_SHIFT"] = "BITWISE_LEFT_SHIFT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     */
    OperatorType["BITWISE_RIGHT_SHIFT"] = "BITWISE_RIGHT_SHIFT";
    /*
        Functions That Create JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-creation-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Search JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Modify JSON Values
        https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html
    */
    /**
     * @todo
     */
    /*
        Functions That Return JSON Value Attributes
        https://dev.mysql.com/doc/refman/8.0/en/json-attribute-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Table Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Schema Validation Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-validation-functions.html
    */
    /**
     * @todo
     */
    /*
        JSON Utility Functions
        https://dev.mysql.com/doc/refman/8.0/en/json-utility-functions.html
    */
    /**
     * @todo
     */
    /*
        Spatial Analysis Functions
        https://dev.mysql.com/doc/refman/8.0/en/spatial-analysis-functions.html

        @todo Split into subchapters
    */
    /*
        Aggregate (GROUP BY) Function Descriptions
        https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     * + PostgreSQL : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     * + SQLite     : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
     */
    OperatorType["AGGREGATE_AVERAGE"] = "AGGREGATE_AVERAGE";
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-and
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `BIT_AND(x)/BIT_AND(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `18446744073709551615`
     * + PostgreSQL : `BIT_AND(x)/BIT_AND(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `NULL`
     * + SQLite     : None. Implement with user-defined function.
     */
    //AGGREGATE_BITWISE_AND = "AGGREGATE_BITWISE_AND",
    /*
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-or
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `BIT_OR(x)/BIT_OR(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `0`
     * + PostgreSQL : `BIT_OR(x)/BIT_OR(x) OVER()`
     *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `NULL`
     * + SQLite     : None. Implement with user-defined function.
     */
    //AGGREGATE_BITWISE_OR = "AGGREGATE_BITWISE_OR",
    /**
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-xor
     */
    //BIT_XOR = "BIT_XOR",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` always returns one row
     * + PostgreSQL : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` can return zero rows
     * + SQLite     : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
     *   + `COUNT(x) OVER()` can return zero rows
     */
    OperatorType["AGGREGATE_COUNT_EXPR"] = "AGGREGATE_COUNT_EXPR";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     * + PostgreSQL : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     * + SQLite     : `COUNT(*)/COUNT(*) OVER()`
     *   + `COUNT(*) OVER()` can return zero rows
     */
    OperatorType["AGGREGATE_COUNT_ALL"] = "AGGREGATE_COUNT_ALL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
     * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
     *   + The order of the concatenated elements is arbitrary.
     *   + Uses comma as separator
     *
     * -----
     *
     * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
     * for the DB-unified implementation.
     *
     * Unless we modify the SQLite implementation with a user-defined function?
     * @todo Investigate
     */
    OperatorType["AGGREGATE_GROUP_CONCAT_DISTINCT"] = "AGGREGATE_GROUP_CONCAT_DISTINCT";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(expr, separator)`
     * + SQLite     : `GROUP_CONCAT(expr, separator)`
     *   + The order of the concatenated elements is arbitrary.
     */
    OperatorType["AGGREGATE_GROUP_CONCAT_ALL"] = "AGGREGATE_GROUP_CONCAT_ALL";
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-arrayagg
     * @todo?
     *
     * Could also be related to `ARRAY_AGG()` from PostgreSQL,
     */
    //JSON_ARRAYAGG = "JSON_ARRAYAGG",
    /*
     * Appears to be MySQL-specific,
     * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-objectagg
     */
    //JSON_OBJECTAGG = "JSON_OBJECTAGG",
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     * + PostgreSQL : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     * + SQLite     : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
     */
    OperatorType["AGGREGATE_MAX"] = "AGGREGATE_MAX";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(DISTINCT x)/MIN(x) OVER()`
     * + PostgreSQL : `MIN(DISTINCT x)/MIN(x) OVER()`
     * + SQLite     : `MIN(DISTINCT x)/MIN(x)/MIN(x) OVER()`
     */
    OperatorType["AGGREGATE_MIN"] = "AGGREGATE_MIN";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
     * + PostgreSQL : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_POPULATION_STANDARD_DEVIATION"] = "AGGREGATE_POPULATION_STANDARD_DEVIATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
     * + PostgreSQL : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_SAMPLE_STANDARD_DEVIATION"] = "AGGREGATE_SAMPLE_STANDARD_DEVIATION";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM"] = "AGGREGATE_SUM";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM_AS_DECIMAL"] = "AGGREGATE_SUM_AS_DECIMAL";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
     */
    OperatorType["AGGREGATE_SUM_AS_BIGINT_SIGNED"] = "AGGREGATE_SUM_AS_BIGINT_SIGNED";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_POP(x)/VAR_POP(x) OVER()`
     * + PostgreSQL : `VAR_POP(x)/VAR_POP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_POPULATION_VARIANCE"] = "AGGREGATE_POPULATION_VARIANCE";
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
     * + PostgreSQL : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     */
    OperatorType["AGGREGATE_SAMPLE_VARIANCE"] = "AGGREGATE_SAMPLE_VARIANCE";
    /*
        https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html

        Subqueries with `EXISTS` or `NOT EXISTS`
    */
    /**
     * + https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html
     * + https://www.postgresql.org/docs/8.1/functions-subquery.html#AEN13171
     * + https://www.sqlite.org/lang_expr.html#exists_op
     *
     * -----
     *
     * + MySQL      : `EXISTS(query)`
     * + PostgreSQL : `EXISTS(query)`
     * + SQLite     : `EXISTS(query)`
     */
    OperatorType["EXISTS"] = "EXISTS";
    /*
        https://dev.mysql.com/doc/refman/5.7/en/information-functions.html

        Information Functions
    */
    /**
     * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://www.sqlite.org/lang_attach.html
     *
     * -----
     *
     * + MySQL      : `DATABASE()`
     * + PostgreSQL : `CURRENT_SCHEMA`
     * + SQLite     : `'main'` should always be the current database.
     *   + There's also `'temp'`, I guess
     */
    OperatorType["CURRENT_SCHEMA"] = "CURRENT_SCHEMA";
    /**
     * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
     *
     * -----
     *
     * + MySQL      : `CURRENT_USER`
     * + PostgreSQL : `CURRENT_USER`
     * + SQLite     : None. It does not make sense to ask what the current user is.
     */
    OperatorType["CURRENT_USER"] = "CURRENT_USER";
    /*
        Custom library functions

        These functions are not standard SQL,
        but can be implemented using standard SQL.
    */
    /*
     * An invalid expression that is syntactically valid.
     * So, it will run.
     * But evaluating it will throw a run-time error.
     *
     * Good for stuff like,
     * ```sql
     *  -- Throw if the condition is false
     *  -- Otherwise, return the expression
     *  IF(
     *      -- condition,
     *      -- expression,
     *      THROW()
     *  )
     * ```
     *
     * Or,
     * ```sql
     *  -- Throw if expression is null
     *  -- Otherwise, return the expression
     *  COALESCE(
     *      -- possibly null expression,
     *      throw()
     *  )
     * ```
     *
     * A good example of such a throwing expression is,
     * ```sql
     *  -- Returns two rows,
     *  (SELECT NULL UNION ALL SELECT NULL)
     * ```
     *
     * @todo Find other such throwing expressions?
     *
     * This cannot be done in PostgreSQL.
     * PostgeSQL's type system does not allow mixing types like,
     * ```sql
     *  COALESCE(true, (SELECT NULL UNION ALL SELECT NULL))
     * ```
     */
    //THROW = "THROW",
    /**
     * + MySQL      - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
     * + PostgreSQL - `COALESCE(x, (SELECT NULL UNION ALL SELECT x))`
     *   Unfortunately, with PostgreSQL, we need to duplicate the expression...
     *   But this is a debug expression, anyway, and should not be used often.
     * + SQLite     - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
     */
    OperatorType["THROW_IF_NULL"] = "THROW_IF_NULL";
})(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
//# sourceMappingURL=operator-type.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OrderByClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/order-by-clause/util/index.js");
exports.OrderByClauseUtil = OrderByClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/order-by-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/order-by-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/operation/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/operation/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./order-by */ "./node_modules/@squill/squill/dist/order-by-clause/util/operation/order-by.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/operation/order-by.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/operation/order-by.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/order-by-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const order_1 = __webpack_require__(/*! ../../../order */ "./node_modules/@squill/squill/dist/order/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
/**
 * Returns the MySQL equivalent of `...orderBy, orderByDelegate(columns)`
 *
 * This will change when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 *
 * -----
 *
 * @param fromClause
 * @param orderByClause
 * @param orderByDelegate
 */
function orderBy(fromClause, groupByClause, selectClause, orderByClause, orderByDelegate) {
    const columns = query_1.allowedColumnRef(fromClause, selectClause);
    const orderBy = orderByDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    if (groupByClause == undefined) {
        for (const rawOrder of orderBy) {
            const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
            if (built_in_expr_1.BuiltInExprUtil.isAggregate(sortExpr)) {
                throw new Error(`Aggregate expressions in ORDER BY clause not allowed without GROUP BY clause`);
            }
            if (column_1.ColumnUtil.isColumn(sortExpr)) {
                column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
            }
            else {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
            }
        }
    }
    else {
        const nonAggregateColumns = query_1.allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause);
        for (const rawOrder of orderBy) {
            const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
            if (column_1.ColumnUtil.isColumn(sortExpr)) {
                column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(nonAggregateColumns, sortExpr);
            }
            else {
                if (built_in_expr_1.BuiltInExprUtil.isAggregate(sortExpr)) {
                    used_ref_1.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
                }
                else {
                    used_ref_1.UsedRefUtil.assertAllowed({ columns: nonAggregateColumns }, sortExpr.usedRef);
                }
            }
        }
    }
    return (orderByClause == undefined ?
        orderBy.map(order_1.OrderUtil.fromRawOrder) :
        [...orderByClause, ...orderBy.map(order_1.OrderUtil.fromRawOrder)]);
}
exports.orderBy = orderBy;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause) {
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    const selectClauseColumns = (selectClause == undefined ?
        {} :
        column_ref_1.ColumnRefUtil.fromSelectClause(selectClause));
    const result = column_ref_1.ColumnRefUtil.intersect(inner, selectClauseColumns);
    return result;
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause, selectClause) {
    const usedRef = used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause));
    return usedRef;
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-used-ref.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-used-ref.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
/**
 * For now, this is basically the same as `HavingClauseUtil.AllowedColumnRef<>`.
 *
 * They will diverge when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 */
function allowedColumnRef(fromClause, selectClause) {
    const fromClauseColumns = column_ref_1.ColumnRefUtil.fromJoinArray((fromClause.currentJoins != undefined) ?
        fromClause.currentJoins :
        []);
    const selectClauseColumns = (selectClause == undefined ?
        {} :
        column_ref_1.ColumnRefUtil.fromSelectClause(selectClause));
    const result = column_ref_1.ColumnRefUtil.intersect(fromClauseColumns, selectClauseColumns);
    return result;
}
exports.allowedColumnRef = allowedColumnRef;
/**
 * For now, this is basically the same as `HavingClauseUtil.AllowedUsedRef<>`.
 *
 * They will diverge when,
 * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
 */
function allowedUsedRef(fromClause, selectClause) {
    const usedRef = used_ref_1.UsedRefUtil.fromColumnRef(allowedColumnRef(fromClause, selectClause));
    return usedRef;
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order-by-clause/util/query/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order-by-clause/util/query/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/order-by-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OrderUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/order/util/index.js");
exports.OrderUtil = OrderUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/constructor/from-raw-order.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/constructor/from-raw-order.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/order/util/predicate/index.js");
function fromRawOrder(rawOrder) {
    if (predicate_1.isOrder(rawOrder)) {
        return rawOrder;
    }
    else {
        return [rawOrder, sort_direction_1.SortDirection.ASC];
    }
}
exports.fromRawOrder = fromRawOrder;
//# sourceMappingURL=from-raw-order.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/constructor/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/constructor/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-raw-order */ "./node_modules/@squill/squill/dist/order/util/constructor/from-raw-order.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/order/util/constructor/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/order/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/order/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/predicate/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/predicate/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-order */ "./node_modules/@squill/squill/dist/order/util/predicate/is-order.js"));
__export(__webpack_require__(/*! ./is-sort-expr */ "./node_modules/@squill/squill/dist/order/util/predicate/is-sort-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/predicate/is-order.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/predicate/is-order.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
/**
 * Checks,
 * + If it is an 2-tuple
 * + If the second element is a `SortDirection`
 *
 * Does not check,
 * + If the first element is a `SortExpr` (for run-time performance)
 *
 * @param mixed
 */
function isOrder(mixed) {
    return (Array.isArray(mixed) &&
        mixed.length == 2 &&
        sort_direction_1.SortDirectionUtil.isSortDirection(mixed[1]));
}
exports.isOrder = isOrder;
//# sourceMappingURL=is-order.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/predicate/is-sort-expr.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/predicate/is-sort-expr.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
function isSortExpr(mixed) {
    return (column_1.ColumnUtil.isColumn(mixed) ||
        expr_1.ExprUtil.isExpr(mixed) ||
        expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(mixed));
}
exports.isSortExpr = isSortExpr;
//# sourceMappingURL=is-sort-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/query/extract-sort-expr.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/query/extract-sort-expr.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/order/util/predicate/index.js");
function extractSortExpr(rawOrder) {
    if (predicate_1.isOrder(rawOrder)) {
        return rawOrder[0];
    }
    else {
        return rawOrder;
    }
}
exports.extractSortExpr = extractSortExpr;
//# sourceMappingURL=extract-sort-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/order/util/query/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/order/util/query/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-sort-expr */ "./node_modules/@squill/squill/dist/order/util/query/extract-sort-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/partial-row/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/partial-row/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const PartialRowUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/partial-row/util/index.js");
exports.PartialRowUtil = PartialRowUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/partial-row/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/partial-row/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/partial-row/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/partial-row/util/query/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/partial-row/util/query/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/partial-row/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/partial-row/util/query/mapper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/partial-row/util/query/mapper.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.partialMapper(table.columns);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/primary-key/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/primary-key/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const PrimaryKeyUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/primary-key/util/index.js");
exports.PrimaryKeyUtil = PrimaryKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/primary-key/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/primary-key/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/primary-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/primary-key/util/query/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/primary-key/util/query/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/primary-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/primary-key/util/query/mapper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/primary-key/util/query/mapper.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, table.primaryKey));
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/promise-util/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/promise-util/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./invoke-async-callback-safely */ "./node_modules/@squill/squill/dist/promise-util/invoke-async-callback-safely.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/promise-util/invoke-async-callback-safely.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/promise-util/invoke-async-callback-safely.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
async function invokeAsyncCallbackSafely(asyncCallback, thenCallback, catchCallback) {
    try {
        return asyncCallback()
            .then(thenCallback, catchCallback);
    }
    catch (syncErr) {
        return catchCallback(syncErr);
    }
}
exports.invokeAsyncCallbackSafely = invokeAsyncCallbackSafely;
//# sourceMappingURL=invoke-async-callback-safely.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const QueryBaseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/query-base/util/index.js");
exports.QueryBaseUtil = QueryBaseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/query-base/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/query-base/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/query-base/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/as.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const derived_table_1 = __webpack_require__(/*! ../../../derived-table */ "./node_modules/@squill/squill/dist/derived-table/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/query-base/util/query/index.js");
const constants_1 = __webpack_require__(/*! ../../../constants */ "./node_modules/@squill/squill/dist/constants.js");
const derived_table_select_item_1 = __webpack_require__(/*! ../../../derived-table-select-item */ "./node_modules/@squill/squill/dist/derived-table-select-item/index.js");
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/query-base/util/predicate/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function assertAliasable(query) {
    const duplicateColumnAlias = select_clause_1.SelectClauseUtil.duplicateColumnAlias(query.selectClause);
    if (duplicateColumnAlias.length > 0) {
        throw new Error(`Cannot alias query with duplicate names in SELECT clause; ${duplicateColumnAlias.join(", ")}`);
    }
}
function as(query, alias) {
    assertAliasable(query);
    if (predicate_1.isOneSelectItem(query) && predicate_1.isZeroOrOneRow(query)) {
        const result = new derived_table_select_item_1.DerivedTableSelectItem({
            mapper: query_1.mapper(query),
            isLateral: false,
            tableAlias: constants_1.ALIASED,
            alias,
            columns: (column_map_1.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
            usedRef: used_ref_1.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                [] :
                query.fromClause.outerQueryJoins),
            isAggregate: false,
        }, ast_1.parentheses(query, false));
        /**
         * @todo Investigate why we can't cast to `As<>` directly
         */
        return result;
    }
    else {
        const result = new derived_table_1.DerivedTable({
            isLateral: false,
            alias,
            columns: (column_map_1.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
            usedRef: used_ref_1.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                [] :
                query.fromClause.outerQueryJoins),
        }, query);
        /**
         * @todo Investigate why we can't cast to `As<>` directly
         */
        return result;
    }
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/asc.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/asc.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js");
function asc(query) {
    return [
        coalesce_1.coalesce(query, null),
        sort_direction_1.SortDirection.ASC
    ];
}
exports.asc = asc;
//# sourceMappingURL=asc.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function coalesce(query, defaultValue) {
    return ExprLib.coalesce(query, defaultValue);
}
exports.coalesce = coalesce;
//# sourceMappingURL=coalesce.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/desc.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/desc.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/index.js");
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js");
function desc(query) {
    return [
        coalesce_1.coalesce(query, null),
        sort_direction_1.SortDirection.DESC
    ];
}
exports.desc = desc;
//# sourceMappingURL=desc.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./as */ "./node_modules/@squill/squill/dist/query-base/util/operation/as.js"));
__export(__webpack_require__(/*! ./asc */ "./node_modules/@squill/squill/dist/query-base/util/operation/asc.js"));
__export(__webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js"));
__export(__webpack_require__(/*! ./desc */ "./node_modules/@squill/squill/dist/query-base/util/operation/desc.js"));
__export(__webpack_require__(/*! ./sort */ "./node_modules/@squill/squill/dist/query-base/util/operation/sort.js"));
__export(__webpack_require__(/*! ./throw-if-null */ "./node_modules/@squill/squill/dist/query-base/util/operation/throw-if-null.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/sort.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/sort.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const coalesce_1 = __webpack_require__(/*! ./coalesce */ "./node_modules/@squill/squill/dist/query-base/util/operation/coalesce.js");
function sort(query, sortDirection) {
    return [
        coalesce_1.coalesce(query, null),
        sortDirection
    ];
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/operation/throw-if-null.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/operation/throw-if-null.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function throwIfNull(query) {
    return ExprLib.throwIfNull(query);
}
exports.throwIfNull = throwIfNull;
//# sourceMappingURL=throw-if-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-after-from-clause */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-from-clause.js"));
__export(__webpack_require__(/*! ./is-after-select-clause */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-select-clause.js"));
__export(__webpack_require__(/*! ./is-before-compound-query-clause */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-compound-query-clause.js"));
__export(__webpack_require__(/*! ./is-before-select-clause */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-select-clause.js"));
__export(__webpack_require__(/*! ./is-one-row */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-row.js"));
__export(__webpack_require__(/*! ./is-one-select-item */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-select-item.js"));
__export(__webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row-using-limit */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row-using-compound-query-limit */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js"));
__export(__webpack_require__(/*! ./is-zero-or-one-row */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-from-clause.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-from-clause.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
function isAfterFromClause(x) {
    return is_query_1.isQuery(x) && from_clause_1.FromClauseUtil.isAfterFromClause(x.fromClause);
}
exports.isAfterFromClause = isAfterFromClause;
//# sourceMappingURL=is-after-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-select-clause.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-select-clause.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
function isAfterSelectClause(x) {
    return is_query_1.isQuery(x) && (x.selectClause != undefined);
}
exports.isAfterSelectClause = isAfterSelectClause;
//# sourceMappingURL=is-after-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-compound-query-clause.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-compound-query-clause.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
function isBeforeCompoundQueryClause(x) {
    return is_query_1.isQuery(x) && (x.compoundQueryClause == undefined);
}
exports.isBeforeCompoundQueryClause = isBeforeCompoundQueryClause;
//# sourceMappingURL=is-before-compound-query-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-select-clause.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-before-select-clause.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
function isBeforeSelectClause(x) {
    return is_query_1.isQuery(x) && (x.selectClause == undefined);
}
exports.isBeforeSelectClause = isBeforeSelectClause;
//# sourceMappingURL=is-before-select-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-row.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-row.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
function isOneRow(x) {
    return (is_query_1.isQuery(x) &&
        ((from_clause_1.FromClauseUtil.isBeforeFromClause(x.fromClause) &&
            x.compoundQueryClause == undefined) ||
            (x.groupByClause != undefined &&
                x.groupByClause.length == 0 &&
                x.compoundQueryClause == undefined)));
}
exports.isOneRow = isOneRow;
//# sourceMappingURL=is-one-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-select-item.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-select-item.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_after_select_clause_1 = __webpack_require__(/*! ./is-after-select-clause */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-after-select-clause.js");
const select_item_1 = __webpack_require__(/*! ../../../select-item */ "./node_modules/@squill/squill/dist/select-item/index.js");
function isOneSelectItem(x) {
    return (is_after_select_clause_1.isAfterSelectClause(x) &&
        x.selectClause.length == 1 &&
        select_item_1.SelectItemUtil.isSingleValueSelectItem(x.selectClause[0]));
}
exports.isOneSelectItem = isOneSelectItem;
//# sourceMappingURL=is-one-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
//import {UsedRefUtil} from "../../../used-ref";
//import {AstUtil} from "../../../ast";
/**
 * Only checks that the properties exist.
 * Does not actually check that they are the right data type!
 *
 * @todo Consider adding checks for increased type safety.
 */
function isQuery(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "fromClause",
        "selectClause",
        "limitClause",
        "compoundQueryClause",
        "compoundQueryLimitClause",
        "mapDelegate",
        "whereClause",
        "groupByClause",
        "havingClause",
        "orderByClause",
        "compoundQueryOrderByClause",
        "isDistinct",
    ])) {
        return false;
    }
    return true;
}
exports.isQuery = isQuery;
//# sourceMappingURL=is-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
function isZeroOrOneRowUsingCompoundQueryLimit(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (is_query_1.isQuery(x) &&
        x.compoundQueryLimitClause != undefined &&
        (tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(0)) ||
            tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(1))));
}
exports.isZeroOrOneRowUsingCompoundQueryLimit = isZeroOrOneRowUsingCompoundQueryLimit;
//# sourceMappingURL=is-zero-or-one-row-using-compound-query-limit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const is_query_1 = __webpack_require__(/*! ./is-query */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-query.js");
function isZeroOrOneRowUsingLimit(x) {
    const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
    return (is_query_1.isQuery(x) &&
        x.limitClause != undefined &&
        (tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(0)) ||
            tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(1))) &&
        x.compoundQueryClause == undefined &&
        x.compoundQueryLimitClause == undefined);
}
exports.isZeroOrOneRowUsingLimit = isZeroOrOneRowUsingLimit;
//# sourceMappingURL=is-zero-or-one-row-using-limit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_one_row_1 = __webpack_require__(/*! ./is-one-row */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-one-row.js");
const is_zero_or_one_row_using_limit_1 = __webpack_require__(/*! ./is-zero-or-one-row-using-limit */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-limit.js");
const is_zero_or_one_row_using_compound_query_limit_1 = __webpack_require__(/*! ./is-zero-or-one-row-using-compound-query-limit */ "./node_modules/@squill/squill/dist/query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit.js");
function isZeroOrOneRow(x) {
    return (
    /**
     * This `OR` expression is sorted from most likely to least likely.
     * Do not change the order unless you have a good reason!
     */
    is_zero_or_one_row_using_limit_1.isZeroOrOneRowUsingLimit(x) ||
        is_zero_or_one_row_using_compound_query_limit_1.isZeroOrOneRowUsingCompoundQueryLimit(x) ||
        is_one_row_1.isOneRow(x));
}
exports.isZeroOrOneRow = isZeroOrOneRow;
//# sourceMappingURL=is-zero-or-one-row.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/query/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/query/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/query-base/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/query-base/util/query/mapper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/query-base/util/query/mapper.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/query-base/util/predicate/index.js");
function mapper(query) {
    if (predicate_1.isOneRow(query)) {
        return query.selectClause[0].mapper;
    }
    else {
        return tm.orNull(query.selectClause[0].mapper);
    }
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/row/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/row/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RowUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/row/util/index.js");
exports.RowUtil = RowUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/row/util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/row/util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/row/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/row/util/query/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/row/util/query/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/row/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/row/util/query/mapper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/row/util/query/mapper.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
function mapper(table) {
    return column_map_1.ColumnMapUtil.mapper(table.columns);
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./schema-validation-error */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js"));
__export(__webpack_require__(/*! ./schema-validation-warning */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js"));
const SchemaValidationUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/schema-validation/util/index.js");
exports.SchemaValidationUtil = SchemaValidationUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SchemaValidationErrorType;
(function (SchemaValidationErrorType) {
    SchemaValidationErrorType["TABLE_ON_APPLICATION_ONLY"] = "TABLE_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["TABLE_ALIAS_MISMATCH"] = "TABLE_ALIAS_MISMATCH";
    SchemaValidationErrorType["PRIMARY_KEY_ON_APPLICATION_ONLY"] = "PRIMARY_KEY_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["PRIMARY_KEY_MISMATCH"] = "PRIMARY_KEY_MISMATCH";
    SchemaValidationErrorType["CANDIDATE_KEY_ON_APPLICATION_ONLY"] = "CANDIDATE_KEY_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY"] = "DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY";
    SchemaValidationErrorType["COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_ON_APPLICATION_ONLY"] = "COLUMN_ON_APPLICATION_ONLY";
    SchemaValidationErrorType["COLUMN_ALIAS_MISMATCH"] = "COLUMN_ALIAS_MISMATCH";
    SchemaValidationErrorType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_DATABASE_ONLY"] = "COLUMN_NULLABLE_ON_DATABASE_ONLY";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION"] = "COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION";
    SchemaValidationErrorType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    SchemaValidationErrorType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
})(SchemaValidationErrorType = exports.SchemaValidationErrorType || (exports.SchemaValidationErrorType = {}));
//# sourceMappingURL=schema-validation-error.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SchemaValidationWarningType;
(function (SchemaValidationWarningType) {
    SchemaValidationWarningType["TABLE_ON_DATABASE_ONLY"] = "TABLE_ON_DATABASE_ONLY";
    SchemaValidationWarningType["TABLE_HAS_NO_PRIMARY_KEY"] = "TABLE_HAS_NO_PRIMARY_KEY";
    SchemaValidationWarningType["PRIMARY_KEY_ON_DATABASE_ONLY"] = "PRIMARY_KEY_ON_DATABASE_ONLY";
    SchemaValidationWarningType["CANDIDATE_KEY_ON_DATABASE_ONLY"] = "CANDIDATE_KEY_ON_DATABASE_ONLY";
    SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE"] = "COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE";
    SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED"] = "COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["AUTO_INCREMENT_ON_DATABASE_ONLY"] = "AUTO_INCREMENT_ON_DATABASE_ONLY";
    SchemaValidationWarningType["AUTO_INCREMENT_MISMATCH_INSERT_DISABLED"] = "AUTO_INCREMENT_MISMATCH_INSERT_DISABLED";
    SchemaValidationWarningType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE";
    SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE";
    SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED";
})(SchemaValidationWarningType = exports.SchemaValidationWarningType || (exports.SchemaValidationWarningType = {}));
//# sourceMappingURL=schema-validation-warning.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/util/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/util/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/util/operation/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/util/operation/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./validate-column */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-column.js"));
__export(__webpack_require__(/*! ./validate-schema */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-schema.js"));
__export(__webpack_require__(/*! ./validate-table */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-column.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-column.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js");
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "./node_modules/@squill/squill/dist/sqlstring/index.js");
function validateColumn(applicationTable, applicationColumn, columnMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    /**
     * Sanity check...
     */
    if (applicationColumn.columnAlias != columnMeta.columnAlias) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ALIAS_MISMATCH,
            description: `Application column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)}, database column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)}`,
            tableAlias: applicationTable.alias,
            applicationColumnAlias: applicationColumn.columnAlias,
            databaseColumnAlias: columnMeta.columnAlias,
        });
        return result;
    }
    const applicationNullable = applicationTable.nullableColumns.includes(columnMeta.columnAlias);
    const applicationMutable = applicationTable.mutableColumns.includes(applicationColumn.columnAlias);
    /*const applicationAutoIncrement = (
        applicationTable.autoIncrement != undefined &&
        applicationTable.autoIncrement == applicationColumn.columnAlias
    );*/
    const applicationGenerated = applicationTable.generatedColumns.includes(applicationColumn.columnAlias);
    const applicationExplicitDefaultValue = applicationTable.explicitDefaultValueColumns.includes(applicationColumn.columnAlias);
    if (columnMeta.isNullable) {
        if (applicationNullable) {
            /**
             * OK
             */
        }
        else {
            /**
             * + Database is nullable.
             * + Application is **not** nullable.
             *
             * -----
             *
             * + Attempts to `SELECT` the `NULL` value will fail.
             * + Attempts to `INSERT` are fine.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression expecting non-`NULL` will fail.
             *
             */
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on database only; SELECTs will fail`,
                tableAlias: applicationTable.alias,
                columnAlias: applicationColumn.columnAlias,
            });
        }
    }
    else {
        if (applicationNullable) {
            /**
             * + Database is **not** nullable.
             * + Application is nullable.
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` the `NULL` value will fail.
             * + Attempts to `UPDATE` to the `NULL` value will fail.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression expecting nullable are fine.
             *
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs using NULL value will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else if (applicationMutable) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; UPDATEs using NULL value will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs and UPDATEs using NULL value will fail but both are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    if (columnMeta.generationExpression != undefined) {
        if (applicationGenerated) {
            /**
             * OK
             */
        }
        else {
            /**
             * + This column is generated on the database
             * + This column is **not** generated on the application
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` will fail because you cannot set values for generated columns.
             * + Attsmpts to `UPDATE` will fail because you cannot set values for generated columns.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else if (applicationMutable) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; UPDATEs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs and UPDATEs will fail but both are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
        }
    }
    else {
        if (applicationGenerated) {
            if (applicationTable.autoIncrement != undefined &&
                applicationTable.autoIncrement == applicationColumn.columnAlias) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} cannot be generated and auto-increment at the same time`,
                    tableAlias: applicationTable.alias,
                    applicationColumnAlias: applicationTable.autoIncrement,
                });
            }
            else {
                if (columnMeta.isNullable ||
                    columnMeta.isAutoIncrement ||
                    columnMeta.explicitDefaultValue != undefined) {
                    /**
                     * + This column has an implicit/explicit default/generated value on the database
                     *
                     * So, we can kind of pretend it's generated on application code, anyway.
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` won't set the value because we say it is generated.
                     * + Attempts to `UPDATE` won't set the value because we say it is generated.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will use database default value`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    /**
                     * We say it is generated on application code.
                     * But it has **no** default/generated value on the database.
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail because we cannot set the value on application code,
                     *   and there is no default/generated value on the database.
                     * + Attempts to `UPDATE` won't set the value because we say it is generated.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    if (applicationTable.insertEnabled) {
                        result.errors.push({
                            type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                    else {
                        result.warnings.push({
                            type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail but INSERTs are disabled`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                }
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    if (columnMeta.explicitDefaultValue != undefined) {
        if (applicationExplicitDefaultValue) {
            /**
             * OK
             */
        }
        else {
            /**
             * It has an explicit default value on the database.
             * But not on application code.
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` are fine; they just cannot use the default value.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on database only`,
                tableAlias: applicationTable.alias,
                columnAlias: applicationColumn.columnAlias,
                explicitDefaultValue: columnMeta.explicitDefaultValue,
            });
        }
    }
    else {
        if (applicationExplicitDefaultValue) {
            if (columnMeta.isNullable ||
                columnMeta.isAutoIncrement ||
                columnMeta.generationExpression != undefined) {
                /**
                 * It **does not** have an explicit default value on the database.
                 * But it does, on application code.
                 *
                 * However, it does have other default/generated values on the database...
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` are fine; they will just use the other default/generated values on the database.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will use database generated or NULL value`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                    isNullable: columnMeta.isNullable,
                    isAutoIncrement: columnMeta.isAutoIncrement,
                    generationExpression: columnMeta.generationExpression,
                    explicitDefaultValue: columnMeta.explicitDefaultValue,
                });
            }
            else {
                /**
                 * It **does not** have an explicit default value on the database.
                 * But it does, on application code.
                 *
                 * There are also no other default/generated values on the database...
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail; there is no default/generated value on the database to use.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail but INSERTs are disabled`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
            }
        }
        else {
            /**
             * OK
             */
        }
    }
    return result;
}
exports.validateColumn = validateColumn;
//# sourceMappingURL=validate-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-schema.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-schema.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js");
const validate_table_1 = __webpack_require__(/*! ./validate-table */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-table.js");
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "./node_modules/@squill/squill/dist/sqlstring/index.js");
function validateSchema(applicationTables, schemaMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    const tablesOnDatabaseOnly = schemaMeta.tables.filter(tableMeta => {
        const applicationTable = applicationTables.find(applicationTable => applicationTable.alias == tableMeta.tableAlias);
        return (applicationTable == undefined);
    });
    for (const tableMeta of tablesOnDatabaseOnly) {
        result.warnings.push({
            type: schema_validation_warning_1.SchemaValidationWarningType.TABLE_ON_DATABASE_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)} exists on database only`,
            databaseTableAlias: tableMeta.tableAlias,
        });
    }
    const tablesOnApplicationOnly = applicationTables.filter(applicationTable => {
        const tableMeta = schemaMeta.tables.find(tableMeta => applicationTable.alias == tableMeta.tableAlias);
        return (tableMeta == undefined);
    });
    for (const applicationTable of tablesOnApplicationOnly) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.TABLE_ON_APPLICATION_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} exists on application only; not found on schema ${sqlstring_1.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}`,
            applicationTableAlias: applicationTable.alias,
            databaseSchemaAlias: schemaMeta.schemaAlias,
        });
    }
    for (const applicationTable of applicationTables) {
        const tableMeta = schemaMeta.tables.find(tableMeta => tableMeta.tableAlias == applicationTable.alias);
        if (tableMeta == undefined) {
            continue;
        }
        const validateTableResult = validate_table_1.validateTable(applicationTable, tableMeta);
        result.errors.push(...validateTableResult.errors);
        result.warnings.push(...validateTableResult.warnings);
    }
    return result;
}
exports.validateSchema = validateSchema;
//# sourceMappingURL=validate-schema.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-table.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-table.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const schema_validation_error_1 = __webpack_require__(/*! ../../schema-validation-error */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-error.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const schema_validation_warning_1 = __webpack_require__(/*! ../../schema-validation-warning */ "./node_modules/@squill/squill/dist/schema-validation/schema-validation-warning.js");
const validate_column_1 = __webpack_require__(/*! ./validate-column */ "./node_modules/@squill/squill/dist/schema-validation/util/operation/validate-column.js");
const sqlstring_1 = __webpack_require__(/*! ../../../sqlstring */ "./node_modules/@squill/squill/dist/sqlstring/index.js");
function validateTable(applicationTable, tableMeta) {
    const result = {
        errors: [],
        warnings: [],
    };
    /**
     * Sanity check...
     */
    if (applicationTable.alias != tableMeta.tableAlias) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.TABLE_ALIAS_MISMATCH,
            description: `Application table is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}, database table is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}`,
            applicationTableAlias: applicationTable.alias,
            databaseTableAlias: tableMeta.tableAlias,
        });
        return result;
    }
    /**
     * Primary key check
     */
    if (tableMeta.primaryKey == undefined) {
        if (applicationTable.primaryKey == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.TABLE_HAS_NO_PRIMARY_KEY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY`,
                tableAlias: applicationTable.alias,
            });
        }
        else {
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.PRIMARY_KEY_ON_APPLICATION_ONLY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
                tableAlias: applicationTable.alias,
                primaryKey: [...applicationTable.primaryKey],
            });
        }
    }
    else {
        if (applicationTable.primaryKey == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.PRIMARY_KEY_ON_DATABASE_ONLY,
                description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
                tableAlias: applicationTable.alias,
                primaryKey: [...tableMeta.primaryKey.columnAliases],
            });
        }
        else {
            if (key_1.KeyUtil.isEqual(applicationTable.primaryKey, tableMeta.primaryKey.columnAliases)) {
                //OK, no problems here
            }
            else {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.PRIMARY_KEY_MISMATCH,
                    description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application, PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database`,
                    tableAlias: applicationTable.alias,
                    applicationPrimaryKey: [...applicationTable.primaryKey],
                    databasePrimaryKey: [...tableMeta.primaryKey.columnAliases],
                });
            }
        }
    }
    /**
     * Candidate keys check
     */
    const candidateKeysOnDatabaseOnly = tableMeta.candidateKeys.filter(candidateKeyMeta => {
        if (applicationTable.primaryKey != undefined &&
            key_1.KeyUtil.isEqual(applicationTable.primaryKey, candidateKeyMeta.columnAliases)) {
            return false;
        }
        const applicationCandidateKey = applicationTable.candidateKeys.find(applicationCandidateKey => {
            return key_1.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
        });
        return (applicationCandidateKey == undefined);
    });
    for (const candidateKey of candidateKeysOnDatabaseOnly) {
        result.warnings.push({
            type: schema_validation_warning_1.SchemaValidationWarningType.CANDIDATE_KEY_ON_DATABASE_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.columnAliases.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
            tableAlias: applicationTable.alias,
            databaseCandidateKey: [...candidateKey.columnAliases],
        });
    }
    const candidateKeysOnApplicationOnly = applicationTable.candidateKeys.filter(applicationCandidateKey => {
        if (tableMeta.primaryKey != undefined &&
            key_1.KeyUtil.isEqual(tableMeta.primaryKey.columnAliases, applicationCandidateKey)) {
            return false;
        }
        const candidateKeyMeta = tableMeta.candidateKeys.find(candidateKeyMeta => {
            return key_1.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
        });
        return (candidateKeyMeta == undefined);
    });
    for (const candidateKey of candidateKeysOnApplicationOnly) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.CANDIDATE_KEY_ON_APPLICATION_ONLY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.map(sqlstring_1.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
            tableAlias: applicationTable.alias,
            applicationCandidateKey: [...candidateKey],
        });
    }
    /**
     * Tables should really have a candidate key...
     */
    if (tableMeta.primaryKey == undefined && tableMeta.candidateKeys.length == 0) {
        result.errors.push({
            type: schema_validation_error_1.SchemaValidationErrorType.DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY,
            description: `Table ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY or CANDIDATE KEY on database`,
            tableAlias: applicationTable.alias,
        });
    }
    /**
     * There should only be zero or one auto-increment column on tables.
     * We validate them here.
     */
    const autoIncrementColumnMeta = tableMeta.columns.find(columnMeta => columnMeta.isAutoIncrement);
    if (autoIncrementColumnMeta == undefined) {
        if (applicationTable.autoIncrement == undefined) {
            /**
             * OK!
             */
        }
        else {
            /**
             * + The database has **no** auto-increment column.
             * + The application has an auto-increment column.
             *
             * -----
             *
             * + Attempts to `SELECT` are fine.
             * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
             * + Attempts to `UPDATE` are fine.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression are fine.
             */
            if (applicationTable.insertEnabled) {
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationTable.autoIncrement,
                });
            }
            else {
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail but INSERTs are disabled`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationTable.autoIncrement,
                });
            }
        }
    }
    else {
        if (applicationTable.autoIncrement == undefined) {
            result.warnings.push({
                type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_ON_DATABASE_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} is auto-increment on database only`,
                tableAlias: tableMeta.tableAlias,
                columnAlias: autoIncrementColumnMeta.columnAlias,
            });
        }
        else {
            if (autoIncrementColumnMeta.columnAlias == applicationTable.autoIncrement) {
                /**
                 * OK!
                 */
            }
            else {
                /**
                 * The database and application disagree what the auto-increment column is.
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                        applicationColumnAlias: applicationTable.autoIncrement,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.AUTO_INCREMENT_MISMATCH_INSERT_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail but INSERTs are disabled`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                        applicationColumnAlias: applicationTable.autoIncrement,
                    });
                }
            }
        }
    }
    /**
     * Validate columns
     */
    for (const columnMeta of tableMeta.columns) {
        const applicationColumn = applicationTable.columns[columnMeta.columnAlias];
        if (applicationColumn == undefined) {
            if (applicationTable.insertEnabled) {
                if (
                /**
                 * There's an implicit default/generated value
                 */
                columnMeta.isNullable ||
                    columnMeta.isAutoIncrement ||
                    /**
                     * There's an explicit default/generated value
                     */
                    columnMeta.generationExpression != undefined ||
                    columnMeta.explicitDefaultValue != undefined) {
                    /**
                     * + Database has column
                     * + Application **does not** have column
                     * + Database column has default/generated value
                     * + `INSERT` is enabled
                     *
                     * -----
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` are fine; will just use default/generated value on database.
                     * + Attempts to `UPDATE` will never happen; does not exist on application.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression will never happen; does not exist on application.
                     *
                     */
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; but has a default or generated value`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: columnMeta.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                        insertEnabled: applicationTable.insertEnabled,
                    });
                }
                else {
                    /**
                     * + Database has column
                     * + Application **does not** have column
                     * + Database column **does not** have default/generated value
                     * + `INSERT` is enabled
                     *
                     * -----
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail; does not exist on application, and no default/generated value on database.
                     * + Attempts to `UPDATE` will never happen; does not exist on application.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression will never happen; does not exist on application.
                     *
                     */
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs will fail`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: columnMeta.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                        insertEnabled: applicationTable.insertEnabled,
                    });
                }
            }
            else {
                /**
                 * + Database has column
                 * + Application **does not** have column
                 * + `INSERT` is disabled
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will never happen; it is disabled.
                 * + Attempts to `UPDATE` will never happen; does not exist on application.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression will never happen; does not exist on application.
                 *
                 */
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs may fail but INSERTs are disabled`,
                    tableAlias: tableMeta.tableAlias,
                    databaseColumnAlias: columnMeta.columnAlias,
                    isNullable: columnMeta.isNullable,
                    isAutoIncrement: columnMeta.isAutoIncrement,
                    generationExpression: columnMeta.generationExpression,
                    explicitDefaultValue: columnMeta.explicitDefaultValue,
                    insertEnabled: applicationTable.insertEnabled,
                });
            }
        }
        else {
            const validateColumnResult = validate_column_1.validateColumn(applicationTable, applicationColumn, columnMeta);
            result.errors.push(...validateColumnResult.errors);
            result.warnings.push(...validateColumnResult.warnings);
        }
    }
    for (const columnAlias of Object.keys(applicationTable.columns)) {
        const applicationColumn = applicationTable.columns[columnAlias];
        const columnMeta = tableMeta.columns.find(columnMeta => columnMeta.columnAlias == columnAlias);
        if (columnMeta == undefined) {
            /**
             *
             * + Attempts to `SELECT` will fail.
             * + Attempts to `INSERT` will fail.
             * + Attempts to `UPDATE` will fail.
             * + Attempts to `DELETE` are fine.
             * + Attempts to use as expression will fail.
             *
             */
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ON_APPLICATION_ONLY,
                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} exists on application only`,
                tableAlias: applicationTable.alias,
                applicationColumnAlias: applicationColumn.columnAlias,
            });
        }
    }
    return result;
}
exports.validateTable = validateTable;
//# sourceMappingURL=validate-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SelectClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/select-clause/util/index.js");
exports.SelectClauseUtil = SelectClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/constructor/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/constructor/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./value-from-built-in-expr */ "./node_modules/@squill/squill/dist/select-clause/util/constructor/value-from-built-in-expr.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/constructor/value-from-built-in-expr.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/constructor/value-from-built-in-expr.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
exports.SELECT_VALUE_ALIAS = "value";
function valueFromBuiltInExpr(builtInExpr) {
    if (column_1.ColumnUtil.isColumn(builtInExpr) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
        return [builtInExpr];
    }
    else {
        return [
            expr_1.ExprUtil.as(expr_1.ExprUtil.fromBuiltInExpr(builtInExpr), exports.SELECT_VALUE_ALIAS)
        ];
    }
}
exports.valueFromBuiltInExpr = valueFromBuiltInExpr;
//# sourceMappingURL=value-from-built-in-expr.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/select-clause/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/select-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./left-compound */ "./node_modules/@squill/squill/dist/select-clause/util/operation/left-compound.js"));
__export(__webpack_require__(/*! ./select-value */ "./node_modules/@squill/squill/dist/select-clause/util/operation/select-value.js"));
__export(__webpack_require__(/*! ./select */ "./node_modules/@squill/squill/dist/select-clause/util/operation/select.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/operation/left-compound.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/operation/left-compound.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
/**
 * Assumes `A` is shorter than, or the same length as `B`
 */
function leftCompound(a, b) {
    const result = [];
    for (let i = 0; i < a.length; ++i) {
        const itemA = a[i];
        const itemB = b[i];
        if (column_1.ColumnUtil.isColumn(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                result.push(column_1.ColumnUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
            }
            else {
                throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
            }
        }
        else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemA)) {
            if (column_1.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                result.push(expr_select_item_1.ExprSelectItemUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
            }
            else {
                throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
            }
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(itemA)) {
            if (column_map_1.ColumnMapUtil.isColumnMap(itemB)) {
                result.push(column_map_1.ColumnMapUtil.compound(itemA, itemB));
            }
            else {
                throw new Error(`Expected index ${i} to be ColumnMap`);
            }
        }
        else if (column_ref_1.ColumnRefUtil.isColumnRef(itemA)) {
            if (column_ref_1.ColumnRefUtil.isColumnRef(itemB)) {
                result.push(column_ref_1.ColumnRefUtil.compound(itemA, itemB));
            }
            else {
                throw new Error(`Expected index ${i} to be ColumnMap`);
            }
        }
        else {
            throw new Error(`Unknown SELECT item at index ${i}`);
        }
    }
    return result;
}
exports.leftCompound = leftCompound;
//# sourceMappingURL=left-compound.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/operation/select-value.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/operation/select-value.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_1 = __webpack_require__(/*! ./select */ "./node_modules/@squill/squill/dist/select-clause/util/operation/select.js");
const constructor_1 = __webpack_require__(/*! ../constructor */ "./node_modules/@squill/squill/dist/select-clause/util/constructor/index.js");
/**
 * Convenience function for,
 * ```ts
 *  myQuery
 *      .select(() => [myExpr.as("value")])
 * ```
 *
 * Intended usage,
 * ```ts
 *  myQuery
 *      .selectValue(() => myExpr)
 * ```
 */
function selectValue(fromClause, groupByClause, selectClause, selectValueDelegate) {
    return select_1.select(fromClause, groupByClause, selectClause, columns => constructor_1.valueFromBuiltInExpr(selectValueDelegate(columns)));
}
exports.selectValue = selectValue;
//# sourceMappingURL=select-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/operation/select.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/operation/select.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/index.js");
/**
 * Returns the MySQL equivalent of `...selectClause, ...selectClauseDelegate(fromClause)`
 *
 * @param fromClause
 * @param selectClause
 * @param selectDelegate
 *
 * @todo This should only be allowed **BEFORE** the `COMPOUND QUERY` clause.
 * If we `SELECT` after the `COMPOUND QUERY` clause, it'll change the number of columns, leading to bugs.
 */
function select(fromClause, groupByClause, selectClause, selectDelegate) {
    const columns = query_1.allowedColumnRef(fromClause);
    const selects = selectDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    predicate_1.assertValidColumnIdentifier(selectClause, selects);
    if (groupByClause == undefined) {
        if (selects.some(selectItem => expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate) ||
            (selectClause != undefined &&
                selectClause.some(selectItem => expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate))) {
            predicate_1.assertValidUsedRef_Aggregate(fromClause, selects);
            predicate_1.assertValidUsedRef_NonAggregate(fromClause, [], selects);
        }
        else {
            predicate_1.assertValidUsedRef(fromClause, selects);
        }
    }
    else {
        predicate_1.assertValidUsedRef_Aggregate(fromClause, selects);
        predicate_1.assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects);
    }
    return (selectClause == undefined ?
        selects :
        [...selectClause, ...selects]);
}
exports.select = select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-column-identifier.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-column-identifier.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
function assertValidColumnIdentifier(selectClause, selects) {
    const selectsIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selects);
    column_identifier_1.ColumnIdentifierArrayUtil.assertNoDuplicate(selectsIdentifiers);
    if (selectClause != undefined) {
        const selectClauseIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selectClause);
        column_identifier_1.ColumnIdentifierArrayUtil.assertDisjoint(selectClauseIdentifiers, selectsIdentifiers);
    }
}
exports.assertValidColumnIdentifier = assertValidColumnIdentifier;
//# sourceMappingURL=assert-valid-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js");
function assertValidUsedRef_Aggregate(fromClause, selects) {
    const columns = query_1.allowedColumnRef(fromClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            if (selectItem.isAggregate) {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
            }
        }
    }
}
exports.assertValidUsedRef_Aggregate = assertValidUsedRef_Aggregate;
//# sourceMappingURL=assert-valid-used-ref-aggregate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects) {
    const columns = query_1.allowedNonAggregateColumnRef(fromClause, groupByClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            if (!selectItem.isAggregate) {
                used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
            }
        }
        else if (column_1.ColumnUtil.isColumn(selectItem)) {
            column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnMap(selectItem));
        }
        else {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnRef(selectItem));
        }
    }
}
exports.assertValidUsedRef_NonAggregate = assertValidUsedRef_NonAggregate;
//# sourceMappingURL=assert-valid-used-ref-non-aggregate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js");
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function assertValidUsedRef(fromClause, selects) {
    const columns = query_1.allowedColumnRef(fromClause);
    for (const selectItem of selects) {
        if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
        }
        else if (column_1.ColumnUtil.isColumn(selectItem)) {
            column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
        }
        else if (column_map_1.ColumnMapUtil.isColumnMap(selectItem)) {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnMap(selectItem));
        }
        else {
            used_ref_1.UsedRefUtil.assertAllowed({ columns }, used_ref_1.UsedRefUtil.fromColumnRef(selectItem));
        }
    }
}
exports.assertValidUsedRef = assertValidUsedRef;
//# sourceMappingURL=assert-valid-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/predicate/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/predicate/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-valid-column-identifier */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-column-identifier.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref-aggregate */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-aggregate.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref-non-aggregate */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref-non-aggregate.js"));
__export(__webpack_require__(/*! ./assert-valid-used-ref */ "./node_modules/@squill/squill/dist/select-clause/util/predicate/assert-valid-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
function allowedNonAggregateColumnRef(fromClause, groupByClause) {
    const outer = column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
    const inner = column_ref_1.ColumnRefUtil.extractColumnIdentifiers(column_ref_1.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
        [] :
        fromClause.currentJoins), groupByClause);
    return column_ref_1.ColumnRefUtil.intersect(outer, inner);
}
exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
function allowedNonAggregateUsedRef(fromClause, groupByClause) {
    return used_ref_1.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
}
exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
//# sourceMappingURL=allowed-non-aggregate-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/query/allowed-used-ref.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/query/allowed-used-ref.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/query/duplicate-column-alias.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/query/duplicate-column-alias.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_item_1 = __webpack_require__(/*! ../../../select-item */ "./node_modules/@squill/squill/dist/select-item/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
function duplicateColumnAlias(selectClause) {
    const duplicateTracker = {};
    const result = [];
    for (const item of selectClause) {
        for (const columnAlias of select_item_1.SelectItemUtil.columnAlias(item)) {
            const isDuplicate = duplicateTracker[columnAlias];
            if (isDuplicate === undefined) {
                /**
                 * We had never encountered it, and now we have.
                 * But it isn't a duplicate.
                 */
                duplicateTracker[columnAlias] = false;
            }
            else if (!isDuplicate) {
                /**
                 * We had encountered it when it wasn't a duplicate.
                 * Now, it is a duplicate.
                 */
                duplicateTracker[columnAlias] = true;
                result.push(columnAlias);
            }
        }
        if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
            for (const columnAlias of column_ref_1.ColumnRefUtil.duplicateColumnAlias(item)) {
                const isDuplicate = duplicateTracker[columnAlias];
                if (isDuplicate === undefined) {
                    /**
                     * We had never encountered it, and now we have.
                     * But it isn't a duplicate.
                     */
                    duplicateTracker[columnAlias] = false;
                }
                else if (!isDuplicate) {
                    /**
                     * We had encountered it when it wasn't a duplicate.
                     * Now, it is a duplicate.
                     */
                    duplicateTracker[columnAlias] = true;
                    result.push(columnAlias);
                }
            }
        }
    }
    return result;
}
exports.duplicateColumnAlias = duplicateColumnAlias;
//# sourceMappingURL=duplicate-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-clause/util/query/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-clause/util/query/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-non-aggregate-used-ref */ "./node_modules/@squill/squill/dist/select-clause/util/query/allowed-non-aggregate-used-ref.js"));
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/select-clause/util/query/allowed-used-ref.js"));
__export(__webpack_require__(/*! ./duplicate-column-alias */ "./node_modules/@squill/squill/dist/select-clause/util/query/duplicate-column-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SelectItemUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/select-item/util/index.js");
exports.SelectItemUtil = SelectItemUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/util/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/util/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/select-item/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/select-item/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/util/predicate/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/util/predicate/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-single-value-select-item */ "./node_modules/@squill/squill/dist/select-item/util/predicate/is-single-value-select-item.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/util/predicate/is-single-value-select-item.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/util/predicate/is-single-value-select-item.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
function isSingleValueSelectItem(x) {
    return (column_1.ColumnUtil.isColumn(x) ||
        expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(x));
}
exports.isSingleValueSelectItem = isSingleValueSelectItem;
//# sourceMappingURL=is-single-value-select-item.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/util/query/column-alias.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/util/query/column-alias.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const expr_select_item_1 = __webpack_require__(/*! ../../../expr-select-item */ "./node_modules/@squill/squill/dist/expr-select-item/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
function columnAlias(item) {
    if (column_1.ColumnUtil.isColumn(item)) {
        return [item.columnAlias];
    }
    else if (expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(item)) {
        return [item.alias];
    }
    else if (column_map_1.ColumnMapUtil.isColumnMap(item)) {
        return column_map_1.ColumnMapUtil.columnAlias(item);
    }
    else if (column_ref_1.ColumnRefUtil.isColumnRef(item)) {
        return column_ref_1.ColumnRefUtil.columnAlias(item);
    }
    else {
        throw new Error("Unknown select item");
    }
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/select-item/util/query/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/select-item/util/query/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/select-item/util/query/column-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sort-direction/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sort-direction/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/sort-direction.js"));
const SortDirectionUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/sort-direction/util/index.js");
exports.SortDirectionUtil = SortDirectionUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sort-direction/sort-direction.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sort-direction/sort-direction.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The direction to sort the result set
 */
var SortDirection;
(function (SortDirection) {
    /**
     * Sorts the result set in ascending order
     */
    SortDirection.ASC = "ASC";
    /**
     * Sorts the result set in descending order
     */
    SortDirection.DESC = "DESC";
})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
;
//# sourceMappingURL=sort-direction.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sort-direction/util/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sort-direction/util/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/sort-direction/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sort-direction/util/predicate/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sort-direction/util/predicate/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/util/predicate/is-sort-direction.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sort-direction/util/predicate/is-sort-direction.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sort-direction/util/predicate/is-sort-direction.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const sort_direction_1 = __webpack_require__(/*! ../../sort-direction */ "./node_modules/@squill/squill/dist/sort-direction/sort-direction.js");
function isSortDirection(mixed) {
    return (mixed == sort_direction_1.SortDirection.ASC ||
        mixed == sort_direction_1.SortDirection.DESC);
}
exports.isSortDirection = isSortDirection;
//# sourceMappingURL=is-sort-direction.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/sqlstring/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/sqlstring/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const ID_BACKTICK_GLOBAL_REGEXP = /`/g;
const ID_DOUBLE_QUOTE_GLOBAL_REGEXP = /"/g;
const CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
const CHARS_ESCAPE_MAP = {
    "\0": "\\0",
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\x1a": "\\Z",
    "\"": "\\\"",
    "\'": "\\\'",
    "\\": "\\\\",
};
/**
 * Escapes a MySQL identifier.
 *
 * For example,
 * + Database name
 * + Table name
 * + Column name
 * + Alias
 *
 * -----
 *
 * ```ts
 * escapeIdentifier("x") == "`x`"
 * escapeIdentifier("x.y") == "`x.y`"
 * escapeIdentifier("x`x.y") == "`x``x.y`"
 * ```
 *
 * @param rawIdentifier - The identifier to escape
 *
 * @todo Refactor this.
 * + MySQL uses backticks.
 * + PostgreSQL uses double quotes. (Following the same rules as MySQL)
 * + MySQL can be made to use double quotes by enabling `ANSI_QUOTES` but this is disabled by default
 *
 * Each database adapter will need to create their own `escaoeIdentifier` function
 * and pass it around.
 *
 * A pain in the butt. Necessary, however.
 *
 * -----
 *
 * Another option would be forcing the MySQL adapter to always run a SQL query
 * to enable `ANSI_QUOTES`...
 *
 * Definitely less of a hassle there.
 *
 * @deprecated Use the `Identifier` AST Node instead
 */
function escapeIdentifierWithBackticks(rawIdentifier) {
    return ("`" +
        String(rawIdentifier).replace(ID_BACKTICK_GLOBAL_REGEXP, "``") +
        "`");
}
exports.escapeIdentifierWithBackticks = escapeIdentifierWithBackticks;
function escapeIdentifierWithDoubleQuotes(rawIdentifier) {
    return ("\"" +
        String(rawIdentifier).replace(ID_DOUBLE_QUOTE_GLOBAL_REGEXP, "\"\"") +
        "\"");
}
exports.escapeIdentifierWithDoubleQuotes = escapeIdentifierWithDoubleQuotes;
function tryUnescapeIdentifierWithDoubleQuotes(rawIdentifier) {
    rawIdentifier = rawIdentifier.trim();
    if (rawIdentifier.startsWith(`"`) && rawIdentifier.endsWith(`"`)) {
        rawIdentifier = rawIdentifier.substr(1, rawIdentifier.length - 2);
        return rawIdentifier.replace(/""/g, `"`);
    }
    else {
        return rawIdentifier;
    }
}
exports.tryUnescapeIdentifierWithDoubleQuotes = tryUnescapeIdentifierWithDoubleQuotes;
/**
 * Escapes a MySQL value.
 *
 * Does not handle `Date` as timezones are a pain.
 *
 * @param rawValue - The value to escape
 */
function escapeValue(rawValue) {
    if (rawValue === null) {
        return "NULL";
    }
    if (tm.TypeUtil.isBigInt(rawValue)) {
        /**
         * Max `BIGINT SIGNED` value: `SELECT 9223372036854775807+9223372036854775807`
         *
         * + MySQL      : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
         * + PostgreSQL : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
         * + SQLite     : `SELECT 9223372036854775807+9223372036854775807`; `18446744073709552000` (incorrect value)
         * + Expected   : `18446744073709551614`
         *
         * -----
         *
         * + MySQL      : `SELECT 18446744073709551615+18446744073709551615`; Error, out of range of bigint unsigned value
         * + PostgreSQL : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103230` (DECIMAL, not bigint unsigned)
         * + SQLite     : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103000` (incorrect value)
         * + Expected   : `36893488147419103230`
         *
         * PostgreSQL and SQLite do not support `BIGINT UNSIGNED`.
         * Selecting an integer larger than bigint signed in PostgreSQL will give you a `DECIMAL` value.
         *
         * @todo Fix this
         */
        return String(rawValue);
    }
    switch (typeof rawValue) {
        case "boolean": {
            return rawValue ?
                "TRUE" :
                "FALSE";
        }
        case "number": {
            if (!isFinite(rawValue)) {
                return "NULL";
            }
            const result = String(rawValue);
            if (result.indexOf("e") < 0) {
                /**
                 * We add `e0` at the end to signal to the DBMS that this is a double value.
                 * Not a `DECIMAL` value.
                 */
                /**
                 * + MySQL      : `SELECT 1e300`; `1e300`
                 * + PostgreSQL : `SELECT 1e300`; `1000000000...` (total 300 zeroes) (DECIMAL)
                 * + SQLite     : `SELECT 1e300`; `1e300`
                 *
                 * -----
                 *
                 * PostgreSQL:
                 * ```sql
                 *  SELECT
                 *      pg_typeof(1e19), -- numeric
                 *      pg_typeof(1e1),  -- numeric
                 *      pg_typeof(10)    -- integer
                 * ```
                 *
                 * SQLite:
                 * ```sql
                 *  SELECT
                 *      typeof(1e19), -- real
                 *      typeof(1e1),  -- real
                 *      typeof(10)    -- integer
                 * ```
                 */
                return result + "e0";
            }
            else {
                return result;
            }
        }
        case "object": {
            if (rawValue instanceof Uint8Array) {
                return uint8ArrayToString(rawValue);
            }
            else {
                throw new Error(`Don't know how to escape non-Uint8Array object`);
            }
        }
        default: {
            throw new Error(`Don't know how to escape ${typeof rawValue}`);
        }
    }
}
exports.escapeValue = escapeValue;
;
//https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
function buf2hex(buffer) {
    return Array.prototype.map
        .call(new Uint8Array(buffer), 
    //Should always return a string of length 2
    x => ("0" + x.toString(16)).slice(-2))
        .join("");
}
function uint8ArrayToString(buffer) {
    return "X" + cStyleEscapeString(buf2hex(buffer));
}
;
/**
 * Only MySQL supports C-style escapes (using the backslash character).
 */
function cStyleEscapeString(rawString) {
    let result = "";
    let chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    let match = CHARS_GLOBAL_REGEXP.exec(rawString);
    while (match != undefined) {
        const escapedChar = CHARS_ESCAPE_MAP[match[0]];
        if (escapedChar == undefined) {
            throw new Error(`Unknown escapable character ${match[0]}`);
        }
        result += rawString.slice(chunkIndex, match.index) + escapedChar;
        chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
        match = CHARS_GLOBAL_REGEXP.exec(rawString);
    }
    if (chunkIndex === 0) {
        //Nothing was escaped
        return "'" + rawString + "'";
    }
    if (chunkIndex < rawString.length) {
        return "'" + result + rawString.slice(chunkIndex) + "'";
    }
    return "'" + result + "'";
}
exports.cStyleEscapeString = cStyleEscapeString;
/**
 * PostgreSQL and SQLite use Pascal-style escapes
 */
function pascalStyleEscapeString(rawString) {
    const result = rawString.replace(/\'/g, `''`);
    return "'" + result + "'";
}
exports.pascalStyleEscapeString = pascalStyleEscapeString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/string-util/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/string-util/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./zero-pad */ "./node_modules/@squill/squill/dist/string-util/zero-pad.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/string-util/zero-pad.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/string-util/zero-pad.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
    zeroPad(1, 4)     === "0001"
    zeroPad(34, 4)    === "0034"
    zeroPad(678, 4)   === "0678"
    zeroPad(1337, 4)  === "1337"
    zeroPad(92678, 4) === "92678"
*/
function zeroPad(num, length) {
    const str = num.toString();
    if (str.length < length) {
        return "0".repeat(length - str.length) + str;
    }
    else {
        return str;
    }
}
exports.zeroPad = zeroPad;
function trailingZeroPad(num, length) {
    const str = num.toString();
    if (str.length < length) {
        return str + "0".repeat(length - str.length);
    }
    else {
        return str;
    }
}
exports.trailingZeroPad = trailingZeroPad;
//# sourceMappingURL=zero-pad.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/super-key/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/super-key/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SuperKeyUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/super-key/util/index.js");
exports.SuperKeyUtil = SuperKeyUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/super-key/util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/super-key/util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/super-key/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/super-key/util/query/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/super-key/util/query/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./mapper */ "./node_modules/@squill/squill/dist/super-key/util/query/mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/super-key/util/query/mapper.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/super-key/util/query/mapper.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function mapper(table) {
    return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
        /**
         * This usage of `tm.deepMerge()` is safe.
         * This is not true, in general.
         *
         * The two objects we'll be deep merging do not share any
         * properties.
         */
        return tm.deepMerge(column_map_1.ColumnMapUtil.mapper(type_util_1.pickOwnEnumerable(table.columns, candidateKey)), column_map_1.ColumnMapUtil.partialMapper(type_util_1.omitOwnEnumerable(table.columns, candidateKey)));
    }));
}
exports.mapper = mapper;
//# sourceMappingURL=mapper.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table-where/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table-where/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-where */ "./node_modules/@squill/squill/dist/table-where/table-where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table-where/table-where.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table-where/table-where.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = __webpack_require__(/*! ../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const table_1 = __webpack_require__(/*! ../table */ "./node_modules/@squill/squill/dist/table/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
/**
 * @todo Implement something like `TableWhereOrderBy`?
 *
 * `.fetchAll()` is not provided here
 * because "proper" usage would minimally require,
 * + `ORDER BY` clause - For deterministic ordering
 * + `LIMIT` clause - To prevent accidental OOMs
 *
 * `.paginate()`, `.emulatedCursor()` are not provided here
 * because "proper" usage of them would minimally require,
 * + `ORDER BY` clause - For deterministic ordering
 *
 */
/**
 * @todo Better name
 * This is basically a `table` + `WHERE` clause.
 */
class TableWhere {
    constructor(table, whereDelegate) {
        this.table = table;
        this.whereDelegate = whereDelegate;
    }
    where(whereDelegate) {
        return new TableWhere(this.table, (columns) => {
            return ExprLib.and(this.whereDelegate(columns), whereDelegate(columns));
        });
    }
    assertExists(connection) {
        return table_1.TableUtil.assertExists(this.table, connection, this.whereDelegate);
    }
    exists(connection) {
        return table_1.TableUtil.exists(this.table, connection, this.whereDelegate);
    }
    fetchOne(connection, selectDelegate) {
        return table_1.TableUtil.__fetchOneHelper(this.table, connection, this.whereDelegate, selectDelegate);
    }
    fetchValue(connection, selectValueDelegate) {
        return table_1.TableUtil.fetchValue(this.table, connection, this.whereDelegate, selectValueDelegate);
    }
    delete(connection) {
        return execution_1.ExecutionUtil.delete(this.table, connection, this.whereDelegate);
    }
    deleteOne(connection) {
        return execution_1.ExecutionUtil.deleteOne(this.table, connection, this.whereDelegate);
    }
    deleteZeroOrOne(connection) {
        return execution_1.ExecutionUtil.deleteZeroOrOne(this.table, connection, this.whereDelegate);
    }
    update(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.update(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    updateOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    updateZeroOrOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    /**
     * The `table` must have at least one `candidateKey` to use this method.
     *
     * Internally,
     * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
     * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
     *    (if the candidate key will not be updated, this step is skipped)
     * 3. Run the `UPDATE` statement.
     * 4. Fetch the row using the new candidate key.
     *
     * This algorithm will probably fail if you have triggers that modify the candidate key
     * `ON UPDATE`.
     */
    updateAndFetchOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateAndFetchOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
    /**
     * The `table` must have at least one `candidateKey` to use this method.
     *
     * Internally,
     * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
     * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
     *    (if the candidate key will not be updated, this step is skipped)
     * 3. Run the `UPDATE` statement.
     * 4. Fetch the row using the new candidate key (if any were found during the `UPDATE`)
     *
     * This algorithm will probably fail if you have triggers that modify the candidate key
     * `ON UPDATE`.
     */
    updateAndFetchZeroOrOne(connection, assignmentMapDelegate) {
        return execution_1.ExecutionUtil.updateAndFetchZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
    }
}
exports.TableWhere = TableWhere;
//# sourceMappingURL=table-where.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/index.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js"));
const TableUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/table/util/index.js");
exports.TableUtil = TableUtil;
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/table/util/index.js");
exports.table = util_1.fromTableAlias;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/table-impl.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/table-impl.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TableUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/table/util/index.js");
const execution_1 = __webpack_require__(/*! ../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
const ExprLib = __webpack_require__(/*! ../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const table_where_1 = __webpack_require__(/*! ../table-where */ "./node_modules/@squill/squill/dist/table-where/index.js");
class Table {
    /**
     * You should never need to explicitly instantiate a `Table`.
     * Use `table()` instead.
     *
     * @param data
     * @param unaliasedAst
     */
    constructor(data, unaliasedAst) {
        this.isLateral = data.isLateral;
        this.alias = data.alias;
        this.columns = data.columns;
        this.usedRef = data.usedRef;
        this.unaliasedAst = unaliasedAst;
        this.insertEnabled = data.insertEnabled;
        this.deleteEnabled = data.deleteEnabled;
        this.autoIncrement = data.autoIncrement;
        this.id = data.id;
        this.primaryKey = data.primaryKey;
        this.candidateKeys = data.candidateKeys;
        this.generatedColumns = data.generatedColumns;
        this.nullableColumns = data.nullableColumns;
        this.explicitDefaultValueColumns = data.explicitDefaultValueColumns;
        this.mutableColumns = data.mutableColumns;
        this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
    }
    /**
     * Makes all non-generated columns mutable.
     *
     * + Mutable columns may be modified with `UPDATE` statements using this library.
     * + Immutable columns may not be modified with this library
     *   (but could still be modified outside of this library)
     */
    addAllMutable() {
        return TableUtil.addAllMutable(this);
    }
    /**
     * Adds a candidate key to the table.
     *
     * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
     *
     * + A table may have zero-to-many candidate keys. (recommended to have at least one)
     * + A candidate key cannot be a subset of other candidate keys.
     * + A candidate key cannot be a superset of other candidate keys.
     * + A candidate key can intersect other candidate keys.
     * + A candidate key can be disjoint from other candidate keys.
     */
    addCandidateKey(delegate) {
        return TableUtil.addCandidateKey(this, delegate);
    }
    addColumns(rawColumns) {
        return TableUtil.addColumns(this, rawColumns);
    }
    /**
     * Tells the library that these columns have explicit `DEFAULT` values.
     *
     * An example of an "explicit" default value,
     * ```sql
     * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
     * ```
     *
     * + Columns with server default values are optional with `INSERT` statements.
     * + Generated columns have implicit default values.
     * + Nullable columns have implicit default values.
     * + `AUTO_INCREMENT` columns have implicit default values
     */
    addExplicitDefaultValue(delegate) {
        return TableUtil.addExplicitDefaultValue(this, delegate);
    }
    /**
     * Adds a `GENERATED` column to the table.
     *
     * + Setting generated column values will not be allowed with `INSERT` statements.
     * + Updating generated column values will also not be allowed with `UPDATE` statements.
     */
    addGenerated(delegate) {
        return TableUtil.addGenerated(this, delegate);
    }
    /**
     * Lets these columns be updated through this library.
     */
    addMutable(delegate) {
        return TableUtil.addMutable(this, delegate);
    }
    /**
     * Aliases a table reference in a query.
     *
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable AS aliasedTable
     * ```
     */
    as(newTableAlias) {
        return TableUtil.as(this, newTableAlias);
    }
    /**
     * Prevents rows of this table from being deleted through this library.
     *
     * Good for look-up tables, or append-only tables.
     */
    disableDelete() {
        return TableUtil.disableDelete(this);
    }
    /**
     * Prevents rows from being inserted through this library.
     *
     * Good for look-up tables.
     */
    disableInsert() {
        return TableUtil.disableInsert(this);
    }
    /**
     * The opposite of `disableInsert()`.
     * You really shouldn't need to use this as tables allow insert by default.
     */
    enableInsert() {
        return TableUtil.enableInsert(this);
    }
    /**
     * Makes all columns immutable.
     */
    removeAllMutable() {
        return TableUtil.removeAllMutable(this);
    }
    /**
     * Removes columns from the set of columns with explicit `DEFAULT` values
     *
     */
    removeExplicitDefaultValue(delegate) {
        return TableUtil.removeExplicitDefaultValue(this, delegate);
    }
    /**
     * Removes columns from the set of `GENERATED` columns.
     *
     */
    removeGenerated(delegate) {
        return TableUtil.removeGenerated(this, delegate);
    }
    /**
     * Removes columns from the set of mutable columns.
     *
     * You will not be able to update them through this library.
     *
     */
    removeMutable(delegate) {
        return TableUtil.removeMutable(this, delegate);
    }
    /**
     * Designates one column as the `AUTO_INCREMENT` column.
     *
     * -----
     *
     * + `AUTO_INCREMENT` columns cannot be nullable
     * + `AUTO_INCREMENT` columns must be a candidate key
     * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
     * + The `number|string|bigint` requirement is only a compile-time constraint
     */
    setAutoIncrement(delegate) {
        return TableUtil.setAutoIncrement(this, delegate);
    }
    enableExplicitAutoIncrementValue() {
        return TableUtil.enableExplicitAutoIncrementValue(this);
    }
    /**
     * Sets a column as the single-column identifier for this table.
     *
     * -----
     *
     * + `id-column`s cannot be nullable
     * + `id-column`s must be a candidate key
     * + `id-column`s must be a `PRIMARY KEY`
     *
     */
    setId(delegate) {
        return TableUtil.setId(this, delegate);
    }
    /**
     * Sets the `PRIMARY KEY` of the table.
     *
     * In MySQL, a `PRIMARY KEY` is just a candidate key
     * where all its columns are non-nullable.
     *
     * -----
     *
     * + `PRIMARY KEY` columns cannot be nullable
     * + `PRIMARY KEY` columns must be a candidate key
     */
    setPrimaryKey(delegate) {
        return TableUtil.setPrimaryKey(this, delegate);
    }
    /**
     * Sets the `schema` that this table belongs to.
     *
     * This is usually not required because the schema used
     * will be the one your database connection session is using.
     *
     * -----
     *
     * This library does not support cross-schema compile-time safe queries.
     *
     * However, if you **do** need cross-schema support,
     * this library can support it somewhat.
     */
    setSchemaName(newSchemaName) {
        return TableUtil.setSchemaName(this, newSchemaName);
    }
    /**
     * Changes the alias of the table.
     *
     * Useful if you have multiple tables with exactly the same structure.
     *
     * This is different from `.as()`!
     *
     * -----
     *
     * You will have to call `.setSchemaName()` again if you called it before.
     */
    setTableAlias(newTableAlias) {
        return TableUtil.setTableAlias(this, newTableAlias);
    }
    ;
    /*
    addParent<
        ParentT extends ITable
    > (
        parent : TableUtil.Parent<this, ParentT>
    ) : (
        TableUtil.AddParent<this, ParentT>
    ) {
        return TableUtil.addParent<this, ParentT>(this, parent);
    }

    /*
    validate (connection : IConnection, result : TableUtil.ValidateTableResult) {
        return TableUtil.validate(this, connection, result);
    }*/
    pickColumns(delegate) {
        return TableUtil.pickColumns(this, delegate);
    }
    insertOne(connection, row) {
        return execution_1.ExecutionUtil.insertOne(this, connection, row);
    }
    insertMany(connection, rows) {
        return execution_1.ExecutionUtil.insertMany(this, connection, rows);
    }
    insertIgnoreOne(connection, row) {
        return execution_1.ExecutionUtil.insertIgnoreOne(this, connection, row);
    }
    insertIgnoreMany(connection, rows) {
        return execution_1.ExecutionUtil.insertIgnoreMany(this, connection, rows);
    }
    replaceOne(connection, row) {
        return execution_1.ExecutionUtil.replaceOne(this, connection, row);
    }
    replaceMany(connection, rows) {
        return execution_1.ExecutionUtil.replaceMany(this, connection, rows);
    }
    insertAndFetch(connection, row) {
        return execution_1.ExecutionUtil.insertAndFetch(this, connection, row);
    }
    where(whereDelegate) {
        return new table_where_1.TableWhere(this, whereDelegate);
    }
    whereEqCandidateKey(candidateKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqCandidateKey(this, candidateKey));
    }
    whereEqPrimaryKey(primaryKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqPrimaryKey(this, primaryKey));
    }
    whereEqSuperKey(superKey) {
        return new table_where_1.TableWhere(this, () => ExprLib.eqSuperKey(this, superKey));
    }
}
exports.Table = Table;
//# sourceMappingURL=table-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/constructor/from-table-alias.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/constructor/from-table-alias.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Creates a table with the given alias
 *
 * @param tableAlias
 */
function fromTableAlias(tableAlias) {
    const result = new table_impl_1.Table({
        isLateral: false,
        alias: tableAlias,
        columns: {},
        usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
        autoIncrement: undefined,
        id: undefined,
        primaryKey: undefined,
        candidateKeys: [],
        insertEnabled: true,
        deleteEnabled: true,
        generatedColumns: [],
        nullableColumns: [],
        explicitDefaultValueColumns: [],
        mutableColumns: [],
        explicitAutoIncrementValueEnabled: false,
    }, ast_1.identifierNode(tableAlias));
    return result;
}
exports.fromTableAlias = fromTableAlias;
//# sourceMappingURL=from-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/constructor/from-table.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/constructor/from-table.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Creates a copy of the `table`
 *
 * @param table
 */
function fromTable(table) {
    const result = new table_impl_1.Table(table, table.unaliasedAst);
    return result;
}
exports.fromTable = fromTable;
//# sourceMappingURL=from-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/constructor/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/constructor/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-table-alias */ "./node_modules/@squill/squill/dist/table/util/constructor/from-table-alias.js"));
__export(__webpack_require__(/*! ./from-table */ "./node_modules/@squill/squill/dist/table/util/constructor/from-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/execution/assert-exists.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/execution/assert-exists.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
async function assertExists(table, connection, whereDelegate) {
    return unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .assertExists(connection);
}
exports.assertExists = assertExists;
//# sourceMappingURL=assert-exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/execution/exists.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/execution/exists.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
async function exists(table, connection, whereDelegate) {
    return unified_query_1.QueryUtil.newInstance()
        .from(table)
        .where(whereDelegate)
        .exists(connection);
}
exports.exists = exists;
//# sourceMappingURL=exists.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/execution/fetch-one.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/execution/fetch-one.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
function fetchOne(table, connection, whereDelegate, selectDelegate) {
    try {
        const query = unified_query_1.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate);
        if (selectDelegate == undefined) {
            return query
                .select(((columns) => [columns]))
                .fetchOne(connection);
        }
        else {
            return query
                .select(selectDelegate)
                .fetchOne(connection);
        }
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchOne = fetchOne;
/**
 * Not meant to be invoked directly
 */
function __fetchOneHelper(table, connection, whereDelegate, selectDelegate) {
    if (selectDelegate == undefined) {
        return fetchOne(table, connection, whereDelegate);
    }
    else {
        return fetchOne(table, connection, whereDelegate, selectDelegate);
    }
}
exports.__fetchOneHelper = __fetchOneHelper;
//# sourceMappingURL=fetch-one.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/execution/fetch-value.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/execution/fetch-value.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const unified_query_1 = __webpack_require__(/*! ../../../unified-query */ "./node_modules/@squill/squill/dist/unified-query/index.js");
function fetchValue(table, connection, whereDelegate, selectValueDelegate) {
    try {
        return unified_query_1.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate)
            .selectValue(selectValueDelegate)
            .fetchValue(connection);
    }
    catch (err) {
        const result = Promise.reject(err);
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.or = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        //eslint-disable-next-line @typescript-eslint/unbound-method
        result.orUndefined = () => {
            //To avoid `unhandled rejection` warnings
            result.catch(() => { });
            return Promise.reject(err);
        };
        return result;
    }
}
exports.fetchValue = fetchValue;
//# sourceMappingURL=fetch-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/execution/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/execution/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-exists */ "./node_modules/@squill/squill/dist/table/util/execution/assert-exists.js"));
__export(__webpack_require__(/*! ./exists */ "./node_modules/@squill/squill/dist/table/util/execution/exists.js"));
__export(__webpack_require__(/*! ./fetch-one */ "./node_modules/@squill/squill/dist/table/util/execution/fetch-one.js"));
__export(__webpack_require__(/*! ./fetch-value */ "./node_modules/@squill/squill/dist/table/util/execution/fetch-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/table/util/constructor/index.js"));
__export(__webpack_require__(/*! ./execution */ "./node_modules/@squill/squill/dist/table/util/execution/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/table/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/table/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/table/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-all-mutable.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-all-mutable.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/table/util/query/index.js");
/**
 * Makes all non-generated columns, and non-implicit auto-increment mutable.
 *
 * + Mutable columns may be modified with `UPDATE` statements using this library.
 * + Immutable columns may not be modified with this library
 *   (but could still be modified outside of this library)
 *
 * @param table
 */
function addAllMutable(table) {
    const mutableColumns = (key_1.KeyUtil.fromColumnArray(column_1.ColumnArrayUtil
        .fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            !query_1.isImplicitAutoIncrement(table, column.columnAlias));
    })));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addAllMutable = addAllMutable;
//# sourceMappingURL=add-all-mutable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-candidate-key.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-candidate-key.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/table/util/predicate/index.js");
function assertNotEmptyKey(columns) {
    if (columns.length == 0) {
        throw new Error(`Key cannot be empty`);
    }
}
exports.assertNotEmptyKey = assertNotEmptyKey;
function assertNotSubKey(table, columns) {
    const key = key_1.KeyUtil.fromColumnArray(columns);
    const superKeys = key_1.KeyArrayUtil.findSuperKeys(table.candidateKeys, key);
    if (superKeys.length > 0) {
        throw new Error(`${key.join("|")} is a sub key of ${superKeys[0].join("|")}`);
    }
}
exports.assertNotSubKey = assertNotSubKey;
function assertNotSuperKey(table, columns) {
    const key = key_1.KeyUtil.fromColumnArray(columns);
    const subKeys = key_1.KeyArrayUtil.findSubKeys(table.candidateKeys, key);
    if (subKeys.length > 0) {
        throw new Error(`${key.join("|")} is a super key of ${subKeys[0].join("|")}`);
    }
}
exports.assertNotSuperKey = assertNotSuperKey;
function assertValidCandidateKey(table, columns) {
    predicate_1.assertHasColumnIdentifiers(table, columns);
    assertNotEmptyKey(columns);
    assertNotSubKey(table, columns);
    assertNotSuperKey(table, columns);
}
exports.assertValidCandidateKey = assertValidCandidateKey;
/**
 * Adds a candidate key to the table.
 *
 * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
 *
 * + A table may have zero-to-many candidate keys. (recommended to have at least one)
 * + A candidate key cannot be a subset of other candidate keys.
 * + A candidate key cannot be a superset of other candidate keys.
 * + A candidate key can intersect other candidate keys.
 * + A candidate key can be disjoint from other candidate keys.
 *
 * @param table
 * @param delegate
 */
function addCandidateKey(table, delegate) {
    const newCandidateKey = delegate(table.columns);
    assertValidCandidateKey(table, newCandidateKey);
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, key_1.KeyUtil.fromColumnArray(newCandidateKey));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, 
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addCandidateKey = addCandidateKey;
//# sourceMappingURL=add-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-field-array.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-field-array.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
/**
 * Converts an array of fields to columns of the table
 *
 * @param table
 * @param fields
 *
 * @deprecated
 */
function addColumnsFromFieldArray(table, fields) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const tableColumns = table.columns;
    //https://github.com/Microsoft/TypeScript/issues/28592
    const columnMapFromFieldArray = column_map_1.ColumnMapUtil.fromFieldArray(table.alias, fields);
    const columns = column_map_1.ColumnMapUtil.intersect(tableColumns, columnMapFromFieldArray);
    const nullableColumns = column_map_1.ColumnMapUtil.nullableColumnAliases(columns);
    const result = new table_impl_1.Table({
        /**
         * This fails,
         * ```ts
         * ...table
         * ```
         *
         * This fails,
         * ```ts
         * ...(table as ITable)
         * ```
         *
         * This succeeds,
         * ```ts
         * ...(table as TableData)
         * ```
         *
         * @todo Investigate and possibly file issue
         */
        ...table,
        columns,
        nullableColumns,
    }, table.unaliasedAst);
    return result;
}
exports.addColumnsFromFieldArray = addColumnsFromFieldArray;
//# sourceMappingURL=add-columns-from-field-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-mapper-map.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-mapper-map.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
/**
 * Converts a map of `columnAlias -> mapper` to columns of the table
 *
 * @param table
 * @param mapperMap
 */
function addColumnsFromMapperMap(table, mapperMap) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const tableColumns = table.columns;
    const columns = column_map_1.ColumnMapUtil.intersect(tableColumns, column_map_1.ColumnMapUtil.fromMapperMap(table.alias, mapperMap));
    const nullableColumns = column_map_1.ColumnMapUtil.nullableColumnAliases(columns);
    const result = new table_impl_1.Table({
        ...table,
        columns,
        nullableColumns,
    }, table.unaliasedAst);
    return result;
}
exports.addColumnsFromMapperMap = addColumnsFromMapperMap;
//# sourceMappingURL=add-columns-from-mapper-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-columns.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-columns.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const add_columns_from_field_array_1 = __webpack_require__(/*! ./add-columns-from-field-array */ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-field-array.js");
const add_columns_from_mapper_map_1 = __webpack_require__(/*! ./add-columns-from-mapper-map */ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-mapper-map.js");
function addColumns(table, rawColumns) {
    if (Array.isArray(rawColumns)) {
        return add_columns_from_field_array_1.addColumnsFromFieldArray(table, rawColumns);
    }
    else {
        return add_columns_from_mapper_map_1.addColumnsFromMapperMap(table, rawColumns);
    }
}
exports.addColumns = addColumns;
//# sourceMappingURL=add-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-explicit-default-value.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-explicit-default-value.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function addExplicitDefaultValueColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            //!table.nullableColumns.includes(column.columnAlias) &&
            (table.autoIncrement != column.columnAlias) &&
            !table.explicitDefaultValueColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addExplicitDefaultValueColumnMap = addExplicitDefaultValueColumnMap;
/**
 * Tells the library that these columns have explicit `DEFAULT` values.
 *
 * An example of an "explicit" default value,
 * ```sql
 * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
 * ```
 *
 * + Columns with server default values are optional with `INSERT` statements.
 * + Generated columns have implicit default values.
 * + Nullable columns have implicit default values.
 * + `AUTO_INCREMENT` columns have implicit default values
 *
 * -----
 *
 * @param table
 * @param delegate
 */
function addExplicitDefaultValue(table, delegate) {
    const columnMap = addExplicitDefaultValueColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const explicitDefaultValueColumns = key_1.KeyUtil.concat(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
    //explicitDefaultValueColumns,
    mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addExplicitDefaultValue = addExplicitDefaultValue;
//# sourceMappingURL=add-explicit-default-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-generated.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-generated.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function addGeneratedColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            column.columnAlias != table.autoIncrement);
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addGeneratedColumnMap = addGeneratedColumnMap;
/**
 * Adds a `GENERATED` column to the table.
 *
 * + Setting generated column values will not be allowed with `INSERT` statements.
 * + Updating generated column values will also not be allowed with `UPDATE` statements.
 *
 * @param table
 * @param delegate
 */
function addGenerated(table, delegate) {
    const columnMap = addGeneratedColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const generatedColumns = key_1.KeyUtil.concat(table.generatedColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const explicitDefaultValueColumns = key_1.KeyUtil.subtract(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const mutableColumns = key_1.KeyUtil.subtract(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, 
    //explicitDefaultValueColumns,
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addGenerated = addGenerated;
//# sourceMappingURL=add-generated.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/add-mutable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/add-mutable.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/table/util/query/index.js");
function addMutableColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!table.generatedColumns.includes(column.columnAlias) &&
            !table.mutableColumns.includes(column.columnAlias) &&
            !query_1.isImplicitAutoIncrement(table, column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.addMutableColumnMap = addMutableColumnMap;
/**
 * Lets these columns be updated through this library.
 *
 * @param table
 * @param delegate
 */
function addMutable(table, delegate) {
    const columnMap = addMutableColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const mutableColumns = key_1.KeyUtil.concat(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.addMutable = addMutable;
//# sourceMappingURL=add-mutable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/as.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/as.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Aliases a table reference in a query.
 *
 * ```sql
 *  SELECT
 *      *
 *  FROM
 *      myTable AS aliasedTable
 * ```
 */
function as(table, newTableAlias) {
    const { isLateral, 
    //alias,
    columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias: newTableAlias,
        columns: column_map_1.ColumnMapUtil.withTableAlias(columns, newTableAlias),
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.as = as;
//# sourceMappingURL=as.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/disable-delete.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/disable-delete.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Prevents rows of this table from being deleted through this library.
 *
 * Good for look-up tables, or append-only tables.
 *
 * @param table
 */
function disableDelete(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, 
    //deleteEnabled,
    generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled: false,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.disableDelete = disableDelete;
//# sourceMappingURL=disable-delete.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/disable-insert.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/disable-insert.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Prevents rows from being inserted through this library.
 *
 * Good for look-up tables.
 *
 * @param table
 */
function disableInsert(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
    //insertEnabled,
    deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled: false,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.disableInsert = disableInsert;
//# sourceMappingURL=disable-insert.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/enable-explicit-auto-increment-value.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/enable-explicit-auto-increment-value.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Allows explicit values for auto-increment columns.
 */
function enableExplicitAutoIncrementValue(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled: true,
    }, table.unaliasedAst);
    return result;
}
exports.enableExplicitAutoIncrementValue = enableExplicitAutoIncrementValue;
//# sourceMappingURL=enable-explicit-auto-increment-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/enable-insert.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/enable-insert.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
function enableInsert(table) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
    //insertEnabled,
    deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled: true,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.enableInsert = enableInsert;
//# sourceMappingURL=enable-insert.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./add-all-mutable */ "./node_modules/@squill/squill/dist/table/util/operation/add-all-mutable.js"));
__export(__webpack_require__(/*! ./add-candidate-key */ "./node_modules/@squill/squill/dist/table/util/operation/add-candidate-key.js"));
__export(__webpack_require__(/*! ./add-columns-from-field-array */ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-field-array.js"));
__export(__webpack_require__(/*! ./add-columns-from-mapper-map */ "./node_modules/@squill/squill/dist/table/util/operation/add-columns-from-mapper-map.js"));
__export(__webpack_require__(/*! ./add-columns */ "./node_modules/@squill/squill/dist/table/util/operation/add-columns.js"));
__export(__webpack_require__(/*! ./add-explicit-default-value */ "./node_modules/@squill/squill/dist/table/util/operation/add-explicit-default-value.js"));
__export(__webpack_require__(/*! ./add-generated */ "./node_modules/@squill/squill/dist/table/util/operation/add-generated.js"));
__export(__webpack_require__(/*! ./add-mutable */ "./node_modules/@squill/squill/dist/table/util/operation/add-mutable.js"));
__export(__webpack_require__(/*! ./as */ "./node_modules/@squill/squill/dist/table/util/operation/as.js"));
__export(__webpack_require__(/*! ./disable-delete */ "./node_modules/@squill/squill/dist/table/util/operation/disable-delete.js"));
__export(__webpack_require__(/*! ./disable-insert */ "./node_modules/@squill/squill/dist/table/util/operation/disable-insert.js"));
__export(__webpack_require__(/*! ./enable-explicit-auto-increment-value */ "./node_modules/@squill/squill/dist/table/util/operation/enable-explicit-auto-increment-value.js"));
__export(__webpack_require__(/*! ./enable-insert */ "./node_modules/@squill/squill/dist/table/util/operation/enable-insert.js"));
__export(__webpack_require__(/*! ./pick-columns */ "./node_modules/@squill/squill/dist/table/util/operation/pick-columns.js"));
__export(__webpack_require__(/*! ./remove-all-mutable */ "./node_modules/@squill/squill/dist/table/util/operation/remove-all-mutable.js"));
__export(__webpack_require__(/*! ./remove-explicit-default-value */ "./node_modules/@squill/squill/dist/table/util/operation/remove-explicit-default-value.js"));
__export(__webpack_require__(/*! ./remove-generated */ "./node_modules/@squill/squill/dist/table/util/operation/remove-generated.js"));
__export(__webpack_require__(/*! ./remove-mutable */ "./node_modules/@squill/squill/dist/table/util/operation/remove-mutable.js"));
__export(__webpack_require__(/*! ./set-auto-increment */ "./node_modules/@squill/squill/dist/table/util/operation/set-auto-increment.js"));
__export(__webpack_require__(/*! ./set-id */ "./node_modules/@squill/squill/dist/table/util/operation/set-id.js"));
__export(__webpack_require__(/*! ./set-primary-key */ "./node_modules/@squill/squill/dist/table/util/operation/set-primary-key.js"));
__export(__webpack_require__(/*! ./set-schema-name */ "./node_modules/@squill/squill/dist/table/util/operation/set-schema-name.js"));
__export(__webpack_require__(/*! ./set-table-alias */ "./node_modules/@squill/squill/dist/table/util/operation/set-table-alias.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/pick-columns.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/pick-columns.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const aliased_table_1 = __webpack_require__(/*! ../../../aliased-table */ "./node_modules/@squill/squill/dist/aliased-table/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function pickColumns(table, delegate) {
    const newColumns = delegate(table.columns);
    const { isLateral, alias, columns, usedRef, } = table;
    const result = new aliased_table_1.AliasedTable({
        isLateral,
        alias,
        columns: type_util_1.pickOwnEnumerable(columns, newColumns.map(column => column.columnAlias)),
        usedRef,
    }, table.unaliasedAst);
    return result;
}
exports.pickColumns = pickColumns;
//# sourceMappingURL=pick-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/remove-all-mutable.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/remove-all-mutable.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
/**
 * Makes all columns immutable.
 *
 * @param table
 */
function removeAllMutable(table) {
    const mutableColumns = [];
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeAllMutable = removeAllMutable;
//# sourceMappingURL=remove-all-mutable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/remove-explicit-default-value.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/remove-explicit-default-value.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function removeExplicitDefaultValueColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.explicitDefaultValueColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeExplicitDefaultValueColumnMap = removeExplicitDefaultValueColumnMap;
/**
 * Removes columns from the set of columns with explicit `DEFAULT` values
 *
 * @param table
 * @param delegate
 */
function removeExplicitDefaultValue(table, delegate) {
    const columnMap = removeExplicitDefaultValueColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const explicitDefaultValueColumns = key_1.KeyUtil.subtract(table.explicitDefaultValueColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
    //explicitDefaultValueColumns,
    mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeExplicitDefaultValue = removeExplicitDefaultValue;
//# sourceMappingURL=remove-explicit-default-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/remove-generated.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/remove-generated.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function removeGeneratedColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.generatedColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeGeneratedColumnMap = removeGeneratedColumnMap;
/**
 * Removes columns from the set of `GENERATED` columns.
 *
 * @param table
 * @param delegate
 */
function removeGenerated(table, delegate) {
    const columnMap = removeGeneratedColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const generatedColumns = key_1.KeyUtil.subtract(table.generatedColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeGenerated = removeGenerated;
//# sourceMappingURL=remove-generated.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/remove-mutable.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/remove-mutable.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function removeMutableColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (table.mutableColumns.includes(column.columnAlias));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.removeMutableColumnMap = removeMutableColumnMap;
/**
 * Removes columns from the set of mutable columns.
 *
 * You will not be able to update them through this library.
 *
 * @param table
 * @param delegate
 */
function removeMutable(table, delegate) {
    const columnMap = removeMutableColumnMap(table);
    const columnsT = delegate(columnMap);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
    const mutableColumns = key_1.KeyUtil.subtract(table.mutableColumns, key_1.KeyUtil.fromColumnArray(columnsT));
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.removeMutable = removeMutable;
//# sourceMappingURL=remove-mutable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/set-auto-increment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/set-auto-increment.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const set_primary_key_1 = __webpack_require__(/*! ./set-primary-key */ "./node_modules/@squill/squill/dist/table/util/operation/set-primary-key.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function setAutoIncrementColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!tm.canOutputNull(column.mapper) &&
            !key_1.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.setAutoIncrementColumnMap = setAutoIncrementColumnMap;
function assertValidAutoIncrement(table, autoIncrement) {
    const columnMap = setAutoIncrementColumnMap(table);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, autoIncrement);
    set_primary_key_1.assertValidPrimaryKey(table, [autoIncrement]);
}
exports.assertValidAutoIncrement = assertValidAutoIncrement;
/**
 * Designates one column as the `AUTO_INCREMENT` column.
 *
 * -----
 *
 * + `AUTO_INCREMENT` columns cannot be nullable
 * + `AUTO_INCREMENT` columns must be a candidate key
 * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
 * + The `number|string|bigint` requirement is only a compile-time constraint
 *
 * @todo Consider having run-time checks to see if it allows 1,2,3,4,5,... ?
 */
function setAutoIncrement(table, delegate) {
    const newAutoIncrement = delegate(setAutoIncrementColumnMap(table));
    assertValidAutoIncrement(table, newAutoIncrement);
    const primaryKey = (key_1.KeyUtil.fromColumn(newAutoIncrement));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const generatedColumns = key_1.KeyUtil.remove(table.generatedColumns, newAutoIncrement.columnAlias);
    const explicitDefaultValueColumns = key_1.KeyUtil.remove(table.explicitDefaultValueColumns, newAutoIncrement.columnAlias);
    const mutableColumns = key_1.KeyUtil.remove(table.mutableColumns, newAutoIncrement.columnAlias);
    const { isLateral, alias, columns, usedRef, 
    //autoIncrement,
    //id,
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, 
    //generatedColumns,
    nullableColumns, 
    //explicitDefaultValueColumns,
    //mutableColumns,
    explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement: newAutoIncrement.columnAlias,
        id: newAutoIncrement.columnAlias,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setAutoIncrement = setAutoIncrement;
//# sourceMappingURL=set-auto-increment.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/set-id.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/set-id.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const set_primary_key_1 = __webpack_require__(/*! ./set-primary-key */ "./node_modules/@squill/squill/dist/table/util/operation/set-primary-key.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
function setIdColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => {
        return (!tm.canOutputNull(column.mapper) &&
            !key_1.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
    })
        .map(column => column.columnAlias));
    return result;
}
exports.setIdColumnMap = setIdColumnMap;
function assertValidId(table, id) {
    const columnMap = setIdColumnMap(table);
    column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, id);
    set_primary_key_1.assertValidPrimaryKey(table, [id]);
}
exports.assertValidId = assertValidId;
/**
 * Sets a column as the single-column identifier for this table.
 *
 * -----
 *
 * + `id-column`s cannot be nullable
 * + `id-column`s must be a candidate key
 * + `id-column`s must be a `PRIMARY KEY`
 *
 */
function setId(table, delegate) {
    const newId = delegate(setIdColumnMap(table));
    assertValidId(table, newId);
    const primaryKey = (key_1.KeyUtil.fromColumn(newId));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const { isLateral, alias, columns, usedRef, autoIncrement, 
    //id,
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id: newId.columnAlias,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setId = setId;
//# sourceMappingURL=set-id.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/set-primary-key.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/set-primary-key.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tm = __webpack_require__(/*! type-mapping */ "./node_modules/type-mapping/dist/index.js");
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_1 = __webpack_require__(/*! ../../../column */ "./node_modules/@squill/squill/dist/column/index.js");
const add_candidate_key_1 = __webpack_require__(/*! ./add-candidate-key */ "./node_modules/@squill/squill/dist/table/util/operation/add-candidate-key.js");
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
function setPrimaryKeyColumnMap(table) {
    const result = type_util_1.pickOwnEnumerable(table.columns, column_1.ColumnArrayUtil.fromColumnMap(table.columns)
        .filter(column => !tm.canOutputNull(column.mapper))
        .map(column => column.columnAlias));
    return result;
}
exports.setPrimaryKeyColumnMap = setPrimaryKeyColumnMap;
function assertValidPrimaryKey(table, columns) {
    //An extra run-time check, just to be safe...
    //For all the JS-land users
    for (const column of columns) {
        if (tm.canOutputNull(column.mapper)) {
            throw new Error(`${column.tableAlias}.${column.columnAlias} cannot be part of a PRIMARY KEY; it is nullable`);
        }
    }
    add_candidate_key_1.assertValidCandidateKey(table, columns);
}
exports.assertValidPrimaryKey = assertValidPrimaryKey;
/**
 * Sets the `PRIMARY KEY` of the table.
 *
 * In MySQL, a `PRIMARY KEY` is just a candidate key
 * where all its columns are non-nullable.
 *
 * -----
 *
 * + `PRIMARY KEY` columns cannot be nullable
 * + `PRIMARY KEY` columns must be a candidate key
 */
function setPrimaryKey(table, delegate) {
    const newPrimaryKey = delegate(setPrimaryKeyColumnMap(table));
    assertValidPrimaryKey(table, newPrimaryKey);
    const primaryKey = (key_1.KeyUtil.fromColumnArray(newPrimaryKey));
    const candidateKeys = key_1.KeyArrayUtil.append(table.candidateKeys, primaryKey);
    const { isLateral, alias, columns, usedRef, autoIncrement, id, 
    //primaryKey,
    //candidateKeys,
    insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    const result = new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, table.unaliasedAst);
    return result;
}
exports.setPrimaryKey = setPrimaryKey;
//# sourceMappingURL=set-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/set-schema-name.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/set-schema-name.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Sets the `schema` that this table belongs to.
 *
 * This is usually not required because the schema used
 * will be the one your database connection session is using.
 *
 * -----
 *
 * This library does not support cross-schema compile-time safe queries.
 *
 * However, if you **do** need cross-schema support,
 * this library can support it somewhat.
 *
 * -----
 *
 * @param table
 * @param newSchemaName
 */
function setSchemaName(table, newSchemaName) {
    const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    return new table_impl_1.Table({
        isLateral,
        alias,
        columns,
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, (ast_1.isIdentifierNode(table.unaliasedAst) ?
        ast_1.identifierNode(newSchemaName, 
        //The table alias on the database
        table.unaliasedAst.identifiers[table.unaliasedAst.identifiers.length - 1]) :
        ast_1.identifierNode(newSchemaName, alias)));
}
exports.setSchemaName = setSchemaName;
//# sourceMappingURL=set-schema-name.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/operation/set-table-alias.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/operation/set-table-alias.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const table_impl_1 = __webpack_require__(/*! ../../table-impl */ "./node_modules/@squill/squill/dist/table/table-impl.js");
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
/**
 * Changes the alias of the table.
 *
 * Useful if you have multiple tables with exactly the same structure.
 *
 * This is different from `.as()`!
 *
 * -----
 *
 * You will have to call `.setSchemaName()` again if you called it before.
 *
 * @param table
 * @param newTableAlias
 */
function setTableAlias(table, newTableAlias) {
    //https://github.com/Microsoft/TypeScript/issues/28592
    const columns = table.columns;
    const { isLateral, 
    //tableAlias,
    //columns,
    usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
    return new table_impl_1.Table({
        isLateral,
        alias: newTableAlias,
        columns: column_map_1.ColumnMapUtil.withTableAlias(columns, newTableAlias),
        usedRef,
        autoIncrement,
        id,
        primaryKey,
        candidateKeys,
        insertEnabled,
        deleteEnabled,
        generatedColumns,
        nullableColumns,
        explicitDefaultValueColumns,
        mutableColumns,
        explicitAutoIncrementValueEnabled,
    }, ((ast_1.isIdentifierNode(table.unaliasedAst) &&
        table.unaliasedAst.identifiers.length == 2) ?
        ast_1.identifierNode(
        //The `schemaName`
        table.unaliasedAst.identifiers[0], newTableAlias) :
        ast_1.identifierNode(newTableAlias)));
}
exports.setTableAlias = setTableAlias;
//# sourceMappingURL=set-table-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/assert-delete-enabled.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/assert-delete-enabled.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isDeleteEnabled(table) {
    return table.deleteEnabled;
}
exports.isDeleteEnabled = isDeleteEnabled;
function assertDeleteEnabled(table) {
    if (!isDeleteEnabled(table)) {
        throw new Error(`Cannot DELETE FROM/REPLACE INTO ${table.alias}`);
    }
}
exports.assertDeleteEnabled = assertDeleteEnabled;
//# sourceMappingURL=assert-delete-enabled.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-candidate-key.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/assert-has-candidate-key.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertHasCandidateKey(table) {
    if (table.candidateKeys.length == 0) {
        throw new Error(`${table.alias} must have a candidate key`);
    }
}
exports.assertHasCandidateKey = assertHasCandidateKey;
//# sourceMappingURL=assert-has-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-column-identifiers.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/assert-has-column-identifiers.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_map_1 = __webpack_require__(/*! ../../../column-identifier-map */ "./node_modules/@squill/squill/dist/column-identifier-map/index.js");
/**
 * A run-time check mostly for JS-land users.
 *
 * Checks that the `table` contains all `columns` passed through,
 * using just the `tableAlias` and `columnAlias`.
 *
 * @param table
 * @param columns
 */
function assertHasColumnIdentifiers(table, columns) {
    for (const column of columns) {
        column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(table.columns, column);
    }
}
exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
//# sourceMappingURL=assert-has-column-identifiers.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
const has_null_safe_comparable_primary_key_1 = __webpack_require__(/*! ./has-null-safe-comparable-primary-key */ "./node_modules/@squill/squill/dist/table/util/predicate/has-null-safe-comparable-primary-key.js");
function assertHasNullSafeComparablePrimaryKey(table, columnMap) {
    if (!has_null_safe_comparable_primary_key_1.hasNullSafeComparablePrimaryKey(table, columnMap)) {
        const myTableAlias = column_map_1.ColumnMapUtil.tableAlias(table.columns);
        const myPrimaryKey = table.primaryKey.join(",");
        const otherTableAlias = column_map_1.ColumnMapUtil.tableAlias(columnMap);
        const otherColumnAliases = table.primaryKey
            .filter(pk => (Object.prototype.hasOwnProperty.call(columnMap, pk) &&
            Object.prototype.propertyIsEnumerable.call(columnMap, pk)))
            .join(",");
        throw new Error(`${myTableAlias} primary key (${myPrimaryKey}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
    }
}
exports.assertHasNullSafeComparablePrimaryKey = assertHasNullSafeComparablePrimaryKey;
//# sourceMappingURL=assert-has-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/assert-insert-enabled.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/assert-insert-enabled.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isInsertEnabled(table) {
    return table.insertEnabled;
}
exports.isInsertEnabled = isInsertEnabled;
function assertInsertEnabled(table) {
    if (!isInsertEnabled(table)) {
        throw new Error(`Cannot INSERT INTO ${table.alias}`);
    }
}
exports.assertInsertEnabled = assertInsertEnabled;
//# sourceMappingURL=assert-insert-enabled.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/has-null-safe-comparable-primary-key.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/has-null-safe-comparable-primary-key.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ideally, we'd want to have run-time checks
 * ensuring PK columns and `columnMap` columns
 * have null-safe comparable types.
 *
 * However, due to how the project is structured,
 * this is not possible.
 *
 * So, at the very least, we just check
 * the columns exist.
 */
function hasNullSafeComparablePrimaryKey(table, columnMap) {
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring PK columns and `columnMap` columns
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    const myColumnAliases = Object.keys(table.columns);
    for (const pkColumnAlias of table.primaryKey) {
        if (!myColumnAliases.includes(pkColumnAlias)) {
            /**
             * My column does not exist
             */
            return false;
        }
    }
    const otherColumnAliases = Object.keys(columnMap);
    for (const pkColumnAlias of table.primaryKey) {
        if (!otherColumnAliases.includes(pkColumnAlias)) {
            /**
             * Other column does not exist
             */
            return false;
        }
    }
    return true;
}
exports.hasNullSafeComparablePrimaryKey = hasNullSafeComparablePrimaryKey;
//# sourceMappingURL=has-null-safe-comparable-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-delete-enabled */ "./node_modules/@squill/squill/dist/table/util/predicate/assert-delete-enabled.js"));
__export(__webpack_require__(/*! ./assert-has-candidate-key */ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-candidate-key.js"));
__export(__webpack_require__(/*! ./assert-has-column-identifiers */ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-column-identifiers.js"));
__export(__webpack_require__(/*! ./assert-has-null-safe-comparable-primary-key */ "./node_modules/@squill/squill/dist/table/util/predicate/assert-has-null-safe-comparable-primary-key.js"));
__export(__webpack_require__(/*! ./assert-insert-enabled */ "./node_modules/@squill/squill/dist/table/util/predicate/assert-insert-enabled.js"));
__export(__webpack_require__(/*! ./has-null-safe-comparable-primary-key */ "./node_modules/@squill/squill/dist/table/util/predicate/has-null-safe-comparable-primary-key.js"));
__export(__webpack_require__(/*! ./is-table */ "./node_modules/@squill/squill/dist/table/util/predicate/is-table.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/predicate/is-table.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/predicate/is-table.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
/**
 * Actually only checks if it has all the properties of `ITable`.
 *
 * So, if it has all the properties but they're of the wrong data type...
 */
function isTable(mixed) {
    return type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
        "isLateral",
        "alias",
        "columns",
        "usedRef",
        "unaliasedAst",
        "autoIncrement",
        "id",
        "primaryKey",
        "candidateKeys",
        "insertEnabled",
        "deleteEnabled",
        "generatedColumns",
        "nullableColumns",
        "explicitDefaultValueColumns",
        "mutableColumns",
        "explicitAutoIncrementValueEnabled",
    ]);
}
exports.isTable = isTable;
//# sourceMappingURL=is-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/column-alias.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/column-alias.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_map_1 = __webpack_require__(/*! ../../../column-map */ "./node_modules/@squill/squill/dist/column-map/index.js");
/**
 * @todo Pluralize this and others where relevant?
 * Be more consistent with pluralization.
 */
function columnAlias(table) {
    return column_map_1.ColumnMapUtil.columnAlias(table.columns);
}
exports.columnAlias = columnAlias;
//# sourceMappingURL=column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/explicit-auto-increment.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/explicit-auto-increment.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isExplicitAutoIncrement(table, columnAlias) {
    if (table.explicitAutoIncrementValueEnabled) {
        return columnAlias === table.autoIncrement;
    }
    else {
        return false;
    }
}
exports.isExplicitAutoIncrement = isExplicitAutoIncrement;
function isImplicitAutoIncrement(table, columnAlias) {
    if (!table.explicitAutoIncrementValueEnabled) {
        return columnAlias === table.autoIncrement;
    }
    else {
        return false;
    }
}
exports.isImplicitAutoIncrement = isImplicitAutoIncrement;
//# sourceMappingURL=explicit-auto-increment.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const key_1 = __webpack_require__(/*! ../../../key */ "./node_modules/@squill/squill/dist/key/index.js");
function extractCandidateKeysWithColumnAliasInTable(candidateKeysTable, columnAliasesTable) {
    const result = [];
    const columnAliases = Object.keys(columnAliasesTable.columns);
    for (const candidateKey of candidateKeysTable.candidateKeys) {
        if (key_1.KeyUtil.isSubKey(candidateKey, columnAliases)) {
            result.push(candidateKey);
        }
    }
    return result;
}
exports.extractCandidateKeysWithColumnAliasInTable = extractCandidateKeysWithColumnAliasInTable;
//# sourceMappingURL=extract-candidate-keys-with-column-alias-in-table.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/table/util/query/column-alias.js"));
__export(__webpack_require__(/*! ./explicit-auto-increment */ "./node_modules/@squill/squill/dist/table/util/query/explicit-auto-increment.js"));
__export(__webpack_require__(/*! ./extract-candidate-keys-with-column-alias-in-table */ "./node_modules/@squill/squill/dist/table/util/query/extract-candidate-keys-with-column-alias-in-table.js"));
__export(__webpack_require__(/*! ./insertable-column-alias */ "./node_modules/@squill/squill/dist/table/util/query/insertable-column-alias.js"));
__export(__webpack_require__(/*! ./optional-column-alias */ "./node_modules/@squill/squill/dist/table/util/query/optional-column-alias.js"));
__export(__webpack_require__(/*! ./required-column-alias */ "./node_modules/@squill/squill/dist/table/util/query/required-column-alias.js"));
__export(__webpack_require__(/*! ./try-get-schema-name */ "./node_modules/@squill/squill/dist/table/util/query/try-get-schema-name.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/insertable-column-alias.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/insertable-column-alias.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/table/util/query/column-alias.js");
const explicit_auto_increment_1 = __webpack_require__(/*! ./explicit-auto-increment */ "./node_modules/@squill/squill/dist/table/util/query/explicit-auto-increment.js");
function isInsertableColumnAlias(table, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
        !table.generatedColumns.includes(columnAlias) &&
        !explicit_auto_increment_1.isImplicitAutoIncrement(table, columnAlias));
}
exports.isInsertableColumnAlias = isInsertableColumnAlias;
function insertableColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isInsertableColumnAlias(table, columnAlias)));
}
exports.insertableColumnAlias = insertableColumnAlias;
//# sourceMappingURL=insertable-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/optional-column-alias.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/optional-column-alias.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/table/util/query/column-alias.js");
const explicit_auto_increment_1 = __webpack_require__(/*! ./explicit-auto-increment */ "./node_modules/@squill/squill/dist/table/util/query/explicit-auto-increment.js");
function isOptionalColumnAlias(table, columnAlias) {
    return (explicit_auto_increment_1.isExplicitAutoIncrement(table, columnAlias) ||
        ((table.nullableColumns.indexOf(columnAlias) >= 0 ||
            table.explicitDefaultValueColumns.indexOf(columnAlias) >= 0) &&
            table.generatedColumns.indexOf(columnAlias) < 0));
}
exports.isOptionalColumnAlias = isOptionalColumnAlias;
function optionalColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isOptionalColumnAlias(table, columnAlias)));
}
exports.optionalColumnAlias = optionalColumnAlias;
//# sourceMappingURL=optional-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/required-column-alias.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/required-column-alias.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_alias_1 = __webpack_require__(/*! ./column-alias */ "./node_modules/@squill/squill/dist/table/util/query/column-alias.js");
function isRequiredColumnAlias(table, columnAlias) {
    return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
        Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
        table.generatedColumns.indexOf(columnAlias) < 0 &&
        table.nullableColumns.indexOf(columnAlias) < 0 &&
        table.explicitDefaultValueColumns.indexOf(columnAlias) < 0 &&
        table.autoIncrement !== columnAlias);
}
exports.isRequiredColumnAlias = isRequiredColumnAlias;
function requiredColumnAlias(table) {
    return column_alias_1.columnAlias(table).filter((columnAlias) => (isRequiredColumnAlias(table, columnAlias)));
}
exports.requiredColumnAlias = requiredColumnAlias;
//# sourceMappingURL=required-column-alias.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/table/util/query/try-get-schema-name.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/table/util/query/try-get-schema-name.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = __webpack_require__(/*! ../../../ast */ "./node_modules/@squill/squill/dist/ast/index.js");
function tryGetSchemaName(table) {
    return ((ast_1.isIdentifierNode(table.unaliasedAst) &&
        table.unaliasedAst.identifiers.length == 2) ?
        table.unaliasedAst.identifiers[0] :
        undefined);
}
exports.tryGetSchemaName = tryGetSchemaName;
//# sourceMappingURL=try-get-schema-name.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/transaction-access-mode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/transaction-access-mode.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction access modes ranked from least to most permissive,
 * 1. `READ_ONLY`
 * 2. `READ_WRITE`
 *
 * https://github.com/AnyhowStep/tsql/issues/14
 */
var TransactionAccessMode;
(function (TransactionAccessMode) {
    TransactionAccessMode["READ_ONLY"] = "READ_ONLY";
    TransactionAccessMode["READ_WRITE"] = "READ_WRITE";
})(TransactionAccessMode = exports.TransactionAccessMode || (exports.TransactionAccessMode = {}));
var TransactionAccessModeUtil;
(function (TransactionAccessModeUtil) {
    const transactionAccessModePermissions = {
        [TransactionAccessMode.READ_ONLY]: 0,
        [TransactionAccessMode.READ_WRITE]: 1,
    };
    /**
     * Is transaction access mode `a` less permissive than `b`?
     */
    function isLessPermissiveThan(a, b) {
        return transactionAccessModePermissions[a] < transactionAccessModePermissions[b];
    }
    TransactionAccessModeUtil.isLessPermissiveThan = isLessPermissiveThan;
})(TransactionAccessModeUtil = exports.TransactionAccessModeUtil || (exports.TransactionAccessModeUtil = {}));
//# sourceMappingURL=transaction-access-mode.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/tuple-util/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/tuple-util/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-hint.js":
/*!*******************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-hint.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TypeHint;
(function (TypeHint) {
    TypeHint["DECIMAL"] = "DECIMAL";
    TypeHint["STRING"] = "STRING";
    TypeHint["DOUBLE"] = "DOUBLE";
    TypeHint["BIGINT_SIGNED"] = "BIGINT_SIGNED";
    TypeHint["BOOLEAN"] = "BOOLEAN";
    TypeHint["BUFFER"] = "BUFFER";
    TypeHint["NULL"] = "NULL";
    TypeHint["DATE_TIME"] = "DATE_TIME";
})(TypeHint = exports.TypeHint || (exports.TypeHint = {}));
//# sourceMappingURL=type-hint.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-map/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-map/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeMapUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/type-map/util/index.js");
exports.TypeMapUtil = TypeMapUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-map/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-map/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-ref/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-ref/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeRefUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/type-ref/util/index.js");
exports.TypeRefUtil = TypeRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-ref/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-ref/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-util/assert-same-own-enumerable-keys.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-util/assert-same-own-enumerable-keys.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function assertSameOwnEnumerableKeys(a, b) {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const extraKeys = aKeys.filter(k => !bKeys.includes(k));
    const missingKeys = bKeys.filter(k => !aKeys.includes(k));
    if (extraKeys.length > 0) {
        if (missingKeys.length > 0) {
            throw new Error(`Extra keys found: ${extraKeys.join(",")}; Missing keys found: ${missingKeys.join(",")}`);
        }
        else {
            throw new Error(`Extra keys found: ${extraKeys.join(",")}`);
        }
    }
    else {
        if (missingKeys.length > 0) {
            throw new Error(`Missing keys found: ${missingKeys.join(",")}`);
        }
        else {
            //Do nothing
        }
    }
}
exports.assertSameOwnEnumerableKeys = assertSameOwnEnumerableKeys;
//# sourceMappingURL=assert-same-own-enumerable-keys.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-same-own-enumerable-keys */ "./node_modules/@squill/squill/dist/type-util/assert-same-own-enumerable-keys.js"));
__export(__webpack_require__(/*! ./is-object-with-own-enumerable-keys */ "./node_modules/@squill/squill/dist/type-util/is-object-with-own-enumerable-keys.js"));
__export(__webpack_require__(/*! ./omit-own-enumerable */ "./node_modules/@squill/squill/dist/type-util/omit-own-enumerable.js"));
__export(__webpack_require__(/*! ./pick-own-enumerable */ "./node_modules/@squill/squill/dist/type-util/pick-own-enumerable.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-util/is-object-with-own-enumerable-keys.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-util/is-object-with-own-enumerable-keys.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isObjectWithOwnEnumerableKeys() {
    return (raw, keys) => {
        if (raw == undefined) {
            return false;
        }
        if (!(raw instanceof Object)) {
            return false;
        }
        for (const k of keys) {
            if (!Object.prototype.hasOwnProperty.call(raw, k)) {
                return false;
            }
            if (!Object.prototype.propertyIsEnumerable.call(raw, k)) {
                return false;
            }
        }
        return true;
    };
}
exports.isObjectWithOwnEnumerableKeys = isObjectWithOwnEnumerableKeys;
//# sourceMappingURL=is-object-with-own-enumerable-keys.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-util/omit-own-enumerable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-util/omit-own-enumerable.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function omitOwnEnumerable(obj, keys) {
    const result = {};
    for (const k of Object.keys(obj)) {
        if (Object.prototype.propertyIsEnumerable.call(obj, k) &&
            keys.indexOf(k) < 0) {
            result[k] = obj[k];
        }
    }
    return result;
}
exports.omitOwnEnumerable = omitOwnEnumerable;
//# sourceMappingURL=omit-own-enumerable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/type-util/pick-own-enumerable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/type-util/pick-own-enumerable.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function pickOwnEnumerable(obj, keys) {
    const result = {};
    for (const k of keys) {
        if (Object.prototype.hasOwnProperty.call(obj, k) &&
            Object.prototype.propertyIsEnumerable.call(obj, k)) {
            result[k] = obj[k];
        }
    }
    return result;
}
exports.pickOwnEnumerable = pickOwnEnumerable;
//# sourceMappingURL=pick-own-enumerable.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/convenience.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/convenience.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const QueryUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/unified-query/util/index.js");
function from(aliasedTable) {
    return QueryUtil.newInstance()
        .from(aliasedTable);
}
exports.from = from;
function requireOuterQueryJoins(...aliasedTables) {
    return QueryUtil.newInstance()
        .requireOuterQueryJoins(...aliasedTables);
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
function requireNullableOuterQueryJoins(...aliasedTables) {
    return QueryUtil.newInstance()
        .requireNullableOuterQueryJoins(...aliasedTables);
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
function select(selectDelegate) {
    return QueryUtil.newInstance()
        .select(selectDelegate);
}
exports.select = select;
function selectValue(selectValueDelegate) {
    return QueryUtil.newInstance()
        .selectValue(selectValueDelegate);
}
exports.selectValue = selectValue;
//# sourceMappingURL=convenience.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./convenience */ "./node_modules/@squill/squill/dist/unified-query/convenience.js"));
__export(__webpack_require__(/*! ./query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js"));
const QueryUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/unified-query/util/index.js");
exports.QueryUtil = QueryUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/query-impl.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/query-impl.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @todo Rename to `UnifiedQueryUtil` or something
 */
const QueryUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/unified-query/util/index.js");
const query_base_1 = __webpack_require__(/*! ../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const compound_query_1 = __webpack_require__(/*! ../compound-query */ "./node_modules/@squill/squill/dist/compound-query/index.js");
const execution_1 = __webpack_require__(/*! ../execution */ "./node_modules/@squill/squill/dist/execution/index.js");
class Query {
    constructor(data, extraData) {
        this.fromClause = data.fromClause;
        this.selectClause = data.selectClause;
        this.limitClause = data.limitClause;
        this.compoundQueryClause = data.compoundQueryClause;
        this.compoundQueryLimitClause = data.compoundQueryLimitClause;
        this.mapDelegate = data.mapDelegate;
        this.groupByClause = data.groupByClause;
        this.whereClause = extraData.whereClause;
        this.havingClause = extraData.havingClause;
        this.orderByClause = extraData.orderByClause;
        this.compoundQueryOrderByClause = extraData.compoundQueryOrderByClause;
        this.isDistinct = extraData.isDistinct;
    }
    limit(maxRowCount) {
        return QueryUtil.limit(this, maxRowCount);
    }
    offset(offset) {
        return QueryUtil.offset(this, offset);
    }
    compoundQueryLimit(maxRowCount) {
        return QueryUtil.compoundQueryLimit(this, maxRowCount);
    }
    compoundQueryOffset(offset) {
        return QueryUtil.compoundQueryOffset(this, offset);
    }
    requireOuterQueryJoins(...aliasedTables) {
        return QueryUtil.requireOuterQueryJoins(this, ...aliasedTables);
    }
    requireNullableOuterQueryJoins(...aliasedTables) {
        return QueryUtil.requireNullableOuterQueryJoins(this, ...aliasedTables);
    }
    from(aliasedTable) {
        return QueryUtil.from(this, aliasedTable);
    }
    crossJoin(aliasedTable) {
        return QueryUtil.crossJoin(this, aliasedTable);
    }
    groupBy(groupByDelegate) {
        return QueryUtil.groupBy(this, groupByDelegate);
    }
    having(havingDelegate) {
        return QueryUtil.having(this, havingDelegate);
    }
    innerJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        return QueryUtil.innerJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
    }
    innerJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
        return QueryUtil.innerJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
    }
    innerJoin(aliasedTable, onDelegate) {
        return QueryUtil.innerJoin(this, aliasedTable, onDelegate);
    }
    leftJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        return QueryUtil.leftJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
    }
    leftJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
        return QueryUtil.leftJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
    }
    leftJoin(aliasedTable, onDelegate) {
        return QueryUtil.leftJoin(this, aliasedTable, onDelegate);
    }
    orderBy(orderByDelegate) {
        return QueryUtil.orderBy(this, orderByDelegate);
    }
    selectValue(selectValueDelegate) {
        return QueryUtil.selectValue(this, selectValueDelegate);
    }
    select(selectDelegate) {
        return QueryUtil.select(this, selectDelegate);
    }
    compoundQueryOrderBy(compoundQueryOrderByDelegate) {
        return QueryUtil.compoundQueryOrderBy(this, compoundQueryOrderByDelegate);
    }
    unionDistinct(targetQuery) {
        return QueryUtil.compoundQuery(this, compound_query_1.CompoundQueryType.UNION, true, targetQuery);
    }
    unionAll(targetQuery) {
        return QueryUtil.compoundQuery(this, compound_query_1.CompoundQueryType.UNION, false, targetQuery);
    }
    whereEqCandidateKey(
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqCandidateKey(this, ...args);
    }
    whereEqColumns(
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqColumns(this, ...args);
    }
    whereEqInnerQueryPrimaryKey(srcDelegate, dstDelegate) {
        return QueryUtil.whereEqInnerQueryPrimaryKey(this, srcDelegate, dstDelegate);
    }
    whereEqOuterQueryPrimaryKey(
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate, dstDelegate) {
        return QueryUtil.whereEqOuterQueryPrimaryKey(this, srcDelegate, dstDelegate);
    }
    whereEqPrimaryKey(
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqPrimaryKey(this, ...args);
    }
    whereEqSuperKey(
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEqSuperKey(this, ...args);
    }
    whereEq(
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereEq(this, ...args);
    }
    whereIsNotNull(whereIsNotNullDelegate) {
        return QueryUtil.whereIsNotNull(this, whereIsNotNullDelegate);
    }
    whereIsNull(whereIsNullDelegate) {
        return QueryUtil.whereIsNull(this, whereIsNullDelegate);
    }
    whereNullSafeEq(
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        return QueryUtil.whereNullSafeEq(this, ...args);
    }
    where(whereDelegate) {
        return QueryUtil.where(this, whereDelegate);
    }
    as(alias) {
        return query_base_1.QueryBaseUtil.as(this, alias);
    }
    correlate() {
        return QueryUtil.correlate(this);
    }
    /**
     * @todo Maybe implement `selectDistinct()` as a convenience method?
     */
    distinct() {
        return QueryUtil.distinct(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  tsql.coalesce(myQuery.limit(1), myDefaultValue);
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).coalesce(myDefaultValue);
     * ```
     */
    coalesce(defaultValue) {
        return query_base_1.QueryBaseUtil.coalesce(this, defaultValue);
    }
    /**
     * Convenience method for,
     * ```ts
     *  tsql.throwIfNull(myQuery.limit(1));
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).throwIfNull();
     * ```
     */
    throwIfNull() {
        return query_base_1.QueryBaseUtil.throwIfNull(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).asc();
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).asc();
     * ```
     */
    asc() {
        return query_base_1.QueryBaseUtil.asc(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).desc();
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).desc();
     * ```
     */
    desc() {
        return query_base_1.QueryBaseUtil.desc(this);
    }
    /**
     * Convenience method for,
     * ```ts
     *  myQuery.limit(1).coalesce(null).sort(sortDirection);
     * ```
     *
     * Usage,
     * ```ts
     *  myQuery.limit(1).sort(sortDirection);
     * ```
     */
    sort(sortDirection) {
        return query_base_1.QueryBaseUtil.sort(this, sortDirection);
    }
    map(mapDelegate) {
        if (this.mapDelegate == undefined) {
            return QueryUtil.mapInitial(this, mapDelegate);
        }
        else {
            return QueryUtil.mapCompose(this, mapDelegate);
        }
    }
    fetchAllMapped(connection) {
        return execution_1.ExecutionUtil.fetchAllMapped(this, connection);
    }
    fetchAllUnmappedFlattened(connection) {
        return execution_1.ExecutionUtil.fetchAllUnmappedFlattened(this, connection);
    }
    fetchAllUnmapped(connection) {
        return execution_1.ExecutionUtil.fetchAllUnmapped(this, connection);
    }
    fetchAll(connection) {
        return execution_1.ExecutionUtil.fetchAll(this, connection);
    }
    fetchOneOrUndefined(connection) {
        return execution_1.ExecutionUtil.fetchOneOrUndefined(this, connection);
    }
    fetchOneOr(connection, defaultValue) {
        return execution_1.ExecutionUtil.fetchOneOr(this, connection, defaultValue);
    }
    fetchOne(connection) {
        return execution_1.ExecutionUtil.fetchOne(this, connection);
    }
    fetchValueArray(connection) {
        return execution_1.ExecutionUtil.fetchValueArray(this, connection);
    }
    fetchValueOrUndefined(connection) {
        return execution_1.ExecutionUtil.fetchValueOrUndefined(this, connection);
    }
    fetchValueOr(connection, defaultValue) {
        return execution_1.ExecutionUtil.fetchValueOr(this, connection, defaultValue);
    }
    fetchValue(connection) {
        return execution_1.ExecutionUtil.fetchValue(this, connection);
    }
    count(connection) {
        return execution_1.ExecutionUtil.count(this, connection);
    }
    paginate(connection, rawArgs) {
        return execution_1.ExecutionUtil.paginate(this, connection, rawArgs);
    }
    exists(connection) {
        return execution_1.ExecutionUtil.exists(this, connection);
    }
    assertExists(connection) {
        return execution_1.ExecutionUtil.assertExists(this, connection);
    }
    emulatedCursor(connection, 
    /**
     * If set, determines the starting `page` of the cursor.
     * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
     */
    rawArgs = {}) {
        return execution_1.ExecutionUtil.emulatedCursor(this, connection, rawArgs);
    }
    insert(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.insertSelect(connection, this, table, rowDelegate);
    }
    insertIgnore(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.insertIgnoreSelect(connection, this, table, rowDelegate);
    }
    replace(connection, table, rowDelegate) {
        return execution_1.ExecutionUtil.replaceSelect(connection, this, table, rowDelegate);
    }
}
exports.Query = Query;
//# sourceMappingURL=query-impl.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/constructor/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/constructor/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./new-instance */ "./node_modules/@squill/squill/dist/unified-query/util/constructor/new-instance.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/constructor/new-instance.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/constructor/new-instance.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function newInstance() {
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.newInstance(),
        selectClause: undefined,
        limitClause: undefined,
        compoundQueryClause: undefined,
        compoundQueryLimitClause: undefined,
        mapDelegate: undefined,
        groupByClause: undefined,
    }, {
        whereClause: undefined,
        havingClause: undefined,
        orderByClause: undefined,
        compoundQueryOrderByClause: undefined,
        isDistinct: false,
    });
    return result;
}
exports.newInstance = newInstance;
//# sourceMappingURL=new-instance.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/unified-query/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/unified-query/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function compoundQueryLimit(query, maxRowCount) {
    const compoundQueryLimitClause = limit_clause_1.LimitClauseUtil.limit(query.compoundQueryLimitClause, maxRowCount);
    const { fromClause, selectClause, limitClause, compoundQueryClause, 
    //compoundQueryLimitClause,
    mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQueryLimit = compoundQueryLimit;
//# sourceMappingURL=compound-query-limit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-limit */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/compound-query-limit.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function compoundQueryOffset(query, offset) {
    const compoundQueryLimitClause = limit_clause_1.LimitClauseUtil.offset(query.compoundQueryLimitClause, offset);
    const { fromClause, selectClause, limitClause, compoundQueryClause, 
    //compoundQueryLimitClause,
    mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQueryOffset = compoundQueryOffset;
//# sourceMappingURL=compound-query-offset.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-offset */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/compound-query-offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-order-by.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-order-by.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const compound_query_order_by_clause_1 = __webpack_require__(/*! ../../../compound-query-order-by-clause */ "./node_modules/@squill/squill/dist/compound-query-order-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function compoundQueryOrderBy(query, compoundQueryOrderByDelegate) {
    const compoundQueryOrderByClause = compound_query_order_by_clause_1.CompoundQueryOrderByClauseUtil.compoundQueryOrderBy(query.selectClause, query.compoundQueryOrderByClause, compoundQueryOrderByDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, 
    //compoundQueryOrderByClause,
    isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.compoundQueryOrderBy = compoundQueryOrderBy;
//# sourceMappingURL=compound-query-order-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const compound_query_clause_1 = __webpack_require__(/*! ../../../compound-query-clause */ "./node_modules/@squill/squill/dist/compound-query-clause/index.js");
function compoundQuery(query, compoundQueryType, isDistinct, targetQuery) {
    const { selectClause, compoundQueryClause, } = compound_query_clause_1.CompoundQueryClauseUtil.compoundQuery(query.fromClause, query.selectClause, query.compoundQueryClause, compoundQueryType, isDistinct, targetQuery);
    const { fromClause, 
    //selectClause,
    limitClause, 
    //compoundQueryClause,
    compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.compoundQuery = compoundQuery;
//# sourceMappingURL=compound-query.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/correlate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/correlate.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
/**
 * @todo A reference to the `query` needs to be added to the following,
 * + `OnDelegate`
 * + `HavingDelegate`
 * + `OrderByDelegate`
 * + `SelectDelegate`
 * + `WhereDelegate`
 *
 * Basically, anywhere a correlated subquery is allowed.
 */
function correlate(query) {
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.correlate(query.fromClause),
        selectClause: undefined,
        limitClause: undefined,
        compoundQueryClause: undefined,
        compoundQueryLimitClause: undefined,
        mapDelegate: undefined,
        groupByClause: undefined,
    }, {
        whereClause: undefined,
        havingClause: undefined,
        orderByClause: undefined,
        compoundQueryOrderByClause: undefined,
        isDistinct: false,
    });
    return result;
}
exports.correlate = correlate;
//# sourceMappingURL=correlate.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/cross-join.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/cross-join.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function crossJoin(query, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.crossJoin(query.fromClause, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.crossJoin = crossJoin;
//# sourceMappingURL=cross-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/distinct.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/distinct.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function distinct(query) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, } = query;
    const result = new query_impl_1.Query(
    /**
     * If you replace the below object literal with
     * just the variable `query`, you will cause `tsc`
     * to OOM.
     */
    //query
    {
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct: true,
    });
    return result;
}
exports.distinct = distinct;
//# sourceMappingURL=distinct.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/from.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/from.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function from(query, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.from(query.fromClause, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/group-by.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/group-by.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const group_by_clause_1 = __webpack_require__(/*! ../../../group-by-clause */ "./node_modules/@squill/squill/dist/group-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function groupBy(query, groupByDelegate) {
    const groupByClause = group_by_clause_1.GroupByClauseUtil.groupBy(query.fromClause, query.groupByClause, groupByDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.groupBy = groupBy;
//# sourceMappingURL=group-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/having.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/having.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const having_clause_1 = __webpack_require__(/*! ../../../having-clause */ "./node_modules/@squill/squill/dist/having-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function having(query, havingDelegate) {
    const havingClause = having_clause_1.HavingClauseUtil.having(query.fromClause, query.groupByClause, query.havingClause, havingDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.having = having;
//# sourceMappingURL=having.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./compound-query-limit */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-limit/index.js"));
__export(__webpack_require__(/*! ./compound-query-offset */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-offset/index.js"));
__export(__webpack_require__(/*! ./limit */ "./node_modules/@squill/squill/dist/unified-query/util/operation/limit/index.js"));
__export(__webpack_require__(/*! ./map */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/index.js"));
__export(__webpack_require__(/*! ./offset */ "./node_modules/@squill/squill/dist/unified-query/util/operation/offset/index.js"));
__export(__webpack_require__(/*! ./compound-query-order-by */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query-order-by.js"));
__export(__webpack_require__(/*! ./compound-query */ "./node_modules/@squill/squill/dist/unified-query/util/operation/compound-query.js"));
__export(__webpack_require__(/*! ./correlate */ "./node_modules/@squill/squill/dist/unified-query/util/operation/correlate.js"));
__export(__webpack_require__(/*! ./cross-join */ "./node_modules/@squill/squill/dist/unified-query/util/operation/cross-join.js"));
__export(__webpack_require__(/*! ./distinct */ "./node_modules/@squill/squill/dist/unified-query/util/operation/distinct.js"));
__export(__webpack_require__(/*! ./from */ "./node_modules/@squill/squill/dist/unified-query/util/operation/from.js"));
__export(__webpack_require__(/*! ./group-by */ "./node_modules/@squill/squill/dist/unified-query/util/operation/group-by.js"));
__export(__webpack_require__(/*! ./having */ "./node_modules/@squill/squill/dist/unified-query/util/operation/having.js"));
__export(__webpack_require__(/*! ./inner-join-using-candidate-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./inner-join-using-primary-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./inner-join */ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join.js"));
__export(__webpack_require__(/*! ./left-join-using-candidate-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-candidate-key.js"));
__export(__webpack_require__(/*! ./left-join-using-primary-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-primary-key.js"));
__export(__webpack_require__(/*! ./left-join */ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join.js"));
__export(__webpack_require__(/*! ./order-by */ "./node_modules/@squill/squill/dist/unified-query/util/operation/order-by.js"));
__export(__webpack_require__(/*! ./require-nullable-outer-query-joins */ "./node_modules/@squill/squill/dist/unified-query/util/operation/require-nullable-outer-query-joins.js"));
__export(__webpack_require__(/*! ./require-outer-query-joins */ "./node_modules/@squill/squill/dist/unified-query/util/operation/require-outer-query-joins.js"));
__export(__webpack_require__(/*! ./select-value */ "./node_modules/@squill/squill/dist/unified-query/util/operation/select-value.js"));
__export(__webpack_require__(/*! ./select */ "./node_modules/@squill/squill/dist/unified-query/util/operation/select.js"));
__export(__webpack_require__(/*! ./where-eq-candidate-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-candidate-key.js"));
__export(__webpack_require__(/*! ./where-eq-columns */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-columns.js"));
__export(__webpack_require__(/*! ./where-eq-inner-query-primary-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-outer-query-primary-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-primary-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-primary-key.js"));
__export(__webpack_require__(/*! ./where-eq-super-key */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-super-key.js"));
__export(__webpack_require__(/*! ./where-eq */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq.js"));
__export(__webpack_require__(/*! ./where-is-not-null */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-not-null.js"));
__export(__webpack_require__(/*! ./where-is-null */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-null.js"));
__export(__webpack_require__(/*! ./where-null-safe-eq */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-null-safe-eq.js"));
__export(__webpack_require__(/*! ./where */ "./node_modules/@squill/squill/dist/unified-query/util/operation/where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-candidate-key.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-candidate-key.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function innerJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
//# sourceMappingURL=inner-join-using-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-primary-key.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join-using-primary-key.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function innerJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
//# sourceMappingURL=inner-join-using-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/inner-join.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "./node_modules/@squill/squill/dist/on-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function innerJoin(query, aliasedTable, onDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.innerJoin(query.fromClause, aliasedTable, columns => {
            const rawOnClause = onDelegate(columns);
            /**
             * @todo Investigate assignability
             */
            const result = rawOnClause;
            on_clause_1.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
            return result;
        }),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.innerJoin = innerJoin;
//# sourceMappingURL=inner-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-candidate-key.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-candidate-key.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function leftJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
//# sourceMappingURL=left-join-using-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-primary-key.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/left-join-using-primary-key.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function leftJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
//# sourceMappingURL=left-join-using-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/left-join.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/left-join.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const on_clause_1 = __webpack_require__(/*! ../../../on-clause */ "./node_modules/@squill/squill/dist/on-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const predicate_1 = __webpack_require__(/*! ../predicate */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js");
function leftJoin(query, aliasedTable, onDelegate) {
    predicate_1.assertValidJoinTarget(query, aliasedTable);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.leftJoin(query.fromClause, aliasedTable, columns => {
            const rawOnClause = onDelegate(columns);
            /**
             * @todo Investigate assignability
             */
            const result = rawOnClause;
            on_clause_1.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
            return result;
        }),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.leftJoin = leftJoin;
//# sourceMappingURL=left-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/limit/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/limit/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./limit */ "./node_modules/@squill/squill/dist/unified-query/util/operation/limit/limit.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/limit/limit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/limit/limit.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function limit(query, maxRowCount) {
    const limitClause = limit_clause_1.LimitClauseUtil.limit(query.limitClause, maxRowCount);
    const { fromClause, selectClause, 
    //limitClause,
    compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.limit = limit;
//# sourceMappingURL=limit.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/map/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./map-compose */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-compose.js"));
__export(__webpack_require__(/*! ./map-initial */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-initial.js"));
__export(__webpack_require__(/*! ./map */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-compose.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-compose.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const map_delegate_1 = __webpack_require__(/*! ../../../../map-delegate */ "./node_modules/@squill/squill/dist/map-delegate/index.js");
function mapCompose(query, mapDelegate) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
    //mapDelegate,
    groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate: (map_delegate_1.MapDelegateUtil.compose(
        /**
         * @todo Clean up?
         */
        query.mapDelegate, mapDelegate)),
        groupByClause,
    }, query);
    return result;
}
exports.mapCompose = mapCompose;
//# sourceMappingURL=map-compose.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-initial.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-initial.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function mapInitial(query, mapDelegate) {
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
    //mapDelegate,
    groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate: mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.mapInitial = mapInitial;
//# sourceMappingURL=map-initial.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/map/map.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const map_initial_1 = __webpack_require__(/*! ./map-initial */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-initial.js");
const map_compose_1 = __webpack_require__(/*! ./map-compose */ "./node_modules/@squill/squill/dist/unified-query/util/operation/map/map-compose.js");
/**
 * @todo Clean up usages of `any`
 *
 * Removing the usages of `any` will cause build times to jump 30s!
 */
function map(query, mapDelegate) {
    if (query.mapDelegate == undefined) {
        return map_initial_1.mapInitial(query, mapDelegate);
    }
    else {
        return map_compose_1.mapCompose(query, mapDelegate);
    }
}
exports.map = map;
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/offset/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/offset/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./offset */ "./node_modules/@squill/squill/dist/unified-query/util/operation/offset/offset.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/offset/offset.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/offset/offset.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limit_clause_1 = __webpack_require__(/*! ../../../../limit-clause */ "./node_modules/@squill/squill/dist/limit-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function offset(query, offset) {
    const limitClause = limit_clause_1.LimitClauseUtil.offset(query.limitClause, offset);
    const { fromClause, selectClause, 
    //limitClause,
    compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.offset = offset;
//# sourceMappingURL=offset.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/order-by.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/order-by.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const order_by_clause_1 = __webpack_require__(/*! ../../../order-by-clause */ "./node_modules/@squill/squill/dist/order-by-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const correlate_1 = __webpack_require__(/*! ./correlate */ "./node_modules/@squill/squill/dist/unified-query/util/operation/correlate.js");
function orderBy(query, orderByDelegate) {
    const orderByClause = order_by_clause_1.OrderByClauseUtil.orderBy(query.fromClause, query.groupByClause, query.selectClause, query.orderByClause, (columns) => {
        return orderByDelegate(columns, correlate_1.correlate(query));
    });
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.orderBy = orderBy;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/require-nullable-outer-query-joins.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/require-nullable-outer-query-joins.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function requireNullableOuterQueryJoins(query, ...aliasedTables) {
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.requireNullableOuterQueryJoins(query.fromClause, ...aliasedTables),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
//# sourceMappingURL=require-nullable-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/require-outer-query-joins.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/require-outer-query-joins.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function requireOuterQueryJoins(query, ...aliasedTables) {
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause: from_clause_1.FromClauseUtil.requireOuterQueryJoins(query.fromClause, ...aliasedTables),
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, query);
    return result;
}
exports.requireOuterQueryJoins = requireOuterQueryJoins;
//# sourceMappingURL=require-outer-query-joins.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/select-value.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/select-value.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
const select_1 = __webpack_require__(/*! ./select */ "./node_modules/@squill/squill/dist/unified-query/util/operation/select.js");
/**
 * @todo Rename to `selectScalar`?
 */
function selectValue(query, selectValueDelegate) {
    return select_1.select(query, (columns, subquery) => select_clause_1.SelectClauseUtil.valueFromBuiltInExpr(selectValueDelegate(columns, subquery)));
}
exports.selectValue = selectValue;
//# sourceMappingURL=select-value.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/select.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/select.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const select_clause_1 = __webpack_require__(/*! ../../../select-clause */ "./node_modules/@squill/squill/dist/select-clause/index.js");
const query_base_1 = __webpack_require__(/*! ../../../query-base */ "./node_modules/@squill/squill/dist/query-base/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const correlate_1 = __webpack_require__(/*! ./correlate */ "./node_modules/@squill/squill/dist/unified-query/util/operation/correlate.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function select(query, selectDelegate
//selectDelegate : SelectDelegate<QueryT["fromClause"], QueryT["selectClause"], SelectsT>
) {
    if (!query_base_1.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
        throw new Error(`Cannot SELECT after COMPOUND QUERY clause; this will change the number of columns`);
    }
    //const correlated = correlate<QueryT>(query);
    const selectClause = select_clause_1.SelectClauseUtil.select(query.fromClause, query.groupByClause, query.selectClause, (columns) => {
        return selectDelegate(columns, correlate_1.correlate(query));
    });
    const { fromClause, 
    //selectClause,
    limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause: (groupByClause != undefined ?
            groupByClause :
            selectClause.some(selectItem => (built_in_expr_1.BuiltInExprUtil.isBuiltInExpr(selectItem) &&
                built_in_expr_1.BuiltInExprUtil.isAggregate(selectItem))) ?
                [] :
                undefined),
    }, query);
    return result;
}
exports.select = select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-candidate-key.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-candidate-key.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEqCandidateKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqCandidateKey(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqCandidateKey = whereEqCandidateKey;
//# sourceMappingURL=where-eq-candidate-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-columns.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-columns.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEqColumns(query, 
/**
 * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqColumns(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqColumns = whereEqColumns;
//# sourceMappingURL=where-eq-columns.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-inner-query-primary-key.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEqInnerQueryPrimaryKey(query, srcDelegate, dstDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqInnerQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
//# sourceMappingURL=where-eq-inner-query-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-outer-query-primary-key.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEqOuterQueryPrimaryKey(query, 
/**
 * This construction effectively makes it impossible for
 * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
srcDelegate, dstDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqOuterQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
//# sourceMappingURL=where-eq-outer-query-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-primary-key.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-primary-key.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEqPrimaryKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqPrimaryKey(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqPrimaryKey = whereEqPrimaryKey;
//# sourceMappingURL=where-eq-primary-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-super-key.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq-super-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
const expr_library_1 = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
function whereEqSuperKey(query, 
/**
 * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEqSuperKey(query.fromClause, query.whereClause, expr_library_1.eqSuperKey, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEqSuperKey = whereEqSuperKey;
//# sourceMappingURL=where-eq-super-key.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-eq.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereEq(query, 
/**
 * This construction effectively makes it impossible for `WhereEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereEq(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereEq = whereEq;
//# sourceMappingURL=where-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-not-null.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-not-null.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereIsNotNull(query, whereIsNotNullDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereIsNotNull(query.fromClause, query.whereClause, whereIsNotNullDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereIsNotNull = whereIsNotNull;
//# sourceMappingURL=where-is-not-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-null.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-is-null.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereIsNull(query, whereIsNullDelegate) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereIsNull(query.fromClause, query.whereClause, whereIsNullDelegate);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereIsNull = whereIsNull;
//# sourceMappingURL=where-is-null.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where-null-safe-eq.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where-null-safe-eq.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function whereNullSafeEq(query, 
/**
 * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
 * to return a union type.
 *
 * This is unfortunate but a necessary compromise for now.
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
 *
 * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
 */
...args) {
    const { fromClause, whereClause, } = from_clause_1.FromClauseUtil.whereNullSafeEq(query.fromClause, query.whereClause, ...args);
    const { 
    //fromClause,
    selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.whereNullSafeEq = whereNullSafeEq;
//# sourceMappingURL=where-null-safe-eq.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/operation/where.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/operation/where.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const where_clause_1 = __webpack_require__(/*! ../../../where-clause */ "./node_modules/@squill/squill/dist/where-clause/index.js");
const query_impl_1 = __webpack_require__(/*! ../../query-impl */ "./node_modules/@squill/squill/dist/unified-query/query-impl.js");
function where(query, whereDelegate) {
    const whereClause = where_clause_1.WhereClauseUtil.where(query.fromClause, query.whereClause, whereDelegate);
    const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
    const result = new query_impl_1.Query({
        fromClause,
        selectClause,
        limitClause,
        compoundQueryClause,
        compoundQueryLimitClause,
        mapDelegate,
        groupByClause,
    }, {
        whereClause,
        havingClause,
        orderByClause,
        compoundQueryOrderByClause,
        isDistinct,
    });
    return result;
}
exports.where = where;
//# sourceMappingURL=where.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/predicate/assert-valid-current-join.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/predicate/assert-valid-current-join.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
function assertValidJoinTarget(query, aliasedTable) {
    from_clause_1.FromClauseUtil.assertValidCurrentJoinBase(query.fromClause, aliasedTable);
    from_clause_1.FromClauseUtil.assertNoUsedRef(aliasedTable);
    from_clause_1.FromClauseUtil.assertNotLateral(aliasedTable);
}
exports.assertValidJoinTarget = assertValidJoinTarget;
//# sourceMappingURL=assert-valid-current-join.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/unified-query/util/predicate/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-valid-current-join */ "./node_modules/@squill/squill/dist/unified-query/util/predicate/assert-valid-current-join.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/update/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@squill/squill/dist/update/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UpdateUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/update/util/index.js");
exports.UpdateUtil = UpdateUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/update/util/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/update/util/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/update/util/operation/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/update/util/operation/clean-assignment-map.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/update/util/operation/clean-assignment-map.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
function cleanAssignmentMap(table, raw) {
    const result = {};
    const allowed = used_ref_1.UsedRefUtil.fromColumnMap(table.columns);
    for (const columnAlias of Object.keys(raw)) {
        const customExpr = raw[columnAlias];
        if (customExpr === undefined) {
            continue;
        }
        if (table.mutableColumns.indexOf(columnAlias) < 0) {
            //This columnAlias is not mutable...
            if (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
                Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias)) {
                throw new Error(`${table.alias}.${columnAlias} is not mutable`);
            }
            else {
                //Just some random extra property that is not a `columnAlias` of `TableT`.
                //This probably only got through because TS does not have exact types at the moment.
                continue;
            }
        }
        result[columnAlias] = built_in_expr_1.BuiltInExprUtil.fromCustomExpr_MapCorrelated(table.columns[columnAlias], allowed, customExpr);
    }
    /*
    if (Object.keys(result).length == 0) {
        //The user specified an empty assignment map?
        //Very weird...
        if (table.mutableColumns.length == 0) {
            throw new Error(`${table.alias} has no mutable columns`);
        }
        const firstColumnAlias = table.mutableColumns[0];
        const firstColumn = table.columns[firstColumnAlias];
        //We specify a no-op assignment, to prevent the `UpdateConnection` from crashing
        result[firstColumnAlias as keyof typeof result] = firstColumn as any;
    }
    */
    return result;
}
exports.cleanAssignmentMap = cleanAssignmentMap;
//# sourceMappingURL=clean-assignment-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/update/util/operation/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/update/util/operation/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./clean-assignment-map */ "./node_modules/@squill/squill/dist/update/util/operation/clean-assignment-map.js"));
__export(__webpack_require__(/*! ./set */ "./node_modules/@squill/squill/dist/update/util/operation/set.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/update/util/operation/set.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/update/util/operation/set.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const clean_assignment_map_1 = __webpack_require__(/*! ./clean-assignment-map */ "./node_modules/@squill/squill/dist/update/util/operation/clean-assignment-map.js");
function set(table, assignmentMapDelegate) {
    const raw = assignmentMapDelegate(table.columns);
    return clean_assignment_map_1.cleanAssignmentMap(table, raw);
}
exports.set = set;
//# sourceMappingURL=set.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UsedRefUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/used-ref/util/index.js");
exports.UsedRefUtil = UsedRefUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-map.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-map.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function fromColumnMap(map) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.fromColumnMap(map),
    };
    return result;
}
exports.fromColumnMap = fromColumnMap;
//# sourceMappingURL=from-column-map.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-ref.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-ref.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumnRef(ref) {
    const result = {
        __contravarianceMarker: () => { },
        columns: ref,
    };
    return result;
}
exports.fromColumnRef = fromColumnRef;
//# sourceMappingURL=from-column-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function fromColumn(column) {
    const result = {
        __contravarianceMarker: () => { },
        columns: {
            [column.tableAlias]: {
                [column.columnAlias]: column
            }
        },
    };
    return result;
}
exports.fromColumn = fromColumn;
//# sourceMappingURL=from-column.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-from-clause.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/from-from-clause.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_join_array_1 = __webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-join-array.js");
function fromFromClause(fromClause) {
    return from_join_array_1.fromJoinArray(fromClause.outerQueryJoins == undefined ?
        [] :
        fromClause.outerQueryJoins);
}
exports.fromFromClause = fromFromClause;
//# sourceMappingURL=from-from-clause.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-join-array.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/from-join-array.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function fromJoinArray(joins) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(joins),
    };
    return result;
}
exports.fromJoinArray = fromJoinArray;
//# sourceMappingURL=from-join-array.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/constructor/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/constructor/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./from-column-map */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-map.js"));
__export(__webpack_require__(/*! ./from-column-ref */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column-ref.js"));
__export(__webpack_require__(/*! ./from-column */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-column.js"));
__export(__webpack_require__(/*! ./from-from-clause */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-from-clause.js"));
__export(__webpack_require__(/*! ./from-join-array */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/from-join-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./constructor */ "./node_modules/@squill/squill/dist/used-ref/util/constructor/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/used-ref/util/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/@squill/squill/dist/used-ref/util/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/used-ref/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/operation/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/operation/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./intersect */ "./node_modules/@squill/squill/dist/used-ref/util/operation/intersect.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/operation/intersect.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/operation/intersect.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function intersect(...arr) {
    let columns = {};
    for (const u of arr) {
        columns = column_identifier_ref_1.ColumnIdentifierRefUtil.intersect(columns, u.columns);
    }
    const result = {
        __contravarianceMarker: () => { },
        columns,
    };
    return result;
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-allowed.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-allowed.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
/**
 * @todo Better naming
 *
 * @param allowed - Which references are allowed
 * @param used - Which references were actually used
 */
function assertAllowed(allowed, used) {
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(allowed.columns, column_identifier_1.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
}
exports.assertAllowed = assertAllowed;
//# sourceMappingURL=assert-allowed.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-empty.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-empty.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
const column_identifier_1 = __webpack_require__(/*! ../../../column-identifier */ "./node_modules/@squill/squill/dist/column-identifier/index.js");
/**
 * @todo Better naming
 *
 * @param used - Which references were actually used
 */
function assertEmpty(used) {
    column_identifier_ref_1.ColumnIdentifierRefUtil.assertHasColumnIdentifiers({}, column_identifier_1.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
}
exports.assertEmpty = assertEmpty;
//# sourceMappingURL=assert-empty.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/predicate/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/predicate/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./assert-allowed */ "./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-allowed.js"));
__export(__webpack_require__(/*! ./assert-empty */ "./node_modules/@squill/squill/dist/used-ref/util/predicate/assert-empty.js"));
__export(__webpack_require__(/*! ./is-used-ref */ "./node_modules/@squill/squill/dist/used-ref/util/predicate/is-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/predicate/is-used-ref.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/predicate/is-used-ref.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const type_util_1 = __webpack_require__(/*! ../../../type-util */ "./node_modules/@squill/squill/dist/type-util/index.js");
//import {ColumnIdentifierRefUtil} from "../../../column-identifier-ref";
/**
 * Does not actually check that `x.columns` is a `ColumnIdentifierRef`.
 *
 * @todo Consider adding check for increased type safety.
 */
function isUsedRef(x) {
    if (!type_util_1.isObjectWithOwnEnumerableKeys()(x, [
        "__contravarianceMarker",
        "columns",
    ])) {
        return false;
    }
    return ((typeof x.__contravarianceMarker == "function") // &&
    //(ColumnIdentifierRefUtil.isColumnIdentifierRef(x.usedRef))
    );
}
exports.isUsedRef = isUsedRef;
//# sourceMappingURL=is-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/query/extract-column-identifier.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/query/extract-column-identifier.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_identifier_ref_1 = __webpack_require__(/*! ../../../column-identifier-ref */ "./node_modules/@squill/squill/dist/column-identifier-ref/index.js");
function extractColumnIdentifiers(usedRef, columnIdentifiers) {
    const result = {
        __contravarianceMarker: () => { },
        columns: column_identifier_ref_1.ColumnIdentifierRefUtil.extractColumnIdentifiers(usedRef.columns, columnIdentifiers),
    };
    return result;
}
exports.extractColumnIdentifiers = extractColumnIdentifiers;
//# sourceMappingURL=extract-column-identifier.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/used-ref/util/query/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/used-ref/util/query/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./extract-column-identifier */ "./node_modules/@squill/squill/dist/used-ref/util/query/extract-column-identifier.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/value-expr/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/value-expr/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ValueExprUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/value-expr/util/index.js");
exports.ValueExprUtil = ValueExprUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/value-expr/util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/value-expr/util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WhereClauseUtil = __webpack_require__(/*! ./util */ "./node_modules/@squill/squill/dist/where-clause/util/index.js");
exports.WhereClauseUtil = WhereClauseUtil;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/util/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/util/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operation */ "./node_modules/@squill/squill/dist/where-clause/util/operation/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/@squill/squill/dist/where-clause/util/query/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/util/operation/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/util/operation/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./where */ "./node_modules/@squill/squill/dist/where-clause/util/operation/where.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/util/operation/where.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/util/operation/where.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const column_ref_1 = __webpack_require__(/*! ../../../column-ref */ "./node_modules/@squill/squill/dist/column-ref/index.js");
const ExprLib = __webpack_require__(/*! ../../../expr-library */ "./node_modules/@squill/squill/dist/expr-library/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./node_modules/@squill/squill/dist/where-clause/util/query/index.js");
const used_ref_1 = __webpack_require__(/*! ../../../used-ref */ "./node_modules/@squill/squill/dist/used-ref/index.js");
const built_in_expr_1 = __webpack_require__(/*! ../../../built-in-expr */ "./node_modules/@squill/squill/dist/built-in-expr/index.js");
const expr_1 = __webpack_require__(/*! ../../../expr */ "./node_modules/@squill/squill/dist/expr/index.js");
/**
 * Returns the MySQL equivalent of `whereClause AND whereDelegate(columns)`
 *
 * @param fromClause
 * @param whereClause
 * @param whereDelegate
 */
function where(fromClause, whereClause, whereDelegate) {
    const columns = query_1.allowedColumnRef(fromClause);
    /**
     * Explicit type annotation required or `tsc` crashes
     */
    const operand = whereDelegate(column_ref_1.ColumnRefUtil.tryFlatten(columns));
    used_ref_1.UsedRefUtil.assertAllowed({ columns }, built_in_expr_1.BuiltInExprUtil.usedRef(operand));
    const result = (whereClause == undefined ?
        expr_1.ExprUtil.fromBuiltInExpr(operand) :
        ExprLib.and(whereClause, operand));
    return result;
}
exports.where = where;
//# sourceMappingURL=where.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/util/query/allowed-used-ref.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/util/query/allowed-used-ref.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const from_clause_1 = __webpack_require__(/*! ../../../from-clause */ "./node_modules/@squill/squill/dist/from-clause/index.js");
function allowedColumnRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
}
exports.allowedColumnRef = allowedColumnRef;
function allowedUsedRef(fromClause) {
    return from_clause_1.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
}
exports.allowedUsedRef = allowedUsedRef;
//# sourceMappingURL=allowed-used-ref.js.map

/***/ }),

/***/ "./node_modules/@squill/squill/dist/where-clause/util/query/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@squill/squill/dist/where-clause/util/query/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allowed-used-ref */ "./node_modules/@squill/squill/dist/where-clause/util/query/allowed-used-ref.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/type-mapping/dist/accessor-util/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/type-mapping/dist/accessor-util/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isAccessorDescriptor(descriptor) {
    if (descriptor == null) {
        return false;
    }
    return (descriptor.hasOwnProperty("get") &&
        descriptor.hasOwnProperty("set") &&
        descriptor.hasOwnProperty("configurable") &&
        descriptor.hasOwnProperty("enumerable") &&
        (typeof descriptor.get == "function" ||
            typeof descriptor.get == "undefined") &&
        (typeof descriptor.set == "function" ||
            typeof descriptor.set == "undefined") &&
        typeof descriptor.configurable == "boolean" &&
        typeof descriptor.enumerable == "boolean");
}
exports.isAccessorDescriptor = isAccessorDescriptor;
var BUILT_IN_PROTOTYPES = [
    Object.prototype,
    Date.prototype,
];
function isBuiltInPrototype(obj) {
    return BUILT_IN_PROTOTYPES.indexOf(obj) >= 0;
}
function getOwnAccessors(obj) {
    var arr = Object.getOwnPropertyNames(obj);
    var result = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var k = arr_1[_i];
        var descriptor = Object.getOwnPropertyDescriptor(obj, k);
        if (isAccessorDescriptor(descriptor)) {
            result.push({
                name: k,
                descriptor: descriptor,
            });
        }
    }
    return result;
}
exports.getOwnAccessors = getOwnAccessors;
function getAllAccessors(obj) {
    var result = [];
    while (!isBuiltInPrototype(obj)) {
        result.push.apply(result, getOwnAccessors(obj));
        obj = Object.getPrototypeOf(obj);
    }
    return result;
}
exports.getAllAccessors = getAllAccessors;
function getAccessor(obj, name) {
    if (isBuiltInPrototype(obj)) {
        return undefined;
    }
    var potentialResult = Object.getOwnPropertyDescriptor(obj, name);
    if (potentialResult == undefined || !isAccessorDescriptor(potentialResult)) {
        return getAccessor(Object.getPrototypeOf(obj), name);
    }
    return potentialResult;
}
exports.getAccessor = getAccessor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/array-buffer-util/equals.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/array-buffer-util/equals.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//https://stackoverflow.com/questions/21553528/how-to-test-for-equality-in-arraybuffer-dataview-and-typedarray
function dataViewsAreEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for (var i = 0; i < a.byteLength; ++i) {
        if (a.getUint8(i) !== b.getUint8(i)) {
            return false;
        }
    }
    return true;
}
/**
 * Allows you to compare,
 * + `Buffer` to `Buffer`
 * + `Uint8Array` to `Uint8Array`
 * + `Buffer` to `Uint8Array`
 * + `Uint8Array` to `Buffer`
 */
function equals(a, b) {
    return dataViewsAreEqual(new DataView(a.buffer, a.byteOffset, a.byteLength), new DataView(b.buffer, b.byteOffset, b.byteLength));
}
exports.equals = equals;
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/array-buffer-util/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/array-buffer-util/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./equals */ "./node_modules/type-mapping/dist/array-buffer-util/equals.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/array-util/array-fill.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/array-util/array-fill.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Replaces all elements of `arr` with `value`
*/
function arrayFill(arr, value) {
    for (var i = 0; i < arr.length; ++i) {
        arr[i] = value;
    }
    return arr;
}
exports.arrayFill = arrayFill;
//# sourceMappingURL=array-fill.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/array-util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/array-util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./array-fill */ "./node_modules/type-mapping/dist/array-util/array-fill.js"));
__export(__webpack_require__(/*! ./remove-duplicate-elements */ "./node_modules/type-mapping/dist/array-util/remove-duplicate-elements.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/array-util/remove-duplicate-elements.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/array-util/remove-duplicate-elements.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
/**
 * Removes duplicates from `arr`.
 * Preserves the order of elements.
 *
 * A "duplicate" is an element that is `===` to another element
 * with a lower index in `arr`.
 *
 * Given the following,
 * ```ts
 * [1,2,1]
 * ```
 * The first `1` is **NOT** a duplicate.
 * The second `1` is a duplicate.
 *
 * @param arr
 */
function removeDuplicateElements(arr) {
    var result = [];
    var _loop_1 = function (element) {
        if (result.some(function (r) { return type_util_1.strictEqual(r, element); })) {
            return "continue";
        }
        result.push(element);
    };
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var element = arr_1[_i];
        _loop_1(element);
    }
    return result;
}
exports.removeDuplicateElements = removeDuplicateElements;
//# sourceMappingURL=remove-duplicate-elements.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/arithmetic.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/arithmetic.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
function add(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) + BigInt(b);
            }
            else {
                return BigInt(a) + b;
            }
        }
        else {
            if (typeof b == "number") {
                return a + BigInt(b);
            }
            else {
                return a + b;
            }
        }
    }
    var result = jsbi_1.JSBI.add(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.add = add;
function addMany(a, b) {
    var rest = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        rest[_i - 2] = arguments[_i];
    }
    var result = add(a, b);
    for (var _a = 0, rest_1 = rest; _a < rest_1.length; _a++) {
        var ele = rest_1[_a];
        result = add(result, ele);
    }
    return result;
}
exports.addMany = addMany;
function sub(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) - BigInt(b);
            }
            else {
                return BigInt(a) - b;
            }
        }
        else {
            if (typeof b == "number") {
                return a - BigInt(b);
            }
            else {
                return a - b;
            }
        }
    }
    var result = jsbi_1.JSBI.subtract(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.sub = sub;
function mul(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) * BigInt(b);
            }
            else {
                return BigInt(a) * b;
            }
        }
        else {
            if (typeof b == "number") {
                return a * BigInt(b);
            }
            else {
                return a * b;
            }
        }
    }
    var result = jsbi_1.JSBI.multiply(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.mul = mul;
function div(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) / BigInt(b);
            }
            else {
                return BigInt(a) / b;
            }
        }
        else {
            if (typeof b == "number") {
                return a / BigInt(b);
            }
            else {
                return a / b;
            }
        }
    }
    var result = jsbi_1.JSBI.divide(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.div = div;
function mod(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) % BigInt(b);
            }
            else {
                return BigInt(a) % b;
            }
        }
        else {
            if (typeof b == "number") {
                return a % BigInt(b);
            }
            else {
                return a % b;
            }
        }
    }
    var result = jsbi_1.JSBI.remainder(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.mod = mod;
//# sourceMappingURL=arithmetic.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/as-int-n.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/as-int-n.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
function asIntN(n, x) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    return BigInt(jsbi_1.JSBI.asIntN(n, jsbi_1.JSBI.BigInt(x.toString())).toString());
}
exports.asIntN = asIntN;
//# sourceMappingURL=as-int-n.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/as-uint-n.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/as-uint-n.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
function asUintN(n, x) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    return BigInt(jsbi_1.JSBI.asUintN(n, jsbi_1.JSBI.BigInt(x.toString())).toString());
}
exports.asUintN = asUintN;
//# sourceMappingURL=as-uint-n.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/bitwise-operation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/bitwise-operation.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
function leftShift(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) << BigInt(b);
            }
            else {
                return BigInt(a) << b;
            }
        }
        else {
            if (typeof b == "number") {
                return a << BigInt(b);
            }
            else {
                return a << b;
            }
        }
    }
    var result = jsbi_1.JSBI.leftShift(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.leftShift = leftShift;
function signedRightShift(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) >> BigInt(b);
            }
            else {
                return BigInt(a) >> b;
            }
        }
        else {
            if (typeof b == "number") {
                return a >> BigInt(b);
            }
            else {
                return a >> b;
            }
        }
    }
    var result = jsbi_1.JSBI.signedRightShift(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.signedRightShift = signedRightShift;
function bitwiseAnd(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) & BigInt(b);
            }
            else {
                return BigInt(a) & b;
            }
        }
        else {
            if (typeof b == "number") {
                return a & BigInt(b);
            }
            else {
                return a & b;
            }
        }
    }
    var result = jsbi_1.JSBI.bitwiseAnd(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.bitwiseAnd = bitwiseAnd;
function bitwiseOr(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) | BigInt(b);
            }
            else {
                return BigInt(a) | b;
            }
        }
        else {
            if (typeof b == "number") {
                return a | BigInt(b);
            }
            else {
                return a | b;
            }
        }
    }
    var result = jsbi_1.JSBI.bitwiseOr(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.bitwiseOr = bitwiseOr;
function bitwiseXor(a, b) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            if (typeof b == "number") {
                return BigInt(a) ^ BigInt(b);
            }
            else {
                return BigInt(a) ^ b;
            }
        }
        else {
            if (typeof b == "number") {
                return a ^ BigInt(b);
            }
            else {
                return a ^ b;
            }
        }
    }
    var result = jsbi_1.JSBI.bitwiseXor(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
    return BigInt(result.toString());
}
exports.bitwiseXor = bitwiseXor;
function bitwiseNot(a) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (type_util_1.isBigIntNativelySupported()) {
        if (typeof a == "number") {
            return ~BigInt(a);
        }
        else {
            return ~a;
        }
    }
    var result = jsbi_1.JSBI.bitwiseNot(jsbi_1.JSBI.BigInt(a.toString()));
    return BigInt(result.toString());
}
exports.bitwiseNot = bitwiseNot;
//# sourceMappingURL=bitwise-operation.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/comparison.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/comparison.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
/**
    Assumes BigInt.toString() is implemented correctly.

    Assummes we won't get strings like,

    + "-0000"
    + "-qwerty"
    + "123.123"
*/
function compare(a, b) {
    if (type_util_1.isBigIntNativelySupported()) {
        return ((typeof a == "number" && isNaN(a)) ?
            NaN :
            (typeof b == "number" && isNaN(b)) ?
                NaN :
                a < b ?
                    -1 :
                    a > b ?
                        1 :
                        0);
    }
    if (typeof a == "number") {
        if (typeof b == "number") {
            return a - b;
        }
        else {
            var cmp = jsbi_1.JSBI.__compareToNumber(jsbi_1.JSBI.BigInt(b.toString()), a);
            return -cmp;
        }
    }
    else {
        if (typeof b == "number") {
            var cmp = jsbi_1.JSBI.__compareToNumber(jsbi_1.JSBI.BigInt(a.toString()), b);
            return cmp;
        }
        else {
            return jsbi_1.JSBI.__compareToBigInt(jsbi_1.JSBI.BigInt(a.toString()), jsbi_1.JSBI.BigInt(b.toString()));
        }
    }
}
exports.compare = compare;
function lessThan(a, b) {
    return compare(a, b) < 0;
}
exports.lessThan = lessThan;
function greaterThan(a, b) {
    return compare(a, b) > 0;
}
exports.greaterThan = greaterThan;
function equal(a, b) {
    return compare(a, b) == 0;
}
exports.equal = equal;
function lessThanOrEqual(a, b) {
    return compare(a, b) <= 0;
}
exports.lessThanOrEqual = lessThanOrEqual;
function greaterThanOrEqual(a, b) {
    return compare(a, b) >= 0;
}
exports.greaterThanOrEqual = greaterThanOrEqual;
function subOneImpl(str) {
    if (str[0] == "-") {
        var result = addOneImpl(str.substr(1));
        return "-" + result;
    }
    if (str == "0") {
        return "-1";
    }
    var digits = str
        .split("")
        .map(function (s) { return parseInt(s); });
    for (var i = digits.length - 1; i >= 0; --i) {
        var d = digits[i];
        if (d == 0) {
            digits[i] = 9;
        }
        else {
            if (i == 0 && digits[i] == 1) {
                digits.shift();
            }
            else {
                digits[i] = d - 1;
            }
            break;
        }
    }
    if (digits.length == 0) {
        return "0";
    }
    else {
        return digits.join("");
    }
}
exports.subOneImpl = subOneImpl;
function addOneImpl(str) {
    jsbi_1.JSBI.__absoluteAddOne;
    if (str[0] == "-") {
        var result = subOneImpl(str.substr(1));
        if (result == "0") {
            return result;
        }
        else {
            return "-" + result;
        }
    }
    var digits = str
        .split("")
        .map(function (s) { return parseInt(s); });
    var carry = true;
    for (var i = digits.length - 1; i >= 0; --i) {
        var d = digits[i];
        if (d == 9) {
            digits[i] = 0;
        }
        else {
            digits[i] = d + 1;
            carry = false;
            break;
        }
    }
    if (carry) {
        digits.unshift(1);
    }
    return digits.join("");
}
exports.addOneImpl = addOneImpl;
//# sourceMappingURL=comparison.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./arithmetic */ "./node_modules/type-mapping/dist/bigint-util/arithmetic.js"));
__export(__webpack_require__(/*! ./as-int-n */ "./node_modules/type-mapping/dist/bigint-util/as-int-n.js"));
__export(__webpack_require__(/*! ./as-uint-n */ "./node_modules/type-mapping/dist/bigint-util/as-uint-n.js"));
__export(__webpack_require__(/*! ./bitwise-operation */ "./node_modules/type-mapping/dist/bigint-util/bitwise-operation.js"));
__export(__webpack_require__(/*! ./comparison */ "./node_modules/type-mapping/dist/bigint-util/comparison.js"));
__export(__webpack_require__(/*! ./to-number */ "./node_modules/type-mapping/dist/bigint-util/to-number.js"));
__export(__webpack_require__(/*! ./to-string */ "./node_modules/type-mapping/dist/bigint-util/to-string.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/jsbi.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/jsbi.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32#Polyfill
 */
function clz32(x) {
    // Let n be ToUint32(x).
    // Let p be the number of leading zero bits in
    // the 32-bit binary representation of n.
    // Return p.
    var asUint = x >>> 0;
    if (asUint === 0) {
        return 32;
    }
    return 31 - (Math.log(asUint) / Math.LN2 | 0) | 0; // the "| 0" acts like math.floor
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul#Polyfill
 */
function imul(a, b) {
    var aHi = (a >>> 16) & 0xffff;
    var aLo = a & 0xffff;
    var bHi = (b >>> 16) & 0xffff;
    var bLo = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return ((aLo * bLo) + (((aHi * bLo + aLo * bHi) << 16) >>> 0) | 0);
}
if (Math.clz32 == undefined) {
    Math.clz32 = clz32;
}
if (Math.imul == undefined) {
    Math.imul = imul;
}
if (Symbol == undefined) {
    Symbol = {};
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
 */
/**
*** Object.appendChain(@object, @prototype)
*
* Appends the first non-native prototype of a chain to a new prototype.
* Returns @object (if it was a primitive value it will transformed into an object).
*
*** Object.appendChain(@object [, "@arg_name_1", "@arg_name_2", "@arg_name_3", "..."], "@function_body")
*** Object.appendChain(@object [, "@arg_name_1, @arg_name_2, @arg_name_3, ..."], "@function_body")
*
* Appends the first non-native prototype of a chain to the native Function.prototype object, then appends a
* new Function(["@arg"(s)], "@function_body") to that chain.
* Returns the function.
*
**/
Object.appendChain = function (oChain, oProto) {
    if (arguments.length < 2) {
        throw new TypeError('Object.appendChain - Not enough arguments');
    }
    if (typeof oProto !== 'object' && typeof oProto !== 'string') {
        throw new TypeError('second argument to Object.appendChain must be an object or a string');
    }
    var oNewProto = oProto;
    var oReturn = oChain instanceof this ? oChain : new oChain.constructor(oChain);
    var o2nd = oReturn;
    var oLast = oReturn;
    for (var o1st = this.getPrototypeOf(o2nd); o1st !== Object.prototype && o1st !== Function.prototype; o1st = this.getPrototypeOf(o2nd)) {
        o2nd = o1st;
    }
    if (oProto.constructor === String) {
        oNewProto = Function.prototype;
        oReturn = Function.apply(null, Array.prototype.slice.call(arguments, 1));
        this.setPrototypeOf(oReturn, oLast);
    }
    this.setPrototypeOf(o2nd, oNewProto);
    return oReturn;
};
// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// <https://apache.org/licenses/LICENSE-2.0>.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * https://github.com/GoogleChromeLabs/jsbi
 */
var JSBI = /** @class */ (function (_super) {
    __extends(JSBI, _super);
    function JSBI(length, sign) {
        var _this = this;
        if (length > JSBI.__kMaxLength) {
            throw new RangeError('Maximum BigInt size exceeded');
        }
        _this = _super.call(this, length) || this;
        _this.sign = sign;
        Object.setPrototypeOf(_this, JSBI.prototype);
        return _this;
    }
    JSBI.BigInt = function (arg) {
        if (typeof arg === 'number') {
            if (arg === 0)
                return JSBI.__zero();
            if ((arg | 0) === arg) {
                if (arg < 0) {
                    return JSBI.__oneDigit(-arg, true);
                }
                return JSBI.__oneDigit(arg, false);
            }
            if (!isFinite(arg) || Math.floor(arg) !== arg) {
                throw new RangeError('The number ' + arg + ' cannot be converted to ' +
                    'BigInt because it is not an integer');
            }
            return JSBI.__fromDouble(arg);
        }
        else if (typeof arg === 'string') {
            var result = JSBI.__fromString(arg);
            if (result === null) {
                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');
            }
            return result;
        }
        else if (typeof arg === 'boolean') {
            if (arg === true) {
                return JSBI.__oneDigit(1, false);
            }
            return JSBI.__zero();
        }
        else if (typeof arg === 'object') {
            if (arg.constructor === JSBI)
                return arg;
            var primitive = JSBI.__toPrimitive(arg);
            return JSBI.BigInt(primitive);
        }
        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');
    };
    JSBI.prototype.toDebugString = function () {
        var result = ['BigInt['];
        for (var _i = 0, _a = this; _i < _a.length; _i++) {
            var digit = _a[_i];
            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');
        }
        result.push(']');
        return result.join('');
    };
    JSBI.prototype.toString = function (radix) {
        if (radix === void 0) { radix = 10; }
        if (radix < 2 || radix > 36) {
            throw new RangeError('toString() radix argument must be between 2 and 36');
        }
        if (this.length === 0)
            return '0';
        if ((radix & (radix - 1)) === 0) {
            return JSBI.__toStringBasePowerOfTwo(this, radix);
        }
        return JSBI.__toStringGeneric(this, radix, false);
    };
    // Equivalent of "Number(my_bigint)" in the native implementation.
    JSBI.toNumber = function (x) {
        var xLength = x.length;
        if (xLength === 0)
            return 0;
        if (xLength === 1) {
            var value = x.__unsignedDigit(0);
            return x.sign ? -value : value;
        }
        var xMsd = x.__digit(xLength - 1);
        var msdLeadingZeros = Math.clz32(xMsd);
        var xBitLength = xLength * 32 - msdLeadingZeros;
        if (xBitLength > 1024)
            return x.sign ? -Infinity : Infinity;
        var exponent = xBitLength - 1;
        var currentDigit = xMsd;
        var digitIndex = xLength - 1;
        var shift = msdLeadingZeros + 1;
        var mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;
        mantissaHigh >>>= 12;
        var mantissaHighBitsUnset = shift - 12;
        var mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));
        var mantissaLowBitsUnset = 20 + shift;
        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            mantissaHigh |= (currentDigit >>> (32 - mantissaHighBitsUnset));
            mantissaLow = currentDigit << mantissaHighBitsUnset;
            mantissaLowBitsUnset = mantissaHighBitsUnset;
        }
        if (mantissaLowBitsUnset > 0 && digitIndex > 0) {
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            mantissaLow |= (currentDigit >>> (32 - mantissaLowBitsUnset));
            mantissaLowBitsUnset -= 32;
        }
        var rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);
        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {
            mantissaLow = (mantissaLow + 1) >>> 0;
            if (mantissaLow === 0) {
                // Incrementing mantissaLow overflowed.
                mantissaHigh++;
                if ((mantissaHigh >>> 20) !== 0) {
                    // Incrementing mantissaHigh overflowed.
                    mantissaHigh = 0;
                    exponent++;
                    if (exponent > 1023) {
                        // Incrementing the exponent overflowed.
                        return x.sign ? -Infinity : Infinity;
                    }
                }
            }
        }
        var signBit = x.sign ? (1 << 31) : 0;
        exponent = (exponent + 0x3FF) << 20;
        JSBI.__kBitConversionInts[1] = signBit | exponent | mantissaHigh;
        JSBI.__kBitConversionInts[0] = mantissaLow;
        return JSBI.__kBitConversionDouble[0];
    };
    // Operations.
    JSBI.unaryMinus = function (x) {
        if (x.length === 0)
            return x;
        var result = x.__copy();
        result.sign = !x.sign;
        return result;
    };
    JSBI.bitwiseNot = function (x) {
        if (x.sign) {
            // ~(-x) == ~(~(x-1)) == x-1
            return JSBI.__absoluteSubOne(x).__trim();
        }
        // ~x == -x-1 == -(x+1)
        return JSBI.__absoluteAddOne(x, true);
    };
    JSBI.exponentiate = function (x, y) {
        if (y.sign) {
            throw new RangeError('Exponent must be positive');
        }
        if (y.length === 0) {
            return JSBI.__oneDigit(1, false);
        }
        if (x.length === 0)
            return x;
        if (x.length === 1 && x.__digit(0) === 1) {
            // (-1) ** even_number == 1.
            if (x.sign && (y.__digit(0) & 1) === 0) {
                return JSBI.unaryMinus(x);
            }
            // (-1) ** odd_number == -1, 1 ** anything == 1.
            return x;
        }
        // For all bases >= 2, very large exponents would lead to unrepresentable
        // results.
        if (y.length > 1)
            throw new RangeError('BigInt too big');
        var expValue = y.__unsignedDigit(0);
        if (expValue === 1)
            return x;
        if (expValue >= JSBI.__kMaxLengthBits) {
            throw new RangeError('BigInt too big');
        }
        if (x.length === 1 && x.__digit(0) === 2) {
            // Fast path for 2^n.
            var neededDigits = 1 + (expValue >>> 5);
            var sign = x.sign && ((expValue & 1) !== 0);
            var result_1 = new JSBI(neededDigits, sign);
            result_1.__initializeDigits();
            // All bits are zero. Now set the n-th bit.
            var msd = 1 << (expValue & 31);
            result_1.__setDigit(neededDigits - 1, msd);
            return result_1;
        }
        var result = null;
        var runningSquare = x;
        // This implicitly sets the result's sign correctly.
        if ((expValue & 1) !== 0)
            result = x;
        expValue >>= 1;
        for (; expValue !== 0; expValue >>= 1) {
            runningSquare = JSBI.multiply(runningSquare, runningSquare);
            if ((expValue & 1) !== 0) {
                if (result === null) {
                    result = runningSquare;
                }
                else {
                    result = JSBI.multiply(result, runningSquare);
                }
            }
        }
        if (result == null) {
            throw new Error("Could not exponentiate");
        }
        return result;
    };
    JSBI.multiply = function (x, y) {
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return y;
        var resultLength = x.length + y.length;
        if (x.__clzmsd() + y.__clzmsd() >= 32) {
            resultLength--;
        }
        var result = new JSBI(resultLength, x.sign !== y.sign);
        result.__initializeDigits();
        for (var i = 0; i < x.length; i++) {
            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);
        }
        return result.__trim();
    };
    JSBI.divide = function (x, y) {
        if (y.length === 0)
            throw new RangeError('Division by zero');
        if (JSBI.__absoluteCompare(x, y) < 0)
            return JSBI.__zero();
        var resultSign = x.sign !== y.sign;
        var divisor = y.__unsignedDigit(0);
        var quotient;
        if (y.length === 1 && divisor <= 0xFFFF) {
            if (divisor === 1) {
                return resultSign === x.sign ? x : JSBI.unaryMinus(x);
            }
            quotient = JSBI.__absoluteDivSmall(x, divisor, null);
        }
        else {
            quotient = JSBI.__absoluteDivLarge(x, y, true, false);
        }
        quotient.sign = resultSign;
        return quotient.__trim();
    };
    JSBI.remainder = function (x, y) {
        if (y.length === 0)
            throw new RangeError('Division by zero');
        if (JSBI.__absoluteCompare(x, y) < 0)
            return x;
        var divisor = y.__unsignedDigit(0);
        if (y.length === 1 && divisor <= 0xFFFF) {
            if (divisor === 1)
                return JSBI.__zero();
            var remainderDigit = JSBI.__absoluteModSmall(x, divisor);
            if (remainderDigit === 0)
                return JSBI.__zero();
            return JSBI.__oneDigit(remainderDigit, x.sign);
        }
        var remainder = JSBI.__absoluteDivLarge(x, y, false, true);
        remainder.sign = x.sign;
        return remainder.__trim();
    };
    JSBI.add = function (x, y) {
        var sign = x.sign;
        if (sign === y.sign) {
            // x + y == x + y
            // -x + -y == -(x + y)
            return JSBI.__absoluteAdd(x, y, sign);
        }
        // x + -y == x - y == -(y - x)
        // -x + y == y - x == -(x - y)
        if (JSBI.__absoluteCompare(x, y) >= 0) {
            return JSBI.__absoluteSub(x, y, sign);
        }
        return JSBI.__absoluteSub(y, x, !sign);
    };
    JSBI.subtract = function (x, y) {
        var sign = x.sign;
        if (sign !== y.sign) {
            // x - (-y) == x + y
            // (-x) - y == -(x + y)
            return JSBI.__absoluteAdd(x, y, sign);
        }
        // x - y == -(y - x)
        // (-x) - (-y) == y - x == -(x - y)
        if (JSBI.__absoluteCompare(x, y) >= 0) {
            return JSBI.__absoluteSub(x, y, sign);
        }
        return JSBI.__absoluteSub(y, x, !sign);
    };
    JSBI.leftShift = function (x, y) {
        if (y.length === 0 || x.length === 0)
            return x;
        if (y.sign)
            return JSBI.__rightShiftByAbsolute(x, y);
        return JSBI.__leftShiftByAbsolute(x, y);
    };
    JSBI.signedRightShift = function (x, y) {
        if (y.length === 0 || x.length === 0)
            return x;
        if (y.sign)
            return JSBI.__leftShiftByAbsolute(x, y);
        return JSBI.__rightShiftByAbsolute(x, y);
    };
    JSBI.unsignedRightShift = function () {
        throw new TypeError('BigInts have no unsigned right shift; use >> instead');
    };
    JSBI.lessThan = function (x, y) {
        return JSBI.__compareToBigInt(x, y) < 0;
    };
    JSBI.lessThanOrEqual = function (x, y) {
        return JSBI.__compareToBigInt(x, y) <= 0;
    };
    JSBI.greaterThan = function (x, y) {
        return JSBI.__compareToBigInt(x, y) > 0;
    };
    JSBI.greaterThanOrEqual = function (x, y) {
        return JSBI.__compareToBigInt(x, y) >= 0;
    };
    JSBI.equal = function (x, y) {
        if (x.sign !== y.sign)
            return false;
        if (x.length !== y.length)
            return false;
        for (var i = 0; i < x.length; i++) {
            if (x.__digit(i) !== y.__digit(i))
                return false;
        }
        return true;
    };
    JSBI.notEqual = function (x, y) {
        return !JSBI.equal(x, y);
    };
    JSBI.bitwiseAnd = function (x, y) {
        var _a;
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteAnd(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            var resultLength = Math.max(x.length, y.length) + 1;
            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))
            // == -(((x-1) | (y-1)) + 1)
            var result = JSBI.__absoluteSubOne(x, resultLength);
            var y1 = JSBI.__absoluteSubOne(y);
            result = JSBI.__absoluteOr(result, y1, result);
            return JSBI.__absoluteAddOne(result, true, result).__trim();
        }
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x & (-y) == x & ~(y-1) == x &~ (y-1)
        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();
    };
    JSBI.bitwiseXor = function (x, y) {
        var _a;
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteXor(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
            var resultLength_1 = Math.max(x.length, y.length);
            var result_2 = JSBI.__absoluteSubOne(x, resultLength_1);
            var y1 = JSBI.__absoluteSubOne(y);
            return JSBI.__absoluteXor(result_2, y1, result_2).__trim();
        }
        var resultLength = Math.max(x.length, y.length) + 1;
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
        var result = JSBI.__absoluteSubOne(y, resultLength);
        result = JSBI.__absoluteXor(result, x, result);
        return JSBI.__absoluteAddOne(result, true, result).__trim();
    };
    JSBI.bitwiseOr = function (x, y) {
        var _a;
        var resultLength = Math.max(x.length, y.length);
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteOr(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))
            // == -(((x-1) & (y-1)) + 1)
            var result_3 = JSBI.__absoluteSubOne(x, resultLength);
            var y1 = JSBI.__absoluteSubOne(y);
            result_3 = JSBI.__absoluteAnd(result_3, y1, result_3);
            return JSBI.__absoluteAddOne(result_3, true, result_3).__trim();
        }
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)
        var result = JSBI.__absoluteSubOne(y, resultLength);
        result = JSBI.__absoluteAndNot(result, x, result);
        return JSBI.__absoluteAddOne(result, true, result).__trim();
    };
    JSBI.asIntN = function (n, x) {
        if (x.length === 0)
            return x;
        if (n === 0)
            return JSBI.__zero();
        // If {x} has less than {n} bits, return it directly.
        if (n >= JSBI.__kMaxLengthBits)
            return x;
        var neededLength = (n + 31) >>> 5;
        if (x.length < neededLength)
            return x;
        var topDigit = x.__unsignedDigit(neededLength - 1);
        var compareDigit = 1 << ((n - 1) & 31);
        if (x.length === neededLength && topDigit < compareDigit)
            return x;
        // Otherwise truncate and simulate two's complement.
        var hasBit = (topDigit & compareDigit) === compareDigit;
        if (!hasBit)
            return JSBI.__truncateToNBits(n, x);
        if (!x.sign)
            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);
        if ((topDigit & (compareDigit - 1)) === 0) {
            for (var i = neededLength - 2; i >= 0; i--) {
                if (x.__digit(i) !== 0) {
                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
                }
            }
            if (x.length === neededLength && topDigit === compareDigit)
                return x;
            return JSBI.__truncateToNBits(n, x);
        }
        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
    };
    JSBI.asUintN = function (n, x) {
        if (x.length === 0)
            return x;
        if (n === 0)
            return JSBI.__zero();
        // If {x} is negative, simulate two's complement representation.
        if (x.sign) {
            if (n > JSBI.__kMaxLengthBits) {
                throw new RangeError('BigInt too big');
            }
            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
        }
        // If {x} is positive and has up to {n} bits, return it directly.
        if (n >= JSBI.__kMaxLengthBits)
            return x;
        var neededLength = (n + 31) >>> 5;
        if (x.length < neededLength)
            return x;
        var bitsInTopDigit = n & 31;
        if (x.length == neededLength) {
            if (bitsInTopDigit === 0)
                return x;
            var topDigit = x.__digit(neededLength - 1);
            if ((topDigit >>> bitsInTopDigit) === 0)
                return x;
        }
        // Otherwise, truncate.
        return JSBI.__truncateToNBits(n, x);
    };
    // Operators.
    JSBI.ADD = function (x, y) {
        x = JSBI.__toPrimitive(x);
        y = JSBI.__toPrimitive(y);
        if (typeof x === 'string') {
            if (typeof y !== 'string')
                y = y.toString();
            return x + y;
        }
        if (typeof y === 'string') {
            return x.toString() + y;
        }
        x = JSBI.__toNumeric(x);
        y = JSBI.__toNumeric(y);
        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {
            return JSBI.add(x, y);
        }
        if (typeof x === 'number' && typeof y === 'number') {
            return x + y;
        }
        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');
    };
    JSBI.LT = function (x, y) {
        return JSBI.__compare(x, y, 0);
    };
    JSBI.LE = function (x, y) {
        return JSBI.__compare(x, y, 1);
    };
    JSBI.GT = function (x, y) {
        return JSBI.__compare(x, y, 2);
    };
    JSBI.GE = function (x, y) {
        return JSBI.__compare(x, y, 3);
    };
    JSBI.EQ = function (x, y) {
        while (true) {
            if (JSBI.__isBigInt(x)) {
                if (JSBI.__isBigInt(y))
                    return JSBI.equal(x, y);
                return JSBI.EQ(y, x);
            }
            else if (typeof x === 'number') {
                if (JSBI.__isBigInt(y))
                    return JSBI.__equalToNumber(y, x);
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'string') {
                if (JSBI.__isBigInt(y)) {
                    x = JSBI.__fromString(x);
                    if (x === null)
                        return false;
                    return JSBI.equal(x, y);
                }
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'boolean') {
                if (JSBI.__isBigInt(y))
                    return JSBI.__equalToNumber(y, +x);
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'symbol') {
                if (JSBI.__isBigInt(y))
                    return false;
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'object') {
                if (typeof y === 'object' && y.constructor !== JSBI)
                    return x == y;
                x = JSBI.__toPrimitive(x);
            }
            else {
                return x == y;
            }
        }
    };
    JSBI.NE = function (x, y) {
        return !JSBI.EQ(x, y);
    };
    // Helpers.
    JSBI.__zero = function () {
        return new JSBI(0, false);
    };
    JSBI.__oneDigit = function (value, sign) {
        var result = new JSBI(1, sign);
        result.__setDigit(0, value);
        return result;
    };
    JSBI.prototype.__copy = function () {
        var result = new JSBI(this.length, this.sign);
        for (var i = 0; i < this.length; i++) {
            result[i] = this[i];
        }
        return result;
    };
    JSBI.prototype.__trim = function () {
        var newLength = this.length;
        var last = this[newLength - 1];
        while (last === 0) {
            newLength--;
            last = this[newLength - 1];
            this.pop();
        }
        if (newLength === 0)
            this.sign = false;
        return this;
    };
    JSBI.prototype.__initializeDigits = function () {
        for (var i = 0; i < this.length; i++) {
            this[i] = 0;
        }
    };
    JSBI.__decideRounding = function (x, mantissaBitsUnset, digitIndex, currentDigit) {
        if (mantissaBitsUnset > 0)
            return -1;
        var topUnconsumedBit;
        if (mantissaBitsUnset < 0) {
            topUnconsumedBit = -mantissaBitsUnset - 1;
        }
        else {
            // {currentDigit} fit the mantissa exactly; look at the next digit.
            if (digitIndex === 0)
                return -1;
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            topUnconsumedBit = 31;
        }
        // If the most significant remaining bit is 0, round down.
        var mask = 1 << topUnconsumedBit;
        if ((currentDigit & mask) === 0)
            return -1;
        // If any other remaining bit is set, round up.
        mask -= 1;
        if ((currentDigit & mask) !== 0)
            return 1;
        while (digitIndex > 0) {
            digitIndex--;
            if (x.__digit(digitIndex) !== 0)
                return 1;
        }
        return 0;
    };
    JSBI.__fromDouble = function (value) {
        var sign = value < 0;
        JSBI.__kBitConversionDouble[0] = value;
        var rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;
        var exponent = rawExponent - 0x3FF;
        var digits = (exponent >>> 5) + 1;
        var result = new JSBI(digits, sign);
        var kHiddenBit = 0x00100000;
        var mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;
        var mantissaLow = JSBI.__kBitConversionInts[0];
        var kMantissaHighTopBit = 20;
        // 0-indexed position of most significant bit in most significant digit.
        var msdTopBit = exponent & 31;
        // Number of unused bits in the mantissa. We'll keep them shifted to the
        // left (i.e. most significant part).
        var remainingMantissaBits = 0;
        // Next digit under construction.
        var digit;
        // First, build the MSD by shifting the mantissa appropriately.
        if (msdTopBit < kMantissaHighTopBit) {
            var shift = kMantissaHighTopBit - msdTopBit;
            remainingMantissaBits = shift + 32;
            digit = mantissaHigh >>> shift;
            mantissaHigh = (mantissaHigh << (32 - shift)) |
                (mantissaLow >>> shift);
            mantissaLow = mantissaLow << (32 - shift);
        }
        else if (msdTopBit === kMantissaHighTopBit) {
            remainingMantissaBits = 32;
            digit = mantissaHigh;
            mantissaHigh = mantissaLow;
        }
        else {
            var shift = msdTopBit - kMantissaHighTopBit;
            remainingMantissaBits = 32 - shift;
            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));
            mantissaHigh = mantissaLow << shift;
        }
        result.__setDigit(digits - 1, digit);
        // Then fill in the rest of the digits.
        for (var digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {
            if (remainingMantissaBits > 0) {
                remainingMantissaBits -= 32;
                digit = mantissaHigh;
                mantissaHigh = mantissaLow;
            }
            else {
                digit = 0;
            }
            result.__setDigit(digitIndex, digit);
        }
        return result.__trim();
    };
    JSBI.__isWhitespace = function (c) {
        if (c <= 0x0D && c >= 0x09)
            return true;
        if (c <= 0x9F)
            return c === 0x20;
        if (c <= 0x01FFFF) {
            return c === 0xA0 || c === 0x1680;
        }
        if (c <= 0x02FFFF) {
            c &= 0x01FFFF;
            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||
                c === 0x5F || c === 0x1000;
        }
        return c === 0xFEFF;
    };
    JSBI.__fromString = function (string, radix) {
        if (radix === void 0) { radix = 0; }
        var sign = 0;
        //This line was found in the source code but never used?
        var leadingZero = false;
        //This line makes the compiler think it was used.
        leadingZero;
        var length = string.length;
        var cursor = 0;
        if (cursor === length)
            return JSBI.__zero();
        var current = string.charCodeAt(cursor);
        // Skip whitespace.
        while (JSBI.__isWhitespace(current)) {
            if (++cursor === length)
                return JSBI.__zero();
            current = string.charCodeAt(cursor);
        }
        // Detect radix.
        if (current === 0x2B) { // '+'
            if (++cursor === length)
                return null;
            current = string.charCodeAt(cursor);
            sign = 1;
        }
        else if (current === 0x2D) { // '-'
            if (++cursor === length)
                return null;
            current = string.charCodeAt(cursor);
            sign = -1;
        }
        if (radix === 0) {
            radix = 10;
            if (current === 0x30) { // '0'
                if (++cursor === length)
                    return JSBI.__zero();
                current = string.charCodeAt(cursor);
                if (current === 0x58 || current === 0x78) { // 'X' or 'x'
                    radix = 16;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'
                    radix = 8;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'
                    radix = 2;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else {
                    leadingZero = true;
                }
            }
        }
        else if (radix === 16) {
            if (current === 0x30) { // '0'
                // Allow "0x" prefix.
                if (++cursor === length)
                    return JSBI.__zero();
                current = string.charCodeAt(cursor);
                if (current === 0x58 || current === 0x78) { // 'X' or 'x'
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else {
                    leadingZero = true;
                }
            }
        }
        // Skip leading zeros.
        while (current === 0x30) {
            leadingZero = true;
            if (++cursor === length)
                return JSBI.__zero();
            current = string.charCodeAt(cursor);
        }
        // Allocate result.
        var chars = length - cursor;
        var bitsPerChar = JSBI.__kMaxBitsPerChar[radix];
        var roundup = JSBI.__kBitsPerCharTableMultiplier - 1;
        if (chars > (1 << 30) / bitsPerChar)
            return null;
        var bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;
        var resultLength = (bitsMin + 31) >>> 5;
        var result = new JSBI(resultLength, false);
        // Parse.
        var limDigit = radix < 10 ? radix : 10;
        var limAlpha = radix > 10 ? radix - 10 : 0;
        if ((radix & (radix - 1)) === 0) {
            // Power-of-two radix.
            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;
            var parts = [];
            var partsBits = [];
            var done = false;
            do {
                var part = 0;
                var bits = 0;
                while (true) {
                    var d = void 0;
                    if (((current - 48) >>> 0) < limDigit) {
                        d = current - 48;
                    }
                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {
                        d = (current | 32) - 87;
                    }
                    else {
                        done = true;
                        break;
                    }
                    bits += bitsPerChar;
                    part = (part << bitsPerChar) | d;
                    if (++cursor === length) {
                        done = true;
                        break;
                    }
                    current = string.charCodeAt(cursor);
                    if (bits + bitsPerChar > 32)
                        break;
                }
                parts.push(part);
                partsBits.push(bits);
            } while (!done);
            JSBI.__fillFromParts(result, parts, partsBits);
        }
        else {
            result.__initializeDigits();
            var done = false;
            var charsSoFar = 0;
            do {
                var part = 0;
                var multiplier = 1;
                while (true) {
                    var d = void 0;
                    if (((current - 48) >>> 0) < limDigit) {
                        d = current - 48;
                    }
                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {
                        d = (current | 32) - 87;
                    }
                    else {
                        done = true;
                        break;
                    }
                    var m = multiplier * radix;
                    if (m > 0xFFFFFFFF)
                        break;
                    multiplier = m;
                    part = part * radix + d;
                    charsSoFar++;
                    if (++cursor === length) {
                        done = true;
                        break;
                    }
                    current = string.charCodeAt(cursor);
                }
                roundup = JSBI.__kBitsPerCharTableMultiplier * 32 - 1;
                var digitsSoFar = (bitsPerChar * charsSoFar + roundup) >>>
                    (JSBI.__kBitsPerCharTableShift + 5);
                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);
            } while (!done);
        }
        while (cursor !== length) {
            if (!JSBI.__isWhitespace(current))
                return null;
            current = string.charCodeAt(cursor++);
        }
        // Get result.
        if (sign !== 0 && radix !== 10)
            return null;
        result.sign = (sign === -1);
        return result.__trim();
    };
    JSBI.__fillFromParts = function (result, parts, partsBits) {
        var digitIndex = 0;
        var digit = 0;
        var bitsInDigit = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var part = parts[i];
            var partBits = partsBits[i];
            digit |= (part << bitsInDigit);
            bitsInDigit += partBits;
            if (bitsInDigit === 32) {
                result.__setDigit(digitIndex++, digit);
                bitsInDigit = 0;
                digit = 0;
            }
            else if (bitsInDigit > 32) {
                result.__setDigit(digitIndex++, digit);
                bitsInDigit -= 32;
                digit = part >>> (partBits - bitsInDigit);
            }
        }
        if (digit !== 0) {
            if (digitIndex >= result.length)
                throw new Error('implementation bug');
            result.__setDigit(digitIndex++, digit);
        }
        for (; digitIndex < result.length; digitIndex++) {
            result.__setDigit(digitIndex, 0);
        }
    };
    JSBI.__toStringBasePowerOfTwo = function (x, radix) {
        var length = x.length;
        var bits = radix - 1;
        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);
        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);
        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);
        var bitsPerChar = bits;
        var charMask = radix - 1;
        var msd = x.__digit(length - 1);
        var msdLeadingZeros = Math.clz32(msd);
        var bitLength = length * 32 - msdLeadingZeros;
        var charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;
        if (x.sign)
            charsRequired++;
        if (charsRequired > (1 << 28))
            throw new Error('string too long');
        var result = new Array(charsRequired);
        var pos = charsRequired - 1;
        var digit = 0;
        var availableBits = 0;
        for (var i = 0; i < length - 1; i++) {
            var newDigit = x.__digit(i);
            var current_1 = (digit | (newDigit << availableBits)) & charMask;
            result[pos--] = JSBI.__kConversionChars[current_1];
            var consumedBits = bitsPerChar - availableBits;
            digit = newDigit >>> consumedBits;
            availableBits = 32 - consumedBits;
            while (availableBits >= bitsPerChar) {
                result[pos--] = JSBI.__kConversionChars[digit & charMask];
                digit >>>= bitsPerChar;
                availableBits -= bitsPerChar;
            }
        }
        var current = (digit | (msd << availableBits)) & charMask;
        result[pos--] = JSBI.__kConversionChars[current];
        digit = msd >>> (bitsPerChar - availableBits);
        while (digit !== 0) {
            result[pos--] = JSBI.__kConversionChars[digit & charMask];
            digit >>>= bitsPerChar;
        }
        if (x.sign)
            result[pos--] = '-';
        if (pos !== -1)
            throw new Error('implementation bug');
        return result.join('');
    };
    JSBI.__toStringGeneric = function (x, radix, isRecursiveCall) {
        var length = x.length;
        if (length === 0)
            return '';
        if (length === 1) {
            var result = x.__unsignedDigit(0).toString(radix);
            if (isRecursiveCall === false && x.sign) {
                result = '-' + result;
            }
            return result;
        }
        var bitLength = length * 32 - Math.clz32(x.__digit(length - 1));
        var maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];
        var minBitsPerChar = maxBitsPerChar - 1;
        var charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;
        charsRequired += minBitsPerChar - 1;
        charsRequired = (charsRequired / minBitsPerChar) | 0;
        var secondHalfChars = (charsRequired + 1) >> 1;
        // Divide-and-conquer: split by a power of {radix} that's approximately
        // the square root of {x}, then recurse.
        var conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));
        var quotient;
        var secondHalf;
        var divisor = conqueror.__unsignedDigit(0);
        if (conqueror.length === 1 && divisor <= 0xFFFF) {
            quotient = new JSBI(x.length, false);
            quotient.__initializeDigits();
            var remainder = 0;
            for (var i = x.length * 2 - 1; i >= 0; i--) {
                var input = (remainder << 16) | x.__halfDigit(i);
                quotient.__setHalfDigit(i, (input / divisor) | 0);
                remainder = (input % divisor) | 0;
            }
            secondHalf = remainder.toString(radix);
        }
        else {
            var divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);
            quotient = divisionResult.quotient;
            var remainder = divisionResult.remainder.__trim();
            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);
        }
        quotient.__trim();
        var firstHalf = JSBI.__toStringGeneric(quotient, radix, true);
        while (secondHalf.length < secondHalfChars) {
            secondHalf = '0' + secondHalf;
        }
        if (isRecursiveCall === false && x.sign) {
            firstHalf = '-' + firstHalf;
        }
        return firstHalf + secondHalf;
    };
    JSBI.__unequalSign = function (leftNegative) {
        return leftNegative ? -1 : 1;
    };
    JSBI.__absoluteGreater = function (bothNegative) {
        return bothNegative ? -1 : 1;
    };
    JSBI.__absoluteLess = function (bothNegative) {
        return bothNegative ? 1 : -1;
    };
    JSBI.__compareToBigInt = function (x, y) {
        var xSign = x.sign;
        if (xSign !== y.sign)
            return JSBI.__unequalSign(xSign);
        var result = JSBI.__absoluteCompare(x, y);
        if (result > 0)
            return JSBI.__absoluteGreater(xSign);
        if (result < 0)
            return JSBI.__absoluteLess(xSign);
        return 0;
    };
    JSBI.__compareToNumber = function (x, y) {
        /**
         * @todo Investigate this weird `0 === 0` construct
         */
        if (y | (0 === 0)) {
            var xSign = x.sign;
            var ySign = (y < 0);
            if (xSign !== ySign)
                return JSBI.__unequalSign(xSign);
            if (x.length === 0) {
                if (ySign)
                    throw new Error('implementation bug');
                return y === 0 ? 0 : -1;
            }
            // Any multi-digit BigInt is bigger than an int32.
            if (x.length > 1)
                return JSBI.__absoluteGreater(xSign);
            var yAbs = Math.abs(y);
            var xDigit = x.__unsignedDigit(0);
            if (xDigit > yAbs)
                return JSBI.__absoluteGreater(xSign);
            if (xDigit < yAbs)
                return JSBI.__absoluteLess(xSign);
            return 0;
        }
        return JSBI.__compareToDouble(x, y);
    };
    /**
     * @returns NaN|-1|1|0
     *
     * + NaN    : `y` was `NaN`
     * + -1     : `x < y`
     * + +1     : `x > y`
     * +  0     : `x == y`
     */
    JSBI.__compareToDouble = function (x, y) {
        if (y !== y)
            return y; // NaN.
        if (y === Infinity)
            return -1;
        if (y === -Infinity)
            return 1;
        var xSign = x.sign;
        var ySign = (y < 0);
        if (xSign !== ySign)
            return JSBI.__unequalSign(xSign);
        if (y === 0) {
            throw new Error('implementation bug: should be handled elsewhere');
        }
        if (x.length === 0)
            return -1;
        JSBI.__kBitConversionDouble[0] = y;
        var rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;
        if (rawExponent === 0x7FF) {
            throw new Error('implementation bug: handled elsewhere');
        }
        var exponent = rawExponent - 0x3FF;
        if (exponent < 0) {
            // The absolute value of y is less than 1. Only 0n has an absolute
            // value smaller than that, but we've already covered that case.
            return JSBI.__absoluteGreater(xSign);
        }
        var xLength = x.length;
        var xMsd = x.__digit(xLength - 1);
        var msdLeadingZeros = Math.clz32(xMsd);
        var xBitLength = xLength * 32 - msdLeadingZeros;
        var yBitLength = exponent + 1;
        if (xBitLength < yBitLength)
            return JSBI.__absoluteLess(xSign);
        if (xBitLength > yBitLength)
            return JSBI.__absoluteGreater(xSign);
        // Same sign, same bit length. Shift mantissa to align with x and compare
        // bit for bit.
        var kHiddenBit = 0x00100000;
        var mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;
        var mantissaLow = JSBI.__kBitConversionInts[0];
        var kMantissaHighTopBit = 20;
        var msdTopBit = 31 - msdLeadingZeros;
        if (msdTopBit !== ((xBitLength - 1) % 31)) {
            throw new Error('implementation bug');
        }
        var compareMantissa; // Shifted chunk of mantissa.
        var remainingMantissaBits = 0;
        // First, compare most significant digit against beginning of mantissa.
        if (msdTopBit < kMantissaHighTopBit) {
            var shift = kMantissaHighTopBit - msdTopBit;
            remainingMantissaBits = shift + 32;
            compareMantissa = mantissaHigh >>> shift;
            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);
            mantissaLow = mantissaLow << (32 - shift);
        }
        else if (msdTopBit === kMantissaHighTopBit) {
            remainingMantissaBits = 32;
            compareMantissa = mantissaHigh;
            mantissaHigh = mantissaLow;
        }
        else {
            var shift = msdTopBit - kMantissaHighTopBit;
            remainingMantissaBits = 32 - shift;
            compareMantissa =
                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));
            mantissaHigh = mantissaLow << shift;
        }
        xMsd = xMsd >>> 0;
        compareMantissa = compareMantissa >>> 0;
        if (xMsd > compareMantissa)
            return JSBI.__absoluteGreater(xSign);
        if (xMsd < compareMantissa)
            return JSBI.__absoluteLess(xSign);
        // Then, compare additional digits against remaining mantissa bits.
        for (var digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {
            if (remainingMantissaBits > 0) {
                remainingMantissaBits -= 32;
                compareMantissa = mantissaHigh >>> 0;
                mantissaHigh = mantissaLow;
                mantissaLow = 0;
            }
            else {
                compareMantissa = 0;
            }
            var digit = x.__unsignedDigit(digitIndex);
            if (digit > compareMantissa)
                return JSBI.__absoluteGreater(xSign);
            if (digit < compareMantissa)
                return JSBI.__absoluteLess(xSign);
        }
        // Integer parts are equal; check whether {y} has a fractional part.
        if (mantissaHigh !== 0 || mantissaLow !== 0) {
            if (remainingMantissaBits === 0)
                throw new Error('implementation bug');
            return JSBI.__absoluteLess(xSign);
        }
        return 0;
    };
    JSBI.__equalToNumber = function (x, y) {
        if (y | (0 === y)) {
            if (y === 0)
                return x.length === 0;
            // Any multi-digit BigInt is bigger than an int32.
            return (x.length === 1) && (x.sign === (y < 0)) &&
                (x.__unsignedDigit(0) === Math.abs(y));
        }
        return JSBI.__compareToDouble(x, y) === 0;
    };
    // Comparison operations, chosen such that "op ^ 2" reverses direction:
    // 0 - lessThan
    // 1 - lessThanOrEqual
    // 2 - greaterThan
    // 3 - greaterThanOrEqual
    JSBI.__comparisonResultToBool = function (result, op) {
        switch (op) {
            case 0: return result < 0;
            case 1: return result <= 0;
            case 2: return result > 0;
            case 3: return result >= 0;
        }
        throw new Error('unreachable');
    };
    JSBI.__compare = function (x, y, op) {
        x = JSBI.__toPrimitive(x);
        y = JSBI.__toPrimitive(y);
        if (typeof x === 'string' && typeof y === 'string') {
            switch (op) {
                case 0: return x < y;
                case 1: return x <= y;
                case 2: return x > y;
                case 3: return x >= y;
            }
        }
        if (JSBI.__isBigInt(x) && typeof y === 'string') {
            y = JSBI.__fromString(y);
            if (y === null)
                return false;
            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
        }
        if (typeof x === 'string' && JSBI.__isBigInt(y)) {
            x = JSBI.__fromString(x);
            if (x === null)
                return false;
            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
        }
        if (x == null || y == null) {
            throw new Error("x and y should not be null");
        }
        x = JSBI.__toNumeric(x);
        y = JSBI.__toNumeric(y);
        if (JSBI.__isBigInt(x)) {
            if (JSBI.__isBigInt(y)) {
                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
            }
            if (typeof y !== 'number')
                throw new Error('implementation bug');
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);
        }
        if (typeof x !== 'number')
            throw new Error('implementation bug');
        if (JSBI.__isBigInt(y)) {
            // Note that "op ^ 2" reverses the op's direction.
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));
        }
        if (typeof y !== 'number')
            throw new Error('implementation bug');
        switch (op) {
            case 0: return x < y;
            case 1: return x <= y;
            case 2: return x > y;
            case 3: return x >= y;
        }
    };
    JSBI.prototype.__clzmsd = function () {
        return Math.clz32(this[this.length - 1]);
    };
    JSBI.__absoluteAdd = function (x, y, resultSign) {
        if (x.length < y.length)
            return JSBI.__absoluteAdd(y, x, resultSign);
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return x.sign === resultSign ? x : JSBI.unaryMinus(x);
        var resultLength = x.length;
        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {
            resultLength++;
        }
        var result = new JSBI(resultLength, resultSign);
        var carry = 0;
        var i = 0;
        for (; i < y.length; i++) {
            var yDigit = y.__digit(i);
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) + (yDigit & 0xFFFF) + carry;
            var rHigh = (xDigit >>> 16) + (yDigit >>> 16) + (rLow >>> 16);
            carry = rHigh >>> 16;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < x.length; i++) {
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) + carry;
            var rHigh = (xDigit >>> 16) + (rLow >>> 16);
            carry = rHigh >>> 16;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        if (i < result.length) {
            result.__setDigit(i, carry);
        }
        return result.__trim();
    };
    JSBI.__absoluteSub = function (x, y, resultSign) {
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return x.sign === resultSign ? x : JSBI.unaryMinus(x);
        var result = new JSBI(x.length, resultSign);
        var borrow = 0;
        var i = 0;
        for (; i < y.length; i++) {
            var xDigit = x.__digit(i);
            var yDigit = y.__digit(i);
            var rLow = (xDigit & 0xFFFF) - (yDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (xDigit >>> 16) - (yDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < x.length; i++) {
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (xDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        return result.__trim();
    };
    JSBI.__absoluteAddOne = function (x, sign, result) {
        if (result === void 0) { result = null; }
        var inputLength = x.length;
        if (result === null) {
            result = new JSBI(inputLength, sign);
        }
        else {
            result.sign = sign;
        }
        var carry = true;
        for (var i = 0; i < inputLength; i++) {
            var digit = x.__digit(i);
            var newCarry = digit === (0xFFFFFFFF | 0);
            if (carry)
                digit = (digit + 1) | 0;
            carry = newCarry;
            result.__setDigit(i, digit);
        }
        if (carry) {
            result.__setDigitGrow(inputLength, 1);
        }
        return result;
    };
    JSBI.__absoluteSubOne = function (x, resultLength) {
        var length = x.length;
        resultLength = resultLength || length;
        var result = new JSBI(resultLength, false);
        var borrow = true;
        for (var i = 0; i < length; i++) {
            var digit = x.__digit(i);
            var newBorrow = digit === 0;
            if (borrow)
                digit = (digit - 1) | 0;
            borrow = newBorrow;
            result.__setDigit(i, digit);
        }
        for (var i = length; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteAnd = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = numPairs;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) & y.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteAndNot = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteOr = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) | y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteXor = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteCompare = function (x, y) {
        var diff = x.length - y.length;
        if (diff !== 0)
            return diff;
        var i = x.length - 1;
        while (i >= 0 && x.__digit(i) === y.__digit(i))
            i--;
        if (i < 0)
            return 0;
        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;
    };
    JSBI.__multiplyAccumulate = function (multiplicand, multiplier, accumulator, accumulatorIndex) {
        if (multiplier === 0)
            return;
        var m2Low = multiplier & 0xFFFF;
        var m2High = multiplier >>> 16;
        var carry = 0;
        var highLower = 0;
        var highHigher = 0;
        for (var i = 0; i < multiplicand.length; i++, accumulatorIndex++) {
            var acc = accumulator.__digit(accumulatorIndex);
            var accLow = acc & 0xFFFF;
            var accHigh = acc >>> 16;
            var m1 = multiplicand.__digit(i);
            var m1Low = m1 & 0xFFFF;
            var m1High = m1 >>> 16;
            var rLow = Math.imul(m1Low, m2Low);
            var rMid1 = Math.imul(m1Low, m2High);
            var rMid2 = Math.imul(m1High, m2Low);
            var rHigh = Math.imul(m1High, m2High);
            accLow += highLower + (rLow & 0xFFFF);
            accHigh += highHigher + carry + (accLow >>> 16) + (rLow >>> 16) +
                (rMid1 & 0xFFFF) + (rMid2 & 0xFFFF);
            carry = accHigh >>> 16;
            highLower = (rMid1 >>> 16) + (rMid2 >>> 16) + (rHigh & 0xFFFF) + carry;
            carry = highLower >>> 16;
            highLower &= 0xFFFF;
            highHigher = rHigh >>> 16;
            acc = (accLow & 0xFFFF) | (accHigh << 16);
            accumulator.__setDigit(accumulatorIndex, acc);
        }
        for (; carry !== 0 || highLower !== 0 || highHigher !== 0; accumulatorIndex++) {
            var acc = accumulator.__digit(accumulatorIndex);
            var accLow = (acc & 0xFFFF) + highLower;
            var accHigh = (acc >>> 16) + (accLow >>> 16) + highHigher + carry;
            highLower = 0;
            highHigher = 0;
            carry = accHigh >>> 16;
            acc = (accLow & 0xFFFF) | (accHigh << 16);
            accumulator.__setDigit(accumulatorIndex, acc);
        }
    };
    JSBI.__internalMultiplyAdd = function (source, factor, summand, n, result) {
        var carry = summand;
        var high = 0;
        for (var i = 0; i < n; i++) {
            var digit = source.__digit(i);
            var rx = Math.imul(digit & 0xFFFF, factor);
            var r0 = (rx & 0xFFFF) + high + carry;
            carry = r0 >>> 16;
            var ry = Math.imul(digit >>> 16, factor);
            var r16 = (ry & 0xFFFF) + (rx >>> 16) + carry;
            carry = r16 >>> 16;
            high = ry >>> 16;
            result.__setDigit(i, (r16 << 16) | (r0 & 0xFFFF));
        }
        if (result.length > n) {
            result.__setDigit(n++, carry + high);
            while (n < result.length) {
                result.__setDigit(n++, 0);
            }
        }
        else {
            if (carry + high !== 0)
                throw new Error('implementation bug');
        }
    };
    JSBI.prototype.__inplaceMultiplyAdd = function (multiplier, summand, length) {
        if (length > this.length)
            length = this.length;
        var mLow = multiplier & 0xFFFF;
        var mHigh = multiplier >>> 16;
        var carry = 0;
        var highLower = summand & 0xFFFF;
        var highHigher = summand >>> 16;
        for (var i = 0; i < length; i++) {
            var d = this.__digit(i);
            var dLow = d & 0xFFFF;
            var dHigh = d >>> 16;
            var pLow = Math.imul(dLow, mLow);
            var pMid1 = Math.imul(dLow, mHigh);
            var pMid2 = Math.imul(dHigh, mLow);
            var pHigh = Math.imul(dHigh, mHigh);
            var rLow = highLower + (pLow & 0xFFFF);
            var rHigh = highHigher + carry + (rLow >>> 16) + (pLow >>> 16) +
                (pMid1 & 0xFFFF) + (pMid2 & 0xFFFF);
            highLower = (pMid1 >>> 16) + (pMid2 >>> 16) + (pHigh & 0xFFFF) +
                (rHigh >>> 16);
            carry = highLower >>> 16;
            highLower &= 0xFFFF;
            highHigher = pHigh >>> 16;
            var result = (rLow & 0xFFFF) | (rHigh << 16);
            this.__setDigit(i, result);
        }
        if (carry !== 0 || highLower !== 0 || highHigher !== 0) {
            throw new Error('implementation bug');
        }
    };
    JSBI.__absoluteDivSmall = function (x, divisor, quotient) {
        if (quotient === null)
            quotient = new JSBI(x.length, false);
        var remainder = 0;
        for (var i = x.length * 2 - 1; i >= 0; i -= 2) {
            var input = ((remainder << 16) | x.__halfDigit(i)) >>> 0;
            var upperHalf = (input / divisor) | 0;
            remainder = (input % divisor) | 0;
            input = ((remainder << 16) | x.__halfDigit(i - 1)) >>> 0;
            var lowerHalf = (input / divisor) | 0;
            remainder = (input % divisor) | 0;
            quotient.__setDigit(i >>> 1, (upperHalf << 16) | lowerHalf);
        }
        return quotient;
    };
    JSBI.__absoluteModSmall = function (x, divisor) {
        var remainder = 0;
        for (var i = x.length * 2 - 1; i >= 0; i--) {
            var input = ((remainder << 16) | x.__halfDigit(i)) >>> 0;
            remainder = (input % divisor) | 0;
        }
        return remainder;
    };
    JSBI.__absoluteDivLarge = function (dividend, divisor, wantQuotient, wantRemainder) {
        var n = divisor.__halfDigitLength();
        var n2 = divisor.length;
        var m = dividend.__halfDigitLength() - n;
        var q = null;
        if (wantQuotient) {
            q = new JSBI((m + 2) >>> 1, false);
            q.__initializeDigits();
        }
        var qhatv = new JSBI((n + 2) >>> 1, false);
        qhatv.__initializeDigits();
        // D1.
        var shift = JSBI.__clz16(divisor.__halfDigit(n - 1));
        if (shift > 0) {
            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);
        }
        var u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);
        // D2.
        var vn1 = divisor.__halfDigit(n - 1);
        var halfDigitBuffer = 0;
        for (var j = m; j >= 0; j--) {
            // D3.
            var qhat = 0xFFFF;
            var ujn = u.__halfDigit(j + n);
            if (ujn !== vn1) {
                var input = ((ujn << 16) | u.__halfDigit(j + n - 1)) >>> 0;
                qhat = (input / vn1) | 0;
                var rhat = (input % vn1) | 0;
                var vn2 = divisor.__halfDigit(n - 2);
                var ujn2 = u.__halfDigit(j + n - 2);
                while ((Math.imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {
                    qhat--;
                    rhat += vn1;
                    if (rhat > 0xFFFF)
                        break;
                }
            }
            // D4.
            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);
            var c = u.__inplaceSub(qhatv, j, n + 1);
            if (c !== 0) {
                c = u.__inplaceAdd(divisor, j, n);
                u.__setHalfDigit(j + n, u.__halfDigit(j + n) + c);
                qhat--;
            }
            if (wantQuotient && q != null) {
                if (j & 1) {
                    halfDigitBuffer = qhat << 16;
                }
                else {
                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);
                }
            }
        }
        if (wantRemainder) {
            u.__inplaceRightShift(shift);
            if (wantQuotient && q != null) {
                return { quotient: q, remainder: u };
            }
            return u;
        }
        if (wantQuotient && q != null)
            return q;
        throw new Error("Either wantQuotient or wantRemainder must be set");
    };
    JSBI.__clz16 = function (value) {
        return Math.clz32(value) - 16;
    };
    // TODO: work on full digits, like __inplaceSub?
    JSBI.prototype.__inplaceAdd = function (summand, startIndex, halfDigits) {
        var carry = 0;
        for (var i = 0; i < halfDigits; i++) {
            var sum = this.__halfDigit(startIndex + i) +
                summand.__halfDigit(i) +
                carry;
            carry = sum >>> 16;
            this.__setHalfDigit(startIndex + i, sum);
        }
        return carry;
    };
    JSBI.prototype.__inplaceSub = function (subtrahend, startIndex, halfDigits) {
        var fullSteps = (halfDigits - 1) >>> 1;
        var borrow = 0;
        if (startIndex & 1) {
            // this:   [..][..][..]
            // subtr.:   [..][..]
            startIndex >>= 1;
            var current = this.__digit(startIndex);
            var r0 = current & 0xFFFF;
            var i = 0;
            for (; i < fullSteps; i++) {
                var sub_1 = subtrahend.__digit(i);
                var r16_1 = (current >>> 16) - (sub_1 & 0xFFFF) - borrow;
                borrow = (r16_1 >>> 16) & 1;
                this.__setDigit(startIndex + i, (r16_1 << 16) | (r0 & 0xFFFF));
                current = this.__digit(startIndex + i + 1);
                r0 = (current & 0xFFFF) - (sub_1 >>> 16) - borrow;
                borrow = (r0 >>> 16) & 1;
            }
            // Unrolling the last iteration gives a 5% performance benefit!
            var sub = subtrahend.__digit(i);
            var r16 = (current >>> 16) - (sub & 0xFFFF) - borrow;
            borrow = (r16 >>> 16) & 1;
            this.__setDigit(startIndex + i, (r16 << 16) | (r0 & 0xFFFF));
            var subTop = sub >>> 16;
            if (startIndex + i + 1 >= this.length) {
                throw new RangeError('out of bounds');
            }
            if ((halfDigits & 1) === 0) {
                current = this.__digit(startIndex + i + 1);
                r0 = (current & 0xFFFF) - subTop - borrow;
                borrow = (r0 >>> 16) & 1;
                this.__setDigit(startIndex + subtrahend.length, (current & 0xFFFF0000) | (r0 & 0xFFFF));
            }
        }
        else {
            startIndex >>= 1;
            var i = 0;
            for (; i < subtrahend.length - 1; i++) {
                var current_2 = this.__digit(startIndex + i);
                var sub_2 = subtrahend.__digit(i);
                var r0_1 = (current_2 & 0xFFFF) - (sub_2 & 0xFFFF) - borrow;
                borrow = (r0_1 >>> 16) & 1;
                var r16_2 = (current_2 >>> 16) - (sub_2 >>> 16) - borrow;
                borrow = (r16_2 >>> 16) & 1;
                this.__setDigit(startIndex + i, (r16_2 << 16) | (r0_1 & 0xFFFF));
            }
            var current = this.__digit(startIndex + i);
            var sub = subtrahend.__digit(i);
            var r0 = (current & 0xFFFF) - (sub & 0xFFFF) - borrow;
            borrow = (r0 >>> 16) & 1;
            var r16 = 0;
            if ((halfDigits & 1) === 0) {
                r16 = (current >>> 16) - (sub >>> 16) - borrow;
                borrow = (r16 >>> 16) & 1;
            }
            this.__setDigit(startIndex + i, (r16 << 16) | (r0 & 0xFFFF));
        }
        return borrow;
    };
    JSBI.prototype.__inplaceRightShift = function (shift) {
        if (shift === 0)
            return;
        var carry = this.__digit(0) >>> shift;
        var last = this.length - 1;
        for (var i = 0; i < last; i++) {
            var d = this.__digit(i + 1);
            this.__setDigit(i, (d << (32 - shift)) | carry);
            carry = d >>> shift;
        }
        this.__setDigit(last, carry);
    };
    JSBI.__specialLeftShift = function (x, shift, addDigit) {
        var n = x.length;
        var resultLength = n + addDigit;
        var result = new JSBI(resultLength, false);
        if (shift === 0) {
            for (var i = 0; i < n; i++)
                result.__setDigit(i, x.__digit(i));
            if (addDigit > 0)
                result.__setDigit(n, 0);
            return result;
        }
        var carry = 0;
        for (var i = 0; i < n; i++) {
            var d = x.__digit(i);
            result.__setDigit(i, (d << shift) | carry);
            carry = d >>> (32 - shift);
        }
        if (addDigit > 0) {
            result.__setDigit(n, carry);
        }
        return result;
    };
    JSBI.__leftShiftByAbsolute = function (x, y) {
        var shift = JSBI.__toShiftAmount(y);
        if (shift < 0)
            throw new RangeError('BigInt too big');
        var digitShift = shift >>> 5;
        var bitsShift = shift & 31;
        var length = x.length;
        var grow = bitsShift !== 0 &&
            (x.__digit(length - 1) >>> (32 - bitsShift)) !== 0;
        var resultLength = length + digitShift + (grow ? 1 : 0);
        var result = new JSBI(resultLength, x.sign);
        if (bitsShift === 0) {
            var i = 0;
            for (; i < digitShift; i++)
                result.__setDigit(i, 0);
            for (; i < resultLength; i++) {
                result.__setDigit(i, x.__digit(i - digitShift));
            }
        }
        else {
            var carry = 0;
            for (var i = 0; i < digitShift; i++)
                result.__setDigit(i, 0);
            for (var i = 0; i < length; i++) {
                var d = x.__digit(i);
                result.__setDigit(i + digitShift, (d << bitsShift) | carry);
                carry = d >>> (32 - bitsShift);
            }
            if (grow) {
                result.__setDigit(length + digitShift, carry);
            }
            else {
                if (carry !== 0)
                    throw new Error('implementation bug');
            }
        }
        return result.__trim();
    };
    JSBI.__rightShiftByAbsolute = function (x, y) {
        var length = x.length;
        var sign = x.sign;
        var shift = JSBI.__toShiftAmount(y);
        if (shift < 0)
            return JSBI.__rightShiftByMaximum(sign);
        var digitShift = shift >>> 5;
        var bitsShift = shift & 31;
        var resultLength = length - digitShift;
        if (resultLength <= 0)
            return JSBI.__rightShiftByMaximum(sign);
        // For negative numbers, round down if any bit was shifted out (so that
        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen
        // and whether itc an cause overflow into a new digit. If we allocate the
        // result large enough up front, it avoids having to do grow it later.
        var mustRoundDown = false;
        if (sign) {
            var mask = (1 << bitsShift) - 1;
            if ((x.__digit(digitShift) & mask) !== 0) {
                mustRoundDown = true;
            }
            else {
                for (var i = 0; i < digitShift; i++) {
                    if (x.__digit(i) !== 0) {
                        mustRoundDown = true;
                        break;
                    }
                }
            }
        }
        // If bitsShift is non-zero, it frees up bits, preventing overflow.
        if (mustRoundDown && bitsShift === 0) {
            // Overflow cannot happen if the most significant digit has unset bits.
            var msd = x.__digit(length - 1);
            var roundingCanOverflow = ~msd === 0;
            if (roundingCanOverflow)
                resultLength++;
        }
        var result = new JSBI(resultLength, sign);
        if (bitsShift === 0) {
            for (var i = digitShift; i < length; i++) {
                result.__setDigit(i - digitShift, x.__digit(i));
            }
        }
        else {
            var carry = x.__digit(digitShift) >>> bitsShift;
            var last = length - digitShift - 1;
            for (var i = 0; i < last; i++) {
                var d = x.__digit(i + digitShift + 1);
                result.__setDigit(i, (d << (32 - bitsShift)) | carry);
                carry = d >>> bitsShift;
            }
            result.__setDigit(last, carry);
        }
        if (mustRoundDown) {
            // Since the result is negative, rounding down means adding one to its
            // absolute value. This cannot overflow.
            result = JSBI.__absoluteAddOne(result, true, result);
        }
        return result.__trim();
    };
    JSBI.__rightShiftByMaximum = function (sign) {
        if (sign) {
            return JSBI.__oneDigit(1, true);
        }
        return JSBI.__zero();
    };
    JSBI.__toShiftAmount = function (x) {
        if (x.length > 1)
            return -1;
        var value = x.__unsignedDigit(0);
        if (value > JSBI.__kMaxLengthBits)
            return -1;
        return value;
    };
    JSBI.__toPrimitive = function (obj, hint) {
        if (hint === void 0) { hint = 'default'; }
        if (typeof obj !== 'object')
            return obj;
        if (obj.constructor === JSBI)
            return obj;
        var exoticToPrim = Symbol.toPrimitive == undefined ? undefined : obj[Symbol.toPrimitive];
        if (exoticToPrim) {
            var primitive = exoticToPrim(hint);
            if (typeof primitive !== 'object')
                return primitive;
            throw new TypeError('Cannot convert object to primitive value');
        }
        var valueOf = obj.valueOf;
        if (valueOf) {
            var primitive = valueOf.call(obj);
            if (typeof primitive !== 'object')
                return primitive;
        }
        var toString = obj.toString;
        if (toString) {
            var primitive = toString.call(obj);
            if (typeof primitive !== 'object')
                return primitive;
        }
        throw new TypeError('Cannot convert object to primitive value');
    };
    JSBI.__toNumeric = function (value) {
        if (JSBI.__isBigInt(value))
            return value;
        return +value;
    };
    JSBI.__isBigInt = function (value) {
        return typeof value === 'object' && value.constructor === JSBI;
    };
    JSBI.__truncateToNBits = function (n, x) {
        var neededDigits = (n + 31) >>> 5;
        var result = new JSBI(neededDigits, x.sign);
        var last = neededDigits - 1;
        for (var i = 0; i < last; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        var msd = x.__digit(last);
        if ((n & 31) !== 0) {
            var drop = 32 - (n & 31);
            msd = (msd << drop) >>> drop;
        }
        result.__setDigit(last, msd);
        return result.__trim();
    };
    JSBI.__truncateAndSubFromPowerOfTwo = function (n, x, resultSign) {
        var neededDigits = (n + 31) >>> 5;
        var result = new JSBI(neededDigits, resultSign);
        var i = 0;
        var last = neededDigits - 1;
        var borrow = 0;
        var limit = Math.min(last, x.length);
        for (; i < limit; i++) {
            var xDigit = x.__digit(i);
            var rLow = 0 - (xDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = 0 - (xDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < last; i++) {
            result.__setDigit(i, (-borrow) | 0);
        }
        var msd = last < x.length ? x.__digit(last) : 0;
        var msdBitsConsumed = n & 31;
        var resultMsd;
        if (msdBitsConsumed === 0) {
            var rLow = 0 - (msd & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = 0 - (msd >>> 16) - borrow;
            resultMsd = (rLow & 0xFFFF) | (rHigh << 16);
        }
        else {
            var drop = 32 - msdBitsConsumed;
            msd = (msd << drop) >>> drop;
            var minuendMsd = 1 << (32 - drop);
            var rLow = (minuendMsd & 0xFFFF) - (msd & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (minuendMsd >>> 16) - (msd >>> 16) - borrow;
            resultMsd = (rLow & 0xFFFF) | (rHigh << 16);
            resultMsd &= (minuendMsd - 1);
        }
        result.__setDigit(last, resultMsd);
        return result.__trim();
    };
    // Digit helpers.
    JSBI.prototype.__digit = function (i) {
        return this[i];
    };
    JSBI.prototype.__unsignedDigit = function (i) {
        return this[i] >>> 0;
    };
    JSBI.prototype.__setDigit = function (i, digit) {
        this[i] = digit | 0;
    };
    JSBI.prototype.__setDigitGrow = function (i, digit) {
        this[i] = digit | 0;
    };
    JSBI.prototype.__halfDigitLength = function () {
        var len = this.length;
        if (this.__unsignedDigit(len - 1) <= 0xFFFF)
            return len * 2 - 1;
        return len * 2;
    };
    JSBI.prototype.__halfDigit = function (i) {
        return (this[i >>> 1] >>> ((i & 1) << 4)) & 0xFFFF;
    };
    JSBI.prototype.__setHalfDigit = function (i, value) {
        var digitIndex = i >>> 1;
        var previous = this.__digit(digitIndex);
        var updated = (i & 1) ? (previous & 0xFFFF) | (value << 16)
            : (previous & 0xFFFF0000) | (value & 0xFFFF);
        this.__setDigit(digitIndex, updated);
    };
    JSBI.__digitPow = function (base, exponent) {
        var result = 1;
        while (exponent > 0) {
            if (exponent & 1)
                result *= base;
            exponent >>>= 1;
            base *= base;
        }
        return result;
    };
    JSBI.__kMaxLength = 1 << 25;
    JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;
    // Lookup table for the maximum number of bits required per character of a
    // base-N string representation of a number. To increase accuracy, the array
    // value is the actual value multiplied by 32. To generate this table:
    //
    // for (let i = 0; i <= 36; i++) {
    //   console.log(Math.ceil(Math.log2(i) * 32) + ',');
    // }
    JSBI.__kMaxBitsPerChar = [
        0, 0, 32, 51, 64, 75, 83, 90, 96,
        102, 107, 111, 115, 119, 122, 126, 128,
        131, 134, 136, 139, 141, 143, 145, 147,
        149, 151, 153, 154, 156, 158, 159, 160,
        162, 163, 165, 166,
    ];
    JSBI.__kBitsPerCharTableShift = 5;
    JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;
    JSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
    JSBI.__kBitConversionBuffer = new ArrayBuffer(8);
    JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);
    JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);
    return JSBI;
}(Array));
exports.JSBI = JSBI;
//# sourceMappingURL=jsbi.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/to-number.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/to-number.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Attempts to convert `x` into a `number`
 * without any loss in precision.
 *
 * If it is not possible, an error is thrown.
 *
 * -----
 *
 * In general, this should not happen if our `bigint` is
 * in the range,
 *
 * `[Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]`
 *
 * Which is,
 *
 * `[-9007199254740991, 9007199254740991]`
 *
 * @param x - The `bigint` to convert to a `number`
 */
function toNumber(x) {
    var result = Number(x);
    if (x.toString() === result.toString()) {
        return result;
    }
    else {
        throw new Error("Cannot convert bigint to number without loss in precision");
    }
}
exports.toNumber = toNumber;
//# sourceMappingURL=to-number.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/bigint-util/to-string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/bigint-util/to-string.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var jsbi_1 = __webpack_require__(/*! ./jsbi */ "./node_modules/type-mapping/dist/bigint-util/jsbi.js");
function toString(x, radix) {
    return jsbi_1.JSBI.BigInt(x.toString()).toString(radix);
}
exports.toString = toString;
//# sourceMappingURL=to-string.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/decorator/func.js":
/*!**********************************************************!*\
  !*** ./node_modules/type-mapping/dist/decorator/func.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function func() {
    var mappers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mappers[_i] = arguments[_i];
    }
    var factory = function (target) {
        if (mappers.length == 0) {
            //Nothing to validate.
            return target;
        }
        var name = (typeof target.name == "string") ?
            typeof target.name :
            "[Anonymous function]";
        var result = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var max = Math.max(args.length, target.length);
            for (var i = 0; i < max; ++i) {
                var mapper = (i < mappers.length) ?
                    mappers[i] :
                    //Probably a rest parameter
                    mappers[mappers.length - 1];
                if (i < args.length) {
                    args[i] = mapper(name + "(#" + i + ")", args[i]);
                }
                else {
                    args.push(mapper(name + "(#" + i + ")", undefined));
                }
            }
            return target.apply(this, args);
        };
        return result;
    };
    return factory;
}
exports.func = func;
//# sourceMappingURL=func.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/decorator/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/type-mapping/dist/decorator/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./func */ "./node_modules/type-mapping/dist/decorator/func.js"));
__export(__webpack_require__(/*! ./method */ "./node_modules/type-mapping/dist/decorator/method.js"));
__export(__webpack_require__(/*! ./prop */ "./node_modules/type-mapping/dist/decorator/prop.js"));
__export(__webpack_require__(/*! ./setter */ "./node_modules/type-mapping/dist/decorator/setter.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/decorator/method.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/decorator/method.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
function method() {
    var mappers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mappers[_i] = arguments[_i];
    }
    var result = function (target, propertyKey, descriptor) {
        if (mappers.length == 0) {
            //Nothing to validate.
            return;
        }
        var propertyName = (typeof propertyKey == "string") ?
            propertyKey :
            "Symbol(" + propertyKey.toString() + ")";
        var ctorName = type_util_1.getCtorName(target.constructor);
        var fullName = ctorName + "." + propertyName;
        var originalMethod = descriptor.value;
        if (!(originalMethod instanceof Function)) {
            throw new Error("Method " + fullName + " not found");
        }
        descriptor.value = (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var max = Math.max(args.length, originalMethod.length);
            for (var i = 0; i < max; ++i) {
                var mapper = (i < mappers.length) ?
                    mappers[i] :
                    //Probably a rest parameter
                    mappers[mappers.length - 1];
                if (i < args.length) {
                    args[i] = mapper(fullName + "(#" + i + ")", args[i]);
                }
                else {
                    args.push(mapper(fullName + "(#" + i + ")", undefined));
                }
            }
            if (originalMethod != undefined) {
                return originalMethod.apply(this, args);
            }
            else {
                return undefined;
            }
        });
    };
    return result;
}
exports.method = method;
/*
class Clazz {
    @method(() => 1, () => "")
    foo (arg0 : number, arg1 : string) {
    }
    //Rest params are a bit iffy
    @method(() => 1, ...[() => ""])
    foo2 (arg0 : number, ...arg1 : string[]) {
    }

    @setter()
    get x () {
        return 5;
    }

    @setter(() => 1, () => "")
    set name (v : string) {
        console.log(v);
    }
}
type wtf = ExtractKeyWithParams<Clazz, [() => 1]>
type c_name = Clazz["name"]
const c = new Clazz();
type p = Parameters<(arg0 : number, ...args : string[]) => void>
type p0 = p[0];
type p1 = p[1];
type p2 = p[2];
type l = p["length"];
//*/ 
//# sourceMappingURL=method.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/decorator/prop.js":
/*!**********************************************************!*\
  !*** ./node_modules/type-mapping/dist/decorator/prop.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var accessor_util_1 = __webpack_require__(/*! ../accessor-util */ "./node_modules/type-mapping/dist/accessor-util/index.js");
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
function prop(f) {
    var result = function (target, propertyKey) {
        /*
            Implementation copied over from schema-decorator.
            The code isn't too well-written and kind of confusing.
        */
        var propertyName = (typeof propertyKey == "string") ?
            propertyKey :
            "Symbol(" + propertyKey.toString() + ")";
        var privateName = "____hijacked-by-type-mapping-" + propertyName;
        var ctorName = type_util_1.getCtorName(target.constructor);
        var fullName = ctorName + "." + propertyName;
        /*
            We call this `superAccessorGenerator` because
            calling `.set()` on this may trigger the base class'
            decorator that may create another accessor on the base class.

            `superSetter` below is the `.set()` of the base class,
            if it exists.

            We need to also call the base class' `.set()`
            because there may be other mappers running in the
            base class.
        */
        var superAccessorGenerator = accessor_util_1.getAccessor(target, propertyKey);
        Object.defineProperty(target, propertyKey, {
            get: function () {
                return this[privateName];
            },
            set: function (mixed) {
                //If we are here, we have the accessor defined on the class prototype,
                //but not on the instance itself.
                //We want to preserve the behaviour of Object.keys(),
                //So, we need to define the accessor on the instance.
                var superSetter = undefined;
                if (superAccessorGenerator != undefined && superAccessorGenerator.set != undefined) {
                    superAccessorGenerator.set.bind(this)(mixed);
                    var accessor = Object.getOwnPropertyDescriptor(this, propertyKey);
                    if (!accessor_util_1.isAccessorDescriptor(accessor) || accessor.set == undefined) {
                        throw new Error("Expected " + fullName + " to be an accessor and have a \"set()\" method");
                    }
                    superSetter = accessor.set.bind(this);
                }
                //Set the value on the instance first,
                //We define a property that is not enumerable,
                //So it does not show up in Object.keys().
                //We don't want this property to show up because
                //its name is `privateName`, not the "original" name.
                if (superSetter == undefined) {
                    Object.defineProperty(this, privateName, {
                        value: f(fullName, mixed),
                        writable: true,
                        enumerable: false,
                    });
                }
                else {
                    superSetter(f(fullName, mixed));
                }
                //We define the accessor that should be used from now on
                //And will be enumerable with Object.keys(instance)
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return this[privateName];
                    },
                    set: function (mixed) {
                        if (superSetter == undefined) {
                            this[privateName] = f(fullName, mixed);
                        }
                        else {
                            superSetter(f(fullName, mixed));
                        }
                    },
                    enumerable: true,
                    configurable: true,
                });
            },
            enumerable: true,
        });
    };
    return result;
}
exports.prop = prop;
/*
class Clazz {
    @prop(() => "1")
    prop0 : number = 3;
}
const c = new Clazz();
//*/ 
//# sourceMappingURL=prop.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/decorator/setter.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/decorator/setter.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
function setter(f) {
    var result = function (target, propertyKey, descriptor) {
        var propertyName = (typeof propertyKey == "string") ?
            propertyKey :
            "Symbol(" + propertyKey.toString() + ")";
        var ctorName = type_util_1.getCtorName(target.constructor);
        var fullName = ctorName + "." + propertyName;
        var originalMethod = descriptor.set;
        descriptor.set = (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length == 0) {
                throw new Error("Cannot call " + fullName + ".set() with zero arguments");
            }
            for (var i = 0; i < args.length; ++i) {
                args[i] = f(fullName, args[i]);
            }
            if (originalMethod != undefined) {
                return originalMethod.apply(this, args);
            }
            else {
                return undefined;
            }
        });
    };
    return result;
}
exports.setter = setter;
/*
class Clazz {
    @setter(() => "1")
    set name (v : string) {
        console.log(v);
    }
}
//*/ 
//# sourceMappingURL=setter.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/enum-util/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/type-mapping/dist/enum-util/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//Please only pass enums here
var Enum;
(function (Enum) {
})(Enum = exports.Enum || (exports.Enum = {}));
function getKeys(e) {
    return (Object.keys(e)
        .filter(function (k) {
        if (/^\d/.test(k)) {
            return false;
        }
        var v = e[k];
        return (typeof v == "string" ||
            typeof v == "number");
    }));
}
exports.getKeys = getKeys;
function getValues(e) {
    return getKeys(e).map(function (k) { return e[k]; });
}
exports.getValues = getValues;
function getEntries(e) {
    return getKeys(e).map(function (k) {
        return {
            key: k,
            value: e[k],
        };
    });
}
exports.getEntries = getEntries;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-code.js":
/*!******************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-code.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function toKeyEnum() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return arr.reduce(function (memo, k) {
        memo[k] = k;
        return memo;
    }, {});
}
/**
 * @todo More error codes
 */
exports.ErrorCode = toKeyEnum(
/**
 * + `expectedMeta.gt`
 */
"EXPECTED_GREATER_THAN", 
/**
 * + `expectedMeta.lt`
 */
"EXPECTED_LESS_THAN", 
/**
 * + `expectedMeta.gtEq`
 */
"EXPECTED_GREATER_THAN_OR_EQUAL_TO", 
/**
 * + `expectedMeta.ltEq`
 */
"EXPECTED_LESS_THAN_OR_EQUAL_TO", 
/**
 * + `expected`
 */
"EXPECTED_TYPE", 
/**
 * + `expectedMeta.min`
 * + `expectedMeta.max`
 */
"EXPECTED_LENGTH", 
/**
 * + `expectedMeta.min`
 * + `expectedMeta.max`
 */
"EXPECTED_BYTE_LENGTH", 
/**
 * + `expectedMeta.mappableValue`
 * + `expectedMeta.outputValue`
 * + `expectedMeta.entries`
 */
"EXPECTED_ENUM_KEY", 
/**
 * + `expectedMeta.mappableValue`
 * + `expectedMeta.outputValue`
 * + `expectedMeta.entries`
 */
"EXPECTED_ENUM_VALUE", 
/**
 * + `expectedMeta.mappableValue`
 * + `expectedMeta.outputValue`
 * + `expectedMeta.desiredValue`
 * + `expectedMeta.validKeys`
 */
"EXPECTED_ONE_ENUM_VALUE_OR_VALID_ENUM_KEY", 
/**
 * + `expectedMeta.maxPrecision`
 * + `expectedMeta.maxScale`
 * + `expectedMeta.curPrecision`
 * + `expectedMeta.curScale`
 */
"EXPECTED_DECIMAL_PRECISION_LESS_THAN_OR_EQUAL_TO", 
/**
 * + `expectedMeta.maxPrecision`
 * + `expectedMeta.maxScale`
 * + `expectedMeta.curPrecision`
 * + `expectedMeta.curScale`
 */
"EXPECTED_DECIMAL_SCALE_LESS_THAN_OR_EQUAL_TO");
//# sourceMappingURL=error-code.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/flatten-union-errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/flatten-union-errors.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function flattenUnionErrors(arr) {
    var result = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var err = arr_1[_i];
        if (err.unionErrors == undefined || err.unionErrors.length == 0) {
            result.push(err);
        }
        else {
            result.push.apply(result, flattenUnionErrors(err.unionErrors));
        }
    }
    return result;
}
exports.flattenUnionErrors = flattenUnionErrors;
//# sourceMappingURL=flatten-union-errors.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/indent-error-message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/indent-error-message.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function indentErrorMessage(str) {
    str = str
        .split("\n")
        .map(function (str) { return "\t" + str; })
        .join("\n");
    return "(\n" + str + "\n)";
}
exports.indentErrorMessage = indentErrorMessage;
//# sourceMappingURL=indent-error-message.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./flatten-union-errors */ "./node_modules/type-mapping/dist/error-util/flatten-union-errors.js"));
__export(__webpack_require__(/*! ./indent-error-message */ "./node_modules/type-mapping/dist/error-util/indent-error-message.js"));
__export(__webpack_require__(/*! ./is-mapping-error */ "./node_modules/type-mapping/dist/error-util/is-mapping-error.js"));
__export(__webpack_require__(/*! ./make-mapping-error */ "./node_modules/type-mapping/dist/error-util/make-mapping-error.js"));
__export(__webpack_require__(/*! ./make-normalized-union-error */ "./node_modules/type-mapping/dist/error-util/make-normalized-union-error.js"));
__export(__webpack_require__(/*! ./try-get-property-error */ "./node_modules/type-mapping/dist/error-util/try-get-property-error.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/is-mapping-error.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/is-mapping-error.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isMappingErrorArray(x) {
    if (!(x instanceof Array)) {
        return false;
    }
    for (var _i = 0, x_1 = x; _i < x_1.length; _i++) {
        var i = x_1[_i];
        if (!isMappingError(i)) {
            return false;
        }
    }
    return true;
}
exports.isMappingErrorArray = isMappingErrorArray;
function isMappingError(x) {
    if (!(x instanceof Error)) {
        return false;
    }
    var mixed = x;
    if (typeof mixed.inputName != "string") {
        return false;
    }
    if (mixed.expected != undefined && typeof mixed.expected != "string") {
        return false;
    }
    if (mixed.expectedMeta != undefined && !(mixed.expectedMeta instanceof Object)) {
        return false;
    }
    if (mixed.propertyErrors != undefined &&
        !isMappingErrorArray(mixed.propertyErrors)) {
        return false;
    }
    if (mixed.unionErrors != undefined &&
        !isMappingErrorArray(mixed.unionErrors)) {
        return false;
    }
    if (mixed.intersectionErrors != undefined &&
        !isMappingErrorArray(mixed.intersectionErrors)) {
        return false;
    }
    return true;
}
exports.isMappingError = isMappingError;
//# sourceMappingURL=is-mapping-error.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/make-mapping-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/make-mapping-error.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function makeMappingError(args) {
    var err = new Error(args.message);
    Object.defineProperty(err, "inputName", {
        value: args.inputName,
        enumerable: false,
    });
    Object.defineProperty(err, "actualValue", {
        value: args.actualValue,
        enumerable: false,
    });
    Object.defineProperty(err, "expected", {
        value: args.expected,
        enumerable: false,
    });
    Object.defineProperty(err, "expectedMeta", {
        value: args.expectedMeta,
        enumerable: false,
    });
    if ("propertyErrors" in args) {
        Object.defineProperty(err, "propertyErrors", {
            value: args.propertyErrors,
            enumerable: false,
        });
    }
    if ("unionErrors" in args) {
        Object.defineProperty(err, "unionErrors", {
            value: args.unionErrors,
            enumerable: false,
        });
    }
    if ("intersectionErrors" in args) {
        Object.defineProperty(err, "intersectionErrors", {
            value: args.intersectionErrors,
            enumerable: false,
        });
    }
    if (typeof args.stack == "string") {
        Object.defineProperty(err, "stack", {
            value: args.stack,
            enumerable: false,
        });
    }
    return err;
}
exports.makeMappingError = makeMappingError;
//# sourceMappingURL=make-mapping-error.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/make-normalized-union-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/make-normalized-union-error.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var flatten_union_errors_1 = __webpack_require__(/*! ./flatten-union-errors */ "./node_modules/type-mapping/dist/error-util/flatten-union-errors.js");
var array_util_1 = __webpack_require__(/*! ../array-util */ "./node_modules/type-mapping/dist/array-util/index.js");
var make_mapping_error_1 = __webpack_require__(/*! ./make-mapping-error */ "./node_modules/type-mapping/dist/error-util/make-mapping-error.js");
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var indent_error_message_1 = __webpack_require__(/*! ./indent-error-message */ "./node_modules/type-mapping/dist/error-util/indent-error-message.js");
function everyElementHasMappableValues(arr) {
    return arr.every(function (err) { return err.expectedMeta != undefined && err.expectedMeta.mappableValues != undefined; });
}
function everyElementHasOutputValues(arr) {
    return arr.every(function (err) { return err.expectedMeta != undefined && err.expectedMeta.outputValues != undefined; });
}
function makeNormalizedUnionError(name, mixed, unionErrors) {
    unionErrors = flatten_union_errors_1.flattenUnionErrors(unionErrors);
    var rawExpectedArr = unionErrors
        .map(function (e) { return e.expected; })
        .filter(function (i) { return typeof i == "string"; });
    if (rawExpectedArr.length == unionErrors.length) {
        var expected = array_util_1.removeDuplicateElements(rawExpectedArr)
            .map(function (str) { return "(" + str + ")"; })
            .join(" or ");
        return make_mapping_error_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                mappableValues: (everyElementHasMappableValues(unionErrors) ?
                    unionErrors.reduce(function (memo, err) {
                        memo.push.apply(memo, err.expectedMeta.mappableValues);
                        return memo;
                    }, []) :
                    undefined),
                outputValues: (everyElementHasOutputValues(unionErrors) ?
                    unionErrors.reduce(function (memo, err) {
                        memo.push.apply(memo, err.expectedMeta.outputValues);
                        return memo;
                    }, []) :
                    undefined),
            },
            unionErrors: unionErrors,
        });
    }
    else {
        /**
         * At least one of our mappers did not throw
         * a `MappingError`
         */
        var errorMessages = array_util_1.removeDuplicateElements(unionErrors
            .map(function (e) { return indent_error_message_1.indentErrorMessage(e.message); })).map(function (str) { return "(" + str + ")"; });
        var expected = array_util_1.removeDuplicateElements(rawExpectedArr.concat(["valid value"]))
            .map(function (str) { return "(" + str + ")"; })
            .join(" or ");
        return make_mapping_error_1.makeMappingError({
            message: name + " is invalid.\n" + errorMessages.join(" or\n"),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            unionErrors: unionErrors,
        });
    }
}
exports.makeNormalizedUnionError = makeNormalizedUnionError;
//# sourceMappingURL=make-normalized-union-error.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/error-util/try-get-property-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/error-util/try-get-property-error.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function tryGetPropertyError(mappingError, inputName) {
    if (mappingError.propertyErrors == undefined) {
        return undefined;
    }
    for (var _i = 0, _a = mappingError.propertyErrors; _i < _a.length; _i++) {
        var propertyError = _a[_i];
        if (propertyError.inputName == inputName) {
            return propertyError;
        }
    }
    return undefined;
}
exports.tryGetPropertyError = tryGetPropertyError;
//# sourceMappingURL=try-get-property-error.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/field-map/ctor.js":
/*!**********************************************************!*\
  !*** ./node_modules/type-mapping/dist/field-map/ctor.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
/**
    Constructs multiple `Field<>` instances at once.
*/
function fields(map) {
    var result = {};
    for (var name in map) {
        if (!map.hasOwnProperty(name)) {
            continue;
        }
        result[name] = mapper_1.withName(map[name], name);
    }
    return result;
}
exports.fields = fields;
//# sourceMappingURL=ctor.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/field-map/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/type-mapping/dist/field-map/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ctor */ "./node_modules/type-mapping/dist/field-map/ctor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fixed-point-util/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fixed-point-util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./is-equal */ "./node_modules/type-mapping/dist/fixed-point-util/is-equal.js"));
__export(__webpack_require__(/*! ./try-parse */ "./node_modules/type-mapping/dist/fixed-point-util/try-parse.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fixed-point-util/is-equal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fixed-point-util/is-equal.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BigIntUtil = __webpack_require__(/*! ../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
var ZeroEqualityAlgorithm;
(function (ZeroEqualityAlgorithm) {
    ZeroEqualityAlgorithm["NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL"] = "NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL";
    ZeroEqualityAlgorithm["NEGATIVE_AND_POSITIVE_ZERO_NOT_EQUAL"] = "NEGATIVE_AND_POSITIVE_ZERO_NOT_EQUAL";
})(ZeroEqualityAlgorithm = exports.ZeroEqualityAlgorithm || (exports.ZeroEqualityAlgorithm = {}));
function isEqual(a, b, zeroEqualityAlgorithm) {
    if (zeroEqualityAlgorithm == ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL &&
        a.isZero &&
        b.isZero) {
        return true;
    }
    if (a.isInteger != b.isInteger) {
        return false;
    }
    if (a.isNegative != b.isNegative) {
        return false;
    }
    if (a.isZero != b.isZero) {
        return false;
    }
    if (!BigIntUtil.equal(a.fixedPointIntegerPartLength, b.fixedPointIntegerPartLength)) {
        return false;
    }
    if (!BigIntUtil.equal(a.fixedPointFractionalPartLength, b.fixedPointFractionalPartLength)) {
        return false;
    }
    if (!BigIntUtil.equal(a.fixedPointLength, b.fixedPointLength)) {
        return false;
    }
    return (a.getFixedPointString() ==
        b.getFixedPointString());
}
exports.isEqual = isEqual;
//# sourceMappingURL=is-equal.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fixed-point-util/try-parse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fixed-point-util/try-parse.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FloatingPointUtil = __webpack_require__(/*! ../floating-point-util */ "./node_modules/type-mapping/dist/floating-point-util/index.js");
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var BigIntUtil = __webpack_require__(/*! ../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
var string_util_1 = __webpack_require__(/*! ../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
function lazyInit(initDelegate) {
    var initialized = false;
    var value = undefined;
    return function () {
        if (!initialized) {
            value = initDelegate();
            initialized = true;
        }
        return value;
    };
}
/**
 * @todo Make `getXxx()` functions cache results
 */
function tryParse(str) {
    var parsed = FloatingPointUtil.tryParse(str);
    if (parsed == undefined) {
        return undefined;
    }
    var _a = FloatingPointUtil.toIntegerAndExponent(parsed), isNegative = _a.isNegative, integerPart = _a.integerPart, isZero = _a.isZero, exponentValue = _a.exponentValue;
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    if (isZero) {
        var fixedPointIntegerPartLength = BigInt(1);
        var fixedPointFractionalPartLength = BigInt(1);
        var fixedPointLength = BigIntUtil.addMany((isNegative ? BigInt(1) : BigInt(0)), fixedPointIntegerPartLength, BigInt(1), fixedPointFractionalPartLength);
        var getFixedPointIntegerPartString_1 = function () { return "0"; };
        var getFixedPointFractionalPartString_1 = function () { return "0"; };
        var getFixedPointString = lazyInit(function () {
            var sign = isNegative ? "-" : "";
            return (sign +
                getFixedPointIntegerPartString_1() +
                "." +
                getFixedPointFractionalPartString_1());
        });
        return {
            isInteger: true,
            isNegative: isNegative,
            isZero: isZero,
            fixedPointIntegerPartLength: fixedPointIntegerPartLength,
            fixedPointFractionalPartLength: fixedPointFractionalPartLength,
            fixedPointLength: fixedPointLength,
            getFixedPointIntegerPartString: getFixedPointIntegerPartString_1,
            getFixedPointFractionalPartString: getFixedPointFractionalPartString_1,
            getFixedPointString: getFixedPointString,
        };
    }
    if (BigIntUtil.greaterThanOrEqual(exponentValue, 0)) {
        var fixedPointIntegerPartLength = BigIntUtil.add(BigInt(integerPart.length), exponentValue);
        var fixedPointFractionalPartLength = BigInt(1);
        var fixedPointLength = BigIntUtil.addMany((isNegative ? BigInt(1) : BigInt(0)), fixedPointIntegerPartLength, BigInt(1), fixedPointFractionalPartLength);
        var getFixedPointIntegerPartString_2 = lazyInit(function () { return (integerPart + string_util_1.stringRepeat("0", BigIntUtil.toNumber(exponentValue))); });
        var getFixedPointFractionalPartString_2 = function () { return "0"; };
        var getFixedPointString = lazyInit(function () {
            var sign = isNegative ? "-" : "";
            return (sign +
                getFixedPointIntegerPartString_2() +
                "." +
                getFixedPointFractionalPartString_2());
        });
        return {
            isInteger: true,
            isNegative: isNegative,
            isZero: isZero,
            fixedPointIntegerPartLength: fixedPointIntegerPartLength,
            fixedPointFractionalPartLength: fixedPointFractionalPartLength,
            fixedPointLength: fixedPointLength,
            getFixedPointIntegerPartString: getFixedPointIntegerPartString_2,
            getFixedPointFractionalPartString: getFixedPointFractionalPartString_2,
            getFixedPointString: getFixedPointString,
        };
    }
    else {
        var fractionalOffset = BigIntUtil.mul(exponentValue, -1);
        if (BigIntUtil.lessThan(fractionalOffset, integerPart.length)) {
            var newIntegerPart_1 = integerPart.substring(0, integerPart.length - BigIntUtil.toNumber(fractionalOffset));
            var newFractionalPart_1 = integerPart.substring(integerPart.length - BigIntUtil.toNumber(fractionalOffset), integerPart.length).replace(/(0+)$/, "");
            if (newFractionalPart_1 == "") {
                newFractionalPart_1 = "0";
            }
            var fixedPointIntegerPartLength = BigInt(newIntegerPart_1.length);
            var fixedPointFractionalPartLength = BigInt(newFractionalPart_1.length);
            var fixedPointLength = BigIntUtil.addMany((isNegative ? BigInt(1) : BigInt(0)), fixedPointIntegerPartLength, BigInt(1), fixedPointFractionalPartLength);
            var getFixedPointIntegerPartString_3 = function () { return newIntegerPart_1; };
            var getFixedPointFractionalPartString_3 = function () { return newFractionalPart_1; };
            var getFixedPointString = lazyInit(function () {
                var sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString_3() +
                    "." +
                    getFixedPointFractionalPartString_3());
            });
            return {
                isInteger: (newFractionalPart_1 == "0"),
                isNegative: isNegative,
                isZero: isZero,
                fixedPointIntegerPartLength: fixedPointIntegerPartLength,
                fixedPointFractionalPartLength: fixedPointFractionalPartLength,
                fixedPointLength: fixedPointLength,
                getFixedPointIntegerPartString: getFixedPointIntegerPartString_3,
                getFixedPointFractionalPartString: getFixedPointFractionalPartString_3,
                getFixedPointString: getFixedPointString,
            };
        }
        else if (BigIntUtil.equal(fractionalOffset, BigInt(integerPart.length))) {
            var newFractionalPart_2 = integerPart.replace(/(0+)$/, "");
            if (newFractionalPart_2 == "") {
                newFractionalPart_2 = "0";
            }
            var fixedPointIntegerPartLength = BigInt(1);
            var fixedPointFractionalPartLength = BigInt(newFractionalPart_2.length);
            var fixedPointLength = BigIntUtil.addMany((isNegative ? BigInt(1) : BigInt(0)), fixedPointIntegerPartLength, BigInt(1), fixedPointFractionalPartLength);
            var getFixedPointIntegerPartString_4 = function () { return ("0"); };
            var getFixedPointFractionalPartString_4 = function () { return newFractionalPart_2; };
            var getFixedPointString = lazyInit(function () {
                var sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString_4() +
                    "." +
                    getFixedPointFractionalPartString_4());
            });
            return {
                isInteger: (newFractionalPart_2 == "0"),
                isNegative: isNegative,
                isZero: isZero,
                fixedPointIntegerPartLength: fixedPointIntegerPartLength,
                fixedPointFractionalPartLength: fixedPointFractionalPartLength,
                fixedPointLength: fixedPointLength,
                getFixedPointIntegerPartString: getFixedPointIntegerPartString_4,
                getFixedPointFractionalPartString: getFixedPointFractionalPartString_4,
                getFixedPointString: getFixedPointString,
            };
        }
        else {
            var leadingZeroCount_1 = BigIntUtil.sub(fractionalOffset, BigInt(integerPart.length));
            var newFractionalPart_3 = integerPart.replace(/(0+)$/, "");
            if (newFractionalPart_3 == "") {
                leadingZeroCount_1 = BigInt(0);
                newFractionalPart_3 = "0";
            }
            var fixedPointIntegerPartLength = BigInt(1);
            var fixedPointFractionalPartLength = BigIntUtil.add(leadingZeroCount_1, BigInt(newFractionalPart_3.length));
            var fixedPointLength = BigIntUtil.addMany((isNegative ? BigInt(1) : BigInt(0)), fixedPointIntegerPartLength, BigInt(1), fixedPointFractionalPartLength);
            var getFixedPointIntegerPartString_5 = function () { return ("0"); };
            var getFixedPointFractionalPartString_5 = lazyInit(function () { return (string_util_1.stringRepeat("0", BigIntUtil.toNumber(leadingZeroCount_1)) +
                newFractionalPart_3); });
            var getFixedPointString = lazyInit(function () {
                var sign = isNegative ? "-" : "";
                return (sign +
                    getFixedPointIntegerPartString_5() +
                    "." +
                    getFixedPointFractionalPartString_5());
            });
            return {
                isInteger: (newFractionalPart_3 == "0"),
                isNegative: isNegative,
                isZero: isZero,
                fixedPointIntegerPartLength: fixedPointIntegerPartLength,
                fixedPointFractionalPartLength: fixedPointFractionalPartLength,
                fixedPointLength: fixedPointLength,
                getFixedPointIntegerPartString: getFixedPointIntegerPartString_5,
                getFixedPointFractionalPartString: getFixedPointFractionalPartString_5,
                getFixedPointString: getFixedPointString,
            };
        }
    }
}
exports.tryParse = tryParse;
//# sourceMappingURL=try-parse.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/floating-point-util/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/floating-point-util/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./to-integer-and-exponent */ "./node_modules/type-mapping/dist/floating-point-util/to-integer-and-exponent.js"));
__export(__webpack_require__(/*! ./try-parse */ "./node_modules/type-mapping/dist/floating-point-util/try-parse.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/floating-point-util/to-integer-and-exponent.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/floating-point-util/to-integer-and-exponent.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var BigIntUtil = __webpack_require__(/*! ../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
/**
 * Converts the fractional part to an integer part,
 * by lowering the exponent
 */
function toIntegerAndExponent(arg) {
    if (arg.fractionalPart == "0") {
        return arg;
    }
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    var exponentValue = BigIntUtil.sub(arg.exponentValue, BigInt(arg.fractionalPart.length));
    var integerPart = (arg.integerPart == "0" ?
        arg.fractionalPart.replace(/^(0+)/, "") :
        arg.integerPart + arg.fractionalPart);
    return {
        isNegative: arg.isNegative,
        integerPart: integerPart,
        fractionalPart: "0",
        isZero: arg.isZero,
        exponentValue: exponentValue,
    };
}
exports.toIntegerAndExponent = toIntegerAndExponent;
//# sourceMappingURL=to-integer-and-exponent.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/floating-point-util/try-parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/floating-point-util/try-parse.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var BigIntUtil = __webpack_require__(/*! ../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
exports.floatingPointRegex = /^([-+])?([0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)([eE]([-+])?([0-9]+))?$/;
function tryParse(str) {
    var m = exports.floatingPointRegex.exec(str);
    if (m == undefined) {
        return undefined;
    }
    //-123.456e+789
    //~
    var rawCoefficientSign = m[1];
    //-123.456e+789
    // ~~~~~~~
    var rawCoefficientValue = m[2];
    //-123.456e+789
    //         ~
    var rawExponentSign = m[4];
    //-123.456e+789
    //          ~~~
    var rawExponentValue = m[5];
    var rawDecimalPlaceIndex = rawCoefficientValue.indexOf(".");
    var rawIntegerPart = (rawDecimalPlaceIndex < 0 ?
        rawCoefficientValue :
        rawCoefficientValue.substring(0, rawDecimalPlaceIndex));
    var rawFractionalPart = (rawDecimalPlaceIndex < 0 ?
        "" :
        rawCoefficientValue.substring(rawDecimalPlaceIndex + 1, rawCoefficientValue.length));
    var trimmedIntegerPart = rawIntegerPart.replace(/^(0+)/, "");
    var integerPart = (trimmedIntegerPart == "" ?
        "0" :
        trimmedIntegerPart);
    var trimmedFractionalPart = rawFractionalPart.replace(/(0+)$/, "");
    var fractionalPart = (trimmedFractionalPart == "" ?
        "0" :
        trimmedFractionalPart);
    var isZero = (integerPart == "0" && fractionalPart == "0");
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    var exponentValue = (isZero ?
        BigInt(0) :
        rawExponentValue == undefined ?
            BigInt(0) :
            BigIntUtil.mul(BigInt(rawExponentValue), BigInt((rawExponentSign === "-") ?
                -1 :
                1)));
    return {
        isNegative: (rawCoefficientSign === "-"),
        integerPart: integerPart,
        fractionalPart: fractionalPart,
        isZero: isZero,
        exponentValue: exponentValue,
    };
}
exports.tryParse = tryParse;
//# sourceMappingURL=try-parse.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fluent-lib/field-map-ctor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fluent-lib/field-map-ctor.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_mapper_1 = __webpack_require__(/*! ../fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js");
/**
    Constructs multiple `Field<>` instances at once,
    that are also `FluentMapper<>` instances
*/
function fields(map) {
    var result = {};
    for (var name in map) {
        if (!map.hasOwnProperty(name)) {
            continue;
        }
        result[name] = fluent_mapper_1.fluentMapper(map[name]).withName(name);
    }
    return result;
}
exports.fields = fields;
//# sourceMappingURL=field-map-ctor.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fluent-lib/generic.js":
/*!**************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fluent-lib/generic.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var m = __webpack_require__(/*! ../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
var fluent_mapper_1 = __webpack_require__(/*! ../fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js");
function arrayLike(f) {
    return fluent_mapper_1.fluentMapper(m.arrayLike(f));
}
exports.arrayLike = arrayLike;
function arrayLikeToArray(f) {
    return fluent_mapper_1.fluentMapper(m.arrayLikeToArray(f));
}
exports.arrayLikeToArray = arrayLikeToArray;
function arrayLikeToReadOnlyArray(f) {
    return fluent_mapper_1.fluentMapper(m.arrayLikeToReadOnlyArray(f));
}
exports.arrayLikeToReadOnlyArray = arrayLikeToReadOnlyArray;
function array(f) {
    return fluent_mapper_1.fluentMapper(m.array(f));
}
exports.array = array;
function readOnlyArray(f) {
    return fluent_mapper_1.fluentMapper(m.readOnlyArray(f));
}
exports.readOnlyArray = readOnlyArray;
function castEnumFlyweight(e) {
    var src = m.castEnumFlyweight(e);
    var result = {
        toValue: {},
        toKey: {},
    };
    for (var k in src.toValue) {
        if (!src.toValue.hasOwnProperty(k)) {
            continue;
        }
        result.toValue[k] = fluent_mapper_1.fluentMapper(src.toValue[k]);
    }
    for (var k in src.toKey) {
        if (!src.toKey.hasOwnProperty(k)) {
            continue;
        }
        result.toKey[k] = fluent_mapper_1.fluentMapper(src.toKey[k]);
    }
    return result;
}
exports.castEnumFlyweight = castEnumFlyweight;
function toEnumValue(e) {
    return fluent_mapper_1.fluentMapper(m.toEnumValue(e));
}
exports.toEnumValue = toEnumValue;
function toEnumKey(e) {
    return fluent_mapper_1.fluentMapper(m.toEnumKey(e));
}
exports.toEnumKey = toEnumKey;
function toOneEnumValue(e, k) {
    return fluent_mapper_1.fluentMapper(m.toOneEnumValue(e, k));
}
exports.toOneEnumValue = toOneEnumValue;
function toOneEnumKey(e, k) {
    return fluent_mapper_1.fluentMapper(m.toOneEnumKey(e, k));
}
exports.toOneEnumKey = toOneEnumKey;
function enumKey(e) {
    return fluent_mapper_1.fluentMapper(m.enumKey(e));
}
exports.enumKey = enumKey;
function enumValue(e) {
    return fluent_mapper_1.fluentMapper(m.enumValue(e));
}
exports.enumValue = enumValue;
function unsafeLiteral() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.unsafeLiteral.apply(m, arr));
}
exports.unsafeLiteral = unsafeLiteral;
function literal(arg0) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.literal.apply(m, [arg0].concat(arr)));
}
exports.literal = literal;
function tupleLiteral() {
    var tuple = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tuple[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.tupleLiteral.apply(m, tuple));
}
exports.tupleLiteral = tupleLiteral;
function deriveMap(map) {
    return fluent_mapper_1.fluentMapper(m.deriveMap(map));
}
exports.deriveMap = deriveMap;
function derive(srcKey, dstKey, f) {
    return fluent_mapper_1.fluentMapper(m.derive(srcKey, dstKey, f));
}
exports.derive = derive;
function instanceOf(ctor) {
    return fluent_mapper_1.fluentMapper(m.instanceOf(ctor));
}
exports.instanceOf = instanceOf;
function objectFromArray() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.objectFromArray.apply(m, arr));
}
exports.objectFromArray = objectFromArray;
function objectFromMap(map) {
    return fluent_mapper_1.fluentMapper(m.objectFromMap(map));
}
exports.objectFromMap = objectFromMap;
exports.object = function () {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.object.apply(m, arr));
};
function partialDeriveMap(map) {
    return fluent_mapper_1.fluentMapper(m.partialDeriveMap(map));
}
exports.partialDeriveMap = partialDeriveMap;
function partialObjectFromArray() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.partialObjectFromArray.apply(m, arr));
}
exports.partialObjectFromArray = partialObjectFromArray;
function partialObjectFromMap(map) {
    return fluent_mapper_1.fluentMapper(m.partialObjectFromMap(map));
}
exports.partialObjectFromMap = partialObjectFromMap;
exports.partialObject = function () {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.partialObject.apply(m, arr));
};
function partialRenameMap(map) {
    return fluent_mapper_1.fluentMapper(m.partialRenameMap(map));
}
exports.partialRenameMap = partialRenameMap;
function renameMap(map) {
    return fluent_mapper_1.fluentMapper(m.renameMap(map));
}
exports.renameMap = renameMap;
function rename(srcKey, dstKey, f) {
    return fluent_mapper_1.fluentMapper(m.rename(srcKey, dstKey, f));
}
exports.rename = rename;
function unsafeStringIndexer(f) {
    return fluent_mapper_1.fluentMapper(m.unsafeStringIndexer(f));
}
exports.unsafeStringIndexer = unsafeStringIndexer;
function stringIndexer(f) {
    return fluent_mapper_1.fluentMapper(m.stringIndexer(f));
}
exports.stringIndexer = stringIndexer;
function cache(cached, f) {
    return fluent_mapper_1.fluentMapper(m.cache(cached, f));
}
exports.cache = cache;
function cast(srcDelegate, castDelegate, dstDelegate) {
    return fluent_mapper_1.fluentMapper(m.cast(srcDelegate, castDelegate, dstDelegate));
}
exports.cast = cast;
function unsafeDeepMerge() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.unsafeDeepMerge.apply(m, arr));
}
exports.unsafeDeepMerge = unsafeDeepMerge;
function deepMerge(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.deepMerge.apply(m, [f].concat(arr)));
}
exports.deepMerge = deepMerge;
function unsafeDiscriminatedUnion(discriminantK) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.unsafeDiscriminatedUnion.apply(m, [discriminantK].concat(arr)));
}
exports.unsafeDiscriminatedUnion = unsafeDiscriminatedUnion;
function discriminatedUnion(discriminantK, f) {
    var arr = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        arr[_i - 2] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.discriminatedUnion.apply(m, [discriminantK, f].concat(arr)));
}
exports.discriminatedUnion = discriminatedUnion;
function excludeLiteral(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.excludeLiteral.apply(m, [f].concat(arr)));
}
exports.excludeLiteral = excludeLiteral;
function orUndefined(f) {
    return fluent_mapper_1.fluentMapper(m.orUndefined(f));
}
exports.orUndefined = orUndefined;
function orNull(f) {
    return fluent_mapper_1.fluentMapper(m.orNull(f));
}
exports.orNull = orNull;
function orMaybe(f) {
    return fluent_mapper_1.fluentMapper(m.orMaybe(f));
}
exports.orMaybe = orMaybe;
function notUndefined(f) {
    return fluent_mapper_1.fluentMapper(m.notUndefined(f));
}
exports.notUndefined = notUndefined;
function notNull(f) {
    return fluent_mapper_1.fluentMapper(m.notNull(f));
}
exports.notNull = notNull;
function notMaybe(f) {
    return fluent_mapper_1.fluentMapper(m.notMaybe(f));
}
exports.notMaybe = notMaybe;
function optional(f) {
    return fluent_mapper_1.fluentMapper(m.optional(f));
}
exports.optional = optional;
function notOptional(f) {
    return fluent_mapper_1.fluentMapper(m.notOptional(f));
}
exports.notOptional = notOptional;
function unsafeOr() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.unsafeOr.apply(m, arr));
}
exports.unsafeOr = unsafeOr;
function or(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.or.apply(m, [f].concat(arr)));
}
exports.or = or;
exports.pipe = function () {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.reallyUnsafePipe.apply(m, arr));
};
function unsafePipe(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.unsafePipe.apply(m, [f].concat(arr)));
}
exports.unsafePipe = unsafePipe;
function reallyUnsafePipe() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return fluent_mapper_1.fluentMapper(m.reallyUnsafePipe.apply(m, arr));
}
exports.reallyUnsafePipe = reallyUnsafePipe;
function deferred() {
    return fluent_mapper_1.fluentMapper(m.deferred());
}
exports.deferred = deferred;
//# sourceMappingURL=generic.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fluent-lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fluent-lib/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../buffer.d.ts" />
var non_generic_1 = __webpack_require__(/*! ./non-generic */ "./node_modules/type-mapping/dist/fluent-lib/non-generic.js");
exports.null = non_generic_1.null;
/**
    Export generated with `npm run generate-fluent-lib-export`

    The export generation script is needed because of this,
    https://github.com/microsoft/TypeScript/issues/31824
*/
var non_generic_2 = __webpack_require__(/*! ./non-generic */ "./node_modules/type-mapping/dist/fluent-lib/non-generic.js");
exports.unsafeAny = non_generic_2.unsafeAny;
exports.instanceOfArray = non_generic_2.instanceOfArray;
exports.instanceOfReadOnlyArray = non_generic_2.instanceOfReadOnlyArray;
exports.implementsArrayLike = non_generic_2.implementsArrayLike;
exports.length = non_generic_2.length;
exports.bigInt = non_generic_2.bigInt;
exports.unsignedBigInt = non_generic_2.unsignedBigInt;
exports.stringToBigInt = non_generic_2.stringToBigInt;
exports.stringToUnsignedBigInt = non_generic_2.stringToUnsignedBigInt;
exports.integerToBigInt = non_generic_2.integerToBigInt;
exports.unsignedIntegerToUnsignedBigInt = non_generic_2.unsignedIntegerToUnsignedBigInt;
exports.toBigInt = non_generic_2.toBigInt;
exports.toUnsignedBigInt = non_generic_2.toUnsignedBigInt;
exports.bigIntGt = non_generic_2.bigIntGt;
exports.bigIntLt = non_generic_2.bigIntLt;
exports.bigIntGtEq = non_generic_2.bigIntGtEq;
exports.bigIntLtEq = non_generic_2.bigIntLtEq;
exports.bigIntRange = non_generic_2.bigIntRange;
exports.boolean = non_generic_2.boolean;
exports.finiteNumberToBoolean = non_generic_2.finiteNumberToBoolean;
exports.stringToBoolean = non_generic_2.stringToBoolean;
exports.finiteNumberToTrue = non_generic_2.finiteNumberToTrue;
exports.finiteNumberToFalse = non_generic_2.finiteNumberToFalse;
exports.stringToTrue = non_generic_2.stringToTrue;
exports.stringToFalse = non_generic_2.stringToFalse;
exports.toBoolean = non_generic_2.toBoolean;
exports.toTrue = non_generic_2.toTrue;
exports.toFalse = non_generic_2.toFalse;
exports.instanceOfBuffer = non_generic_2.instanceOfBuffer;
exports.bufferLength = non_generic_2.bufferLength;
exports.bufferExactLength = non_generic_2.bufferExactLength;
exports.unsafeStringToDate = non_generic_2.unsafeStringToDate;
exports.dateToString = non_generic_2.dateToString;
exports.unixTimestampSecondsToDate = non_generic_2.unixTimestampSecondsToDate;
exports.unixTimestampMillisecondsToDate = non_generic_2.unixTimestampMillisecondsToDate;
exports.dateToUnixTimestampSeconds = non_generic_2.dateToUnixTimestampSeconds;
exports.dateToUnixTimestampMilliseconds = non_generic_2.dateToUnixTimestampMilliseconds;
exports.instanceOfDate = non_generic_2.instanceOfDate;
exports.stringToJsonObject = non_generic_2.stringToJsonObject;
exports.jsonObject = non_generic_2.jsonObject;
exports.never = non_generic_2.never;
exports.nonMaybe = non_generic_2.nonMaybe;
exports.undefinedToNull = non_generic_2.undefinedToNull;
exports.emptyStringToNull = non_generic_2.emptyStringToNull;
exports.whitespaceStringToNull = non_generic_2.whitespaceStringToNull;
exports.stringToFiniteNumber = non_generic_2.stringToFiniteNumber;
exports.stringToInteger = non_generic_2.stringToInteger;
exports.stringToUnsignedInteger = non_generic_2.stringToUnsignedInteger;
exports.toFiniteNumber = non_generic_2.toFiniteNumber;
exports.toInteger = non_generic_2.toInteger;
exports.toUnsignedInteger = non_generic_2.toUnsignedInteger;
exports.gt = non_generic_2.gt;
exports.lt = non_generic_2.lt;
exports.gtEq = non_generic_2.gtEq;
exports.ltEq = non_generic_2.ltEq;
exports.range = non_generic_2.range;
exports.unsafeNumber = non_generic_2.unsafeNumber;
exports.finiteNumber = non_generic_2.finiteNumber;
exports.integer = non_generic_2.integer;
exports.unsignedInteger = non_generic_2.unsignedInteger;
exports.toEmptyObject = non_generic_2.toEmptyObject;
exports.instanceOfObject = non_generic_2.instanceOfObject;
exports.pojo = non_generic_2.pojo;
exports.runTimeRequired = non_generic_2.runTimeRequired;
exports.notRunTimeRequired = non_generic_2.notRunTimeRequired;
exports.finiteNumberToFiniteNumberString = non_generic_2.finiteNumberToFiniteNumberString;
exports.integerToIntegerString = non_generic_2.integerToIntegerString;
exports.unsignedIntegerToUnsignedIntegerString = non_generic_2.unsignedIntegerToUnsignedIntegerString;
exports.jsonObjectToJsonObjectString = non_generic_2.jsonObjectToJsonObjectString;
exports.ipAddressString = non_generic_2.ipAddressString;
exports.ipV4MappedIpV6String = non_generic_2.ipV4MappedIpV6String;
exports.ipV4OctetString = non_generic_2.ipV4OctetString;
exports.ipV4String = non_generic_2.ipV4String;
exports.ipV6SegmentString = non_generic_2.ipV6SegmentString;
exports.ipV6StringWithMaxSegmentCount = non_generic_2.ipV6StringWithMaxSegmentCount;
exports.ipV6String = non_generic_2.ipV6String;
exports.floatingPointFormatString = non_generic_2.floatingPointFormatString;
exports.integerFormatString = non_generic_2.integerFormatString;
exports.unsignedIntegerFormatString = non_generic_2.unsignedIntegerFormatString;
exports.finiteNumberString = non_generic_2.finiteNumberString;
exports.integerString = non_generic_2.integerString;
exports.unsignedIntegerString = non_generic_2.unsignedIntegerString;
exports.string = non_generic_2.string;
exports.jsonObjectString = non_generic_2.jsonObjectString;
exports.stringLength = non_generic_2.stringLength;
exports.stringExactLength = non_generic_2.stringExactLength;
exports.match = non_generic_2.match;
exports.notMatch = non_generic_2.notMatch;
exports.email = non_generic_2.email;
exports.emailAddress = non_generic_2.emailAddress;
exports.hexadecimalString = non_generic_2.hexadecimalString;
exports.toUpperCase = non_generic_2.toUpperCase;
exports.toLowerCase = non_generic_2.toLowerCase;
exports.padLeft = non_generic_2.padLeft;
exports.padRight = non_generic_2.padRight;
exports.subStringBlacklist = non_generic_2.subStringBlacklist;
exports.toTrimmed = non_generic_2.toTrimmed;
exports.byteLength = non_generic_2.byteLength;
exports.instanceOfUint8Array = non_generic_2.instanceOfUint8Array;
exports.uint8ArrayLength = non_generic_2.uint8ArrayLength;
exports.uint8ArrayExactLength = non_generic_2.uint8ArrayExactLength;
exports.nullToUndefined = non_generic_2.nullToUndefined;
exports.emptyStringToUndefined = non_generic_2.emptyStringToUndefined;
exports.whitespaceStringToUndefined = non_generic_2.whitespaceStringToUndefined;
exports.undefined = non_generic_2.undefined;
exports.unknown = non_generic_2.unknown;
__export(__webpack_require__(/*! ./generic */ "./node_modules/type-mapping/dist/fluent-lib/generic.js"));
__export(__webpack_require__(/*! ./field-map-ctor */ "./node_modules/type-mapping/dist/fluent-lib/field-map-ctor.js"));
var ArrayBufferUtil = __webpack_require__(/*! ../array-buffer-util */ "./node_modules/type-mapping/dist/array-buffer-util/index.js");
exports.ArrayBufferUtil = ArrayBufferUtil;
var EnumUtil = __webpack_require__(/*! ../enum-util */ "./node_modules/type-mapping/dist/enum-util/index.js");
exports.EnumUtil = EnumUtil;
var BigIntUtil = __webpack_require__(/*! ../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
exports.BigIntUtil = BigIntUtil;
var FixedPointUtil = __webpack_require__(/*! ../fixed-point-util */ "./node_modules/type-mapping/dist/fixed-point-util/index.js");
exports.FixedPointUtil = FixedPointUtil;
var FloatingPointUtil = __webpack_require__(/*! ../floating-point-util */ "./node_modules/type-mapping/dist/floating-point-util/index.js");
exports.FloatingPointUtil = FloatingPointUtil;
__export(__webpack_require__(/*! ../decorator */ "./node_modules/type-mapping/dist/decorator/index.js"));
var ErrorUtil = __webpack_require__(/*! ../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
exports.ErrorUtil = ErrorUtil;
var jsonApi = __webpack_require__(/*! ../json-api-lib */ "./node_modules/type-mapping/dist/json-api-lib/index.js");
exports.jsonApi = jsonApi;
__export(__webpack_require__(/*! ../mapper */ "./node_modules/type-mapping/dist/mapper/index.js"));
var mysql = __webpack_require__(/*! ../mysql-lib */ "./node_modules/type-mapping/dist/mysql-lib/index.js");
exports.mysql = mysql;
var TypeUtil = __webpack_require__(/*! ../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
exports.TypeUtil = TypeUtil;
__export(__webpack_require__(/*! ../error-code */ "./node_modules/type-mapping/dist/error-code.js"));
__export(__webpack_require__(/*! ../fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fluent-lib/non-generic.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/fluent-lib/non-generic.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var m = __webpack_require__(/*! ../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
var fluent_mapper_1 = __webpack_require__(/*! ../fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js");
function omit(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var result = __assign({}, obj);
    for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
        var k = keys_1[_a];
        delete result[k];
    }
    return result;
}
function toFluentExport(obj) {
    var result = {};
    var _loop_1 = function (k) {
        if (!obj.hasOwnProperty(k)) {
            return "continue";
        }
        result[k] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fluent_mapper_1.fluentMapper(obj[k].apply(obj, args));
        };
    };
    for (var k in obj) {
        _loop_1(k);
    }
    return result;
}
//No need for omit<>() because `fluent-lib/index.ts`
//overwrites the generic functions with the ones
//in `fluent-lib/generic.ts`
var fluentExport = toFluentExport(omit(m, 
//Well, we need to omit this one because
//it doesn't return a SafeMapper<>
"castEnumFlyweight"));
module.exports = fluentExport;
//# sourceMappingURL=non-generic.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/fluent-mapper.js":
/*!*********************************************************!*\
  !*** ./node_modules/type-mapping/dist/fluent-mapper.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ./mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var functional_lib_1 = __webpack_require__(/*! ./functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
var type_util_1 = __webpack_require__(/*! ./type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
function fluentMapper(f) {
    var result = function (name, mixed) {
        return f(name, mixed);
    };
    result.__optional = mapper_1.getOptionalFlagOrFalse(f);
    //== mapper/debug ==
    result._debugIsExpectedInput = function (_x) {
    };
    result._debugIsHandledInput = function (_x) {
    };
    result._debugIsMappableInput = function (_x) {
    };
    result._debugIsOutput = function (_x) {
    };
    //== mapper/operation ==
    result.map = function (name, mixed) {
        return mapper_1.map(f, name, mixed);
    };
    result.mapExpected = function (name, mixed) {
        return mapper_1.mapExpected(f, name, mixed);
    };
    result.mapMappable = function (name, mixed) {
        return mapper_1.mapMappable(f, name, mixed);
    };
    result.mapHandled = function (name, mixed) {
        return mapper_1.mapHandled(f, name, mixed);
    };
    result.tryMap = function (name, mixed) {
        return mapper_1.tryMap(f, name, mixed);
    };
    result.tryMapExpected = function (name, mixed) {
        return mapper_1.tryMapExpected(f, name, mixed);
    };
    result.tryMapMappable = function (name, mixed) {
        return mapper_1.tryMapMappable(f, name, mixed);
    };
    result.tryMapHandled = function (name, mixed) {
        return mapper_1.tryMapHandled(f, name, mixed);
    };
    result.expectMappableInput = function () {
        return fluentMapper(mapper_1.expectMappableInput(f));
    };
    result.withExpectedInput = function () {
        return fluentMapper(mapper_1.withExpectedInput(f)());
    };
    result.withMapper = function (newMapper) {
        return fluentMapper(mapper_1.withMapper(f, newMapper));
    };
    result.withName = function (name) {
        return fluentMapper(mapper_1.withName(f, name));
    };
    //== array ==
    result.array = function () {
        return fluentMapper(functional_lib_1.array(f));
    };
    result.readOnlyArray = function () {
        return fluentMapper(functional_lib_1.readOnlyArray(f));
    };
    result.arrayLikeToArray = function () {
        return fluentMapper(functional_lib_1.arrayLikeToArray(f));
    };
    result.arrayLikeToReadOnlyArray = function () {
        return fluentMapper(functional_lib_1.arrayLikeToReadOnlyArray(f));
    };
    //== array-like ==
    result.arrayLike = function () {
        return fluentMapper(functional_lib_1.arrayLike(f));
    };
    // == object
    result.derive = function (srcKey, dstKey) {
        return fluentMapper(functional_lib_1.derive(srcKey, dstKey, f));
    };
    result.rename = function (srcKey, dstKey) {
        return fluentMapper(functional_lib_1.rename(srcKey, dstKey, f));
    };
    result.unsafeStringIndexer = function () {
        return fluentMapper(functional_lib_1.unsafeStringIndexer(f));
    };
    result.stringIndexer = function () {
        return fluentMapper(functional_lib_1.stringIndexer(f));
    };
    //== operator ==
    result.cast = function (castDelegate, dstDelegate) {
        return fluentMapper(functional_lib_1.cast(f, castDelegate, dstDelegate));
    };
    result.deepMerge = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        var result = functional_lib_1.deepMerge.apply(void 0, [f].concat(arr));
        return fluentMapper(result);
    };
    result.excludeLiteral = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return fluentMapper(functional_lib_1.excludeLiteral.apply(void 0, [f].concat(arr)));
    };
    result.orUndefined = function () {
        return fluentMapper(functional_lib_1.orUndefined(f));
    };
    result.orNull = function () {
        return fluentMapper(functional_lib_1.orNull(f));
    };
    result.orMaybe = function () {
        return fluentMapper(functional_lib_1.orMaybe(f));
    };
    result.notUndefined = function () {
        return fluentMapper(functional_lib_1.notUndefined(f));
    };
    result.notNull = function () {
        return fluentMapper(functional_lib_1.notNull(f));
    };
    result.notMaybe = function () {
        return fluentMapper(functional_lib_1.notMaybe(f));
    };
    result.optional = function () {
        return fluentMapper(functional_lib_1.optional(f));
    };
    result.notOptional = function () {
        return fluentMapper(functional_lib_1.notOptional(f));
    };
    result.or = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return fluentMapper(functional_lib_1.or.apply(void 0, [f].concat(arr)));
    };
    result.pipe = (function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return fluentMapper(functional_lib_1.unsafePipe.apply(void 0, [f].concat(arr)));
    });
    result.unsafePipe = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return fluentMapper(functional_lib_1.unsafePipe.apply(void 0, [f].concat(arr)));
    };
    //== type ==
    result.setImplementation = function (impl) {
        f.setImplementation(impl);
    };
    //const rt : FluentMapper<AnySafeMapper> = result;
    return type_util_1.setFunctionName(result, mapper_1.getNameOrEmptyString(f));
}
exports.fluentMapper = fluentMapper;
/*
import {stringToUnsignedInteger, inclusiveRange} from "./functional-lib";
const n = stringToUnsignedInteger();
const x = fluentMapper(n);
x.__optional
x.__expectedInput
x.__mappableInput
const y = x
    .pipe(
        inclusiveRange({
            min : 3.141,
            max : 6.282,
        })
    )
    .derive("x", "y");
const opt = x.optional()
    .withName("qwerty");
//const x2 = x.withExpectedInput<any>();
//*/ 
//# sourceMappingURL=fluent-mapper.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/any/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/any/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./unsafe-any */ "./node_modules/type-mapping/dist/functional-lib/any/unsafe-any.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/any/unsafe-any.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/any/unsafe-any.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Prefer to use `unknown()` instead.
 */
function unsafeAny() {
    return function (_name, mixed) {
        return mixed;
    };
}
exports.unsafeAny = unsafeAny;
//# sourceMappingURL=unsafe-any.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array-like/array-like.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array-like/array-like.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var implements_array_like_1 = __webpack_require__(/*! ./implements-array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/implements-array-like.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
function copyArrayLike(arr) {
    var result = [];
    for (var i = 0; i < arr.length; ++i) {
        result.push(arr[i]);
    }
    return result;
}
function arrayLike(f) {
    return mapper_1.copyRunTimeModifier(f, operator_1.pipe(implements_array_like_1.implementsArrayLike(), function (name, mixed) {
        var result = mixed;
        var isCopy = false;
        for (var i = 0; i < mixed.length; ++i) {
            /**
             * For now, fail quick for array-likes.
             *
             * @todo Should we accumulate errors like in `objectFromMap()`?
             * The array-like might be too large. How large is too large?
             * Should we accumulate the first `n` errors before throwing?
             */
            var cur = f("" + name + string_util_1.toPropertyAccess(i), mixed[i]);
            //We do not mind === here.
            //If either is a BigInt polyfill, we are okay with the copy.
            if (cur === mixed[i]) {
                continue;
            }
            if (!isCopy) {
                result = copyArrayLike(result);
                isCopy = true;
            }
            result[i] = cur;
        }
        return result;
    }));
}
exports.arrayLike = arrayLike;
//# sourceMappingURL=array-like.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array-like/implements-array-like.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array-like/implements-array-like.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var length_1 = __webpack_require__(/*! ./length */ "./node_modules/type-mapping/dist/functional-lib/array-like/length.js");
/**
    With this, a `string` will pass the check.

    ```ts
    const x : ArrayLike<string> = "test";
    console.log(x[0]);
    ```
*/
function implementsArrayLike() {
    return length_1.length({});
}
exports.implementsArrayLike = implementsArrayLike;
//# sourceMappingURL=implements-array-like.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array-like/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array-like/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/array-like.js"));
__export(__webpack_require__(/*! ./implements-array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/implements-array-like.js"));
__export(__webpack_require__(/*! ./length */ "./node_modules/type-mapping/dist/functional-lib/array-like/length.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array-like/length.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array-like/length.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var object_1 = __webpack_require__(/*! ../object */ "./node_modules/type-mapping/dist/functional-lib/object/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var operator_2 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function length(args) {
    var lengthDelegate = operator_1.pipe(number_1.unsignedInteger(), number_1.range({
        gtEq: args.min,
        ltEq: args.max,
    }));
    var expected = ((args.min == undefined) ?
        ((args.max == undefined) ?
            "value with \"length\" property" :
            "value of length less than, or equal to " + args.max.toString()) :
        ((args.max == undefined) ?
            "value of length greater than, or equal to " + args.min.toString() :
            (args.min == args.max) ?
                "value of length " + args.min.toString() :
                "value of length between " + args.min.toString() + " and " + args.max.toString()));
    return operator_1.pipe(operator_2.or(object_1.instanceOfObject(), string_1.string()), function (name, mixed) {
        var lengthResult = mapper_1.tryMapHandled(lengthDelegate, "" + name + string_util_1.toPropertyAccess("length"), mixed.length);
        if (lengthResult.success) {
            return mixed;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LENGTH,
                    min: args.min,
                    max: args.max,
                },
                propertyErrors: [
                    lengthResult.mappingError,
                ],
            });
        }
    });
}
exports.length = length;
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array/array.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array/array.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var instance_of_array_1 = __webpack_require__(/*! ./instance-of-array */ "./node_modules/type-mapping/dist/functional-lib/array/instance-of-array.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
function array(f) {
    return mapper_1.copyRunTimeModifier(f, operator_1.pipe(instance_of_array_1.instanceOfArray(), function (name, mixed) {
        var result = mixed;
        var isCopy = false;
        for (var i = 0; i < mixed.length; ++i) {
            /**
             * For now, fail quick for arrays.
             *
             * @todo Should we accumulate errors like in `objectFromMap()`?
             * The array might be too large. How large is too large?
             * Should we accumulate the first `n` errors before throwing?
             */
            var cur = f("" + name + string_util_1.toPropertyAccess(i), mixed[i]);
            //We do not mind === here.
            //If either is a BigInt polyfill, we are okay with the copy.
            if (cur === mixed[i]) {
                continue;
            }
            if (!isCopy) {
                result = result.slice();
                isCopy = true;
            }
            result[i] = cur;
        }
        return result;
    }));
}
exports.array = array;
function readOnlyArray(f) {
    return array(f);
}
exports.readOnlyArray = readOnlyArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array/cast/array-like-to-array.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array/cast/array-like-to-array.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var array_like_1 = __webpack_require__(/*! ../../array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/index.js");
function arrayLikeToArray(f) {
    return operator_1.pipe(array_like_1.arrayLike(f), (function (_name, arrayLike) {
        if (arrayLike instanceof Array) {
            return arrayLike;
        }
        var result = [];
        for (var i = 0; i < arrayLike.length; ++i) {
            result.push(arrayLike[i]);
        }
        return result;
    }));
}
exports.arrayLikeToArray = arrayLikeToArray;
function arrayLikeToReadOnlyArray(f) {
    return arrayLikeToArray(f);
}
exports.arrayLikeToReadOnlyArray = arrayLikeToReadOnlyArray;
//# sourceMappingURL=array-like-to-array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array/cast/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array/cast/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./array-like-to-array */ "./node_modules/type-mapping/dist/functional-lib/array/cast/array-like-to-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/array/cast/index.js"));
__export(__webpack_require__(/*! ./array */ "./node_modules/type-mapping/dist/functional-lib/array/array.js"));
__export(__webpack_require__(/*! ./instance-of-array */ "./node_modules/type-mapping/dist/functional-lib/array/instance-of-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/array/instance-of-array.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/array/instance-of-array.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function instanceOfArray() {
    return function (name, mixed) {
        if (!(mixed instanceof Array)) {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of Array; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "array",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.instanceOfArray = instanceOfArray;
function instanceOfReadOnlyArray() {
    return instanceOfArray();
}
exports.instanceOfReadOnlyArray = instanceOfReadOnlyArray;
//# sourceMappingURL=instance-of-array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var comparison_1 = __webpack_require__(/*! ./comparison */ "./node_modules/type-mapping/dist/functional-lib/bigint/comparison.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function bigInt() {
    return function (name, mixed) {
        if (type_util_1.isBigInt(mixed)) {
            return mixed;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be bigint; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: "bigint",
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
            },
        });
    };
}
exports.bigInt = bigInt;
/**
    bigint >= 0
*/
function unsignedBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.pipe(bigInt(), comparison_1.bigIntGtEq(bigIntFactory(0)));
}
exports.unsignedBigInt = unsignedBigInt;
//# sourceMappingURL=bigint.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/bigint/cast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/bigint/cast.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var bigint_1 = __webpack_require__(/*! ./bigint */ "./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
/**
    Uses `integerFormatString()` and `BigInt()` internally.
*/
function stringToBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(string_1.integerFormatString(), bigIntFactory, bigint_1.bigInt());
}
exports.stringToBigInt = stringToBigInt;
/**
    Uses `unsignedIntegerFormatString()` and `BigInt()` internally.
*/
function stringToUnsignedBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(string_1.unsignedIntegerFormatString(), bigIntFactory, bigint_1.unsignedBigInt());
}
exports.stringToUnsignedBigInt = stringToUnsignedBigInt;
function integerToBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(number_1.integer(), bigIntFactory, bigint_1.bigInt());
}
exports.integerToBigInt = integerToBigInt;
function unsignedIntegerToUnsignedBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(number_1.unsignedInteger(), bigIntFactory, bigint_1.unsignedBigInt());
}
exports.unsignedIntegerToUnsignedBigInt = unsignedIntegerToUnsignedBigInt;
/**
    Uses `integerFormatString()` and `BigInt()` internally.
*/
function toBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(operator_1.or(string_1.integerFormatString(), number_1.integer()), bigIntFactory, bigint_1.bigInt());
}
exports.toBigInt = toBigInt;
/**
    Uses `unsignedIntegerFormatString()` and `BigInt()` internally.
*/
function toUnsignedBigInt() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return operator_1.cast(operator_1.or(string_1.unsignedIntegerFormatString(), number_1.unsignedInteger()), bigIntFactory, bigint_1.unsignedBigInt());
}
exports.toUnsignedBigInt = toUnsignedBigInt;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/bigint/comparison.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/bigint/comparison.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var bigint_1 = __webpack_require__(/*! ./bigint */ "./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var bigint_util_1 = __webpack_require__(/*! ../../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function bigIntGt(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.greaterThan(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "greater than " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN,
                    gt: x,
                },
            });
        }
    });
}
exports.bigIntGt = bigIntGt;
function bigIntLt(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.lessThan(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "less than " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN,
                    lt: x,
                },
            });
        }
    });
}
exports.bigIntLt = bigIntLt;
function bigIntGtEq(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.greaterThanOrEqual(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than, or equal to " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "greater than, or equal to " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN_OR_EQUAL_TO,
                    gtEq: x,
                },
            });
        }
    });
}
exports.bigIntGtEq = bigIntGtEq;
function bigIntLtEq(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.lessThanOrEqual(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than, or equal to " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "less than, or equal to " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN_OR_EQUAL_TO,
                    ltEq: x,
                },
            });
        }
    });
}
exports.bigIntLtEq = bigIntLtEq;
function bigIntRange(args) {
    var min = ((type_util_1.isBigInt(args.gt)) ?
        ((type_util_1.isBigInt(args.gtEq)) ?
            ((bigint_util_1.greaterThanOrEqual(args.gt, args.gtEq)) ?
                {
                    f: bigIntGt(args.gt),
                    inclusive: false,
                    value: args.gt,
                } :
                {
                    f: bigIntGtEq(args.gtEq),
                    inclusive: true,
                    value: args.gtEq,
                }) :
            {
                f: bigIntGt(args.gt),
                inclusive: false,
                value: args.gt,
            }) :
        ((type_util_1.isBigInt(args.gtEq)) ?
            {
                f: bigIntGtEq(args.gtEq),
                inclusive: true,
                value: args.gtEq,
            } :
            undefined));
    var max = ((type_util_1.isBigInt(args.lt)) ?
        ((type_util_1.isBigInt(args.ltEq)) ?
            ((bigint_util_1.lessThanOrEqual(args.lt, args.ltEq)) ?
                {
                    f: bigIntLt(args.lt),
                    inclusive: false,
                    value: args.lt,
                } :
                {
                    f: bigIntLtEq(args.ltEq),
                    inclusive: true,
                    value: args.ltEq,
                }) :
            {
                f: bigIntLt(args.lt),
                inclusive: false,
                value: args.lt,
            }) :
        ((type_util_1.isBigInt(args.ltEq)) ?
            {
                f: bigIntLtEq(args.ltEq),
                inclusive: true,
                value: args.ltEq,
            } :
            undefined));
    if (min == undefined) {
        if (max == undefined) {
            return bigint_1.bigInt();
        }
        else {
            return max.f;
        }
    }
    else {
        if (max == undefined) {
            return min.f;
        }
        else {
            if (bigint_util_1.greaterThan(min.value, max.value)) {
                throw new Error("Min value cannot be greater than max value");
            }
            else if (bigint_util_1.equal(min.value, max.value)) {
                if (min.inclusive && max.inclusive) {
                    return literal_1.literal(min.value);
                }
                else {
                    throw new Error("Min value cannot be equal to max value unless using gtEq and ltEq");
                }
            }
            else {
                if (bigint_util_1.addOneImpl(min.value.toString()) == max.value.toString() &&
                    !min.inclusive &&
                    !max.inclusive) {
                    throw new Error("There is no bigint 'x' where: " + min.value.toString() + " < x < " + max.value.toString());
                }
                return operator_1.pipe(min.f, max.f);
            }
        }
    }
}
exports.bigIntRange = bigIntRange;
//# sourceMappingURL=comparison.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/bigint/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/bigint/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint */ "./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js"));
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/bigint/cast.js"));
__export(__webpack_require__(/*! ./comparison */ "./node_modules/type-mapping/dist/functional-lib/bigint/comparison.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/boolean/boolean.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/boolean/boolean.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function boolean() {
    return function (name, mixed) {
        if (typeof mixed != "boolean") {
            throw error_util_1.makeMappingError({
                message: name + " must be boolean; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "boolean",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.boolean = boolean;
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/boolean/cast.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/boolean/cast.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var boolean_1 = __webpack_require__(/*! ./boolean */ "./node_modules/type-mapping/dist/functional-lib/boolean/boolean.js");
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var operator_2 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
/**
    + Zero is false
    + All other finite number values are true
*/
function finiteNumberToBoolean() {
    return operator_1.cast(number_1.finiteNumber(), function (num) { return (num != 0); }, boolean_1.boolean());
}
exports.finiteNumberToBoolean = finiteNumberToBoolean;
/**
    + `"1"` is true
    + `/^true$/i` is true
    + All other string values are false

    TODO Is this a good convention?
*/
function stringToBoolean() {
    return operator_1.cast(string_1.string(), function (str) { return (str == "1" || str.toLowerCase() == "true"); }, boolean_1.boolean());
}
exports.stringToBoolean = stringToBoolean;
/**
    + Zero is false
    + All other finite number values are true
*/
function finiteNumberToTrue() {
    return operator_2.pipe(finiteNumberToBoolean(), literal_1.literal(true));
}
exports.finiteNumberToTrue = finiteNumberToTrue;
/**
    + Zero is false
    + All other finite number values are true
*/
function finiteNumberToFalse() {
    return operator_2.pipe(finiteNumberToBoolean(), literal_1.literal(false));
}
exports.finiteNumberToFalse = finiteNumberToFalse;
/**
    + `"1"` is true
    + `/^true$/i` is true
    + All other string values are false

    TODO Is this a good convention?
*/
function stringToTrue() {
    return operator_2.pipe(stringToBoolean(), literal_1.literal(true));
}
exports.stringToTrue = stringToTrue;
/**
    + `"1"` is true
    + `/^true$/i` is true
    + All other string values are false

    TODO Is this a good convention?
*/
function stringToFalse() {
    return operator_2.pipe(stringToBoolean(), literal_1.literal(false));
}
exports.stringToFalse = stringToFalse;
/**
    Uses `stringToBoolean()` and `finiteNumberToBoolean()` internally
*/
function toBoolean() {
    return operator_1.or(stringToBoolean(), finiteNumberToBoolean());
}
exports.toBoolean = toBoolean;
/**
    Uses `stringToTrue()` and `finiteNumberToTrue()` internally
*/
function toTrue() {
    return operator_1.or(stringToTrue(), finiteNumberToTrue());
}
exports.toTrue = toTrue;
/**
    Uses `stringToFalse()` and `finiteNumberToFalse()` internally
*/
function toFalse() {
    return operator_1.or(stringToFalse(), finiteNumberToFalse());
}
exports.toFalse = toFalse;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/boolean/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/boolean/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./boolean */ "./node_modules/type-mapping/dist/functional-lib/boolean/boolean.js"));
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/boolean/cast.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/buffer/buffer.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/buffer/buffer.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var uint_8_array_1 = __webpack_require__(/*! ../uint-8-array */ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/index.js");
var buffer_ctor_1 = __webpack_require__(/*! ../../type-util/buffer-ctor */ "./node_modules/type-mapping/dist/type-util/buffer-ctor.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function instanceOfBuffer() {
    return function (name, mixed) {
        if (!buffer_ctor_1.isInstanceOfBuffer(mixed)) {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of Buffer; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "Buffer",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.instanceOfBuffer = instanceOfBuffer;
function bufferLength(args) {
    return operator_1.pipe(uint_8_array_1.byteLength(args), instanceOfBuffer());
}
exports.bufferLength = bufferLength;
function bufferExactLength(length) {
    return bufferLength({
        min: length,
        max: length,
    });
}
exports.bufferExactLength = bufferExactLength;
//# sourceMappingURL=buffer.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/buffer/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/buffer/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./buffer */ "./node_modules/type-mapping/dist/functional-lib/buffer/buffer.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/date/cast.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/date/cast.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var instance_of_date_1 = __webpack_require__(/*! ./instance-of-date */ "./node_modules/type-mapping/dist/functional-lib/date/instance-of-date.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
/**
    Unsafe because it just uses `new Date(str)`
    to convert to a `Date`.

    This may have surprising results.
    ```ts
    new Date("1").getTime() === 978325200000
    ```
*/
function unsafeStringToDate() {
    return operator_1.cast(string_1.string(), function (str) { return new Date(str); }, instance_of_date_1.instanceOfDate());
}
exports.unsafeStringToDate = unsafeStringToDate;
/**
    Feel free to specify your own `Date` parsing function,
    using any JS Date library you want.

    It is safe for `dateParser` to throw `Error`s.

    Do not use `Date.parse(str)` or `new Date(str)`
    as implementations vary wildly.

    If you wish to use either of those,
    use `unsafeStringToDate()` instead.
*/
function dateToString(dateParser) {
    return operator_1.cast(string_1.string(), function (str) { return dateParser(str); }, instance_of_date_1.instanceOfDate());
}
exports.dateToString = dateToString;
/**
 * Convert the number of seconds since the Unix Epoch to a `Date`.
 *
 * The Unix Epoch is January 1st, 1970 at UTC.
 */
function unixTimestampSecondsToDate() {
    return operator_1.cast(number_1.integer(), 
    //Multiply by 1000 because `Date` ctor expects
    //milliseconds since Unix Epoch
    function (num) { return new Date(num * 1000); }, instance_of_date_1.instanceOfDate());
}
exports.unixTimestampSecondsToDate = unixTimestampSecondsToDate;
/**
 * Convert the number of milliseconds since the Unix Epoch to a `Date`.
 *
 * The Unix Epoch is January 1st, 1970 at UTC.
 */
function unixTimestampMillisecondsToDate() {
    return operator_1.cast(number_1.integer(), function (num) { return new Date(num); }, instance_of_date_1.instanceOfDate());
}
exports.unixTimestampMillisecondsToDate = unixTimestampMillisecondsToDate;
/**
 * Convert a `Date` to the number of seconds since the Unix Epoch.
 *
 * The Unix Epoch is January 1st, 1970 at UTC.
 */
function dateToUnixTimestampSeconds() {
    return operator_1.cast(instance_of_date_1.instanceOfDate(), function (d) { return Math.floor(d.getTime() / 1000); }, number_1.integer());
}
exports.dateToUnixTimestampSeconds = dateToUnixTimestampSeconds;
/**
 * Convert a `Date` to the number of milliseconds since the Unix Epoch.
 *
 * The Unix Epoch is January 1st, 1970 at UTC.
 */
function dateToUnixTimestampMilliseconds() {
    return operator_1.cast(instance_of_date_1.instanceOfDate(), function (d) { return d.getTime(); }, number_1.integer());
}
exports.dateToUnixTimestampMilliseconds = dateToUnixTimestampMilliseconds;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/date/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/date/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/date/cast.js"));
__export(__webpack_require__(/*! ./instance-of-date */ "./node_modules/type-mapping/dist/functional-lib/date/instance-of-date.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/date/instance-of-date.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/date/instance-of-date.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
/**
 * Must be a valid date.
 *
 * `mixed.getTime()` must be a finite number.
 */
function instanceOfDate() {
    var unixTimestampMsDelegate = number_1.finiteNumber();
    return function (name, mixed) {
        if (!(mixed instanceof Date)) {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of Date; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "Date",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        var unixTimestampMs = mixed.getTime();
        unixTimestampMsDelegate(name + ".getTime()", unixTimestampMs);
        return mixed;
    };
}
exports.instanceOfDate = instanceOfDate;
//# sourceMappingURL=instance-of-date.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/enum/cast-enum-flyweight.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/enum/cast-enum-flyweight.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var enum_util_1 = __webpack_require__(/*! ../../enum-util */ "./node_modules/type-mapping/dist/enum-util/index.js");
var cast_1 = __webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/enum/cast.js");
function castEnumFlyweight(e) {
    var keys = enum_util_1.getKeys(e);
    var result = {
        toValue: keys.reduce(function (memo, k) {
            memo[k] = cast_1.toOneEnumValue(e, k);
            return memo;
        }, cast_1.toEnumValue(e)),
        toKey: keys.reduce(function (memo, k) {
            memo[k] = cast_1.toOneEnumKey(e, k);
            return memo;
        }, cast_1.toEnumKey(e)),
    };
    return result;
}
exports.castEnumFlyweight = castEnumFlyweight;
//# sourceMappingURL=cast-enum-flyweight.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/enum/cast.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/enum/cast.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var enum_util_1 = __webpack_require__(/*! ../../enum-util */ "./node_modules/type-mapping/dist/enum-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function toEnumValue(e) {
    var entries = enum_util_1.getEntries(e);
    var expected = entries.map(function (e) { return type_util_1.toLiteralStr(e.key); }).join("|");
    //https://github.com/microsoft/TypeScript/issues/31602
    //Discovered string and conditional types also give problems
    return mapper_1.mapper(operator_1.or(literal_1.unsafeLiteral.apply(void 0, entries.map(function (e) { return e.value; })), 
    //Not a value, so maybe a key?
    function (name, mixed) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            if (mixed === entry.key) {
                return entry.value;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ENUM_KEY,
                mappableValues: entries.map(function (entry) { return entry.key; }),
                outputValues: entries.map(function (entry) { return entry.value; }),
                entries: entries.slice(),
            },
        });
    }));
}
exports.toEnumValue = toEnumValue;
function toEnumKey(e) {
    var entries = enum_util_1.getEntries(e);
    var expected = entries.map(function (e) { return type_util_1.toLiteralStr(e.value); }).join("|");
    //https://github.com/microsoft/TypeScript/issues/31602
    //Discovered string and conditional types also give problems
    return mapper_1.mapper(operator_1.or(literal_1.unsafeLiteral.apply(void 0, entries.map(function (e) { return e.key; })), 
    //Not a key, so maybe a value?
    function (name, mixed) {
        for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
            var entry = entries_2[_i];
            if (mixed === entry.value) {
                return entry.key;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ENUM_VALUE,
                mappableValues: entries.map(function (entry) { return entry.value; }),
                outputValues: entries.map(function (entry) { return entry.key; }),
                entries: entries.slice(),
            },
        });
    }));
}
exports.toEnumKey = toEnumKey;
function toOneEnumValue(e, k) {
    var desiredValue = e[k];
    var entries = enum_util_1.getEntries(e);
    var validKeys = entries
        .filter(function (entry) { return (entry.value === desiredValue &&
        entry.key !== desiredValue); })
        .map(function (entry) { return entry.key; });
    var expected = (type_util_1.toLiteralOrTypeUnionStr([
        desiredValue
    ].concat(validKeys)));
    return mapper_1.mapper(function (name, mixed) {
        if (mixed === desiredValue) {
            return desiredValue;
        }
        for (var _i = 0, validKeys_1 = validKeys; _i < validKeys_1.length; _i++) {
            var validKey = validKeys_1[_i];
            if (mixed === validKey) {
                return desiredValue;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ONE_ENUM_VALUE_OR_VALID_ENUM_KEY,
                mappableValues: [desiredValue].concat(validKeys),
                outputValues: [desiredValue],
                desiredValue: desiredValue,
                validKeys: validKeys.slice(),
            },
        });
    });
}
exports.toOneEnumValue = toOneEnumValue;
function toOneEnumKey(e, k) {
    var validValue = e[k];
    var entries = enum_util_1.getEntries(e);
    var validKeys = entries
        .filter(function (e) { return (e.value === validValue &&
        e.key !== validValue &&
        e.key !== k); })
        .map(function (e) { return e.key; });
    var expected = (type_util_1.toLiteralOrTypeUnionStr([
        k
    ].concat(validKeys, [
        validValue,
    ])));
    return mapper_1.mapper(function (name, mixed) {
        if (mixed === k) {
            return k;
        }
        for (var _i = 0, validKeys_2 = validKeys; _i < validKeys_2.length; _i++) {
            var validKey = validKeys_2[_i];
            if (mixed === validKey) {
                return k;
            }
        }
        if (mixed === validValue) {
            return k;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                mappableValues: [k].concat(validKeys, [validValue]),
                outputValues: [k],
                desiredKey: k,
                validKeys: validKeys.slice(),
                validValue: validValue,
            },
        });
    });
}
exports.toOneEnumKey = toOneEnumKey;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/enum/enum.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/enum/enum.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var enum_util_1 = __webpack_require__(/*! ../../enum-util */ "./node_modules/type-mapping/dist/enum-util/index.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
function enumKey(e) {
    return literal_1.unsafeLiteral.apply(void 0, enum_util_1.getKeys(e));
}
exports.enumKey = enumKey;
function enumValue(e) {
    return literal_1.unsafeLiteral.apply(void 0, enum_util_1.getValues(e));
}
exports.enumValue = enumValue;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/enum/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/enum/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast-enum-flyweight */ "./node_modules/type-mapping/dist/functional-lib/enum/cast-enum-flyweight.js"));
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/enum/cast.js"));
__export(__webpack_require__(/*! ./enum */ "./node_modules/type-mapping/dist/functional-lib/enum/enum.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./any */ "./node_modules/type-mapping/dist/functional-lib/any/index.js"));
__export(__webpack_require__(/*! ./array */ "./node_modules/type-mapping/dist/functional-lib/array/index.js"));
__export(__webpack_require__(/*! ./array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/index.js"));
__export(__webpack_require__(/*! ./bigint */ "./node_modules/type-mapping/dist/functional-lib/bigint/index.js"));
__export(__webpack_require__(/*! ./boolean */ "./node_modules/type-mapping/dist/functional-lib/boolean/index.js"));
__export(__webpack_require__(/*! ./buffer */ "./node_modules/type-mapping/dist/functional-lib/buffer/index.js"));
__export(__webpack_require__(/*! ./date */ "./node_modules/type-mapping/dist/functional-lib/date/index.js"));
__export(__webpack_require__(/*! ./enum */ "./node_modules/type-mapping/dist/functional-lib/enum/index.js"));
__export(__webpack_require__(/*! ./json-object */ "./node_modules/type-mapping/dist/functional-lib/json-object/index.js"));
__export(__webpack_require__(/*! ./literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js"));
__export(__webpack_require__(/*! ./never */ "./node_modules/type-mapping/dist/functional-lib/never/index.js"));
__export(__webpack_require__(/*! ./non-maybe */ "./node_modules/type-mapping/dist/functional-lib/non-maybe/index.js"));
__export(__webpack_require__(/*! ./null */ "./node_modules/type-mapping/dist/functional-lib/null/index.js"));
__export(__webpack_require__(/*! ./number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js"));
__export(__webpack_require__(/*! ./object */ "./node_modules/type-mapping/dist/functional-lib/object/index.js"));
__export(__webpack_require__(/*! ./operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js"));
__export(__webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js"));
__export(__webpack_require__(/*! ./type */ "./node_modules/type-mapping/dist/functional-lib/type/index.js"));
__export(__webpack_require__(/*! ./uint-8-array */ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/index.js"));
__export(__webpack_require__(/*! ./undefined */ "./node_modules/type-mapping/dist/functional-lib/undefined/index.js"));
__export(__webpack_require__(/*! ./unknown */ "./node_modules/type-mapping/dist/functional-lib/unknown/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/json-object/cast.js":
/*!***************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/json-object/cast.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    Calls `JSON.parse()` once, may call `JSON.stringify()` zero or one times.
*/
function stringToJsonObject() {
    return function (name, mixed) {
        if (typeof mixed != "string") {
            try {
                var str = JSON.stringify(mixed);
                if (typeof str == "string" && str[0] == "{") {
                    if (type_util_1.isBigIntNativelySupported() || !type_util_1.isBigInt(mixed)) {
                        return JSON.parse(str);
                    }
                }
                throw error_util_1.makeMappingError({
                    message: name + " must be JSON Object; received " + type_util_1.toTypeStr(mixed),
                    inputName: name,
                    actualValue: mixed,
                    expected: "JSON Object",
                });
            }
            catch (err) {
                throw error_util_1.makeMappingError({
                    message: name + " must be JSON Object; " + err.message,
                    inputName: name,
                    actualValue: mixed,
                    expected: "JSON Object",
                });
            }
        }
        if (!/^\s*\{/.test(mixed)) {
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object string",
                inputName: name,
                actualValue: mixed,
                expected: "JSON Object string",
            });
        }
        try {
            return JSON.parse(mixed);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be valid JSON Object string; " + err.message,
                inputName: name,
                actualValue: mixed,
                expected: "valid JSON Object string",
            });
        }
    };
}
exports.stringToJsonObject = stringToJsonObject;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/json-object/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/json-object/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/json-object/cast.js"));
__export(__webpack_require__(/*! ./json-object */ "./node_modules/type-mapping/dist/functional-lib/json-object/json-object.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/json-object/json-object.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/json-object/json-object.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    Calls `JSON.stringify()` and `JSON.parse()` once.

    Always returns a new object.
*/
function jsonObject() {
    return function (name, mixed) {
        try {
            var str = JSON.stringify(mixed);
            if (typeof str == "string" && str[0] == "{") {
                if (type_util_1.isBigIntNativelySupported() || !type_util_1.isBigInt(mixed)) {
                    return JSON.parse(str);
                }
            }
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "JSON Object",
            });
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object; " + err.message,
                inputName: name,
                actualValue: mixed,
                expected: "JSON Object",
            });
        }
    };
}
exports.jsonObject = jsonObject;
//# sourceMappingURL=json-object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/literal/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/literal/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./literal */ "./node_modules/type-mapping/dist/functional-lib/literal/literal.js"));
__export(__webpack_require__(/*! ./tuple-literal */ "./node_modules/type-mapping/dist/functional-lib/literal/tuple-literal.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/literal/literal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/literal/literal.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
 * Returns a mapper that validates if the input is an element of `arr`
 *
 * This function throws an error if `arr.length == 0`
 *
 * @param arr
 *  @see {@link LiteralType}
 */
function unsafeLiteral() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        throw new Error("Cannot map zero literals");
    }
    var expected = type_util_1.toLiteralUnionStr(arr);
    return function (name, mixed) {
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var item = arr_1[_i];
            if (type_util_1.strictEqual(mixed, item)) {
                return mixed;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                mappableValues: arr.slice(),
                outputValues: arr.slice(),
            },
        });
    };
}
exports.unsafeLiteral = unsafeLiteral;
/**
 * Returns a mapper that validates if the input is one of the arguments
 *
 * @param arg0
 * @param arr
 *  @see {@link LiteralType}
 */
function literal(arg0) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return unsafeLiteral.apply(void 0, [arg0].concat(arr));
}
exports.literal = literal;
//# sourceMappingURL=literal.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/literal/tuple-literal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/literal/tuple-literal.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var array_1 = __webpack_require__(/*! ../array */ "./node_modules/type-mapping/dist/functional-lib/array/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var array_like_1 = __webpack_require__(/*! ../array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/index.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
/**
 * Returns a mapper that checks if incoming data matches the tuple `TupleT`.
 *
 * ```ts
 * tupleLiteral("a", "b")("x", ["a", "b"]);       //OK!
 * tupleLiteral("a", "b")("x", ["a", "b", "c"]);  //Error
 * tupleLiteral("a", "b")("x", ["a"]);            //Error
 * tupleLiteral("a", "b")("x", ["b", "a"]);       //Error
 * ```
 *
 * @param tuple The tuple incoming data must equal to
 */
function tupleLiteral() {
    var tuple = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tuple[_i] = arguments[_i];
    }
    var lengthDelegate = array_like_1.length({
        min: tuple.length,
        max: tuple.length,
    });
    return operator_1.pipe(array_1.instanceOfArray(), function (name, mixed) {
        lengthDelegate(name, mixed);
        for (var i = 0; i < tuple.length; ++i) {
            if (!type_util_1.strictEqual(mixed[i], tuple[i])) {
                throw error_util_1.makeMappingError({
                    message: "" + name + string_util_1.toPropertyAccess(i) + " must be " + type_util_1.toLiteralStr(tuple[i]) + "; received " + type_util_1.toTypeStr(mixed[i]),
                    inputName: "" + name + string_util_1.toPropertyAccess(i),
                    actualValue: mixed[i],
                    expected: type_util_1.toLiteralStr(tuple[i]),
                    expectedMeta: {
                        mappableValues: [
                            tuple.slice()
                        ],
                        outputValues: [
                            tuple.slice()
                        ],
                    },
                });
            }
        }
        return mixed;
    });
}
exports.tupleLiteral = tupleLiteral;
//# sourceMappingURL=tuple-literal.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/never/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/never/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./never */ "./node_modules/type-mapping/dist/functional-lib/never/never.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/never/never.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/never/never.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
 * Use this if something is never supposed to have a value.
 * Not even `undefined`.
 *
 * For example, `never[]` can be,
 * ```ts
 * const arrayOfNever = array(never());
 * ```
 *
 * The only value that will satisfy this mapper is the empty array.
 */
function never() {
    return function (name, mixed) {
        throw error_util_1.makeMappingError({
            message: name + " must be never",
            inputName: name,
            actualValue: mixed,
            expected: "never",
        });
    };
}
exports.never = never;
//# sourceMappingURL=never.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/non-maybe/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/non-maybe/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./non-maybe */ "./node_modules/type-mapping/dist/functional-lib/non-maybe/non-maybe.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/non-maybe/non-maybe.js":
/*!******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/non-maybe/non-maybe.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var any_1 = __webpack_require__(/*! ../any */ "./node_modules/type-mapping/dist/functional-lib/any/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
function nonMaybe() {
    return operator_1.notMaybe(any_1.unsafeAny());
}
exports.nonMaybe = nonMaybe;
//# sourceMappingURL=non-maybe.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/null/cast.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/null/cast.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var null_1 = __webpack_require__(/*! ./null */ "./node_modules/type-mapping/dist/functional-lib/null/null.js");
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function undefinedToNull() {
    return function (name, mixed) {
        //We do not mind === here.
        if (mixed === undefined || mixed === null) {
            return null;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be null|undefined; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: "null|undefined",
            expectedMeta: {
                mappableValues: [null, undefined],
                outputValues: [null],
            },
        });
    };
}
exports.undefinedToNull = undefinedToNull;
function emptyStringToNull() {
    return operator_1.cast(literal_1.literal(""), function () { return null; }, null_1.null());
}
exports.emptyStringToNull = emptyStringToNull;
/**
    An empty string, or a string of only whitespace
*/
function whitespaceStringToNull() {
    return operator_1.cast(string_1.match(/^\s*$/, function (name) {
        return {
            message: name + " must be a whitespace string",
            expected: "whitespace string",
        };
    }), function () { return null; }, null_1.null());
}
exports.whitespaceStringToNull = whitespaceStringToNull;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/null/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/null/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/null/cast.js"));
__export(__webpack_require__(/*! ./null */ "./node_modules/type-mapping/dist/functional-lib/null/null.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/null/null.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/null/null.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function nil() {
    return function (name, mixed) {
        //We do not mind === here.
        if (mixed === null) {
            return mixed;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be null; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: "null",
            expectedMeta: {
                mappableValues: [null],
                outputValues: [null],
            }
        });
    };
}
exports.null = nil;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/number/cast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/number/cast.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ./number */ "./node_modules/type-mapping/dist/functional-lib/number/number.js");
var bigint_1 = __webpack_require__(/*! ../bigint/bigint */ "./node_modules/type-mapping/dist/functional-lib/bigint/bigint.js");
/**
    Uses `floatingPointFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    stringToFiniteNumber("", s).toString()
    ```
*/
function stringToFiniteNumber() {
    return operator_1.cast(string_1.floatingPointFormatString(), parseFloat, number_1.finiteNumber());
}
exports.stringToFiniteNumber = stringToFiniteNumber;
/**
    Uses `integerFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    stringToInteger("", s).toString()
    ```
*/
function stringToInteger() {
    return operator_1.cast(string_1.integerFormatString(), parseFloat, number_1.integer());
}
exports.stringToInteger = stringToInteger;
/**
    Uses `unsignedIntegerFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    stringToUnsignedInteger("", s).toString()
    ```
*/
function stringToUnsignedInteger() {
    return operator_1.cast(string_1.unsignedIntegerFormatString(), parseFloat, number_1.unsignedInteger());
}
exports.stringToUnsignedInteger = stringToUnsignedInteger;
/**
    Uses `floatingPointFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    toFiniteNumber("", s).toString()
    ```

    -----

    ```ts
    const b = BigInt("999999999999999999999999999")
    //Output is "1e+27" due to loss in precision
    toFiniteNumber("", b).toString()
    ```
*/
function toFiniteNumber() {
    return operator_1.cast(operator_1.or(string_1.floatingPointFormatString(), operator_1.pipe(bigint_1.bigInt(), function (_name, b) {
        return b.toString();
    })), parseFloat, number_1.finiteNumber());
}
exports.toFiniteNumber = toFiniteNumber;
/**
    Uses `floatingPointFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    toUnsafeNumber("", s).toString()
    ```

    -----

    ```ts
    const b = BigInt("999999999999999999999999999")
    //Output is "1e+27" due to loss in precision
    toUnsafeNumber("", b).toString()
    ```
*/
function toUnsafeNumber() {
    return operator_1.cast(operator_1.or(string_1.floatingPointFormatString(), operator_1.pipe(bigint_1.bigInt(), function (_name, b) {
        return b.toString();
    })), parseFloat, number_1.unsafeNumber());
}
exports.toUnsafeNumber = toUnsafeNumber;
/**
    Uses `integerFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    toInteger("", s).toString()
    ```

    -----

    ```ts
    const b = BigInt("999999999999999999999999999")
    //Output is "1e+27" due to loss in precision
    toInteger("", b).toString()
    ```
*/
function toInteger() {
    return operator_1.cast(operator_1.or(string_1.integerFormatString(), operator_1.pipe(bigint_1.bigInt(), function (_name, b) {
        return b.toString();
    })), parseFloat, number_1.integer());
}
exports.toInteger = toInteger;
/**
    Uses `unsignedIntegerFormatString()` and `parseFloat()` internally.

    ```ts
    const s = "999999999999999999999999999"
    //Output is "1e+27" due to loss in precision
    toUnsignedInteger("", s).toString()
    ```

    -----

    ```ts
    const b = BigInt("999999999999999999999999999")
    //Output is "1e+27" due to loss in precision
    toUnsignedInteger("", b).toString()
    ```
*/
function toUnsignedInteger() {
    return operator_1.cast(operator_1.or(string_1.unsignedIntegerFormatString(), operator_1.pipe(bigint_1.bigInt(), function (_name, b) {
        return b.toString();
    })), parseFloat, number_1.unsignedInteger());
}
exports.toUnsignedInteger = toUnsignedInteger;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/number/comparison.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/number/comparison.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ./number */ "./node_modules/type-mapping/dist/functional-lib/number/number.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function gt(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num > x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than " + x,
                inputName: name,
                actualValue: num,
                expected: "greater than " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN,
                    gt: x,
                },
            });
        }
    });
}
exports.gt = gt;
function lt(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num < x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than " + x,
                inputName: name,
                actualValue: num,
                expected: "less than " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN,
                    lt: x,
                },
            });
        }
    });
}
exports.lt = lt;
function gtEq(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num >= x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than, or equal to " + x,
                inputName: name,
                actualValue: num,
                expected: "greater than, or equal to " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN_OR_EQUAL_TO,
                    gtEq: x,
                },
            });
        }
    });
}
exports.gtEq = gtEq;
function ltEq(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num <= x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than, or equal to " + x,
                inputName: name,
                actualValue: num,
                expected: "less than, or equal to " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN_OR_EQUAL_TO,
                    ltEq: x,
                },
            });
        }
    });
}
exports.ltEq = ltEq;
function range(args) {
    var min = ((typeof args.gt == "number") ?
        ((typeof args.gtEq == "number") ?
            ((args.gt >= args.gtEq) ?
                {
                    f: gt(args.gt),
                    inclusive: false,
                    value: args.gt,
                } :
                {
                    f: gtEq(args.gtEq),
                    inclusive: true,
                    value: args.gtEq,
                }) :
            {
                f: gt(args.gt),
                inclusive: false,
                value: args.gt,
            }) :
        ((typeof args.gtEq == "number") ?
            {
                f: gtEq(args.gtEq),
                inclusive: true,
                value: args.gtEq,
            } :
            undefined));
    var max = ((typeof args.lt == "number") ?
        ((typeof args.ltEq == "number") ?
            ((args.lt <= args.ltEq) ?
                {
                    f: lt(args.lt),
                    inclusive: false,
                    value: args.lt,
                } :
                {
                    f: ltEq(args.ltEq),
                    inclusive: true,
                    value: args.ltEq,
                }) :
            {
                f: lt(args.lt),
                inclusive: false,
                value: args.lt,
            }) :
        ((typeof args.ltEq == "number") ?
            {
                f: ltEq(args.ltEq),
                inclusive: true,
                value: args.ltEq,
            } :
            undefined));
    if (min == undefined) {
        if (max == undefined) {
            return number_1.finiteNumber();
        }
        else {
            return max.f;
        }
    }
    else {
        if (max == undefined) {
            return min.f;
        }
        else {
            if (min.value > max.value) {
                throw new Error("Min value cannot be greater than max value");
            }
            else if (min.value == max.value) {
                if (min.inclusive && max.inclusive) {
                    return literal_1.literal(min.value);
                }
                else {
                    throw new Error("Min value cannot be equal to max value unless using gtEq and ltEq");
                }
            }
            else {
                return operator_1.pipe(min.f, max.f);
            }
        }
    }
}
exports.range = range;
//# sourceMappingURL=comparison.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/number/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/number/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/number/cast.js"));
__export(__webpack_require__(/*! ./comparison */ "./node_modules/type-mapping/dist/functional-lib/number/comparison.js"));
__export(__webpack_require__(/*! ./number */ "./node_modules/type-mapping/dist/functional-lib/number/number.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/number/number.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/number/number.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var comparison_1 = __webpack_require__(/*! ./comparison */ "./node_modules/type-mapping/dist/functional-lib/number/comparison.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
//Unsafe because it allows NaN and +/-Infinity
function unsafeNumber() {
    return function (name, mixed) {
        if (typeof mixed != "number") {
            throw error_util_1.makeMappingError({
                message: name + " must be number; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.unsafeNumber = unsafeNumber;
function finiteNumber() {
    return operator_1.pipe(unsafeNumber(), function (name, num) {
        if (isNaN(num)) {
            throw error_util_1.makeMappingError({
                message: name + " must be finite number; received NaN",
                inputName: name,
                actualValue: num,
                expected: "finite number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        if (!isFinite(num)) {
            throw error_util_1.makeMappingError({
                message: name + " must be finite number; received " + num,
                inputName: name,
                actualValue: num,
                expected: "finite number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return num;
    });
}
exports.finiteNumber = finiteNumber;
function integer() {
    return operator_1.pipe(finiteNumber(), function (name, num) {
        if (Math.floor(num) !== num) {
            throw error_util_1.makeMappingError({
                message: name + " must be integer; received double",
                inputName: name,
                actualValue: num,
                expected: "integer",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return num;
    });
}
exports.integer = integer;
/**
    An unsigned integer is an integer >= 0
*/
function unsignedInteger() {
    return operator_1.pipe(integer(), comparison_1.gtEq(0));
}
exports.unsignedInteger = unsignedInteger;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/derive-map.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/derive-map.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var derive_1 = __webpack_require__(/*! ./derive */ "./node_modules/type-mapping/dist/functional-lib/object/derive.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
function deriveMap(map) {
    var arr = [];
    for (var k in map) {
        if (!map.hasOwnProperty(k)) {
            continue;
        }
        var f = map[k];
        arr.push(derive_1.derive(k, mapper_1.getNameOrEmptyString(f), f));
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    return operator_1.unsafeDeepMerge.apply(void 0, arr);
}
exports.deriveMap = deriveMap;
/*
import {string} from "../string";
import {withName, withExpectedInput} from "../../mapper";
import {unsignedInteger, stringToFiniteNumber} from "../number";
import {optional} from "../operator";

const m = renameMap({
    x : withName(string(), "y"),
    x2 : withName(unsignedInteger(), "y"),
    a : withExpectedInput(withName(stringToFiniteNumber(), "b"))<string>(),
    a2 : withExpectedInput(withName(stringToFiniteNumber(), "b2"))<string|number>(),
    a3 : withExpectedInput(withName(stringToFiniteNumber(), "b2"))<number>(),
    o : withExpectedInput(withName(optional(stringToFiniteNumber()), "_o"))<number>(),
});
m.__expectedInput
m.__mappableInput

const x = optional(withExpectedInput(withName(stringToFiniteNumber(), "_o"))<number>());

const m2 = renameMap({
    x : withName(string(), "y" as string),
    x2 : withName(unsignedInteger(), "y" as string),
    a : withExpectedInput(withName(stringToFiniteNumber(), "b"))<string>(),
    a2 : withExpectedInput(withName(stringToFiniteNumber(), "b2"))<string|number>(),
    a3 : withExpectedInput(withName(stringToFiniteNumber(), "b2"))<number>(),
    o : withExpectedInput(withName(optional(stringToFiniteNumber()), "_o"))<number>(),
    c2 : withExpectedInput(withName(stringToFiniteNumber(), "c2"))<string|number>(),
    c3 : withExpectedInput(withName(string(), "c2"))<string>(),
});
//*/ 
//# sourceMappingURL=derive-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/derive.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/derive.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var instance_of_object_1 = __webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function derive(srcKey, dstKey, f) {
    /**
        Must property be explicitly set?

                        | `orUndefined` | `optional` | `runTimeRequired()`
        compile-time    | -no-effect-   | optional   | required
        run-time        | optional      | optional   | required
    */
    var runTimeRequired = mapper_1.getRunTimeRequiredFlagOrFalse(f);
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, mixed) {
        var _a;
        if (!Object.prototype.hasOwnProperty.call(mixed, srcKey)) {
            if (runTimeRequired) {
                var expected = "object with explicitly set property " + JSON.stringify(srcKey);
                throw error_util_1.makeMappingError({
                    message: name + " must be " + expected,
                    inputName: name,
                    actualValue: mixed,
                    expected: expected,
                    expectedMeta: {
                        srcKey: srcKey,
                        dstKey: dstKey,
                    },
                    propertyErrors: [
                        error_util_1.makeMappingError({
                            message: "" + name + string_util_1.toPropertyAccess(srcKey) + " must be explicitly set",
                            inputName: "" + name + string_util_1.toPropertyAccess(srcKey),
                            actualValue: undefined,
                            expected: "explicitly set",
                        }),
                    ],
                });
            }
        }
        var dstResult = mapper_1.tryMapHandled(f, "" + name + string_util_1.toPropertyAccess(srcKey), mixed[srcKey]);
        if (dstResult.success) {
            var obj = (_a = {},
                _a[dstKey] = dstResult.value,
                _a);
            return obj;
        }
        if (dstResult.mappingError.expected == undefined) {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object. " + dstResult.mappingError.message,
                inputName: name,
                actualValue: mixed,
                expected: "valid object",
                expectedMeta: {
                    srcKey: srcKey,
                    dstKey: dstKey,
                },
                propertyErrors: [
                    dstResult.mappingError,
                ],
            });
        }
        else {
            var expected = "object with " + dstResult.mappingError.expected + " property " + JSON.stringify(srcKey);
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    srcKey: srcKey,
                    dstKey: dstKey,
                },
                propertyErrors: [
                    dstResult.mappingError,
                ],
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.derive = derive;
/*
const a = unsignedInteger();
const b = optional(unsignedInteger());
const c = string();
const d = optional(string());

declare const _0 : typeof a;
declare const _1 : typeof b;
declare const _2 : typeof c;
declare const _3 : typeof d;

declare const _01 : (typeof a) | (typeof b);
declare const _02 : (typeof a) | (typeof c);
declare const _03 : (typeof a) | (typeof d);

declare const _12 : (typeof b) | (typeof c);
declare const _13 : (typeof b) | (typeof d);

declare const _23 : (typeof c) | (typeof d);

const __0 = derive("x", "y", _0);
const __1 = derive("x", "y", _1);
const __2 = derive("x", "y", _2);
const __3 = derive("x", "y", _3);

const __01 = derive("x", "y", _01);
const __02 = derive("x", "y", _02);
const __03 = derive("x", "y", _03);

const __12 = derive("x", "y", _12);
const __13 = derive("x", "y", _13);

const __23 = derive("x", "y", _23);
*/ 
//# sourceMappingURL=derive.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./derive-map */ "./node_modules/type-mapping/dist/functional-lib/object/derive-map.js"));
__export(__webpack_require__(/*! ./derive */ "./node_modules/type-mapping/dist/functional-lib/object/derive.js"));
__export(__webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js"));
__export(__webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js"));
__export(__webpack_require__(/*! ./instance-of */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of.js"));
__export(__webpack_require__(/*! ./object-from-array */ "./node_modules/type-mapping/dist/functional-lib/object/object-from-array.js"));
__export(__webpack_require__(/*! ./object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/object-from-map.js"));
__export(__webpack_require__(/*! ./object */ "./node_modules/type-mapping/dist/functional-lib/object/object.js"));
__export(__webpack_require__(/*! ./partial-derive-map */ "./node_modules/type-mapping/dist/functional-lib/object/partial-derive-map.js"));
__export(__webpack_require__(/*! ./partial-object-from-array */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-array.js"));
__export(__webpack_require__(/*! ./partial-object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-map.js"));
__export(__webpack_require__(/*! ./partial-object */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object.js"));
__export(__webpack_require__(/*! ./partial-rename-map */ "./node_modules/type-mapping/dist/functional-lib/object/partial-rename-map.js"));
__export(__webpack_require__(/*! ./pojo */ "./node_modules/type-mapping/dist/functional-lib/object/pojo.js"));
__export(__webpack_require__(/*! ./rename-map */ "./node_modules/type-mapping/dist/functional-lib/object/rename-map.js"));
__export(__webpack_require__(/*! ./rename */ "./node_modules/type-mapping/dist/functional-lib/object/rename.js"));
__export(__webpack_require__(/*! ./string-indexer */ "./node_modules/type-mapping/dist/functional-lib/object/string-indexer.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js":
/*!************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    If you pass in a bigint object created by
    a polyfill, it will be rejected,
    even though it is technically an instance of `Object`.
*/
function instanceOfObject() {
    return function (name, mixed) {
        if (type_util_1.isInstanceOf(mixed, Object)) {
            return mixed;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of Object; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "Object",
            });
        }
    };
}
exports.instanceOfObject = instanceOfObject;
//# sourceMappingURL=instance-of-object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/instance-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/instance-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    If you pass in a bigint object created by
    a polyfill, it will never pass any `instanceof` checks,
    even though the polyfill could be done with an object.
*/
function instanceOf(ctor) {
    if (!type_util_1.allowsInstanceOf(ctor)) {
        throw new Error("instanceof check not allowed on " + type_util_1.getCtorName(ctor));
    }
    var ctorName = type_util_1.getCtorName(ctor);
    return function (name, mixed) {
        if (type_util_1.isInstanceOf(mixed, ctor)) {
            return mixed;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of " + ctorName + "; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: ctorName,
                expectedMeta: {
                    ctor: ctor,
                },
            });
        }
    };
}
exports.instanceOf = instanceOf;
//# sourceMappingURL=instance-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/object-from-array.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/object-from-array.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var object_from_map_1 = __webpack_require__(/*! ./object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/object-from-map.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
/**
    This,
    ```ts
    objectFromArray(
        withName(unsignedInteger(), "foo"),
        withName(string(), "foo")
    );
    ```

    Is the same as,
    ```ts
    objectFromArray(
        withName(or(
            unsignedInteger(),
            string()
        ), "foo")
    );
    ```
*/
function objectFromArray() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    var groupedByName = {};
    for (var _a = 0, arr_1 = arr; _a < arr_1.length; _a++) {
        var f = arr_1[_a];
        var name = mapper_1.getNameOrEmptyString(f);
        var mappers = groupedByName[name];
        if (mappers == undefined) {
            mappers = [];
            groupedByName[name] = mappers;
        }
        mappers.push(f);
    }
    var map = {};
    for (var k in groupedByName) {
        var mappers = groupedByName[k];
        if (mappers == undefined) {
            continue;
        }
        map[k] = (mappers.length == 1) ?
            mappers[0] : operator_1.unsafeOr.apply(void 0, mappers);
    }
    return object_from_map_1.objectFromMap(map);
}
exports.objectFromArray = objectFromArray;
//# sourceMappingURL=object-from-array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/object-from-map.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/object-from-map.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var instance_of_object_1 = __webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    Always returns a new object.

    If the input contains additional fields not part
    of the map, they will not be in the new object.
*/
function objectFromMap(map) {
    var keys = Object.keys(map);
    if (keys.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    var runTimeRequiredDict = {};
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        runTimeRequiredDict[k] = mapper_1.getRunTimeRequiredFlagOrFalse(map[k]);
    }
    return mapper_1.mapper(operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, mixed) {
        var propertyErrors = [];
        var result = {};
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var k = keys_2[_i];
            if (Object.prototype.hasOwnProperty.call(mixed, k) || runTimeRequiredDict[k] === false) {
                var propertyResult = mapper_1.tryMapHandled(map[k], "" + name + string_util_1.toPropertyAccess(k), mixed[k]);
                if (propertyResult.success) {
                    result[k] = propertyResult.value;
                }
                else {
                    propertyErrors.push(propertyResult.mappingError);
                }
            }
            else {
                propertyErrors.push(error_util_1.makeMappingError({
                    message: "" + name + string_util_1.toPropertyAccess(k) + " must be explicitly set",
                    inputName: "" + name + string_util_1.toPropertyAccess(k),
                    actualValue: undefined,
                    expected: "explicitly set",
                }));
            }
        }
        if (propertyErrors.length == 0) {
            return result;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object",
                inputName: name,
                actualValue: mixed,
                expected: "valid object",
                propertyErrors: propertyErrors,
            });
        }
    }));
}
exports.objectFromMap = objectFromMap;
/*
import {optional, orUndefined} from "../operator";
import {unsignedInteger} from "../number";

const m = objectFromMap({
    shouldBeOptional : optional(unsignedInteger()),
    shouldNotBeOptional : orUndefined(unsignedInteger())
});
m.__expectedInput
m.__mappableInput


declare const map2 : {

    [name : string] : SafeMapper<number>|SafeMapper<boolean>
};
const m2 = objectFromMap(map2);
m2.__expectedInput
m2.__mappableInput


declare const map3 : {
    k : SafeMapper<number>|SafeMapper<boolean>,
    l : SafeMapper<number>,
};
const m3 = objectFromMap(map3);
m3.__expectedInput
m3.__mappableInput
//*/ 
//# sourceMappingURL=object-from-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/object.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/object.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var object_from_map_1 = __webpack_require__(/*! ./object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/object-from-map.js");
var object_from_array_1 = __webpack_require__(/*! ./object-from-array */ "./node_modules/type-mapping/dist/functional-lib/object/object-from-array.js");
function object() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 1 && !(arr[0] instanceof Function)) {
        return object_from_map_1.objectFromMap(arr[0]);
    }
    else {
        return object_from_array_1.objectFromArray.apply(void 0, arr);
    }
}
exports.object = object;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/partial-derive-map.js":
/*!************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/partial-derive-map.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var derive_1 = __webpack_require__(/*! ./derive */ "./node_modules/type-mapping/dist/functional-lib/object/derive.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
function partialDeriveMap(map) {
    var arr = [];
    for (var k in map) {
        if (!map.hasOwnProperty(k)) {
            continue;
        }
        var f = map[k];
        arr.push(derive_1.derive(k, mapper_1.getNameOrEmptyString(f), operator_1.optional(f)));
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    return operator_1.unsafeDeepMerge.apply(void 0, arr);
}
exports.partialDeriveMap = partialDeriveMap;
//# sourceMappingURL=partial-derive-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
var partial_object_from_map_1 = __webpack_require__(/*! ./partial-object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-map.js");
/**
    This,
    ```ts
    objectFromArray(
        withName(unsignedInteger(), "foo"),
        withName(string(), "foo")
    );
    ```

    Is the same as,
    ```ts
    objectFromArray(
        withName(or(
            unsignedInteger(),
            string()
        ), "foo")
    );
    ```
*/
function partialObjectFromArray() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    var groupedByName = {};
    for (var _a = 0, arr_1 = arr; _a < arr_1.length; _a++) {
        var f = arr_1[_a];
        var name = mapper_1.getNameOrEmptyString(f);
        var mappers = groupedByName[name];
        if (mappers == undefined) {
            mappers = [];
            groupedByName[name] = mappers;
        }
        mappers.push(f);
    }
    var map = {};
    for (var k in groupedByName) {
        var mappers = groupedByName[k];
        if (mappers == undefined) {
            continue;
        }
        map[k] = (mappers.length == 1) ?
            mappers[0] : operator_1.unsafeOr.apply(void 0, mappers);
    }
    return partial_object_from_map_1.partialObjectFromMap(map);
}
exports.partialObjectFromArray = partialObjectFromArray;
//# sourceMappingURL=partial-object-from-array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-map.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var instance_of_object_1 = __webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
/**
    Always returns a new object.

    If the input contains additional fields not part
    of the map, they will not be in the new object.

    -----

    All input fields are optional.
    All output fields may be undefined.
*/
function partialObjectFromMap(map) {
    var keys = Object.keys(map);
    if (keys.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    var partialMap = {};
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        partialMap[k] = operator_1.optional(map[k]);
    }
    return mapper_1.mapper(operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, mixed) {
        var result = {};
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var k = keys_2[_i];
            result[k] = partialMap[k](name + "." + k, mixed[k]);
        }
        return result;
    }));
}
exports.partialObjectFromMap = partialObjectFromMap;
//# sourceMappingURL=partial-object-from-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/partial-object.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/partial-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var partial_object_from_map_1 = __webpack_require__(/*! ./partial-object-from-map */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-map.js");
var partial_object_from_array_1 = __webpack_require__(/*! ./partial-object-from-array */ "./node_modules/type-mapping/dist/functional-lib/object/partial-object-from-array.js");
function partialObject() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 1 && !(arr[0] instanceof Function)) {
        return partial_object_from_map_1.partialObjectFromMap(arr[0]);
    }
    else {
        return partial_object_from_array_1.partialObjectFromArray.apply(void 0, arr);
    }
}
exports.partialObject = partialObject;
//# sourceMappingURL=partial-object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/partial-rename-map.js":
/*!************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/partial-rename-map.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var rename_1 = __webpack_require__(/*! ./rename */ "./node_modules/type-mapping/dist/functional-lib/object/rename.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
function partialRenameMap(map) {
    var arr = [];
    for (var k in map) {
        if (!map.hasOwnProperty(k)) {
            continue;
        }
        var f = map[k];
        arr.push(rename_1.rename(k, mapper_1.getNameOrEmptyString(f), operator_1.optional(f)));
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    return operator_1.unsafeDeepMerge.apply(void 0, arr);
}
exports.partialRenameMap = partialRenameMap;
//# sourceMappingURL=partial-rename-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/pojo.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/pojo.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
 * Abbreviation for "Plain old JavasScript object".
 *
 * Meaning, an Object that isn't,
 *
 * + Date
 * + Array
 * + Function
 * + An instance of some other class
 */
function pojo() {
    return function (name, mixed) {
        if (!type_util_1.isPojo(mixed)) {
            throw error_util_1.makeMappingError({
                message: name + " must be plain old JavaScript object; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "plain old JavaScript object",
            });
        }
        return mixed;
    };
}
exports.pojo = pojo;
//# sourceMappingURL=pojo.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/rename-map.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/rename-map.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var rename_1 = __webpack_require__(/*! ./rename */ "./node_modules/type-mapping/dist/functional-lib/object/rename.js");
var to_empty_object_1 = __webpack_require__(/*! ./to-empty-object */ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js");
function renameMap(map) {
    var arr = [];
    for (var k in map) {
        if (!map.hasOwnProperty(k)) {
            continue;
        }
        var f = map[k];
        arr.push(rename_1.rename(k, mapper_1.getNameOrEmptyString(f), f));
    }
    if (arr.length == 0) {
        return to_empty_object_1.toEmptyObject();
    }
    return operator_1.unsafeDeepMerge.apply(void 0, arr);
}
exports.renameMap = renameMap;
//# sourceMappingURL=rename-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/rename.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/rename.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var instance_of_object_1 = __webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function rename(srcKey, dstKey, f) {
    var runTimeRequired = mapper_1.getRunTimeRequiredFlagOrFalse(f);
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, mixed) {
        var _a;
        var unsafeKey = "";
        var unsafeName = "";
        var unsafeValue = undefined;
        if (Object.prototype.hasOwnProperty.call(mixed, dstKey)) {
            unsafeKey = dstKey;
            unsafeName = "" + name + string_util_1.toPropertyAccess(dstKey);
            unsafeValue = mixed[dstKey];
        }
        else if (Object.prototype.hasOwnProperty.call(mixed, srcKey)) {
            unsafeKey = srcKey;
            unsafeName = "" + name + string_util_1.toPropertyAccess(srcKey);
            unsafeValue = mixed[srcKey];
        }
        else if (runTimeRequired) {
            var expected = "object with explicitly set property " + JSON.stringify(dstKey);
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    srcKey: srcKey,
                    dstKey: dstKey,
                },
                propertyErrors: [
                    error_util_1.makeMappingError({
                        message: "" + name + string_util_1.toPropertyAccess(dstKey) + " must be explicitly set",
                        inputName: "" + name + string_util_1.toPropertyAccess(dstKey),
                        actualValue: undefined,
                        expected: "explicitly set",
                    }),
                ],
            });
        }
        else {
            unsafeKey = dstKey;
            unsafeName = "" + name + string_util_1.toPropertyAccess(dstKey);
            unsafeValue = undefined;
        }
        var dstResult = mapper_1.tryMapHandled(f, unsafeName, unsafeValue);
        if (dstResult.success) {
            var obj = (_a = {},
                _a[dstKey] = dstResult.value,
                _a);
            return obj;
        }
        if (dstResult.mappingError.expected == undefined) {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object. " + dstResult.mappingError.message,
                inputName: name,
                actualValue: mixed,
                expected: "valid object",
                expectedMeta: {
                    srcKey: srcKey,
                    dstKey: dstKey,
                },
                propertyErrors: [
                    dstResult.mappingError,
                ],
            });
        }
        else {
            var expected = "object with " + dstResult.mappingError.expected + " property " + JSON.stringify(unsafeKey);
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    srcKey: srcKey,
                    dstKey: dstKey,
                },
                propertyErrors: [
                    dstResult.mappingError,
                ],
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.rename = rename;
/*
const a = unsignedInteger();
const b = optional(unsignedInteger());
const c = string();
const d = optional(string());

declare const _0 : typeof a;
declare const _1 : typeof b;
declare const _2 : typeof c;
declare const _3 : typeof d;

declare const _01 : (typeof a) | (typeof b);
declare const _02 : (typeof a) | (typeof c);
declare const _03 : (typeof a) | (typeof d);

declare const _12 : (typeof b) | (typeof c);
declare const _13 : (typeof b) | (typeof d);

declare const _23 : (typeof c) | (typeof d);

const __0 = rename("x", "y", _0);
const __1 = rename("x", "y", _1);
const __2 = rename("x", "y", _2);
const __3 = rename("x", "y", _3);

const __01 = rename("x", "y", _01);
const __02 = rename("x", "y", _02);
const __03 = rename("x", "y", _03);

const __12 = rename("x", "y", _12);
const __13 = rename("x", "y", _13);

const __23 = rename("x", "y", _23);
*/ 
//# sourceMappingURL=rename.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/string-indexer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/string-indexer.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var instance_of_object_1 = __webpack_require__(/*! ./instance-of-object */ "./node_modules/type-mapping/dist/functional-lib/object/instance-of-object.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function unsafeStringIndexer(f) {
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, obj) {
        var propertyErrors = [];
        var result = {};
        for (var k in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, k)) {
                continue;
            }
            var propertyResult = mapper_1.tryMapHandled(f, "" + name + string_util_1.toPropertyAccess(k), obj[k]);
            if (propertyResult.success) {
                result[k] = propertyResult.value;
            }
            else {
                propertyErrors.push(propertyResult.mappingError);
            }
        }
        if (propertyErrors.length == 0) {
            return result;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object",
                inputName: name,
                actualValue: obj,
                expected: "valid object",
                propertyErrors: propertyErrors,
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.unsafeStringIndexer = unsafeStringIndexer;
function stringIndexer(f) {
    var fOrUndefined = operator_1.orUndefined(f);
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, obj) {
        var propertyErrors = [];
        var result = {};
        for (var k in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, k)) {
                continue;
            }
            var propertyResult = mapper_1.tryMapHandled(fOrUndefined, "" + name + string_util_1.toPropertyAccess(k), obj[k]);
            if (propertyResult.success) {
                result[k] = propertyResult.value;
            }
            else {
                propertyErrors.push(propertyResult.mappingError);
            }
        }
        if (propertyErrors.length == 0) {
            return result;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object",
                inputName: name,
                actualValue: obj,
                expected: "valid object",
                propertyErrors: propertyErrors,
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.stringIndexer = stringIndexer;
//# sourceMappingURL=string-indexer.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/object/to-empty-object.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Always returns a new empty object.
    Basically, converts *everything* into an empty object.
*/
function toEmptyObject() {
    return function () {
        return {};
    };
}
exports.toEmptyObject = toEmptyObject;
//# sourceMappingURL=to-empty-object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/cache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/cache.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operation_1 = __webpack_require__(/*! ../../mapper/operation */ "./node_modules/type-mapping/dist/mapper/operation/index.js");
function cache(cached, f) {
    var result = operation_1.copyRunTimeModifier(f, function (name, mixed) {
        return f(name, mixed, cached);
    });
    //https://github.com/microsoft/TypeScript/issues/31602
    return result;
}
exports.cache = cache;
//# sourceMappingURL=cache.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/cast.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/cast.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function cast(srcMapper, castDelegate, dstMapper) {
    var result = mapper_1.copyRunTimeModifier(srcMapper, function (name, mixed) {
        var alreadyDstResult = mapper_1.tryMapHandled(dstMapper, name, mixed);
        if (alreadyDstResult.success) {
            //If this works, we are already the desired data type
            return alreadyDstResult.value;
        }
        var cannotCastPrefix = (alreadyDstResult.mappingError.expected == undefined) ?
            "Cannot cast " + name + ";" :
            "Cannot cast " + name + " to " + alreadyDstResult.mappingError.expected + ";";
        //Failed. We need to cast.
        var mapSrcResult = mapper_1.tryMapHandled(srcMapper, name, mixed);
        if (!mapSrcResult.success) {
            throw error_util_1.makeMappingError({
                message: cannotCastPrefix + " " + mapSrcResult.mappingError.message,
                inputName: name,
                actualValue: mixed,
                expected: (mapSrcResult.mappingError.expected == alreadyDstResult.mappingError.expected ?
                    mapSrcResult.mappingError.expected :
                    "(" + alreadyDstResult.mappingError.expected + ") or (" + mapSrcResult.mappingError.expected + ")"),
                expectedMeta: {
                    mappableValues: ((alreadyDstResult.mappingError.expectedMeta == undefined ||
                        alreadyDstResult.mappingError.expectedMeta.mappableValues == undefined ||
                        mapSrcResult.mappingError.expectedMeta == undefined ||
                        mapSrcResult.mappingError.expectedMeta.mappableValues == undefined) ?
                        undefined : alreadyDstResult.mappingError.expectedMeta.mappableValues.concat(mapSrcResult.mappingError.expectedMeta.mappableValues)),
                    outputValues: ((alreadyDstResult.mappingError.expectedMeta == undefined ||
                        alreadyDstResult.mappingError.expectedMeta.outputValues == undefined) ?
                        undefined : alreadyDstResult.mappingError.expectedMeta.outputValues.slice()),
                },
                unionErrors: [
                    alreadyDstResult.mappingError,
                    mapSrcResult.mappingError,
                ],
            });
        }
        var dst = undefined;
        try {
            dst = castDelegate(mapSrcResult.value);
        }
        catch (castErr) {
            /**
             * In general, this should never happen.
             * If we're here, that means the `castDelegate` or `srcMapper` isn't working right.
             */
            throw error_util_1.makeMappingError({
                message: cannotCastPrefix + " " + castErr.message,
                inputName: name,
                actualValue: mapSrcResult.value,
                /**
                 * Since it seems like the `castDelegate` or `srcMapper` isn't working right,
                 * we should only expect whatever the `dstMapper` expects.
                 */
                expected: alreadyDstResult.mappingError.expected,
                stack: castErr.stack,
            });
        }
        var mapDstResult = mapper_1.tryMapHandled(dstMapper, name, dst);
        if (mapDstResult.success) {
            return mapDstResult.value;
        }
        else {
            /**
             * In general, this should never happen.
             * If we're here, that means the `castDelegate` or `srcMapper` isn't working right.
             */
            throw error_util_1.makeMappingError({
                message: cannotCastPrefix + " " + mapDstResult.mappingError.message,
                inputName: name,
                actualValue: dst,
                /**
                 * Since it seems like the `castDelegate` or `srcMapper` isn't working right,
                 * we should only expect whatever the `dstMapper` expects.
                 */
                expected: mapDstResult.mappingError.expected,
                unionErrors: [
                    alreadyDstResult.mappingError,
                    mapDstResult.mappingError,
                ],
            });
        }
    });
    return result;
}
exports.cast = cast;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/deep-merge.js":
/*!******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/deep-merge.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var TypeUtil = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var array_util_1 = __webpack_require__(/*! ../../array-util */ "./node_modules/type-mapping/dist/array-util/index.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
function unsafeDeepMerge() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        throw new Error("Cannot deep merge zero mappers");
    }
    if (arr.length == 1) {
        return arr[0];
    }
    var mapper = function (name, mixed) {
        var intersectionErrors = [];
        var values = [];
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var f = arr_1[_i];
            var elementResult = mapper_1.tryMapHandled(f, name, mixed);
            if (elementResult.success) {
                values.push(elementResult.value);
            }
            else {
                intersectionErrors.push(elementResult.mappingError);
            }
        }
        if (intersectionErrors.length == 1) {
            throw intersectionErrors[0];
        }
        if (intersectionErrors.length > 1) {
            var errorMessages = array_util_1.removeDuplicateElements(intersectionErrors
                .map(function (e) { return error_util_1.indentErrorMessage(e.message); }));
            var expectedElements = array_util_1.removeDuplicateElements(intersectionErrors
                .map(function (e) { return e.expected; })
                .filter(function (i) { return typeof i == "string"; }));
            throw error_util_1.makeMappingError({
                message: name + " is invalid.\n+ " + errorMessages.join("\n+ "),
                inputName: name,
                actualValue: mixed,
                expected: ((expectedElements.length == 0) ?
                    undefined :
                    (expectedElements.length == 1) ?
                        expectedElements[0] :
                        expectedElements
                            .map(function (str) { return "(" + str + ")"; })
                            .join(" and ")),
                intersectionErrors: intersectionErrors,
            });
        }
        var deepMergeResult = TypeUtil.tryDeepMerge.apply(TypeUtil, values);
        if (deepMergeResult.success) {
            return deepMergeResult.value;
        }
        else {
            /**
             * In general, this should not happen.
             * If we are here, our mappers may be doing something suspicious.
             */
            /**
             * If `path.length == 0`,
             * then it's a top-level value that failed to merge
             */
            if (deepMergeResult.path == undefined) {
                console.log(deepMergeResult);
            }
            if (deepMergeResult.path.length == 0) {
                throw error_util_1.makeMappingError({
                    message: name + " is invalid; " + deepMergeResult.message,
                    inputName: name,
                    actualValue: deepMergeResult.actualValue,
                    expected: deepMergeResult.expected,
                });
            }
            else {
                throw error_util_1.makeMappingError({
                    message: name + " is invalid; " + deepMergeResult.message,
                    inputName: name,
                    actualValue: deepMergeResult.bRoot,
                    expected: deepMergeResult.path.reduceRight(function (memo, part) {
                        return "{ " + JSON.stringify(part) + " : " + memo + " }";
                    }, deepMergeResult.expected),
                    propertyErrors: [
                        error_util_1.makeMappingError({
                            message: deepMergeResult.message,
                            inputName: deepMergeResult.path.reduce(function (memo, part) {
                                return memo + string_util_1.toPropertyAccess(part);
                            }, name),
                            actualValue: deepMergeResult.actualValue,
                            expected: deepMergeResult.expected,
                        }),
                    ],
                });
            }
        }
    };
    return mapper_1.copyRunTimeModifier(arr[0], mapper);
}
exports.unsafeDeepMerge = unsafeDeepMerge;
function deepMerge(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return unsafeDeepMerge.apply(void 0, [f].concat(arr));
}
exports.deepMerge = deepMerge;
/*
import {length} from "../array-like";
import {string} from "../string";
const dm = deepMerge(
    (null as unknown as (() => { x : "test" }) & ExpectedInput<{ foo : string }> & MappableInput<{ foo? : string|Buffer }>),
    () : { x : 1 } => (null as any),
    () : { y : true } => (null as any),
    () : { y? : true } => (null as any),
    (null as unknown as (() => { z : Date }) & MappableInput<{ foo? : Buffer }>),
);
dm("", "").y

//*
const dm2 = deepMerge(
    (null as unknown as (() => number) & ExpectedInput<{ foo : string }> & MappableInput<string>),
    (null as unknown as (() => string) & MappableInput<number>),
);
const dm3 = deepMerge(
    (null as unknown as (() => number) & ExpectedInput<{ foo : string }> & MappableInput<{ foo? : string|Buffer }>),
    (null as unknown as (() => string)),
    (null as unknown as (() => { x : "test" }) & ExpectedInput<{ foo : string }> & MappableInput<{ foo? : string|Buffer }>),
);

const dm4 = deepMerge(
    length({
        min : 1
    }),
    string()
)
//*/ 
//# sourceMappingURL=deep-merge.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/discriminated-union.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/discriminated-union.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
function unsafeDiscriminatedUnion(discriminantK) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    if (arr.length == 0) {
        throw new Error("Cannot call unsafeDiscriminatedUnion() on zero mappers");
    }
    var orDelegate = operator_1.unsafeOr.apply(void 0, arr);
    var result = function (name, mixed) {
        var mapResult = mapper_1.tryMapHandled(orDelegate, name, mixed);
        if (mapResult.success) {
            return mapResult.value;
        }
        else {
            var unionErrors = mapResult.mappingError.unionErrors;
            if (unionErrors == undefined) {
                throw mapResult.mappingError;
            }
            var discriminantInputName_1 = "" + name + string_util_1.toPropertyAccess(discriminantK);
            var discriminantErrors = unionErrors
                .map(function (unionError) {
                return error_util_1.tryGetPropertyError(unionError, discriminantInputName_1);
            })
                .filter(function (propertyError) {
                return propertyError != undefined;
            });
            if (discriminantErrors.length != unionErrors.length) {
                var nonDiscriminantErrors = unionErrors
                    .map(function (unionError) {
                    return (error_util_1.tryGetPropertyError(unionError, discriminantInputName_1) == undefined) ?
                        //This error is not because of the discriminant
                        unionError :
                        undefined;
                })
                    .filter(function (unionError) {
                    return unionError != undefined;
                });
                throw error_util_1.makeNormalizedUnionError(name, mixed, nonDiscriminantErrors);
            }
            var expectedDiscriminators = discriminantErrors.map(function (err) { return err.expected; }).join("|");
            throw error_util_1.makeMappingError({
                message: name + " must be object with " + expectedDiscriminators + " property " + JSON.stringify(discriminantK),
                inputName: name,
                actualValue: mixed,
                expected: "object with " + expectedDiscriminators + " property " + JSON.stringify(discriminantK),
                expectedMeta: undefined,
                propertyErrors: [
                    error_util_1.makeNormalizedUnionError(discriminantInputName_1, (mixed == undefined ?
                        undefined :
                        mixed[discriminantK]), discriminantErrors),
                ],
            });
        }
    };
    return result;
}
exports.unsafeDiscriminatedUnion = unsafeDiscriminatedUnion;
function discriminatedUnion(discriminantK, f) {
    var arr = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        arr[_i - 2] = arguments[_i];
    }
    return unsafeDiscriminatedUnion.apply(void 0, [discriminantK,
        f].concat(arr));
}
exports.discriminatedUnion = discriminatedUnion;
//# sourceMappingURL=discriminated-union.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/exclude-literal.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/exclude-literal.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var array_util_1 = __webpack_require__(/*! ../../array-util */ "./node_modules/type-mapping/dist/array-util/index.js");
function excludeLiteral(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    var literalStrArr = arr.map(function (value) { return type_util_1.toLiteralStr(value); });
    return mapper_1.copyRunTimeModifier(f, function (name, mixed) {
        var mapResult = mapper_1.tryMapHandled(f, name, mixed);
        if (mapResult.success) {
            var value = mapResult.value;
            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                var item = arr_1[_i];
                if (type_util_1.strictEqual(value, item)) {
                    throw error_util_1.makeMappingError({
                        message: name + " must not be " + type_util_1.toLiteralUnionStr(arr) + "; received " + type_util_1.toLiteralStr(item),
                        inputName: name,
                        actualValue: value,
                        expected: "not " + type_util_1.toLiteralUnionStr(arr),
                    });
                }
            }
            return value;
        }
        var rawUnionErrors = mapResult.mappingError.unionErrors;
        if (rawUnionErrors == undefined) {
            throw mapResult.mappingError;
        }
        var unionErrors = rawUnionErrors.filter(function (err) { return (err.expected != undefined &&
            literalStrArr.indexOf(err.expected) < 0); });
        var rawExpectedArr = unionErrors
            .map(function (e) { return e.expected; })
            .filter(function (s) { return s != undefined; });
        if (rawExpectedArr.length != unionErrors.length) {
            throw mapResult.mappingError;
        }
        /**
         * @todo Add checks for zero-length errors elsewhere in the code base, too
         */
        if (rawExpectedArr.length == 0) {
            throw error_util_1.makeMappingError({
                message: name + " must be never; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "never",
                unionErrors: unionErrors,
            });
        }
        else if (rawExpectedArr.length == 1) {
            var expected = rawExpectedArr[0];
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    mappableValues: ((mapResult.mappingError.expectedMeta == undefined ||
                        mapResult.mappingError.expectedMeta.mappableValues == undefined) ?
                        undefined :
                        mapResult.mappingError.expectedMeta.mappableValues.filter(function (mappableValue) { return !arr.some(function (i) { return type_util_1.strictEqual(i, mappableValue); }); })),
                    outputValues: ((mapResult.mappingError.expectedMeta == undefined ||
                        mapResult.mappingError.expectedMeta.outputValues == undefined) ?
                        undefined :
                        mapResult.mappingError.expectedMeta.outputValues.filter(function (outputValue) { return !arr.some(function (i) { return type_util_1.strictEqual(i, outputValue); }); })),
                },
            });
        }
        else {
            var expected = array_util_1.removeDuplicateElements(rawExpectedArr)
                .map(function (str) { return "(" + str + ")"; })
                .join(" or ");
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    mappableValues: ((mapResult.mappingError.expectedMeta == undefined ||
                        mapResult.mappingError.expectedMeta.mappableValues == undefined) ?
                        undefined :
                        mapResult.mappingError.expectedMeta.mappableValues.filter(function (mappableValue) { return !arr.some(function (i) { return type_util_1.strictEqual(i, mappableValue); }); })),
                    outputValues: ((mapResult.mappingError.expectedMeta == undefined ||
                        mapResult.mappingError.expectedMeta.outputValues == undefined) ?
                        undefined :
                        mapResult.mappingError.expectedMeta.outputValues.filter(function (outputValue) { return !arr.some(function (i) { return type_util_1.strictEqual(i, outputValue); }); })),
                },
                unionErrors: unionErrors,
            });
        }
    });
}
exports.excludeLiteral = excludeLiteral;
//# sourceMappingURL=exclude-literal.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cache */ "./node_modules/type-mapping/dist/functional-lib/operator/cache.js"));
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/operator/cast.js"));
__export(__webpack_require__(/*! ./deep-merge */ "./node_modules/type-mapping/dist/functional-lib/operator/deep-merge.js"));
__export(__webpack_require__(/*! ./discriminated-union */ "./node_modules/type-mapping/dist/functional-lib/operator/discriminated-union.js"));
__export(__webpack_require__(/*! ./exclude-literal */ "./node_modules/type-mapping/dist/functional-lib/operator/exclude-literal.js"));
__export(__webpack_require__(/*! ./missing-value */ "./node_modules/type-mapping/dist/functional-lib/operator/missing-value.js"));
__export(__webpack_require__(/*! ./or */ "./node_modules/type-mapping/dist/functional-lib/operator/or.js"));
__export(__webpack_require__(/*! ./pipe */ "./node_modules/type-mapping/dist/functional-lib/operator/pipe.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/missing-value.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/missing-value.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var or_1 = __webpack_require__(/*! ./or */ "./node_modules/type-mapping/dist/functional-lib/operator/or.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var exclude_literal_1 = __webpack_require__(/*! ./exclude-literal */ "./node_modules/type-mapping/dist/functional-lib/operator/exclude-literal.js");
function orUndefined(f) {
    return or_1.or(f, literal_1.literal(undefined));
}
exports.orUndefined = orUndefined;
function orNull(f) {
    return or_1.or(f, literal_1.literal(null));
}
exports.orNull = orNull;
function orMaybe(f) {
    return or_1.or(f, literal_1.literal(undefined), literal_1.literal(null));
}
exports.orMaybe = orMaybe;
function notUndefined(f) {
    return exclude_literal_1.excludeLiteral(f, undefined);
}
exports.notUndefined = notUndefined;
function notNull(f) {
    return exclude_literal_1.excludeLiteral(f, null);
}
exports.notNull = notNull;
function notMaybe(assert) {
    return exclude_literal_1.excludeLiteral(assert, undefined, null);
}
exports.notMaybe = notMaybe;
function optional(f) {
    var g = orUndefined(f);
    g.__optional = true;
    g.__runTimeRequired = false;
    return g;
}
exports.optional = optional;
;
function notOptional(f) {
    var g = notUndefined(f);
    g.__optional = false;
    return g;
}
exports.notOptional = notOptional;
;
function runTimeRequired(f) {
    var g = function (name, mixed) {
        return f(name, mixed);
    };
    g.__runTimeRequired = true;
    g.__optional = false;
    return mapper_1.copyName(f, g);
}
exports.runTimeRequired = runTimeRequired;
;
function notRunTimeRequired(f) {
    var g = function (name, mixed) {
        return f(name, mixed);
    };
    g.__runTimeRequired = false;
    return mapper_1.copyName(f, mapper_1.copyOptional(f, g));
}
exports.notRunTimeRequired = notRunTimeRequired;
;
//# sourceMappingURL=missing-value.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/or.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/or.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function unsafeOr() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        throw new Error("Cannot call unsafeOr() on zero mappers");
    }
    return mapper_1.copyRunTimeModifier(arr[0], function (name, mixed) {
        var unionErrors = [];
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var d = arr_1[_i];
            var elementResult = mapper_1.tryMapHandled(d, name, mixed);
            if (elementResult.success) {
                return elementResult.value;
            }
            else {
                unionErrors.push(elementResult.mappingError);
            }
        }
        throw error_util_1.makeNormalizedUnionError(name, mixed, unionErrors);
    });
}
exports.unsafeOr = unsafeOr;
function or(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return unsafeOr.apply(void 0, [f].concat(arr));
}
exports.or = or;
/*
or(
    (null as unknown as ((() => 1) & ExpectedInput<number>)),
    (null as unknown as ((() => 2) & ExpectedInput<string>)),
    (null as unknown as ((() => 3) & ExpectedInput<boolean>))
).__accepts
*/ 
//# sourceMappingURL=or.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/operator/pipe.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/operator/pipe.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
function pipeImpl() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    if (arr.length == 0) {
        throw new Error("Cannot pipe zero mappers");
    }
    return mapper_1.copyRunTimeModifier(arr[0], function (name, mixed) {
        for (var i = 0; i < arr.length; ++i) {
            var d = arr[i];
            var elementResult = mapper_1.tryMapHandled(d, name, mixed);
            if (elementResult.success) {
                mixed = elementResult.value;
            }
            else {
                throw elementResult.mappingError;
            }
        }
        return mixed;
    });
}
//Not the best...
//export function pipe<ArrT extends AnyMapper[]> (...arr : ArrT) : SafeMapper<unknown>;
function pipe() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return pipeImpl.apply(void 0, arr);
}
exports.pipe = pipe;
function unsafePipe(f) {
    var arr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arr[_i - 1] = arguments[_i];
    }
    return pipeImpl.apply(void 0, [f].concat(arr));
}
exports.unsafePipe = unsafePipe;
function reallyUnsafePipe() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
    }
    return pipeImpl.apply(void 0, arr);
}
exports.reallyUnsafePipe = reallyUnsafePipe;
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/cast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/cast.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var number_string_1 = __webpack_require__(/*! ./number-string */ "./node_modules/type-mapping/dist/functional-lib/string/number-string.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function finiteNumberToFiniteNumberString() {
    return operator_1.cast(number_1.finiteNumber(), function (num) { return num.toString(); }, number_string_1.finiteNumberString());
}
exports.finiteNumberToFiniteNumberString = finiteNumberToFiniteNumberString;
function integerToIntegerString() {
    return operator_1.cast(number_1.integer(), function (num) { return num.toString(); }, number_string_1.integerString());
}
exports.integerToIntegerString = integerToIntegerString;
function unsignedIntegerToUnsignedIntegerString() {
    return operator_1.cast(number_1.unsignedInteger(), function (num) { return num.toString(); }, number_string_1.unsignedIntegerString());
}
exports.unsignedIntegerToUnsignedIntegerString = unsignedIntegerToUnsignedIntegerString;
/**
    Calls either `JSON.stringify()` or `JSON.parse()` once.
*/
function jsonObjectToJsonObjectString() {
    return function (name, mixed) {
        if (typeof mixed == "string") {
            if (!/^\s*\{/.test(mixed)) {
                throw error_util_1.makeMappingError({
                    message: name + " must be JSON Object string",
                    inputName: name,
                    actualValue: mixed,
                    expected: "JSON Object string",
                });
            }
            try {
                JSON.parse(mixed);
            }
            catch (err) {
                throw error_util_1.makeMappingError({
                    message: name + " must be valid JSON Object string; " + err.message,
                    inputName: name,
                    actualValue: mixed,
                    expected: "valid JSON Object string",
                });
            }
            return mixed;
        }
        try {
            var str = JSON.stringify(mixed);
            if (typeof str == "string" && str[0] == "{") {
                if (type_util_1.isBigIntNativelySupported() || !type_util_1.isBigInt(mixed)) {
                    return str;
                }
            }
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "JSON Object",
            });
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object; " + err.message,
                inputName: name,
                actualValue: mixed,
                expected: "JSON Object",
            });
        }
    };
}
exports.jsonObjectToJsonObjectString = jsonObjectToJsonObjectString;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/string/cast.js"));
__export(__webpack_require__(/*! ./ip-address */ "./node_modules/type-mapping/dist/functional-lib/string/ip-address.js"));
__export(__webpack_require__(/*! ./ip-v4-mapped-ip-v6 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4-mapped-ip-v6.js"));
__export(__webpack_require__(/*! ./ip-v4 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4.js"));
__export(__webpack_require__(/*! ./ip-v6 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v6.js"));
__export(__webpack_require__(/*! ./number-string */ "./node_modules/type-mapping/dist/functional-lib/string/number-string.js"));
__export(__webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/string.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/ip-address.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/ip-address.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var ip_v4_1 = __webpack_require__(/*! ./ip-v4 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4.js");
var ip_v6_1 = __webpack_require__(/*! ./ip-v6 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v6.js");
var ip_v4_mapped_ip_v6_1 = __webpack_require__(/*! ./ip-v4-mapped-ip-v6 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4-mapped-ip-v6.js");
function ipAddressString() {
    return operator_1.or(ip_v4_1.ipV4String(), ip_v6_1.ipV6String(), ip_v4_mapped_ip_v6_1.ipV4MappedIpV6String());
}
exports.ipAddressString = ipAddressString;
//# sourceMappingURL=ip-address.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4-mapped-ip-v6.js":
/*!************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/ip-v4-mapped-ip-v6.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var string_1 = __webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/string.js");
var ip_v4_1 = __webpack_require__(/*! ./ip-v4 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4.js");
var ip_v6_1 = __webpack_require__(/*! ./ip-v6 */ "./node_modules/type-mapping/dist/functional-lib/string/ip-v6.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function ipV4MappedIpV6String() {
    var ipV4StringDelegate = ip_v4_1.ipV4String();
    var ipV6PartDelegate = ip_v6_1.ipV6StringWithMaxSegmentCount(6);
    return operator_1.pipe(string_1.string(), function (name, str) {
        var ipV4Start = str.lastIndexOf(":");
        if (ipV4Start < 0) {
            throw error_util_1.makeMappingError({
                message: "Expected " + name + " to have ':' symbol",
                inputName: name,
                actualValue: str,
                expected: "IPv4-mapped IPv6 string with ':' symbol",
            });
        }
        var rawIpV4 = str.substr(ipV4Start + 1);
        //Must have [1, 6] segments
        //Note : If input ends with "::", rawIpV6 becomes ":"
        var rawIpV6 = str.substr(0, ipV4Start);
        if (rawIpV6.length == 0) {
            throw error_util_1.makeMappingError({
                message: "Expected " + name + " to have one to six IPv6 segments; found zero",
                inputName: name,
                actualValue: str,
                expected: "IPv4-mapped IPv6 string with one to six IPv6 segments",
            });
        }
        var rawIpV6EndsWithDoubleColon = string_util_1.stringEndsWith(rawIpV6, ":");
        var ipV4 = ipV4StringDelegate(name + ".IPv4Part", rawIpV4);
        var ipV6 = ipV6PartDelegate(name + ".IPv6Part", rawIpV6EndsWithDoubleColon ?
            rawIpV6 + ":" :
            rawIpV6);
        if (string_util_1.stringEndsWith(ipV6, "::")) {
            return ipV6 + ipV4;
        }
        else if (string_util_1.stringEndsWith(ipV6, ":")) {
            return ipV6 + ipV4;
        }
        else {
            return ipV6 + ":" + ipV4;
        }
    });
}
exports.ipV4MappedIpV6String = ipV4MappedIpV6String;
//# sourceMappingURL=ip-v4-mapped-ip-v6.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/ip-v4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/ip-v4.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var string_1 = __webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/string.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    https://en.wikipedia.org/wiki/Dot-decimal_notation

    An octet is 8-bits.
    In decimal, an octet can represent [0, 255].

    IPv4 strings are made of four octets (written in decimal),
    each separated by a period.

    Examples:

    127.0.0.1
    255.255.255.0
    255.255.255.255
*/
function ipV4OctetString() {
    return operator_1.pipe(number_1.stringToUnsignedInteger(), number_1.ltEq(255), function (_name, octet) {
        return octet.toString();
    });
}
exports.ipV4OctetString = ipV4OctetString;
function ipV4String() {
    var octetDelegate = ipV4OctetString();
    return operator_1.pipe(string_1.string(), function (name, str) {
        var rawOctets = str
            .replace(/\s+/g, "")
            .split(".");
        if (rawOctets.length != 4) {
            throw error_util_1.makeMappingError({
                message: name + " must have four octets; found " + rawOctets.length,
                inputName: name,
                actualValue: str,
                expected: "four IPv4 octets",
            });
        }
        return rawOctets
            .map(function (rawOctet, i) { return octetDelegate(name + ".octet" + i, rawOctet); })
            .join(".");
    });
}
exports.ipV4String = ipV4String;
//# sourceMappingURL=ip-v4.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/ip-v6.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/ip-v6.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var string_1 = __webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/string.js");
var array_util_1 = __webpack_require__(/*! ../../array-util */ "./node_modules/type-mapping/dist/array-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
/**
    == INPUT ==
    https://tools.ietf.org/html/rfc4291#section-2.2

    Each IPv6 segment is any hexadecimal value between
    0 and ffff.

    Each segment is one to four hexadecimal digits.

    == OUTPUT ==
    https://tools.ietf.org/html/rfc5952#section-4.1
    Leading zeros MUST be suppressed.  For example, 2001:0db8::0001 is
    not acceptable and must be represented as 2001:db8::1.  A single 16-
    bit 0000 field MUST be represented as 0.

    https://tools.ietf.org/html/rfc5952#section-4.3

    The characters "a", "b", "c", "d", "e", and "f" in an IPv6 address
    MUST be represented in lowercase.
*/
function ipV6SegmentString() {
    return operator_1.pipe(string_1.stringLength({
        min: 1,
        max: 4,
    }), string_1.hexadecimalString(), function (_name, str) {
        if (/^0+$/.test(str)) {
            return "0";
        }
        return str.toLowerCase()
            .replace(/^0+/, "");
    });
}
exports.ipV6SegmentString = ipV6SegmentString;
function consecutiveZeroCount(segments, start) {
    var count = 0;
    while (segments[start] == "0") {
        ++count;
        ++start;
    }
    return count;
}
function largestConsecutiveZeroCount(segments) {
    var largestStart = 0;
    var largestCount = 0;
    var curStart = 0;
    while (curStart < segments.length) {
        var curCount = consecutiveZeroCount(segments, curStart);
        if (curCount > largestCount) {
            largestStart = curStart;
            largestCount = curCount;
        }
        ++curStart;
    }
    return {
        start: largestStart,
        count: largestCount,
        before: segments.slice(0, largestStart),
        after: segments.slice(largestStart + largestCount),
    };
}
/**
    https://tools.ietf.org/html/rfc5952#section-4.2.1

    The use of the symbol "::" MUST be used to its maximum capability.
    For example, 2001:db8:0:0:0:0:2:1 must be shortened to 2001:db8::2:1.
    Likewise, 2001:db8::0:1 is not acceptable, because the symbol "::"
    could have been used to produce a shorter representation 2001:db8::1.

    https://tools.ietf.org/html/rfc5952#section-4.2.2

    The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field.
    For example, the representation 2001:db8:0:1:1:1:1:1 is correct, but
    2001:db8::1:1:1:1:1 is not correct.

    https://tools.ietf.org/html/rfc5952#section-4.2.3

    When there is an alternative choice in the placement of a "::", the
    longest run of consecutive 16-bit 0 fields MUST be shortened (i.e.,
    the sequence with three consecutive zero fields is shortened in 2001:
    0:0:1:0:0:0:1).  When the length of the consecutive 16-bit 0 fields
    are equal (i.e., 2001:db8:0:0:1:0:0:1), the first sequence of zero
    bits MUST be shortened.  For example, 2001:db8::1:0:0:1 is correct
    representation.
*/
function toIpV6CanonicalString(segments) {
    var result = largestConsecutiveZeroCount(segments);
    if (result.count <= 1) {
        return segments.join(":");
    }
    else {
        return (result.before.join(":") +
            "::" +
            result.after.join(":"));
    }
}
function ipV6StringWithMaxSegmentCount(maxSegmentCount) {
    var ipV6SegmentStringDelegate = ipV6SegmentString();
    return operator_1.pipe(string_1.string(), function (name, str) {
        var consecutiveNonZero = str
            .replace(/\s+/g, "")
            .split("::");
        if (consecutiveNonZero.length == 1) {
            //All non-zeroes
            var rawSegments = consecutiveNonZero[0].split(":");
            if (rawSegments.length != maxSegmentCount) {
                throw error_util_1.makeMappingError({
                    message: name + " must have " + maxSegmentCount + " segments; found " + rawSegments.length,
                    inputName: name,
                    actualValue: str,
                    expected: maxSegmentCount + " IPv6 segments",
                });
            }
            var segments = rawSegments
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + i, rawSegment); });
            return toIpV6CanonicalString(segments);
        }
        else if (consecutiveNonZero.length == 2) {
            //E.g. ffff:ffff::ffff:ffff:ffff
            var rawSegmentsA = consecutiveNonZero[0].split(":").filter(function (s) { return s != ""; });
            var rawSegmentsB = consecutiveNonZero[1].split(":").filter(function (s) { return s != ""; });
            var rawSegmentCount = rawSegmentsA.length + rawSegmentsB.length;
            if (rawSegmentCount >= maxSegmentCount) {
                throw error_util_1.makeMappingError({
                    message: name + " must have up to " + (maxSegmentCount - 1) + " segments when '::' symbol is used; found " + rawSegmentCount,
                    inputName: name,
                    actualValue: str,
                    expected: "up to " + (maxSegmentCount - 1) + " IPv6 segments",
                });
            }
            var segmentsA = rawSegmentsA
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + i, rawSegment); });
            var segmentBStart_1 = maxSegmentCount - rawSegmentsB.length;
            var segmentsB = rawSegmentsB
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + (segmentBStart_1 + i), rawSegment); });
            var zeroes = array_util_1.arrayFill(Array(maxSegmentCount - rawSegmentCount), "0");
            return toIpV6CanonicalString(segmentsA
                .concat(zeroes)
                .concat(segmentsB));
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must have zero or one '::' symbol; found " + (consecutiveNonZero.length - 1) + " uses",
                inputName: name,
                actualValue: str,
                expected: "IPv6 string with zero or one '::' symbol",
            });
        }
    });
}
exports.ipV6StringWithMaxSegmentCount = ipV6StringWithMaxSegmentCount;
function ipV6String() {
    return ipV6StringWithMaxSegmentCount(8);
}
exports.ipV6String = ipV6String;
//# sourceMappingURL=ip-v6.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/number-string.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/number-string.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var string_1 = __webpack_require__(/*! ./string */ "./node_modules/type-mapping/dist/functional-lib/string/string.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var FixedPointUtil = __webpack_require__(/*! ../../fixed-point-util */ "./node_modules/type-mapping/dist/fixed-point-util/index.js");
var FloatingPointUtil = __webpack_require__(/*! ../../floating-point-util */ "./node_modules/type-mapping/dist/floating-point-util/index.js");
/**
    Just because a string is in floating point format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid floating point format
    floatingPointFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
*/
function floatingPointFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), string_1.match(FloatingPointUtil.floatingPointRegex, function (name) {
        return {
            message: name + " must be valid floating point format string",
            expected: "valid floating point format string",
        };
    }));
}
exports.floatingPointFormatString = floatingPointFormatString;
/**
    Just because a string is in integer format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid integer format
    integerFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
    + This mapper allows scientific notation.
*/
function integerFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), function (name, str) {
        var parsed = FixedPointUtil.tryParse(str);
        if (parsed == undefined || !parsed.isInteger) {
            throw error_util_1.makeMappingError({
                message: name + " must be a valid integer format string",
                inputName: name,
                actualValue: str,
                expected: "valid integer format string",
            });
        }
        return str;
    });
}
exports.integerFormatString = integerFormatString;
/**
    Just because a string is in unsigned number format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid unsigned number format
    unsignedIntegerFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
    + This mapper allows scientific notation.
*/
function unsignedIntegerFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), function (name, str) {
        var parsed = FixedPointUtil.tryParse(str);
        if (parsed == undefined || !parsed.isInteger || parsed.isNegative) {
            throw error_util_1.makeMappingError({
                message: name + " must be a valid unsigned integer format string",
                inputName: name,
                actualValue: str,
                expected: "valid unsigned integer format string",
            });
        }
        return str;
    });
}
exports.unsignedIntegerFormatString = unsignedIntegerFormatString;
/**
    Uses `floatingPointFormatString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    finiteNumberString()("", "9999999999999999");
    ```
*/
function finiteNumberString() {
    var finiteNumberDelegate = number_1.finiteNumber();
    return operator_1.pipe(floatingPointFormatString(), function (name, str) {
        return finiteNumberDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.finiteNumberString = finiteNumberString;
/**
    Uses `integerFormatString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    integerString()("", "9999999999999999");
    ```
*/
function integerString() {
    var integerDelegate = number_1.integer();
    return operator_1.pipe(integerFormatString(), function (name, str) {
        return integerDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.integerString = integerString;
/**
    Uses `unsignedIntegerString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    integerString()("", "9999999999999999");
    ```
*/
function unsignedIntegerString() {
    var unsignedIntegerDelegate = number_1.unsignedInteger();
    return operator_1.pipe(unsignedIntegerFormatString(), function (name, str) {
        return unsignedIntegerDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.unsignedIntegerString = unsignedIntegerString;
//# sourceMappingURL=number-string.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/string/string.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/string/string.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var array_like_1 = __webpack_require__(/*! ../array-like */ "./node_modules/type-mapping/dist/functional-lib/array-like/index.js");
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function string() {
    return function (name, mixed) {
        if (typeof mixed != "string") {
            throw error_util_1.makeMappingError({
                message: name + " must be string; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "string",
            });
        }
        return mixed;
    };
}
exports.string = string;
/**
    Calls `JSON.parse()` once.
*/
function jsonObjectString() {
    return operator_1.pipe(string(), function (name, str) {
        if (!/^\s*\{/.test(str)) {
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object string",
                inputName: name,
                actualValue: str,
                expected: "JSON Object string",
            });
        }
        try {
            JSON.parse(str);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be valid JSON Object string; " + err.message,
                inputName: name,
                actualValue: str,
                expected: "valid JSON Object string",
            });
        }
        return str;
    });
}
exports.jsonObjectString = jsonObjectString;
function stringLength(args) {
    return operator_1.pipe(string(), array_like_1.length(args));
}
exports.stringLength = stringLength;
function stringExactLength(length) {
    return stringLength({
        min: length,
        max: length,
    });
}
exports.stringExactLength = stringExactLength;
function match(regex, errorDelegate) {
    return operator_1.pipe(string(), function (name, mixed) {
        if (regex.test(mixed)) {
            return mixed;
        }
        else {
            if (errorDelegate == undefined) {
                throw error_util_1.makeMappingError({
                    message: name + " must match " + regex.toString(),
                    inputName: name,
                    actualValue: mixed,
                    expected: regex.toString(),
                });
            }
            else {
                var errResult = errorDelegate(name);
                if (typeof errResult == "string") {
                    throw error_util_1.makeMappingError({
                        message: errResult,
                        inputName: name,
                        actualValue: mixed,
                        expected: regex.toString(),
                    });
                }
                else {
                    throw error_util_1.makeMappingError({
                        message: errResult.message,
                        inputName: name,
                        actualValue: mixed,
                        expected: errResult.expected,
                    });
                }
            }
        }
    });
}
exports.match = match;
function notMatch(regex, errorDelegate) {
    return operator_1.pipe(string(), function (name, mixed) {
        if (regex.test(mixed)) {
            if (errorDelegate == undefined) {
                throw error_util_1.makeMappingError({
                    message: name + " must not match " + regex.toString(),
                    inputName: name,
                    actualValue: mixed,
                    expected: "not " + regex.toString(),
                });
            }
            else {
                var errResult = errorDelegate(name);
                if (typeof errResult == "string") {
                    throw error_util_1.makeMappingError({
                        message: errResult,
                        inputName: name,
                        actualValue: mixed,
                        expected: "not " + regex.toString(),
                    });
                }
                else {
                    throw error_util_1.makeMappingError({
                        message: errResult.message,
                        inputName: name,
                        actualValue: mixed,
                        expected: errResult.expected,
                    });
                }
            }
        }
        else {
            return mixed;
        }
    });
}
exports.notMatch = notMatch;
/**
 *
 * Alias for `emailAddress()`
 *  @see {@link emailAddress}
 *
 * @deprecated
 */
function email() {
    return emailAddress();
}
exports.email = email;
/**
 * Runs the regex `/^.+@.+$/` on the string.
 * Doesn't exactly follow a standard.
 *
 * You may roll your own email address validator,
 * but it's better to just send a confirmation
 * email to check the email address is valid.
 */
function emailAddress() {
    return match(/^.+@.+$/, function (name) {
        return {
            message: name + " must be an email address",
            expected: "email address",
        };
    });
}
exports.emailAddress = emailAddress;
/**
 * + Allows empty string.
 * + Allows digits 0-9.
 * + Allows uppercase A-F.
 * + Allows lowercase a-f.
 */
function hexadecimalString() {
    return match(/^[a-fA-F0-9]*$/, function (name) {
        return {
            message: name + " must be a hexadecimal string",
            expected: "hexadecimal string",
        };
    });
}
exports.hexadecimalString = hexadecimalString;
function toUpperCase() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.toUpperCase();
    });
}
exports.toUpperCase = toUpperCase;
function toLowerCase() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.toLowerCase();
    });
}
exports.toLowerCase = toLowerCase;
//The `char` must be a single character or an error is thrown
function padLeft(minLength, char) {
    if (char.length != 1) {
        throw new Error("\"char\" must be one character; received " + char);
    }
    return operator_1.pipe(string(), function (_name, str) {
        if (str.length >= minLength) {
            return str;
        }
        return string_util_1.stringRepeat(char, minLength - str.length) + str;
    });
}
exports.padLeft = padLeft;
//The `char` must be a single character or an error is thrown
function padRight(minLength, char) {
    if (char.length != 1) {
        throw new Error("\"char\" must be one character; received " + char);
    }
    return operator_1.pipe(string(), function (_name, str) {
        if (str.length >= minLength) {
            return str;
        }
        return str + string_util_1.stringRepeat(char, minLength - str.length);
    });
}
exports.padRight = padRight;
function subStringBlacklist(blacklist, configuration) {
    if (configuration === void 0) { configuration = {}; }
    //We do not mind === here.
    var caseInsensitive = (configuration.caseInsensitive === true);
    if (caseInsensitive) {
        blacklist = blacklist.map(function (subString) { return subString.toLowerCase(); });
    }
    var blacklistStr = blacklist.map(function (s) { return type_util_1.toLiteralStr(s); }).join(", ");
    var expected = "not " + blacklistStr;
    return operator_1.pipe(string(), function (name, original) {
        var str = caseInsensitive ?
            original.toLowerCase() :
            original;
        var found = [];
        for (var _i = 0, blacklist_1 = blacklist; _i < blacklist_1.length; _i++) {
            var subString = blacklist_1[_i];
            if (str.indexOf(subString) >= 0) {
                found.push(subString);
            }
        }
        if (found.length == 0) {
            return original;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must not contain the following: " + blacklistStr + "; found " + found.map(function (s) { return type_util_1.toLiteralStr(s); }).join(", "),
                inputName: name,
                actualValue: original,
                expected: expected,
            });
        }
    });
}
exports.subStringBlacklist = subStringBlacklist;
function toTrimmed() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.trim();
    });
}
exports.toTrimmed = toTrimmed;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/type/deferred.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/type/deferred.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
;
function deferred() {
    var implementation = undefined;
    var result = function (name, mixed) {
        if (implementation == undefined) {
            throw error_util_1.makeMappingError({
                message: "Cannot check " + name + "; no implementation given for deferred mapper",
                inputName: name,
                actualValue: mixed,
                expected: "implementation for deferred mapper",
            });
        }
        else {
            return implementation(name, mixed);
        }
    };
    result.setImplementation = function (impl) {
        implementation = impl;
    };
    return result;
}
exports.deferred = deferred;
//# sourceMappingURL=deferred.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/type/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/type/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./deferred */ "./node_modules/type-mapping/dist/functional-lib/type/deferred.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/byte-length.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/uint-8-array/byte-length.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var object_1 = __webpack_require__(/*! ../object */ "./node_modules/type-mapping/dist/functional-lib/object/index.js");
var number_1 = __webpack_require__(/*! ../number */ "./node_modules/type-mapping/dist/functional-lib/number/index.js");
var mapper_1 = __webpack_require__(/*! ../../mapper */ "./node_modules/type-mapping/dist/mapper/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function byteLength(args) {
    var byteLengthDelegate = operator_1.pipe(number_1.unsignedInteger(), number_1.range({
        gtEq: args.min,
        ltEq: args.max,
    }));
    var expected = ((args.min == undefined) ?
        ((args.max == undefined) ?
            "value with \"byteLength\" property" :
            "value of byteLength less than, or equal to " + args.max.toString()) :
        ((args.max == undefined) ?
            "value of byteLength greater than, or equal to " + args.min.toString() :
            (args.min == args.max) ?
                "value of byteLength " + args.min.toString() :
                "value of byteLength between " + args.min.toString() + " and " + args.max.toString()));
    return operator_1.pipe(object_1.instanceOfObject(), function (name, mixed) {
        var byteLengthResult = mapper_1.tryMapHandled(byteLengthDelegate, name + ".byteLength", mixed.byteLength);
        if (byteLengthResult.success) {
            return mixed;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: mixed,
                expected: expected,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_BYTE_LENGTH,
                    min: args.min,
                    max: args.max,
                },
                propertyErrors: [
                    byteLengthResult.mappingError,
                ],
            });
        }
    });
}
exports.byteLength = byteLength;
//# sourceMappingURL=byte-length.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/uint-8-array/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./byte-length */ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/byte-length.js"));
__export(__webpack_require__(/*! ./uint-8-array */ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/uint-8-array.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/uint-8-array.js":
/*!************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/uint-8-array/uint-8-array.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var byte_length_1 = __webpack_require__(/*! ./byte-length */ "./node_modules/type-mapping/dist/functional-lib/uint-8-array/byte-length.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
function instanceOfUint8Array() {
    return function (name, mixed) {
        if (!(mixed instanceof Uint8Array)) {
            throw error_util_1.makeMappingError({
                message: name + " must be instance of Uint8Array; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "Uint8Array",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.instanceOfUint8Array = instanceOfUint8Array;
function uint8ArrayLength(args) {
    return operator_1.pipe(byte_length_1.byteLength(args), instanceOfUint8Array());
}
exports.uint8ArrayLength = uint8ArrayLength;
function uint8ArrayExactLength(length) {
    return uint8ArrayLength({
        min: length,
        max: length,
    });
}
exports.uint8ArrayExactLength = uint8ArrayExactLength;
//# sourceMappingURL=uint-8-array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/undefined/cast.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/undefined/cast.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var operator_1 = __webpack_require__(/*! ../operator */ "./node_modules/type-mapping/dist/functional-lib/operator/index.js");
var literal_1 = __webpack_require__(/*! ../literal */ "./node_modules/type-mapping/dist/functional-lib/literal/index.js");
var undefined_1 = __webpack_require__(/*! ./undefined */ "./node_modules/type-mapping/dist/functional-lib/undefined/undefined.js");
var string_1 = __webpack_require__(/*! ../string */ "./node_modules/type-mapping/dist/functional-lib/string/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function nullToUndefined() {
    return function (name, mixed) {
        //We do not mind === here.
        if (mixed === undefined || mixed === null) {
            return undefined;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be null|undefined; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: "null|undefined",
            expectedMeta: {
                mappableValues: [null, undefined],
                outputValues: [undefined],
            },
        });
    };
}
exports.nullToUndefined = nullToUndefined;
function emptyStringToUndefined() {
    return operator_1.cast(literal_1.literal(""), function () { return undefined; }, undefined_1.undefined());
}
exports.emptyStringToUndefined = emptyStringToUndefined;
/**
    An empty string, or a string of only whitespace
*/
function whitespaceStringToUndefined() {
    return operator_1.cast(string_1.match(/^\s*$/, function (name) {
        return {
            message: name + " must be a whitespace string",
            expected: "whitespace string",
        };
    }), function () { return undefined; }, undefined_1.undefined());
}
exports.whitespaceStringToUndefined = whitespaceStringToUndefined;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/undefined/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/undefined/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./cast */ "./node_modules/type-mapping/dist/functional-lib/undefined/cast.js"));
__export(__webpack_require__(/*! ./undefined */ "./node_modules/type-mapping/dist/functional-lib/undefined/undefined.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/undefined/undefined.js":
/*!******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/undefined/undefined.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function undef() {
    return function (name, mixed) {
        //We do not mind === here.
        if (mixed === undefined) {
            return mixed;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be undefined; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: "undefined",
            expectedMeta: {
                mappableValues: [undefined],
                outputValues: [undefined],
            },
        });
    };
}
exports.undefined = undef;
//# sourceMappingURL=undefined.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/unknown/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/unknown/index.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./unknown */ "./node_modules/type-mapping/dist/functional-lib/unknown/unknown.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/functional-lib/unknown/unknown.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/functional-lib/unknown/unknown.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function unknown() {
    return function (_name, mixed) {
        return mixed;
    };
}
exports.unknown = unknown;
//# sourceMappingURL=unknown.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/type-mapping/dist/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="buffer.d.ts" />
var ArrayBufferUtil = __webpack_require__(/*! ./array-buffer-util */ "./node_modules/type-mapping/dist/array-buffer-util/index.js");
exports.ArrayBufferUtil = ArrayBufferUtil;
var EnumUtil = __webpack_require__(/*! ./enum-util */ "./node_modules/type-mapping/dist/enum-util/index.js");
exports.EnumUtil = EnumUtil;
var BigIntUtil = __webpack_require__(/*! ./bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
exports.BigIntUtil = BigIntUtil;
var FixedPointUtil = __webpack_require__(/*! ./fixed-point-util */ "./node_modules/type-mapping/dist/fixed-point-util/index.js");
exports.FixedPointUtil = FixedPointUtil;
var FloatingPointUtil = __webpack_require__(/*! ./floating-point-util */ "./node_modules/type-mapping/dist/floating-point-util/index.js");
exports.FloatingPointUtil = FloatingPointUtil;
__export(__webpack_require__(/*! ./decorator */ "./node_modules/type-mapping/dist/decorator/index.js"));
var ErrorUtil = __webpack_require__(/*! ./error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
exports.ErrorUtil = ErrorUtil;
__export(__webpack_require__(/*! ./field-map */ "./node_modules/type-mapping/dist/field-map/index.js"));
__export(__webpack_require__(/*! ./functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js"));
var jsonApi = __webpack_require__(/*! ./json-api-lib */ "./node_modules/type-mapping/dist/json-api-lib/index.js");
exports.jsonApi = jsonApi;
__export(__webpack_require__(/*! ./mapper */ "./node_modules/type-mapping/dist/mapper/index.js"));
var mysql = __webpack_require__(/*! ./mysql-lib */ "./node_modules/type-mapping/dist/mysql-lib/index.js");
exports.mysql = mysql;
var TypeUtil = __webpack_require__(/*! ./type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
exports.TypeUtil = TypeUtil;
__export(__webpack_require__(/*! ./error-code */ "./node_modules/type-mapping/dist/error-code.js"));
__export(__webpack_require__(/*! ./fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js"));
/**
 * Convenience function.
 * Will create a native `bigint` (if natively supported),
 * or create a polyfilled `bigint` (if polyfilled).
 */
function BigInt(x) {
    return TypeUtil.getBigIntFactoryFunctionOrError()(x);
}
exports.BigInt = BigInt;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/attribute-collection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/attribute-collection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * Must be a plain-old-JavaScript-object in this implementation
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-resource-object-attributes
 *
 * The value of the `attributes` key **MUST** be an object (an attributes object).
 * Members of the attributes object (attributes) represent information about the resource object in which its defined.
 *
 * Attributes may contain any valid JSON value.
 *
 * Complex data structures involving JSON objects and arrays are allowed as attribute values.
 * However, any object that constitutes or is contained in an attribute **MUST NOT**
 * contain a `relationships` or `links` member, as those members are reserved by this specification for future use.
 *
 * Although has-one foreign keys (e.g. `author_id`) are often stored internally alongside other
 * information to be represented in a resource object, these keys **SHOULD NOT** appear as attributes.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-resource-object-fields
 *
 * A resource objects attributes and its relationships are collectively called its fields.
 *
 * Fields for a resource object **MUST** share a common namespace with each other and with `type` and `id`.
 * In other words, a resource can not have an attribute and relationship with the same name,
 * nor can it have an attribute or relationship named `type` or `id`.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-member-names
 *
 * All member names used in a JSON:API document **MUST** be treated as
 * case sensitive by clients and servers, and they **MUST** meet all of the following conditions:
 *
 * + Member names **MUST** contain at least one character.
 * + Member names **MUST** contain only the allowed characters listed below.
 * + Member names **MUST** start and end with a globally allowed character, as defined below.
 *
 * To enable an easy mapping of member names to URLs,
 * it is **RECOMMENDED** that member names use only non-reserved,
 * URL safe characters specified in [RFC 3986](http://tools.ietf.org/html/rfc3986#page-13).
 *
 * ### Allowed Characters
 *
 * The following globally allowed characters **MAY** be used anywhere in a member name:
 *
 * + U+0061 to U+007A, a-z
 * + U+0041 to U+005A, A-Z
 * + U+0030 to U+0039, 0-9
 * + U+0080 and above (non-ASCII Unicode characters; not recommended, not URL safe)
 *
 * Additionally, the following characters are allowed in member names, except as the first or last character:
 *
 * + U+002D HYPHEN-MINUS, -
 * + U+005F LOW LINE, _
 * + U+0020 SPACE,   (not recommended, not URL safe)
 *
 *
 * ### Reserved Characters
 *
 * The following characters **MUST NOT** be used in member names:
 *
 * + U+002B PLUS SIGN, + (used for ordering)
 * + U+002C COMMA, , (used as a separator between relationship paths)
 * + U+002E PERIOD, . (used as a separator within relationship paths)
 * + U+005B LEFT SQUARE BRACKET, [ (used in sparse fieldsets)
 * + U+005D RIGHT SQUARE BRACKET, ] (used in sparse fieldsets)
 * + U+0021 EXCLAMATION MARK, !
 * + U+0022 QUOTATION MARK, 
 * + U+0023 NUMBER SIGN, #
 * + U+0024 DOLLAR SIGN, $
 * + U+0025 PERCENT SIGN, %
 * + U+0026 AMPERSAND, &
 * + U+0027 APOSTROPHE, 
 * + U+0028 LEFT PARENTHESIS, (
 * + U+0029 RIGHT PARENTHESIS, )
 * + U+002A ASTERISK, *
 * + U+002F SOLIDUS, /
 * + U+003A COLON, :
 * + U+003B SEMICOLON, ;
 * + U+003C LESS-THAN SIGN, <
 * + U+003D EQUALS SIGN, =
 * + U+003E GREATER-THAN SIGN, >
 * + U+003F QUESTION MARK, ?
 * + U+0040 COMMERCIAL AT, @
 * + U+005C REVERSE SOLIDUS, \
 * + U+005E CIRCUMFLEX ACCENT, ^
 * + U+0060 GRAVE ACCENT, `
 * + U+007B LEFT CURLY BRACKET, {
 * + U+007C VERTICAL LINE, |
 * + U+007D RIGHT CURLY BRACKET, }
 * + U+007E TILDE, ~
 * + U+007F DELETE
 * + U+0000 to U+001F (C0 Controls)
 *
 *  @see {@link pojo}
 *  @see {@link AttributeCollection}
 *
 * -----
 *
 * The JSON:API spec outlines many restrictions on field names of an `AttributeCollection`.
 *
 * However, we do not implement any of them at the moment.
 *
 * @todo Implement restrictions on field names?
 *
 */
exports.attributeCollection = fLib.pojo;
//# sourceMappingURL=attribute-collection.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/client-resource.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/client-resource.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var attribute_collection_1 = __webpack_require__(/*! ./attribute-collection */ "./node_modules/type-mapping/dist/json-api-lib/attribute-collection.js");
var relationship_1 = __webpack_require__(/*! ./relationship */ "./node_modules/type-mapping/dist/json-api-lib/relationship.js");
var link_collection_1 = __webpack_require__(/*! ./link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * https://jsonapi.org/format/1.0/#document-resource-objects
 *
 * Resource objects appear in a JSON:API document to represent resources.
 *
 * A resource object **MUST** contain at least the following top-level members:
 *
 * + `id`
 * + `type`
 *
 * Exception: The `id` member is not required when the resource object originates
 * at the client and represents a new resource to be created on the server.
 *
 * In addition, a resource object **MAY** contain any of these top-level members:
 *
 * + `attributes`: an attributes object representing some of the resources data.
 * + `relationships`: a relationships object describing relationships between the resource and other JSON:API resources.
 * + `links`: a links object containing links related to the resource.
 * + `meta`: a meta object containing non-standard meta-information about a resource that can not be
 *   represented as an attribute or relationship.
 *
 *  @see {@link attributeCollection}
 *  @see {@link relationship}
 *  @see {@link linkCollection}
 *  @see {@link meta}
 *  @see {@link ClientResource}
 *  @see {@link ExpectedInputClientResource}
 */
exports.clientResource = function () { return fLib.object({
    id: fLib.string().orNull().optional(),
    type: fLib.string(),
    attributes: attribute_collection_1.attributeCollection().orNull().optional(),
    relationships: relationship_1.relationship().orNull().optional(),
    links: link_collection_1.linkCollection().orNull().optional(),
    meta: meta_1.meta().orNull().optional(),
}); };
//# sourceMappingURL=client-resource.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/document/__document-constraint-impl.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/document/__document-constraint-impl.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * Implements the constraints outlined in https://jsonapi.org/format/1.0/#document-top-level
 *
 *  @see {@link serverDocument}
 *  @see {@link clientDocument}
 *  @see {@link __DocumentConstraintImplMapper}
 *  @see {@link __DocumentConstraintImpl}
 */
function __documentConstraintImpl(args) {
    if (args.data == undefined) {
        if (args.meta == undefined) {
            return fLib.object({
                data: fLib.null().optional(),
                included: fLib.null().optional(),
                errors: fLib.array(args.errorObject),
                meta: fLib.null().optional(),
            });
        }
        else {
            return fLib.or(fLib.object({
                data: fLib.null().optional(),
                included: fLib.null().optional(),
                errors: fLib.array(args.errorObject),
                meta: fLib.null().optional(),
            }), fLib.object({
                data: fLib.null().optional(),
                included: fLib.null().optional(),
                errors: fLib.null().optional(),
                meta: args.meta,
            }));
        }
    }
    else if (args.meta == undefined) {
        return fLib.or(fLib.object({
            data: fLib.null().optional(),
            included: fLib.null().optional(),
            errors: fLib.array(args.errorObject),
            meta: fLib.null().optional(),
        }), fLib.object({
            data: args.data,
            included: fLib.array(args.resource).orNull().optional(),
            errors: fLib.null().optional(),
            meta: fLib.null().optional(),
        }));
    }
    else {
        return fLib.or(fLib.object({
            data: fLib.null().optional(),
            included: fLib.null().optional(),
            errors: fLib.array(args.errorObject),
            meta: fLib.null().optional(),
        }), fLib.object({
            data: args.data,
            included: fLib.array(args.resource).orNull().optional(),
            errors: fLib.null().optional(),
            meta: args.meta,
        }));
    }
}
exports.__documentConstraintImpl = __documentConstraintImpl;
//# sourceMappingURL=__document-constraint-impl.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/document/client-document.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/document/client-document.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __document_constraint_impl_1 = __webpack_require__(/*! ./__document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/document/__document-constraint-impl.js");
var json_api_1 = __webpack_require__(/*! ../json-api */ "./node_modules/type-mapping/dist/json-api-lib/json-api.js");
var link_collection_1 = __webpack_require__(/*! ../link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var error_object_1 = __webpack_require__(/*! ../error-object */ "./node_modules/type-mapping/dist/json-api-lib/error-object.js");
var client_resource_1 = __webpack_require__(/*! ../client-resource */ "./node_modules/type-mapping/dist/json-api-lib/client-resource.js");
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * In this implementation, you have to specify one of the following,
 *
 * + `data`
 * + `meta`
 * + both `data` and `meta`
 *
 * If both `data` and `meta` are specified, all documents without `errors` must also contain both.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-top-level
 *
 * JSON object **MUST** be at the root of every JSON:API request and response containing data.
 * This object defines a documents top level.
 *
 * A document **MUST** contain at least one of the following top-level members:
 *
 * + `data`: the documents primary data
 * + `errors`: an array of error objects
 * + `meta`: a meta object that contains non-standard meta-information.
 *
 * The members `data` and `errors` **MUST NOT** coexist in the same document.
 *
 * A document **MAY** contain any of these top-level members:
 *
 * + `jsonapi`: an object describing the clients implementation
 * + `links`: a links object related to the primary data.
 * + `included`: an array of resource objects that are related to the primary data and/or each other (included resources).
 *
 * If a document does not contain a top-level `data` key, the `included` member **MUST NOT** be present either.
 *
 * The top-level links object **MAY** contain the following members:
 *
 * + `self`: the link that generated the current response document.
 * + `related`: a related resource link when the primary data represents a resource relationship.
 * + pagination links for the primary data.
 *
 * The documents primary data is a representation of the resource or collection of resources targeted by a request.
 *
 * Primary data **MUST** be either:
 *
 * + a single resource object, a single resource identifier object,
 *   or `null`, for requests that target single resources
 * + an array of resource objects, an array of resource identifier objects,
 *   or an empty array (`[]`), for requests that target resource collections
 *
 * A logical collection of resources **MUST** be represented as an array, even if it only contains one item or is empty.
 *
 * @param args - The data, or meta mappers (or both)
 *
 *  @see {@link ClientDocumentMapper}
 *  @see {@link ClientDocument}
 *  @see {@link ExpectedInputClientDocument}
 *  @see {@link MappableInputClientDocument}
 */
function clientDocument(args) {
    var clientDocumentBase = {
        errorObject: error_object_1.errorObject(),
        resource: client_resource_1.clientResource(),
    };
    var impl = __document_constraint_impl_1.__documentConstraintImpl(__assign({}, args, clientDocumentBase));
    var base = fLib.object({
        jsonapi: json_api_1.jsonApi().orNull().optional(),
        links: link_collection_1.linkCollection().orNull().optional(),
    });
    return fLib.deepMerge(impl, base);
}
exports.clientDocument = clientDocument;
//# sourceMappingURL=client-document.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/document/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/document/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./__document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/document/__document-constraint-impl.js"));
__export(__webpack_require__(/*! ./client-document */ "./node_modules/type-mapping/dist/json-api-lib/document/client-document.js"));
__export(__webpack_require__(/*! ./server-document */ "./node_modules/type-mapping/dist/json-api-lib/document/server-document.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/document/server-document.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/document/server-document.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __document_constraint_impl_1 = __webpack_require__(/*! ./__document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/document/__document-constraint-impl.js");
var json_api_1 = __webpack_require__(/*! ../json-api */ "./node_modules/type-mapping/dist/json-api-lib/json-api.js");
var link_collection_1 = __webpack_require__(/*! ../link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var error_object_1 = __webpack_require__(/*! ../error-object */ "./node_modules/type-mapping/dist/json-api-lib/error-object.js");
var server_resource_1 = __webpack_require__(/*! ../server-resource */ "./node_modules/type-mapping/dist/json-api-lib/server-resource.js");
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * In this implementation, you have to specify one of the following,
 *
 * + `data`
 * + `meta`
 * + both `data` and `meta`
 *
 * If both `data` and `meta` are specified, all documents without `errors` must also contain both.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-top-level
 *
 * JSON object **MUST** be at the root of every JSON:API request and response containing data.
 * This object defines a documents top level.
 *
 * A document **MUST** contain at least one of the following top-level members:
 *
 * + `data`: the documents primary data
 * + `errors`: an array of error objects
 * + `meta`: a meta object that contains non-standard meta-information.
 *
 * The members `data` and `errors` **MUST NOT** coexist in the same document.
 *
 * A document **MAY** contain any of these top-level members:
 *
 * + `jsonapi`: an object describing the servers implementation
 * + `links`: a links object related to the primary data.
 * + `included`: an array of resource objects that are related to the primary data and/or each other (included resources).
 *
 * If a document does not contain a top-level `data` key, the `included` member **MUST NOT** be present either.
 *
 * The top-level links object **MAY** contain the following members:
 *
 * + `self`: the link that generated the current response document.
 * + `related`: a related resource link when the primary data represents a resource relationship.
 * + pagination links for the primary data.
 *
 * The documents primary data is a representation of the resource or collection of resources targeted by a request.
 *
 * Primary data **MUST** be either:
 *
 * + a single resource object, a single resource identifier object,
 *   or `null`, for requests that target single resources
 * + an array of resource objects, an array of resource identifier objects,
 *   or an empty array (`[]`), for requests that target resource collections
 *
 * A logical collection of resources **MUST** be represented as an array, even if it only contains one item or is empty.
 *
 * @param args - The data, or meta mappers (or both)
 *
 *  @see {@link ServerDocumentMapper}
 *  @see {@link ServerDocument}
 *  @see {@link ExpectedInputServerDocument}
 *  @see {@link MappableInputServerDocument}
 */
function serverDocument(args) {
    var serverDocumentBase = {
        errorObject: error_object_1.errorObject(),
        resource: server_resource_1.serverResource(),
    };
    var impl = __document_constraint_impl_1.__documentConstraintImpl(__assign({}, args, serverDocumentBase));
    var base = fLib.object({
        jsonapi: json_api_1.jsonApi().orNull().optional(),
        links: link_collection_1.linkCollection().orNull().optional(),
    });
    return fLib.deepMerge(impl, base);
}
exports.serverDocument = serverDocument;
//# sourceMappingURL=server-document.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/error-link-collection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/error-link-collection.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var link_collection_1 = __webpack_require__(/*! ./link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var link_1 = __webpack_require__(/*! ./link */ "./node_modules/type-mapping/dist/json-api-lib/link.js");
/**
 * https://jsonapi.org/format/1.0/#error-objects
 *
 * Error objects provide additional information about problems encountered while performing an operation.
 * Error objects **MUST** be returned as an array keyed by `errors` in the top level of a JSON:API document.
 *
 * An error object **MAY** have the following members:
 *
 * + `links`: a links object containing the following members:
 *   + `about`: a link that leads to further details about this particular occurrence of the problem.
 *
 *  @see {@link errorObject}
 *  @see {@link link}
 *  @see {@link ErrorLinkCollection}
 *  @see {@link ExpectedInputErrorLinkCollection}
 */
exports.errorLinkCollection = function () { return fLib.deepMerge(link_collection_1.linkCollection(), fLib.object({
    about: link_1.link()
})); };
//# sourceMappingURL=error-link-collection.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/error-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/error-object.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var error_link_collection_1 = __webpack_require__(/*! ./error-link-collection */ "./node_modules/type-mapping/dist/json-api-lib/error-link-collection.js");
var error_source_1 = __webpack_require__(/*! ./error-source */ "./node_modules/type-mapping/dist/json-api-lib/error-source.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * https://jsonapi.org/format/1.0/#error-objects
 *
 * Error objects provide additional information about problems encountered while performing an operation.
 * Error objects **MUST** be returned as an array keyed by `errors` in the top level of a JSON:API document.
 *
 * An error object **MAY** have the following members:
 *
 * + `id`: a unique identifier for this particular occurrence of the problem.
 * + `links`: a links object containing the following members:
 *   + `about`: a link that leads to further details about this particular occurrence of the problem.
 * + `status`: the HTTP status code applicable to this problem, expressed as a string value.
 * + `code`: an application-specific error code, expressed as a string value.
 * + `title`: a short, human-readable summary of the problem that **SHOULD NOT**
 *   change from occurrence to occurrence of the problem, except for purposes of localization.
 * + `detail`: a human-readable explanation specific to this occurrence of the problem.
 *   Like `title`, this fields value can be localized.
 * + `source`: an object containing references to the source of the error,
 *   optionally including any of the following members:
 *   + `pointer`: a JSON Pointer [RFC6901](https://tools.ietf.org/html/rfc6901) to the associated entity in the request document
 *     [e.g. "/data" for a primary data object, or "/data/attributes/title" for a specific attribute].
 *   + `parameter`: a string indicating which URI query parameter caused the error.
 * + `meta`: a meta object containing non-standard meta-information about the error.
 *
 *  @see {@link errorLinkCollection}
 *  @see {@link errorSource}
 *  @see {@link meta}
 *  @see {@link ErrorObject}
 *  @see {@link ExpectedInputErrorObject}
 */
exports.errorObject = function () { return fLib.object({
    id: fLib.string().orNull().optional(),
    links: error_link_collection_1.errorLinkCollection().orNull().optional(),
    status: fLib.string().orNull().optional(),
    code: fLib.string().orNull().optional(),
    title: fLib.string().orNull().optional(),
    detail: fLib.string().orNull().optional(),
    source: error_source_1.errorSource().orNull().optional(),
    meta: meta_1.meta().orNull().optional(),
}); };
//# sourceMappingURL=error-object.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/error-source.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/error-source.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * https://jsonapi.org/format/1.0/#error-objects
 *
 * Error objects provide additional information about problems encountered while performing an operation.
 * Error objects **MUST** be returned as an array keyed by `errors` in the top level of a JSON:API document.
 *
 * An error object **MAY** have the following members:
 *
 * + `source`: an object containing references to the source of the error,
 *   optionally including any of the following members:
 *   + `pointer`: a JSON Pointer [RFC6901](https://tools.ietf.org/html/rfc6901) to the associated entity in the request document
 *     [e.g. "/data" for a primary data object, or "/data/attributes/title" for a specific attribute].
 *   + `parameter`: a string indicating which URI query parameter caused the error.
 *
 *  @see {@link errorObject}
 *  @see {@link ErrorSource}
 *  @see {@link ExpectedInputErrorSource}
 */
exports.errorSource = function () { return fLib.object({
    pointer: fLib.string().orNull().optional(),
    parameter: fLib.string().orNull().optional(),
}); };
//# sourceMappingURL=error-source.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./document */ "./node_modules/type-mapping/dist/json-api-lib/document/index.js"));
__export(__webpack_require__(/*! ./non-error-document */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/index.js"));
__export(__webpack_require__(/*! ./attribute-collection */ "./node_modules/type-mapping/dist/json-api-lib/attribute-collection.js"));
__export(__webpack_require__(/*! ./client-resource */ "./node_modules/type-mapping/dist/json-api-lib/client-resource.js"));
__export(__webpack_require__(/*! ./error-link-collection */ "./node_modules/type-mapping/dist/json-api-lib/error-link-collection.js"));
__export(__webpack_require__(/*! ./error-object */ "./node_modules/type-mapping/dist/json-api-lib/error-object.js"));
__export(__webpack_require__(/*! ./error-source */ "./node_modules/type-mapping/dist/json-api-lib/error-source.js"));
__export(__webpack_require__(/*! ./json-api */ "./node_modules/type-mapping/dist/json-api-lib/json-api.js"));
__export(__webpack_require__(/*! ./link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js"));
__export(__webpack_require__(/*! ./link */ "./node_modules/type-mapping/dist/json-api-lib/link.js"));
__export(__webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js"));
__export(__webpack_require__(/*! ./partial-relationship */ "./node_modules/type-mapping/dist/json-api-lib/partial-relationship.js"));
__export(__webpack_require__(/*! ./relationship */ "./node_modules/type-mapping/dist/json-api-lib/relationship.js"));
__export(__webpack_require__(/*! ./resource-identifier */ "./node_modules/type-mapping/dist/json-api-lib/resource-identifier.js"));
__export(__webpack_require__(/*! ./resource-linkage */ "./node_modules/type-mapping/dist/json-api-lib/resource-linkage.js"));
__export(__webpack_require__(/*! ./server-resource */ "./node_modules/type-mapping/dist/json-api-lib/server-resource.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/json-api.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/json-api.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * https://jsonapi.org/format/1.0/#document-jsonapi-object
 *
 * A JSON:API document **MAY** include information about its implementation
 * under a top level `jsonapi` member. If present, the value of the `jsonapi`
 * member **MUST** be an object (a jsonapi object).
 *
 * The jsonapi object **MAY** contain a `version` member whose value
 * is a string indicating the highest JSON API version supported.
 * This object **MAY** also contain a `meta` member,
 * whose value is a meta object that contains non-standard meta-information.
 *
 * ```ts
 * {
 *   "jsonapi": {
 *     "version": "1.0"
 *   }
 * }
 * ```
 *
 * If the `version` member is not present,
 * clients should assume the server implements at least version 1.0 of the specification.
 *
 * > Note: Because JSON:API is committed to making additive changes only,
 * > the version string primarily indicates which new features a server may support.
 *
 *  @see {@link meta}
 *  @see {@link JsonApi}
 *  @see {@link ExpectedInputJsonApi}
 */
exports.jsonApi = function () { return fLib.object({
    version: fLib.literal("1.0").orNull().optional(),
    meta: meta_1.meta().orNull().optional(),
}); };
//# sourceMappingURL=json-api.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/link-collection.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var link_1 = __webpack_require__(/*! ./link */ "./node_modules/type-mapping/dist/json-api-lib/link.js");
/**
 * https://jsonapi.org/format/1.0/#document-links
 *
 * Where specified, a `links` member can be used to represent links.
 * The value of each `links` member **MUST** be an object (a links object).
 *
 * Each member of a links object is a link.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-top-level
 *
 * The top-level links object **MAY** contain the following members:
 *
 * + `self`: the link that generated the current response document.
 * + `related`: a related resource link when the primary data represents a resource relationship.
 * + pagination links for the primary data.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#fetching-pagination
 *
 * A server **MAY** choose to limit the number of resources returned in a
 * response to a subset (page) of the whole set available.
 *
 * A server **MAY** provide links to traverse a paginated data set (pagination links).
 *
 * Pagination links **MUST** appear in the links object that corresponds to a collection.
 * To paginate the primary data, supply pagination links in the top-level `links` object.
 * To paginate an included collection returned in a compound document,
 * supply pagination links in the corresponding links object.
 *
 * The following keys **MUST** be used for pagination links:
 *
 * + `first`: the first page of data
 * + `last`: the last page of data
 * + `prev`: the previous page of data
 * + `next`: the next page of data
 *
 * Keys **MUST** either be omitted or have a `null` value to indicate that a particular link is unavailable.
 *
 * Concepts of order, as expressed in the naming of pagination links,
 * **MUST** remain consistent with JSON:APIs sorting rules.
 *
 * The `page` query parameter is reserved for pagination.
 * Servers and clients **SHOULD** use this key for pagination operations.
 *
 * -----
 *
 *  @see {@link link}
 *  @see {@link LinkCollection}
 *  @see {@link ExpectedInputLinkCollection}
 */
exports.linkCollection = function () { return fLib.stringIndexer(link_1.link().orNull()); };
//# sourceMappingURL=link-collection.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/link.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/link.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var metaLib = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * http://jsonapi.org/format/1.0/#document-links
 *
 * A link MUST be represented as either:
 *
 * + a string containing the links URL.
 * + an object (link object) which can contain the following members:
 *     + `href`: a string containing the links URL.
 *     + `meta`: a meta object containing non-standard meta-information about the link.
 *
 * The following self link is simply a URL:
 *
 * ```ts
 * "links": {
 *     "self": "http://example.com/posts"
 * }
 * ```
 *
 * The following related link includes a URL as well as meta-information about a related resource collection:
 *
 * ```ts
 * "links": {
 *     "related": {
 *         "href": "http://example.com/articles/1/comments",
 *         "meta": {
 *             "count": 10
 *         }
 *     }
 * }
 * ```
 *
 *  @see {@link meta}
 *  @see {@link LinkObject}
 *  @see {@link ExpectedInputLinkObject}
 */
exports.linkObject = function () { return fLib.object({
    /** a string containing the links URL. */
    href: fLib.string(),
    /** a meta object containing non-standard meta-information about the link. */
    meta: metaLib.meta().orNull().optional(),
}); };
/**
 * Some description
 *
 * http://jsonapi.org/format/1.0/#document-links
 *
 * A link MUST be represented as either:
 *
 * + a string containing the links URL.
 * + an object (link object) which can contain the following members:
 *   + `href`: a string containing the links URL.
 *   + `meta`: a meta object containing non-standard meta-information about the link.
 *
 * The following self link is simply a URL:
 *
 * ```ts
 * "links": {
 *     "self": "http://example.com/posts"
 * }
 * ```
 *
 * The following related link includes a URL as well as meta-information about a related resource collection:
 *
 * ```ts
 * "links": {
 *     "related": {
 *         "href": "http://example.com/articles/1/comments",
 *         "meta": {
 *             "count": 10
 *         }
 *     }
 * }
 * ```
 *
 *  @see {@link meta}
 *  @see {@link linkObject}
 *  @see {@link Link}
 *  @see {@link ExpectedInputLink}
 */
exports.link = function () { return fLib.or(fLib.string(), exports.linkObject()); };
//# sourceMappingURL=link.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/meta.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/meta.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
;
/**
 * Must be a plain-old-JavaScript-object in this implementation
 *
 * https://jsonapi.org/format/1.0/#document-meta
 *
 * Where specified, a `meta` member can be used to include non-standard meta-information.
 * The value of each `meta` member **MUST** be an object (a meta object).
 *
 * Any members **MAY** be specified within `meta` objects.
 *
 * For example:
 *
 * ```ts
 * {
 *     "meta": {
 *         "copyright": "Copyright 2015 Example Corp.",
 *         "authors": [
 *             "Yehuda Katz",
 *             "Steve Klabnik",
 *             "Dan Gebhardt",
 *             "Tyler Kellen"
 *         ]
 *     },
 *     "data": {
 *         // ...
 *     }
 * }
 * ```
 *
 *  @see {@link pojo}
 *
 */
exports.meta = fLib.pojo;
//# sourceMappingURL=meta.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/__non-error-document-constraint-impl.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/non-error-document/__non-error-document-constraint-impl.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * Implements the constraints outlined in https://jsonapi.org/format/1.0/#document-top-level
 *
 *  @see {@link serverDocument}
 *  @see {@link clientDocument}
 *  @see {@link __DocumentConstraintImplMapper}
 *  @see {@link __DocumentConstraintImpl}
 */
function __nonErrorDocumentConstraintImpl(args) {
    if (args.data == undefined) {
        if (args.meta == undefined) {
            throw new Error("No data and meta mapper specified");
        }
        else {
            return fLib.object({
                data: fLib.null().optional(),
                included: fLib.null().optional(),
                errors: fLib.null().optional(),
                meta: args.meta,
            });
        }
    }
    else if (args.meta == undefined) {
        return fLib.object({
            data: args.data,
            included: fLib.array(args.resource).orNull().optional(),
            errors: fLib.null().optional(),
            meta: fLib.null().optional(),
        });
    }
    else {
        return fLib.object({
            data: args.data,
            included: fLib.array(args.resource).orNull().optional(),
            errors: fLib.null().optional(),
            meta: args.meta,
        });
    }
}
exports.__nonErrorDocumentConstraintImpl = __nonErrorDocumentConstraintImpl;
//# sourceMappingURL=__non-error-document-constraint-impl.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/non-error-document/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./__non-error-document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/__non-error-document-constraint-impl.js"));
__export(__webpack_require__(/*! ./non-error-client-document */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-client-document.js"));
__export(__webpack_require__(/*! ./non-error-server-document */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-server-document.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-client-document.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-client-document.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __non_error_document_constraint_impl_1 = __webpack_require__(/*! ./__non-error-document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/__non-error-document-constraint-impl.js");
var json_api_1 = __webpack_require__(/*! ../json-api */ "./node_modules/type-mapping/dist/json-api-lib/json-api.js");
var link_collection_1 = __webpack_require__(/*! ../link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var client_resource_1 = __webpack_require__(/*! ../client-resource */ "./node_modules/type-mapping/dist/json-api-lib/client-resource.js");
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * In this implementation, you have to specify one of the following,
 *
 * + `data`
 * + `meta`
 * + both `data` and `meta`
 *
 * If both `data` and `meta` are specified, all documents without `errors` must also contain both.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-top-level
 *
 * JSON object **MUST** be at the root of every JSON:API request and response containing data.
 * This object defines a documents top level.
 *
 * A document **MUST** contain at least one of the following top-level members:
 *
 * + `data`: the documents primary data
 * + `errors`: an array of error objects
 * + `meta`: a meta object that contains non-standard meta-information.
 *
 * The members `data` and `errors` **MUST NOT** coexist in the same document.
 *
 * A document **MAY** contain any of these top-level members:
 *
 * + `jsonapi`: an object describing the clients implementation
 * + `links`: a links object related to the primary data.
 * + `included`: an array of resource objects that are related to the primary data and/or each other (included resources).
 *
 * If a document does not contain a top-level `data` key, the `included` member **MUST NOT** be present either.
 *
 * The top-level links object **MAY** contain the following members:
 *
 * + `self`: the link that generated the current response document.
 * + `related`: a related resource link when the primary data represents a resource relationship.
 * + pagination links for the primary data.
 *
 * The documents primary data is a representation of the resource or collection of resources targeted by a request.
 *
 * Primary data **MUST** be either:
 *
 * + a single resource object, a single resource identifier object,
 *   or `null`, for requests that target single resources
 * + an array of resource objects, an array of resource identifier objects,
 *   or an empty array (`[]`), for requests that target resource collections
 *
 * A logical collection of resources **MUST** be represented as an array, even if it only contains one item or is empty.
 *
 * @param args - The data, or meta mappers (or both)
 *
 *  @see {@link ClientDocumentMapper}
 *  @see {@link ClientDocument}
 *  @see {@link ExpectedInputClientDocument}
 *  @see {@link MappableInputClientDocument}
 */
function nonErrorClientDocument(args) {
    var clientDocumentBase = {
        resource: client_resource_1.clientResource(),
    };
    var impl = __non_error_document_constraint_impl_1.__nonErrorDocumentConstraintImpl(__assign({}, args, clientDocumentBase));
    var base = fLib.object({
        jsonapi: json_api_1.jsonApi().orNull().optional(),
        links: link_collection_1.linkCollection().orNull().optional(),
    });
    return fLib.deepMerge(impl, base);
}
exports.nonErrorClientDocument = nonErrorClientDocument;
//# sourceMappingURL=non-error-client-document.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-server-document.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/non-error-document/non-error-server-document.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __non_error_document_constraint_impl_1 = __webpack_require__(/*! ./__non-error-document-constraint-impl */ "./node_modules/type-mapping/dist/json-api-lib/non-error-document/__non-error-document-constraint-impl.js");
var json_api_1 = __webpack_require__(/*! ../json-api */ "./node_modules/type-mapping/dist/json-api-lib/json-api.js");
var link_collection_1 = __webpack_require__(/*! ../link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var server_resource_1 = __webpack_require__(/*! ../server-resource */ "./node_modules/type-mapping/dist/json-api-lib/server-resource.js");
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
 * In this implementation, you have to specify one of the following,
 *
 * + `data`
 * + `meta`
 * + both `data` and `meta`
 *
 * If both `data` and `meta` are specified, all documents without `errors` must also contain both.
 *
 * -----
 *
 * https://jsonapi.org/format/1.0/#document-top-level
 *
 * JSON object **MUST** be at the root of every JSON:API request and response containing data.
 * This object defines a documents top level.
 *
 * A document **MUST** contain at least one of the following top-level members:
 *
 * + `data`: the documents primary data
 * + `errors`: an array of error objects
 * + `meta`: a meta object that contains non-standard meta-information.
 *
 * The members `data` and `errors` **MUST NOT** coexist in the same document.
 *
 * A document **MAY** contain any of these top-level members:
 *
 * + `jsonapi`: an object describing the servers implementation
 * + `links`: a links object related to the primary data.
 * + `included`: an array of resource objects that are related to the primary data and/or each other (included resources).
 *
 * If a document does not contain a top-level `data` key, the `included` member **MUST NOT** be present either.
 *
 * The top-level links object **MAY** contain the following members:
 *
 * + `self`: the link that generated the current response document.
 * + `related`: a related resource link when the primary data represents a resource relationship.
 * + pagination links for the primary data.
 *
 * The documents primary data is a representation of the resource or collection of resources targeted by a request.
 *
 * Primary data **MUST** be either:
 *
 * + a single resource object, a single resource identifier object,
 *   or `null`, for requests that target single resources
 * + an array of resource objects, an array of resource identifier objects,
 *   or an empty array (`[]`), for requests that target resource collections
 *
 * A logical collection of resources **MUST** be represented as an array, even if it only contains one item or is empty.
 *
 * @param args - The data, or meta mappers (or both)
 *
 *  @see {@link ServerDocumentMapper}
 *  @see {@link ServerDocument}
 *  @see {@link ExpectedInputServerDocument}
 *  @see {@link MappableInputServerDocument}
 */
function nonErrorServerDocument(args) {
    var serverDocumentBase = {
        resource: server_resource_1.serverResource(),
    };
    var impl = __non_error_document_constraint_impl_1.__nonErrorDocumentConstraintImpl(__assign({}, args, serverDocumentBase));
    var base = fLib.object({
        jsonapi: json_api_1.jsonApi().orNull().optional(),
        links: link_collection_1.linkCollection().orNull().optional(),
    });
    return fLib.deepMerge(impl, base);
}
exports.nonErrorServerDocument = nonErrorServerDocument;
//# sourceMappingURL=non-error-server-document.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/partial-relationship.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/partial-relationship.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var link_collection_1 = __webpack_require__(/*! ./link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var resource_linkage_1 = __webpack_require__(/*! ./resource-linkage */ "./node_modules/type-mapping/dist/json-api-lib/resource-linkage.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * This is just a "partial" relationship because it does not
 * enforce the "at-least-one constraint"
 *
 * -----
 *
 *  @see {@link relationship}
 *  @see {@link linkCollection}
 *  @see {@link resourceLinkage}
 *  @see {@link meta}
 *  @see {@link PartialRelationship}
 *  @see {@link ExpectedInputPartialRelationship}
 */
exports.partialRelationship = function () { return fLib.object({
    links: link_collection_1.linkCollection().orNull().optional(),
    data: resource_linkage_1.resourceLinkage().orNull().optional(),
    meta: meta_1.meta().orNull().optional(),
}); };
//# sourceMappingURL=partial-relationship.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/relationship.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/relationship.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var partial_relationship_1 = __webpack_require__(/*! ./partial-relationship */ "./node_modules/type-mapping/dist/json-api-lib/partial-relationship.js");
var link_collection_1 = __webpack_require__(/*! ./link-collection */ "./node_modules/type-mapping/dist/json-api-lib/link-collection.js");
var resource_linkage_1 = __webpack_require__(/*! ./resource-linkage */ "./node_modules/type-mapping/dist/json-api-lib/resource-linkage.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * https://jsonapi.org/format/1.0/#document-resource-object-relationships
 *
 * The value of the `relationships` key **MUST** be an object (a relationships object).
 * Members of the relationships object (relationships) represent references from the resource object
 * in which its defined to other resource objects.
 *
 * Relationships may be to-one or to-many.
 *
 * A relationship object **MUST** contain at least one of the following:
 *
 * + `links`: a links object containing at least one of the following:
 *   + `self`: a link for the relationship itself (a relationship link).
 *     This link allows the client to directly manipulate the relationship.
 *     For example, removing an `author` through an `article`s relationship URL would disconnect
 *     the person from the `article` without deleting the `people` resource itself.
 *     When fetched successfully, this link returns the linkage for the related resources as its primary data.
 *     (See Fetching Relationships.)
 *   + `related`: a related resource link
 * + `data`: resource linkage
 * + `meta`: a meta object that contains non-standard meta-information about the relationship.
 *
 * A relationship object that represents a to-many relationship **MAY** also contain pagination links
 * under the `links` member, as described below.
 * Any pagination links in a relationship object **MUST** paginate the relationship data, not the related resources.
 *
 *  @see {@link partialRelationship}
 *  @see {@link Relationship}
 *  @see {@link ExpectedInputRelationship}
 */
exports.relationship = function () { return fLib.deepMerge(partial_relationship_1.partialRelationship(), fLib.or(fLib.object({ links: link_collection_1.linkCollection() }), fLib.object({ data: resource_linkage_1.resourceLinkage() }), fLib.object({ meta: meta_1.meta() }))); };
//# sourceMappingURL=relationship.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/resource-identifier.js":
/*!****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/resource-identifier.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var meta_1 = __webpack_require__(/*! ./meta */ "./node_modules/type-mapping/dist/json-api-lib/meta.js");
/**
 * https://jsonapi.org/format/1.0/#document-resource-identifier-objects
 *
 * A resource identifier object is an object that identifies an individual resource.
 *
 * A resource identifier object **MUST** contain `type` and `id` members.
 *
 * A resource identifier object **MAY** also include a `meta` member,
 * whose value is a meta object that contains non-standard meta-information.
 *
 *  @see {@link meta}
 *  @see {@link ResourceIdentifier}
 *  @see {@link ExpectedInputResourceIdentifier}
 */
exports.resourceIdentifier = function () { return fLib.object({
    type: fLib.string(),
    id: fLib.string(),
    meta: meta_1.meta().orNull().optional(),
}); };
//# sourceMappingURL=resource-identifier.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/resource-linkage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/resource-linkage.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var resource_identifier_1 = __webpack_require__(/*! ./resource-identifier */ "./node_modules/type-mapping/dist/json-api-lib/resource-identifier.js");
/**
 * https://jsonapi.org/format/1.0/#document-resource-object-linkage
 *
 * Resource linkage in a compound document allows a client to link together
 * all of the included resource objects without having to `GET` any URLs via links.
 *
 * Resource linkage **MUST** be represented as one of the following:
 *
 * + `null` for empty to-one relationships.
 * + an empty array (`[]`) for empty to-many relationships.
 * + a single resource identifier object for non-empty to-one relationships.
 * + an array of resource identifier objects for non-empty to-many relationships.
 *
 * > Note: The spec does not impart meaning to order of resource identifier objects in linkage arrays of
 * > to-many relationships, although implementations may do that.
 * > Arrays of resource identifier objects may represent ordered or unordered relationships,
 * > and both types can be mixed in one response object.
 *
 *  @see {@link resourceIdentifier}
 */
exports.resourceLinkage = function () { return fLib.or(resource_identifier_1.resourceIdentifier(), fLib.array(resource_identifier_1.resourceIdentifier())); };
//# sourceMappingURL=resource-linkage.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/json-api-lib/server-resource.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/json-api-lib/server-resource.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var client_resource_1 = __webpack_require__(/*! ./client-resource */ "./node_modules/type-mapping/dist/json-api-lib/client-resource.js");
/**
 *  @see {@link clientResource}
 *  @see {@link ServerResource}
 *  @see {@link ExpectedInputServerResource}
 */
exports.serverResource = function () { return fLib.deepMerge(client_resource_1.clientResource(), fLib.object({
    id: fLib.string(),
})); };
//# sourceMappingURL=server-resource.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/ctor.js":
/*!*******************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/ctor.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    The `ExpectedInput<>` and `MappableInput<>` parts
    of a `Mapper<>` are arbitrary metadata.

    However, they make returning `Mapper<>` functions
    with those parts difficult.

    This helper function makes it easier.

    Does not return a wrapper.

    -----

    TODO Handle `name`?
*/
function mapper(f) {
    return f;
}
exports.mapper = mapper;
//# sourceMappingURL=ctor.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-expected-input.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/debug/_debug-is-expected-input.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function _debugIsExpectedInput(_f, _x) {
}
exports._debugIsExpectedInput = _debugIsExpectedInput;
/*
import {unknown, optional} from "../../functional-lib";
import {withExpectedInput} from "../operation";
_debugIsExpectedInput(
    withExpectedInput(optional(unknown()))<number>(),
    {x : 2} as unknown
);
//*/ 
//# sourceMappingURL=_debug-is-expected-input.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-handled-input.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/debug/_debug-is-handled-input.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function _debugIsHandledInput(_f, _x) {
}
exports._debugIsHandledInput = _debugIsHandledInput;
//# sourceMappingURL=_debug-is-handled-input.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-mappable-input.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/debug/_debug-is-mappable-input.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function _debugIsMappableInput(_f, _x) {
}
exports._debugIsMappableInput = _debugIsMappableInput;
//# sourceMappingURL=_debug-is-mappable-input.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-output.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/debug/_debug-is-output.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function _debugIsOutput(_f, _x) {
}
exports._debugIsOutput = _debugIsOutput;
//# sourceMappingURL=_debug-is-output.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/debug/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/debug/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./_debug-is-expected-input */ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-expected-input.js"));
__export(__webpack_require__(/*! ./_debug-is-handled-input */ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-handled-input.js"));
__export(__webpack_require__(/*! ./_debug-is-mappable-input */ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-mappable-input.js"));
__export(__webpack_require__(/*! ./_debug-is-output */ "./node_modules/type-mapping/dist/mapper/debug/_debug-is-output.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/index.js":
/*!********************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./debug */ "./node_modules/type-mapping/dist/mapper/debug/index.js"));
__export(__webpack_require__(/*! ./operation */ "./node_modules/type-mapping/dist/mapper/operation/index.js"));
__export(__webpack_require__(/*! ./predicate */ "./node_modules/type-mapping/dist/mapper/predicate/index.js"));
__export(__webpack_require__(/*! ./query */ "./node_modules/type-mapping/dist/mapper/query/index.js"));
__export(__webpack_require__(/*! ./ctor */ "./node_modules/type-mapping/dist/mapper/ctor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/copy-run-time-modifier.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/copy-run-time-modifier.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var query_1 = __webpack_require__(/*! ../query */ "./node_modules/type-mapping/dist/mapper/query/index.js");
/**
    Modifies `dst` by setting `name`, `__optional`, `__runTimeRequired`.
    You should not need to call this, in general.
*/
function copyRunTimeModifier(src, dst) {
    type_util_1.setFunctionName(dst, query_1.getNameOrEmptyString(src));
    dst.__optional = query_1.getOptionalFlagOrFalse(src);
    dst.__runTimeRequired = query_1.getRunTimeRequiredFlagOrFalse(src);
    return dst;
}
exports.copyRunTimeModifier = copyRunTimeModifier;
/**
    Modifies `dst` by setting `name`.
    You should not need to call this, in general.
*/
function copyName(src, dst) {
    type_util_1.setFunctionName(dst, query_1.getNameOrEmptyString(src));
    return dst;
}
exports.copyName = copyName;
/**
    Modifies `dst` by setting `__optional`.
    You should not need to call this, in general.
*/
function copyOptional(src, dst) {
    dst.__optional = query_1.getOptionalFlagOrFalse(src);
    return dst;
}
exports.copyOptional = copyOptional;
/**
    Modifies `dst` by setting `__runTimeRequired`.
    You should not need to call this, in general.
*/
function copyRunTimeRequired(src, dst) {
    dst.__runTimeRequired = query_1.getRunTimeRequiredFlagOrFalse(src);
    return dst;
}
exports.copyRunTimeRequired = copyRunTimeRequired;
//# sourceMappingURL=copy-run-time-modifier.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/expect-mappable-input.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/expect-mappable-input.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Makes the `ExpectedInput<>` of a `Mapper<>` the same as its
    `MappableInput<>`.

    Returns the same `Mapper<>`, DOES NOT create a new function.

    TODO Decide if it should return a wrapper.
*/
function expectMappableInput(f) {
    return f;
}
exports.expectMappableInput = expectMappableInput;
;
//# sourceMappingURL=expect-mappable-input.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./copy-run-time-modifier */ "./node_modules/type-mapping/dist/mapper/operation/copy-run-time-modifier.js"));
__export(__webpack_require__(/*! ./expect-mappable-input */ "./node_modules/type-mapping/dist/mapper/operation/expect-mappable-input.js"));
__export(__webpack_require__(/*! ./map */ "./node_modules/type-mapping/dist/mapper/operation/map.js"));
__export(__webpack_require__(/*! ./try-map */ "./node_modules/type-mapping/dist/mapper/operation/try-map.js"));
__export(__webpack_require__(/*! ./with-expected-input */ "./node_modules/type-mapping/dist/mapper/operation/with-expected-input.js"));
__export(__webpack_require__(/*! ./with-mapper */ "./node_modules/type-mapping/dist/mapper/operation/with-mapper.js"));
__export(__webpack_require__(/*! ./with-name */ "./node_modules/type-mapping/dist/mapper/operation/with-name.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/map.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/map.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Alias of `mapExpected<>()`
*/
function map(f, name, mixed) {
    return f(name, mixed);
}
exports.map = map;
;
function mapExpected(f, name, mixed) {
    return f(name, mixed);
}
exports.mapExpected = mapExpected;
;
function mapMappable(f, name, mixed) {
    return f(name, mixed);
}
exports.mapMappable = mapMappable;
;
/**
    You can just call `f(name, mixed)` directly.
    This is only provided for completeness.
*/
function mapHandled(f, name, mixed) {
    return f(name, mixed);
}
exports.mapHandled = mapHandled;
;
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/try-map.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/try-map.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function tryMapImpl(f, name, mixed) {
    try {
        return {
            success: true,
            value: f(name, mixed),
        };
    }
    catch (err) {
        if (error_util_1.isMappingError(err)) {
            return {
                success: false,
                err: err,
                mappingError: err,
            };
        }
        else {
            return {
                success: false,
                err: err,
                mappingError: error_util_1.makeMappingError({
                    message: err.message,
                    inputName: name,
                    actualValue: mixed,
                    expected: undefined,
                    stack: err.stack,
                }),
            };
        }
    }
}
/**
    Alias of `tryMapExpected<>()`
*/
function tryMap(f, name, mixed) {
    return tryMapImpl(f, name, mixed);
}
exports.tryMap = tryMap;
;
function tryMapExpected(f, name, mixed) {
    return tryMapImpl(f, name, mixed);
}
exports.tryMapExpected = tryMapExpected;
;
function tryMapMappable(f, name, mixed) {
    return tryMapImpl(f, name, mixed);
}
exports.tryMapMappable = tryMapMappable;
;
function tryMapHandled(f, name, mixed) {
    return tryMapImpl(f, name, mixed);
}
exports.tryMapHandled = tryMapHandled;
;
//# sourceMappingURL=try-map.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/with-expected-input.js":
/*!********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/with-expected-input.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Lets you modify the `ExpectedInput<>` of a `Mapper<>`.

    Returns the same `Mapper<>`, DOES NOT create a new function.

    TODO Decide if it should return a wrapper.

    -----

    ### Use Case

    Give a `Mapper<>` with the following properties,

    + `MappableInput<> = string|number`
    + `ExpectedInput<> = string`

    If we wish to change the `ExpectedInput<>` to `number`,
    we do the following,

    ```ts
    const otherMapper = withExpectedInput(mapper)<number>();
    ```
*/
function withExpectedInput(f) {
    return function () {
        return f;
    };
}
exports.withExpectedInput = withExpectedInput;
;
//# sourceMappingURL=with-expected-input.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/with-mapper.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/with-mapper.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var query_1 = __webpack_require__(/*! ../query */ "./node_modules/type-mapping/dist/mapper/query/index.js");
var with_name_1 = __webpack_require__(/*! ./with-name */ "./node_modules/type-mapping/dist/mapper/operation/with-name.js");
function withMapper(f, newMapper) {
    return with_name_1.withName(newMapper, query_1.getNameOrEmptyString(f));
}
exports.withMapper = withMapper;
//# sourceMappingURL=with-mapper.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/operation/with-name.js":
/*!**********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/operation/with-name.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var copy_run_time_modifier_1 = __webpack_require__(/*! ./copy-run-time-modifier */ "./node_modules/type-mapping/dist/mapper/operation/copy-run-time-modifier.js");
/**
    Lets you modify the `Name<>` of a `Mapper<>`.

    Returns a new `Mapper<>`.
*/
function withName(f, name) {
    var result = function (name, mixed) {
        return f(name, mixed);
    };
    return copy_run_time_modifier_1.copyRunTimeRequired(f, copy_run_time_modifier_1.copyOptional(f, type_util_1.setFunctionName(result, name)));
}
exports.withName = withName;
;
//# sourceMappingURL=with-name.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/predicate/array.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/predicate/array.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isEmptyArrayMappable(f) {
    try {
        f("", []);
        return true;
    }
    catch (_err) {
        return false;
    }
}
exports.isEmptyArrayMappable = isEmptyArrayMappable;
function canOutputEmptyArray(f) {
    try {
        /*
            Using idempotent property.

            (f(blah) === []) implies (f([]) === [])
        */
        var output = f("", []);
        return ((output instanceof Array) &&
            (output.length == 0));
    }
    catch (_err) {
        return false;
    }
}
exports.canOutputEmptyArray = canOutputEmptyArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/predicate/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/predicate/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./array */ "./node_modules/type-mapping/dist/mapper/predicate/array.js"));
__export(__webpack_require__(/*! ./is-optional */ "./node_modules/type-mapping/dist/mapper/predicate/is-optional.js"));
__export(__webpack_require__(/*! ./missing-value */ "./node_modules/type-mapping/dist/mapper/predicate/missing-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/predicate/is-optional.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/predicate/is-optional.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var query_1 = __webpack_require__(/*! ../query */ "./node_modules/type-mapping/dist/mapper/query/index.js");
var missing_value_1 = __webpack_require__(/*! ./missing-value */ "./node_modules/type-mapping/dist/mapper/predicate/missing-value.js");
//TODO Consider renaming to `isMappableInputOptional()`
function isOptional(f) {
    if (typeof f != "function") {
        return false;
    }
    if (!query_1.getOptionalFlagOrFalse(f)) {
        return false;
    }
    if (!missing_value_1.isUndefinedMappable(f)) {
        return false;
    }
    return true;
}
exports.isOptional = isOptional;
//# sourceMappingURL=is-optional.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/predicate/missing-value.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/predicate/missing-value.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isUndefinedMappable(f) {
    try {
        f("", undefined);
        return true;
    }
    catch (_err) {
        return false;
    }
}
exports.isUndefinedMappable = isUndefinedMappable;
function isNullMappable(f) {
    try {
        f("", null);
        return true;
    }
    catch (_err) {
        return false;
    }
}
exports.isNullMappable = isNullMappable;
function isMaybeMappable(f) {
    try {
        f("", null);
        f("", undefined);
        return true;
    }
    catch (_err) {
        return false;
    }
}
exports.isMaybeMappable = isMaybeMappable;
function canOutputUndefined(f) {
    try {
        /*
            Using idempotent property.

            (f(blah) === undefined) implies (f(undefined) === undefined)
        */
        return (f("", undefined) === undefined);
    }
    catch (_err) {
        return false;
    }
}
exports.canOutputUndefined = canOutputUndefined;
function canOutputNull(f) {
    try {
        /*
            Using idempotent property.

            (f(blah) === null) implies (f(null) === null)
        */
        return (f("", null) === null);
    }
    catch (_err) {
        return false;
    }
}
exports.canOutputNull = canOutputNull;
function canOutputMaybe(f) {
    try {
        /*
            Using idempotent property.

            (f(blah) === null) implies (f(null) === null)
            (f(blah) === undefined) implies (f(null) === undefined)
        */
        return ((f("", null) === null) &&
            (f("", undefined) === undefined));
    }
    catch (_err) {
        return false;
    }
}
exports.canOutputMaybe = canOutputMaybe;
//# sourceMappingURL=missing-value.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/query/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/query/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./name-of */ "./node_modules/type-mapping/dist/mapper/query/name-of.js"));
__export(__webpack_require__(/*! ./optional-flag-of */ "./node_modules/type-mapping/dist/mapper/query/optional-flag-of.js"));
__export(__webpack_require__(/*! ./run-time-required-flag-of */ "./node_modules/type-mapping/dist/mapper/query/run-time-required-flag-of.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/query/name-of.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/query/name-of.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getNameOrEmptyString(f) {
    if (typeof f != "function") {
        return "";
    }
    var result = f.__name;
    return ((typeof result == "string") ?
        result :
        "");
}
exports.getNameOrEmptyString = getNameOrEmptyString;
//# sourceMappingURL=name-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/query/optional-flag-of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/query/optional-flag-of.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getOptionalFlagOrFalse(f) {
    var result = f.__optional;
    return (result === true);
}
exports.getOptionalFlagOrFalse = getOptionalFlagOrFalse;
//# sourceMappingURL=optional-flag-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mapper/query/run-time-required-flag-of.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mapper/query/run-time-required-flag-of.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getRunTimeRequiredFlagOrFalse(f) {
    var result = f.__runTimeRequired;
    return (result === true);
}
exports.getRunTimeRequiredFlagOrFalse = getRunTimeRequiredFlagOrFalse;
//# sourceMappingURL=run-time-required-flag-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/binary/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/binary/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
function bufferDelegate(dataTypeStr, maxLength) {
    var result = function (a, b) {
        if (a == undefined) {
            return fluent_lib_1.bufferLength({
                max: maxLength,
            });
        }
        else if (b == undefined) {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", a);
            return fluent_lib_1.bufferLength({
                max: a,
            });
        }
        else {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 0,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMin", a);
            b = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", b);
            if (a > b) {
                throw new Error(dataTypeStr + " minLength must be <= maxLength");
            }
            return fluent_lib_1.bufferLength({
                min: a,
                max: b,
            });
        }
    };
    result.maxLength = maxLength;
    return result;
}
exports.binary = bufferDelegate("BINARY", 255);
exports.varBinary = bufferDelegate("VARBINARY", 65535);
exports.tinyBlob = bufferDelegate("TINYBLOB", 255);
exports.blob = bufferDelegate("BLOB", 65535);
exports.mediumBlob = bufferDelegate("MEDIUMBLOB", 16777215);
exports.longBlob = bufferDelegate("LONGBLOB", 4294967295);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/boolean/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/boolean/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var TypeUtil = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
/**
    Converts some values to `boolean`.

    The values `0|1|"0"|"1"` were chosen because
    these values are most likely to show up from
    a MySQL driver to represent a `boolean`

    The values `"false"|"true"` were chosen because
    these values will show up in query strings.
*/
function boolean() {
    var BigInt = TypeUtil.getBigIntFactoryFunctionOrError();
    return fLib.or(fLib.boolean(), fLib.literal("0", "1", 0, 1, "false", "true", BigInt(0), BigInt(1)).pipe(function (name, v) {
        switch (v) {
            case "0": return false;
            case "1": return true;
            case 0: return false;
            case 1: return true;
            case "false": return false;
            case "true": return true;
            default: {
                var str = String(v);
                if (str == "0") {
                    return false;
                }
                else if (str == "1") {
                    return true;
                }
                //Shouldn't happen
                throw new Error("Expected " + name + " to be one of '0'|'1'|0|1|'false'|'true'|'0n'|'1n'");
            }
        }
    })).withExpectedInput();
}
exports.boolean = boolean;
/**
    Converts some values to `true`.

    The values `1|"1"` were chosen because
    these values are most likely to show up from
    a MySQL driver to represent a `boolean`

    The values `"true"` was chosen because
    it will show up in query strings.
*/
function toTrue() {
    var BigInt = TypeUtil.getBigIntFactoryFunctionOrError();
    return fLib.or(fLib.literal(true), fLib.literal("1", 1, "true", BigInt(1)).pipe(function (name, v) {
        switch (v) {
            case "1": return true;
            case 1: return true;
            case "true": return true;
            default: {
                var str = String(v);
                if (str == "1") {
                    return true;
                }
                //Shouldn't happen
                throw new Error("Expected " + name + " to be one of '1'|1|'true'");
            }
        }
    })).withExpectedInput();
}
exports.true = toTrue;
/**
    Converts some values to `false`.

    The values `0|"0"` were chosen because
    these values are most likely to show up from
    a MySQL driver to represent a `boolean`

    The values `"false"` was chosen because
    it will show up in query strings.
*/
function toFalse() {
    var BigInt = TypeUtil.getBigIntFactoryFunctionOrError();
    return fLib.or(fLib.literal(false), fLib.literal("0", 0, "false", BigInt(0)).pipe(function (name, v) {
        switch (v) {
            case "0": return false;
            case 0: return false;
            case "false": return false;
            default: {
                var str = String(v);
                if (str == "0") {
                    return false;
                }
                //Shouldn't happen
                throw new Error("Expected " + name + " to be one of '0'|0|'false'");
            }
        }
    })).withExpectedInput();
}
exports.false = toFalse;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/char/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/char/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
function stringDelegate(dataTypeStr, maxLength) {
    var result = function (a, b) {
        if (a == undefined) {
            return fluent_lib_1.stringLength({
                max: maxLength,
            });
        }
        else if (b == undefined) {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", a);
            return fluent_lib_1.stringLength({
                max: a,
            });
        }
        else {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 0,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMin", a);
            b = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", b);
            if (a > b) {
                throw new Error(dataTypeStr + " minLength must be <= maxLength");
            }
            return fluent_lib_1.stringLength({
                min: a,
                max: b,
            });
        }
    };
    result.maxLength = maxLength;
    return result;
}
exports.char = stringDelegate("CHAR", 255);
exports.varChar = stringDelegate("VARCHAR", 65535);
exports.tinyText = stringDelegate("TINYTEXT", 255);
exports.text = stringDelegate("TEXT", 65535);
exports.mediumText = stringDelegate("MEDIUMTEXT", 16777215);
exports.longText = stringDelegate("LONGTEXT", 4294967295);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/date-time/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/date-time/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var DateTimeUtil = __webpack_require__(/*! ./util */ "./node_modules/type-mapping/dist/mysql-lib/date-time/util.js");
exports.DateTimeUtil = DateTimeUtil;
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
function dateTime(fractionalSecondPrecision) {
    if (fractionalSecondPrecision === void 0) { fractionalSecondPrecision = 0; }
    return fluent_lib_1.or(fluent_lib_1.string().pipe(function (name, str) {
        try {
            return DateTimeUtil.fromSqlUtc(str, fractionalSecondPrecision);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be DATETIME(" + fractionalSecondPrecision + "); " + err.message,
                inputName: name,
                actualValue: str,
                expected: "DATETIME(" + fractionalSecondPrecision + ")",
            });
        }
    }), 
    //To work with JSON serialization
    fluent_lib_1.or(
    //Hopefully, it is a JSON date string
    fluent_lib_1.string(), 
    /*
        We turn the Date object into its JSON representation
        because the Date object may have a millisecond part
        when we do not allow it.

        For example,
        new Date().toJSON() //2019-01-01T00:00:00.123Z

        The above is not assignable to DATETIME(0)
        But is assignable to DATETIME(3)

        -----

        new Date().toJSON() //2019-01-01T00:00:00.120Z

        The above is not assignable to DATETIME(0)
        But is assignable to DATETIME(2) or DATETIME(3)
    */
    fluent_lib_1.instanceOfDate().pipe(function (_name, d) { return d.toJSON(); })).pipe(fluent_lib_1.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/, function (name) {
        return {
            message: name + " must be in the format YYYY-MM-DDTHH:mm:ss.sssZ",
            expected: "YYYY-MM-DDTHH:mm:ss.sssZ",
        };
    }), function (name, str) {
        try {
            str = str.replace("T", " ").replace("Z", "");
            return DateTimeUtil.fromSqlUtc(str, fractionalSecondPrecision);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be DATETIME(" + fractionalSecondPrecision + "); " + err.message,
                inputName: name,
                actualValue: str,
                expected: "DATETIME(" + fractionalSecondPrecision + ")",
            });
        }
    })).withExpectedInput();
}
exports.dateTime = dateTime;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/date-time/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/date-time/util.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var string_util_1 = __webpack_require__(/*! ../../string-util */ "./node_modules/type-mapping/dist/string-util/index.js");
//Uses UTC
//Truncates if fractionSecondPrecision is too small.
function toSqlUtc(d, fractionalSecondPrecision /*|4|5|6*/) {
    if (!isFinite(d.getTime())) {
        throw new Error("Invalid date passed");
    }
    var year = string_util_1.zeroPad(d.getUTCFullYear(), 4);
    //getUTCMonth() returns [0, 11]
    //We want [1, 12]
    var month = string_util_1.zeroPad(d.getUTCMonth() + 1, 2);
    var day = string_util_1.zeroPad(d.getUTCDate(), 2);
    var hour = string_util_1.zeroPad(d.getUTCHours(), 2);
    var minute = string_util_1.zeroPad(d.getUTCMinutes(), 2);
    var second = string_util_1.zeroPad(d.getUTCSeconds(), 2);
    if (fractionalSecondPrecision == 0) {
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return [
            "(TIMESTAMP ",
            year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second,
            ")"
        ].join("");
    }
    else {
        var ms = string_util_1.zeroPad(d.getUTCMilliseconds(), fractionalSecondPrecision).substr(0, fractionalSecondPrecision);
        /*
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html

            The TIMESTAMP syntax produces a DATETIME value in MySQL
            because DATETIME has a range that more closely corresponds
            to the standard SQL TIMESTAMP type,
            which has a year range from 0001 to 9999.

            (The MySQL TIMESTAMP year range is 1970 to 2038.)
        */
        return [
            "(TIMESTAMP ",
            year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second + "." + ms,
            ")"
        ].join("");
    }
}
exports.toSqlUtc = toSqlUtc;
//Month is zero-based
//Day is one-based
function isValidDate(year, month, day) {
    /**
     * `year` might be [0, 99].
     * This causes the year to be [1900, 1999]. Not what we want.
     *
     * So, we use `.setFullYear()` below, to set the proper year.
     */
    var d = new Date(year, month, day);
    d.setFullYear(year);
    if (d.getFullYear() === year && d.getMonth() === month && d.getDate() === day) {
        return true;
    }
    return false;
}
var mySqlDateTimeRegex = /^(\d{4})-(\d{2})-(\d{2})( (\d{2}):(\d{2}):(\d{2})(\.(\d{1,6}))?)?$/;
//Assumes UTC
function fromSqlUtc(sql, fractionalSecondPrecision /*|4|5|6*/) {
    var match = mySqlDateTimeRegex.exec(sql);
    if (match == undefined) {
        throw new Error("Invalid MySQL DATETIME string");
    }
    var year = parseInt(match[1]);
    //1-based
    var month = parseInt(match[2]);
    //1-based
    var dayOfMonth = parseInt(match[3]);
    if (!isValidDate(year, month - 1, dayOfMonth)) {
        throw new Error("Invalid MySQL DATETIME string; month or day does not exist for given year");
    }
    var hour = (match[5] == undefined) ?
        0 :
        parseInt(match[5]);
    if (hour > 23) {
        throw new Error("Hour must be [0, 23]");
    }
    var minute = (match[6] == undefined) ?
        0 :
        parseInt(match[6]);
    if (minute > 59) {
        throw new Error("Minute must be [0, 59]");
    }
    var second = (match[7] == undefined) ?
        0 :
        parseInt(match[7]);
    if (second > 59) {
        throw new Error("Second must be [0, 59]");
    }
    var microsecondPart = (match[9] == undefined) ?
        0 :
        parseInt(string_util_1.trailingZeroPad(match[9], 6));
    if (microsecondPart > 999999) {
        throw new Error("Microsecond must be [0, 999999]");
    }
    var millisecond = Math.floor(microsecondPart / 1000);
    var microsecond = microsecondPart % 1000;
    /*
        With DATETIME(0),
        We have per-second precision.
        microsecondPart can only be zero.

        With DATETIME(1),
        We have 100ms precision, 100,000microsecond precision.
        6-1 = 5
        10^5 = 100,000
        By using %(modulo) 100,000, we ensure microsecondPart
        is a multiple of the precision we support.

        With DATETIME(2),
        We have 10ms precision, 10,000microsecond precision.
        6-2 = 4
        10^4 = 10,000
        By using %(modulo) 10,000, we ensure microsecondPart
        is a multiple of the precision we support.

        ...
        With DATETIME(6),
        We have 1microsecond precision.
        6-6 = 0
        10^0 = 1
        Any integer modulo one is zero.
    */
    if (microsecondPart % Math.pow(10, 6 - fractionalSecondPrecision) != 0) {
        throw new Error("Expected DATETIME(" + fractionalSecondPrecision + "), received DATETIME(" + match[9].length + ")");
    }
    /*if (
        match[9] != undefined &&
        match[9].length > fractionalSecondPrecision
    ) {
        throw new Error(`Expected DATETIME(${fractionalSecondPrecision}), received DATETIME(${match[9].length})`);
    }*/
    //TODO-FEATURE Microsecond support
    //JS Date just doesn't support microseconds
    //BEGIN TEMPORARY NON-SUPPORT FOR MICROSECOND
    if (microsecond != 0) {
        throw new Error("Microsecond support for DATETIME is not supported yet");
    }
    //END TEMPORARY NON-SUPPORT FOR MICROSECOND
    var utcMillisecondTimestamp = Date.UTC(year, 
    //Date.UTC() expects [0, 11]
    month - 1, dayOfMonth, hour, minute, second, millisecond);
    var result = new Date(utcMillisecondTimestamp);
    /**
     * `year` might be [0, 99].
     * This causes the year to be [1900, 1999]. Not what we want.
     *
     * So, we use `.setUTCFullYear()` below, to set the proper year.
     */
    result.setUTCFullYear(year);
    return result;
}
exports.fromSqlUtc = fromSqlUtc;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/decimal/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/decimal/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var functional_lib_1 = __webpack_require__(/*! ../../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var FixedPointUtil = __webpack_require__(/*! ../../fixed-point-util */ "./node_modules/type-mapping/dist/fixed-point-util/index.js");
var BigIntUtil = __webpack_require__(/*! ../../bigint-util */ "./node_modules/type-mapping/dist/bigint-util/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var error_code_1 = __webpack_require__(/*! ../../error-code */ "./node_modules/type-mapping/dist/error-code.js");
/**
 *
 * For now, returns a string.
 * Converting to a number risks losing precision.
 *
 * @deprecated
 */
function decimalDeprecated() {
    return fluent_lib_1.pipe(functional_lib_1.or(functional_lib_1.string(), functional_lib_1.finiteNumber(), functional_lib_1.bigInt()), function (_name, mixed) {
        return mixed.toString();
    }, functional_lib_1.floatingPointFormatString());
}
exports.decimalDeprecated = decimalDeprecated;
function assertValidDecimalPrecisionAndScale(
/**
 * + Min precision is `1`, even though MySQL allows min precision `0`.
 *   Precision `0` is not very meaningful, anyway, right?
 */
precision, 
/**
 * + The min scale is `0`.
 * + `scale` must be <= `precision`.
 */
scale) {
    var BigInt = type_util_1.getBigIntFactoryFunctionOrError();
    var precisionMapper = fluent_lib_1.pipe(functional_lib_1.toBigInt(), functional_lib_1.bigIntGtEq(BigInt(1)));
    precision = precisionMapper("precision", precision);
    var scaleMapper = fluent_lib_1.pipe(functional_lib_1.toBigInt(), functional_lib_1.bigIntGtEq(BigInt(0)), functional_lib_1.bigIntLtEq(precision));
    scale = scaleMapper("scale", scale);
    return {
        precision: precision,
        scale: scale,
    };
}
function decimal(precision, scale) {
    if (precision == undefined) {
        return decimalDeprecated();
    }
    var _a = assertValidDecimalPrecisionAndScale(precision, scale), maxPrecision = _a.precision, maxScale = _a.scale;
    var expected = "DECIMAL(" + maxPrecision + ", " + maxScale + ")";
    return fluent_lib_1.pipe(functional_lib_1.or(functional_lib_1.string(), functional_lib_1.finiteNumber(), functional_lib_1.bigInt()), function (_name, mixed) {
        return mixed.toString();
    }, function (name, str) {
        var parsed = FixedPointUtil.tryParse(str);
        if (parsed == undefined) {
            throw error_util_1.makeMappingError({
                message: name + " must be " + expected,
                inputName: name,
                actualValue: str,
                expected: expected,
            });
        }
        var curScale = (parsed.getFixedPointFractionalPartString() == "0" ?
            0 :
            parsed.getFixedPointFractionalPartString().length);
        var curPrecision = (curScale +
            (parsed.getFixedPointIntegerPartString() == "0" ?
                0 :
                parsed.getFixedPointIntegerPartString().length));
        if (BigIntUtil.greaterThan(curPrecision, maxPrecision)) {
            throw error_util_1.makeMappingError({
                message: name + " must have precision less than, or equal to " + maxPrecision,
                inputName: name,
                actualValue: parsed.getFixedPointString(),
                expected: expected,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_DECIMAL_PRECISION_LESS_THAN_OR_EQUAL_TO,
                    maxPrecision: maxPrecision,
                    maxScale: maxScale,
                    curPrecision: curPrecision,
                    curScale: curScale,
                },
            });
        }
        if (BigIntUtil.greaterThan(curScale, maxScale)) {
            throw error_util_1.makeMappingError({
                message: name + " must have scale less than, or equal to " + maxScale,
                inputName: name,
                actualValue: parsed.getFixedPointString(),
                expected: expected,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_DECIMAL_SCALE_LESS_THAN_OR_EQUAL_TO,
                    maxPrecision: maxPrecision,
                    maxScale: maxScale,
                    curPrecision: curPrecision,
                    curScale: curScale,
                },
            });
        }
        return parsed.getFixedPointString();
    });
}
exports.decimal = decimal;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/double/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/double/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
    TS `number` type is actually a `double` type
*/
function double() {
    return fluent_lib_1.toFiniteNumber();
}
exports.double = double;
/**
    Alias for DOUBLE for now.
    JS doesn't have `float` type.

    This means that it is possible
    to send a value to MySQL and
    lose precision.
*/
function float() {
    return double();
}
exports.float = float;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-enum.js":
/*!******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-enum.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
    TODO Handle case-insensitive enum collations

    -----

    https://dev.mysql.com/doc/refman/5.5/en/enum.html

    When retrieved, values stored into an ENUM column are displayed using the lettercase
    that was used in the column definition.

    Note that ENUM columns can be assigned a character set and collation.

    For binary or case-sensitive collations,
    lettercase is taken into account when assigning values to the column.
*/
function unsafeCaseSensitiveEnum() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
    }
    if (elements.length > 65535) {
        throw new Error("ENUM type can only have up to 65,535 elements");
    }
    return fluent_lib_1.unsafeLiteral.apply(void 0, elements);
}
exports.unsafeCaseSensitiveEnum = unsafeCaseSensitiveEnum;
/**
    TODO Handle case-insensitive enum collations

    -----

    https://dev.mysql.com/doc/refman/5.5/en/enum.html

    When retrieved, values stored into an ENUM column are displayed using the lettercase
    that was used in the column definition.

    Note that ENUM columns can be assigned a character set and collation.

    For binary or case-sensitive collations,
    lettercase is taken into account when assigning values to the column.
*/
function caseSensitiveEnum(element0) {
    var elements = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        elements[_i - 1] = arguments[_i];
    }
    return unsafeCaseSensitiveEnum.apply(void 0, [element0].concat(elements));
}
exports.caseSensitiveEnum = caseSensitiveEnum;
//# sourceMappingURL=case-sensitive-enum.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-set.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-set.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var error_util_1 = __webpack_require__(/*! ../../error-util */ "./node_modules/type-mapping/dist/error-util/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
/**
    TODO Handle case-insensitive set collations

    -----

    https://dev.mysql.com/doc/refman/5.5/en/set.html

    When retrieved, values stored in a SET column are displayed using the lettercase
    that was used in the column definition.

    Note that SET columns can be assigned a character set and collation.

    For binary or case-sensitive collations,
    lettercase is taken into account when assigning values to the column.
*/
function caseSenstiveSet() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
    }
    if (elements.length > 64) {
        throw new Error("SET type can only have up to 64 elements");
    }
    fluent_lib_1.array(fluent_lib_1.notMatch(/\,/, function (name) { return name + " must not have comma"; }))("elements", elements);
    var expected = "SET(" + elements.map(function (e) { return type_util_1.toLiteralOrTypeStr(e); }).join(",") + ")";
    return fluent_lib_1.string().pipe(function (name, raw) {
        var arr = raw.split(",");
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var e = arr_1[_i];
            if (elements.indexOf(e) < 0) {
                throw error_util_1.makeMappingError({
                    message: name + " has unknown set element; " + e,
                    inputName: name,
                    actualValue: e,
                    expected: expected,
                });
            }
        }
        return raw;
    });
}
exports.caseSenstiveSet = caseSenstiveSet;
//# sourceMappingURL=case-sensitive-set.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/enum/enum-value.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/enum/enum-value.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_mapper_1 = __webpack_require__(/*! ../../fluent-mapper */ "./node_modules/type-mapping/dist/fluent-mapper.js");
var fLib = __webpack_require__(/*! ../../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
function enumValue(e) {
    var result = fLib.or(fLib.enumValue(e), fLib.pipe(fLib.stringToFiniteNumber(), fLib.enumValue(e)));
    return fluent_mapper_1.fluentMapper(result);
}
exports.enumValue = enumValue;
//# sourceMappingURL=enum-value.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/enum/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/enum/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./case-sensitive-enum */ "./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-enum.js"));
__export(__webpack_require__(/*! ./case-sensitive-set */ "./node_modules/type-mapping/dist/mysql-lib/enum/case-sensitive-set.js"));
__export(__webpack_require__(/*! ./enum-value */ "./node_modules/type-mapping/dist/mysql-lib/enum/enum-value.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./binary */ "./node_modules/type-mapping/dist/mysql-lib/binary/index.js"));
__export(__webpack_require__(/*! ./boolean */ "./node_modules/type-mapping/dist/mysql-lib/boolean/index.js"));
__export(__webpack_require__(/*! ./char */ "./node_modules/type-mapping/dist/mysql-lib/char/index.js"));
__export(__webpack_require__(/*! ./date-time */ "./node_modules/type-mapping/dist/mysql-lib/date-time/index.js"));
__export(__webpack_require__(/*! ./decimal */ "./node_modules/type-mapping/dist/mysql-lib/decimal/index.js"));
__export(__webpack_require__(/*! ./double */ "./node_modules/type-mapping/dist/mysql-lib/double/index.js"));
__export(__webpack_require__(/*! ./enum */ "./node_modules/type-mapping/dist/mysql-lib/enum/index.js"));
__export(__webpack_require__(/*! ./int */ "./node_modules/type-mapping/dist/mysql-lib/int/index.js"));
__export(__webpack_require__(/*! ./json */ "./node_modules/type-mapping/dist/mysql-lib/json/index.js"));
__export(__webpack_require__(/*! ./uint-8-array-binary */ "./node_modules/type-mapping/dist/mysql-lib/uint-8-array-binary/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/int/bigint.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/int/bigint.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
/**
    Does not restrict the min and max value
*/
function unsafeBigInt() {
    return fLib.toBigInt();
}
exports.unsafeBigInt = unsafeBigInt;
/**
    Only allows,
    [-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]
*/
function bigIntSigned() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return unsafeBigInt().pipe(fLib.bigIntRange({
        gtEq: bigIntFactory("-9223372036854775808"),
        ltEq: bigIntFactory("9223372036854775807"),
    }));
}
exports.bigIntSigned = bigIntSigned;
/**
    Only allows,
    [0, 18,446,744,073,709,551,615]
*/
function bigIntUnsigned() {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return unsafeBigInt().pipe(fLib.bigIntRange({
        gtEq: bigIntFactory("0"),
        ltEq: bigIntFactory("18446744073709551615"),
    }));
}
exports.bigIntUnsigned = bigIntUnsigned;
//# sourceMappingURL=bigint.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/int/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/int/index.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bigint */ "./node_modules/type-mapping/dist/mysql-lib/int/bigint.js"));
__export(__webpack_require__(/*! ./int */ "./node_modules/type-mapping/dist/mysql-lib/int/int.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/int/int.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/int/int.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fLib = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var functional_lib_1 = __webpack_require__(/*! ../../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
var type_util_1 = __webpack_require__(/*! ../../type-util */ "./node_modules/type-mapping/dist/type-util/index.js");
/**
    Uses `integerFormatString()` and `BigInt()` internally.
*/
function unsafeInt() {
    return fLib.toBigInt();
}
exports.unsafeInt = unsafeInt;
function intDelegate(min, max) {
    var bigIntFactory = type_util_1.getBigIntFactoryFunctionOrError();
    return unsafeInt().pipe(functional_lib_1.bigIntRange({
        gtEq: bigIntFactory(min),
        ltEq: bigIntFactory(max),
    }));
}
/**
    [-128, 127]
*/
function tinyIntSigned() {
    return intDelegate(-128, 127);
}
exports.tinyIntSigned = tinyIntSigned;
/**
    [-32,768, 32,767]
*/
function smallIntSigned() {
    return intDelegate(-32768, 32767);
}
exports.smallIntSigned = smallIntSigned;
/**
    [-8,388,608, 8,388,607]
*/
function mediumIntSigned() {
    return intDelegate(-8388608, 8388607);
}
exports.mediumIntSigned = mediumIntSigned;
/**
    [-2,147,483,648, 2,147,483,647]
*/
function intSigned() {
    return intDelegate(-2147483648, 2147483647);
}
exports.intSigned = intSigned;
/**
    [0, 255]
*/
function tinyIntUnsigned() {
    return intDelegate(0, 255);
}
exports.tinyIntUnsigned = tinyIntUnsigned;
/**
    [0, 65535]
*/
function smallIntUnsigned() {
    return intDelegate(0, 65535);
}
exports.smallIntUnsigned = smallIntUnsigned;
/**
    [0, 16777215]
*/
function mediumIntUnsigned() {
    return intDelegate(0, 16777215);
}
exports.mediumIntUnsigned = mediumIntUnsigned;
/**
    [0, 4294967295]
*/
function intUnsigned() {
    return intDelegate(0, 4294967295);
}
exports.intUnsigned = intUnsigned;
//# sourceMappingURL=int.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/json/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/json/index.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
var functional_lib_1 = __webpack_require__(/*! ../../functional-lib */ "./node_modules/type-mapping/dist/functional-lib/index.js");
function jsonDelegate(dataTypeStr, maxLength, defaultDesiredLengthMax) {
    if (maxLength < defaultDesiredLengthMax) {
        throw new Error("maxLength must be >= defaultDesiredLengthMax");
    }
    var result = function (a, b) {
        if (a == undefined) {
            return fluent_lib_1.stringLength({
                max: defaultDesiredLengthMax,
            }).pipe(functional_lib_1.jsonObjectString());
        }
        else if (b == undefined) {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", a);
            return fluent_lib_1.stringLength({
                max: a,
            }).pipe(functional_lib_1.jsonObjectString());
        }
        else {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 0,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMin", a);
            b = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", b);
            if (a > b) {
                throw new Error(dataTypeStr + " minLength must be <= maxLength");
            }
            return fluent_lib_1.stringLength({
                min: a,
                max: b,
            }).pipe(functional_lib_1.jsonObjectString());
        }
    };
    result.maxLength = maxLength;
    return result;
}
/**
 * The space required to store a `JSON` document is roughly
 * the same as for `LONGBLOB` or `LONGTEXT`.
 *
 * In addition, MySQL imposes a limit on the size of any `JSON`
 * document stored in a `JSON` column such that it cannot be any
 * larger than the value of `max_allowed_packet`.
 *
 * The default for `max_allowed_packet` is `4194304`, 4MB.
 *
 * The maximum is `1073741824`, 1GB.
 *
 * The value should be a multiple of `1024`;
 * nonmultiples are rounded down to the nearest multiple.
 *
 * -----
 *
 * I set the default to 1MB arbitrarily.
*/
exports.json = jsonDelegate("JSON", 4294967295, 1048576);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/mysql-lib/uint-8-array-binary/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/mysql-lib/uint-8-array-binary/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = __webpack_require__(/*! ../../fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js");
function uint8ArrayDelegate(dataTypeStr, maxLength) {
    var result = function (a, b) {
        if (a == undefined) {
            return fluent_lib_1.uint8ArrayLength({
                max: maxLength,
            });
        }
        else if (b == undefined) {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", a);
            return fluent_lib_1.uint8ArrayLength({
                max: a,
            });
        }
        else {
            a = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 0,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMin", a);
            b = fluent_lib_1.pipe(fluent_lib_1.integer(), fluent_lib_1.range({
                gtEq: 1,
                ltEq: maxLength,
            }))(dataTypeStr + ".desiredLengthMax", b);
            if (a > b) {
                throw new Error(dataTypeStr + " minLength must be <= maxLength");
            }
            return fluent_lib_1.uint8ArrayLength({
                min: a,
                max: b,
            });
        }
    };
    result.maxLength = maxLength;
    return result;
}
exports.uint8ArrayBinary = uint8ArrayDelegate("BINARY", 255);
exports.uint8ArrayVarBinary = uint8ArrayDelegate("VARBINARY", 65535);
exports.uint8ArrayTinyBlob = uint8ArrayDelegate("TINYBLOB", 255);
exports.uint8ArrayBlob = uint8ArrayDelegate("BLOB", 65535);
exports.uint8ArrayMediumBlob = uint8ArrayDelegate("MEDIUMBLOB", 16777215);
exports.uint8ArrayLongBlob = uint8ArrayDelegate("LONGBLOB", 4294967295);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/string-util/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/string-util/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./string-ends-with */ "./node_modules/type-mapping/dist/string-util/string-ends-with.js"));
__export(__webpack_require__(/*! ./string-repeat */ "./node_modules/type-mapping/dist/string-util/string-repeat.js"));
__export(__webpack_require__(/*! ./to-property-access */ "./node_modules/type-mapping/dist/string-util/to-property-access.js"));
__export(__webpack_require__(/*! ./zero-pad */ "./node_modules/type-mapping/dist/string-util/zero-pad.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/string-util/string-ends-with.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/string-util/string-ends-with.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function stringEndsWith(str, suffix) {
    if (str.length < suffix.length) {
        return false;
    }
    if (str.length == suffix.length) {
        return (str == suffix);
    }
    for (var i = 0; i < suffix.length; ++i) {
        var suffixChar = suffix[suffix.length - i - 1];
        var strChar = str[str.length - i - 1];
        if (suffixChar != strChar) {
            return false;
        }
    }
    return true;
}
exports.stringEndsWith = stringEndsWith;
//# sourceMappingURL=string-ends-with.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/string-util/string-repeat.js":
/*!*********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/string-util/string-repeat.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function stringRepeat(str, count) {
    var result = "";
    for (var i = 0; i < count; ++i) {
        result += str;
    }
    return result;
}
exports.stringRepeat = stringRepeat;
//# sourceMappingURL=string-repeat.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/string-util/to-property-access.js":
/*!**************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/string-util/to-property-access.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function toPropertyAccess(name) {
    if (typeof name == "number") {
        return "[" + name + "]";
    }
    if (/\s|\.|\-/.test(name)) {
        return "[" + JSON.stringify(name) + "]";
    }
    if (/^\d+$/.test(name)) {
        return "[" + name + "]";
    }
    if (/^\d+/.test(name)) {
        return "[" + JSON.stringify(name) + "]";
    }
    return "." + name;
}
exports.toPropertyAccess = toPropertyAccess;
//# sourceMappingURL=to-property-access.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/string-util/zero-pad.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/string-util/zero-pad.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var string_repeat_1 = __webpack_require__(/*! ./string-repeat */ "./node_modules/type-mapping/dist/string-util/string-repeat.js");
/*
    zeroPad(1, 4)     === "0001"
    zeroPad(34, 4)    === "0034"
    zeroPad(678, 4)   === "0678"
    zeroPad(1337, 4)  === "1337"
    zeroPad(92678, 4) === "92678"
*/
function zeroPad(num, length) {
    var str = num.toString();
    if (str.length < length) {
        return string_repeat_1.stringRepeat("0", length - str.length) + str;
    }
    else {
        return str;
    }
}
exports.zeroPad = zeroPad;
function trailingZeroPad(num, length) {
    var str = num.toString();
    if (str.length < length) {
        return str + string_repeat_1.stringRepeat("0", length - str.length);
    }
    else {
        return str;
    }
}
exports.trailingZeroPad = trailingZeroPad;
//# sourceMappingURL=zero-pad.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/allows-instance-of.js":
/*!************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/allows-instance-of.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function allowsInstanceOf(ctor) {
    try {
        ({} instanceof ctor);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.allowsInstanceOf = allowsInstanceOf;
//# sourceMappingURL=allows-instance-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/buffer-ctor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/buffer-ctor.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
function tryFindBufferCtor() {
    try {
        return Buffer;
    }
    catch (_err) {
        return undefined;
    }
}
var cachedBufferCtor = "uninitialized";
function tryGetBufferCtor() {
    if (cachedBufferCtor == "uninitialized") {
        cachedBufferCtor = tryFindBufferCtor();
    }
    return cachedBufferCtor;
}
exports.tryGetBufferCtor = tryGetBufferCtor;
function isInstanceOfBuffer(mixed) {
    var ctor = tryFindBufferCtor();
    if (ctor == undefined) {
        return false;
    }
    return (mixed instanceof ctor);
}
exports.isInstanceOfBuffer = isInstanceOfBuffer;
//# sourceMappingURL=buffer-ctor.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/deep-merge.js":
/*!****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/deep-merge.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var to_type_str_1 = __webpack_require__(/*! ./to-type-str */ "./node_modules/type-mapping/dist/type-util/to-type-str.js");
var strict_equal_1 = __webpack_require__(/*! ./strict-equal */ "./node_modules/type-mapping/dist/type-util/strict-equal.js");
var is_primitive_1 = __webpack_require__(/*! ./is-primitive */ "./node_modules/type-mapping/dist/type-util/is-primitive.js");
function deepMergeImpl(a, b) {
    if (strict_equal_1.strictEqual(a, b)) {
        return a;
    }
    if (is_primitive_1.isPrimitive(a) || is_primitive_1.isPrimitive(b)) {
        throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal");
    }
    //We should have object types now.
    if ((typeof a == "function") || (typeof b == "function")) {
        throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal");
    }
    if ((a instanceof Date) || (b instanceof Date)) {
        if (!(a instanceof Date)) {
            throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " with Date");
        }
        if (!(b instanceof Date)) {
            throw new Error("Cannot merge Date with " + to_type_str_1.toTypeStr(b));
        }
        if (a.getTime() === b.getTime()) {
            return a;
        }
        else {
            throw new Error("Cannot merge dates; they must have the same value");
        }
    }
    if ((a instanceof Array) || (b instanceof Array)) {
        if (!(a instanceof Array)) {
            throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " with array");
        }
        if (!(b instanceof Array)) {
            throw new Error("Cannot merge array with " + to_type_str_1.toTypeStr(b));
        }
        if (a.length != b.length) {
            throw new Error("Cannot merge arrays of different lengths");
        }
        var newArray = [];
        for (var i = 0; i < a.length; ++i) {
            newArray.push(deepMergeImpl(a[i], b[i]));
        }
        return newArray;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    var mergedKeys = {};
    var result = {};
    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var key = aKeys_1[_i];
        //We can skip a.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `b.hasOwnProperty()` directly
        //because if `b = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(b, key)) {
            result[key] = deepMergeImpl(a[key], b[key]);
        }
        else {
            result[key] = a[key];
        }
    }
    for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var key = bKeys_1[_a];
        //We can skip b.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `a.hasOwnProperty()` directly
        //because if `a = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(a, key)) {
            result[key] = deepMergeImpl(a[key], b[key]);
        }
        else {
            result[key] = b[key];
        }
    }
    return result;
}
function deepMerge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length == 0) {
        throw new Error("Cannot deep merge zero arguments");
    }
    var result = args[0];
    for (var i = 1; i < args.length; ++i) {
        result = deepMergeImpl(result, args[i]);
    }
    return result;
}
exports.deepMerge = deepMerge;
//# sourceMappingURL=deep-merge.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./allows-instance-of */ "./node_modules/type-mapping/dist/type-util/allows-instance-of.js"));
__export(__webpack_require__(/*! ./buffer-ctor */ "./node_modules/type-mapping/dist/type-util/buffer-ctor.js"));
__export(__webpack_require__(/*! ./deep-merge */ "./node_modules/type-mapping/dist/type-util/deep-merge.js"));
__export(__webpack_require__(/*! ./is-instance-of */ "./node_modules/type-mapping/dist/type-util/is-instance-of.js"));
__export(__webpack_require__(/*! ./is-bigint */ "./node_modules/type-mapping/dist/type-util/is-bigint.js"));
__export(__webpack_require__(/*! ./is-pojo */ "./node_modules/type-mapping/dist/type-util/is-pojo.js"));
__export(__webpack_require__(/*! ./is-primitive */ "./node_modules/type-mapping/dist/type-util/is-primitive.js"));
__export(__webpack_require__(/*! ./omit */ "./node_modules/type-mapping/dist/type-util/omit.js"));
__export(__webpack_require__(/*! ./pick */ "./node_modules/type-mapping/dist/type-util/pick.js"));
__export(__webpack_require__(/*! ./set-function-name */ "./node_modules/type-mapping/dist/type-util/set-function-name.js"));
__export(__webpack_require__(/*! ./strict-equal */ "./node_modules/type-mapping/dist/type-util/strict-equal.js"));
__export(__webpack_require__(/*! ./to-type-str */ "./node_modules/type-mapping/dist/type-util/to-type-str.js"));
__export(__webpack_require__(/*! ./try-deep-merge */ "./node_modules/type-mapping/dist/type-util/try-deep-merge.js"));
__export(__webpack_require__(/*! ./try-get-bigint-factory-function */ "./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/is-bigint.js":
/*!***************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/is-bigint.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var try_get_bigint_factory_function_1 = __webpack_require__(/*! ./try-get-bigint-factory-function */ "./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js");
var buffer_ctor_1 = __webpack_require__(/*! ./buffer-ctor */ "./node_modules/type-mapping/dist/type-util/buffer-ctor.js");
function isBigIntNative(x) {
    return (typeof x == "bigint");
}
function isBigIntPolyfill(x) {
    if (typeof x == "bigint") {
        return true;
    }
    if (!(x instanceof Object)) {
        //It is a primitive type and not a bigint
        return false;
    }
    if ((x instanceof Number) ||
        (x instanceof String) ||
        buffer_ctor_1.isInstanceOfBuffer(x)) {
        //Sanity check.
        //These objects are most likely to pass the
        //numeric `.toString()` check below.
        return false;
    }
    if ((x instanceof Array) ||
        (x instanceof Date) ||
        (x instanceof Function)) {
        //Sanity check.
        //These objects are commonly used.
        return false;
    }
    var bigIntFactory = try_get_bigint_factory_function_1.tryGetBigIntFactoryFunction();
    if (bigIntFactory == undefined) {
        //No BigInt polyfill detected
        return false;
    }
    if (!bigIntFactory.possiblyInstanceOfBigInt(x)) {
        //Definitely not BigInt polyfilled object
        return false;
    }
    /*
        We now have,

        + An object
        + A BigInt factory
        + The object was possibly created by the BigInt factory
    */
    var xStr = String(x);
    if (!/^\-?\d+$/.test(xStr)) {
        //This object's string representation is not valid.
        return false;
    }
    //High confidence that this is a polyfilled BigInt object
    return true;
}
function isBigInt(x) {
    if (try_get_bigint_factory_function_1.isBigIntNativelySupported()) {
        return isBigIntNative(x);
    }
    else {
        return isBigIntPolyfill(x);
    }
}
exports.isBigInt = isBigInt;
//# sourceMappingURL=is-bigint.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/is-instance-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/is-instance-of.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var try_get_bigint_factory_function_1 = __webpack_require__(/*! ./try-get-bigint-factory-function */ "./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js");
var is_bigint_1 = __webpack_require__(/*! ./is-bigint */ "./node_modules/type-mapping/dist/type-util/is-bigint.js");
/**
    Like using "regular" `instanceof` but
    bigint polyfill objects will never be an `instanceof Object`,
    or any other class.
*/
function isInstanceOf(mixed, ctor) {
    return ((mixed instanceof ctor) &&
        (try_get_bigint_factory_function_1.isBigIntNativelySupported() ||
            !is_bigint_1.isBigInt(mixed)));
}
exports.isInstanceOf = isInstanceOf;
//# sourceMappingURL=is-instance-of.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/is-pojo.js":
/*!*************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/is-pojo.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var is_instance_of_1 = __webpack_require__(/*! ./is-instance-of */ "./node_modules/type-mapping/dist/type-util/is-instance-of.js");
/**
    Abbreviation for "Plain old JavasScript object".

    Meaning, an Object that isn't,

    + Date
    + Array
    + Function
    + An instance of some other class

    -----

    Will never consider a BigInt polyfill object a Pojo
*/
function isPojo(mixed) {
    if (!is_instance_of_1.isInstanceOf(mixed, Object)) {
        return false;
    }
    if (Object.getPrototypeOf(mixed) !== Object.prototype) {
        return false;
    }
    return true;
}
exports.isPojo = isPojo;
//# sourceMappingURL=is-pojo.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/is-primitive.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/is-primitive.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var is_bigint_1 = __webpack_require__(/*! ./is-bigint */ "./node_modules/type-mapping/dist/type-util/is-bigint.js");
function isPrimitive(x) {
    if (x == undefined) {
        return true;
    }
    var t = typeof x;
    if (t != "object" && t != "function") {
        return true;
    }
    return is_bigint_1.isBigInt(x);
}
exports.isPrimitive = isPrimitive;
function isLiteral(x) {
    if (x == undefined) {
        return true;
    }
    var t = typeof x;
    if (t != "object" && t != "function" && t != "symbol") {
        return true;
    }
    return is_bigint_1.isBigInt(x);
}
exports.isLiteral = isLiteral;
//# sourceMappingURL=is-primitive.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/omit.js":
/*!**********************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/omit.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Performs `Omit<>` on an `object` during run-time
 *
 * @param obj - The object to omit key-value pairs from
 * @param keys - The keys to omit
 */
function omit(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var result = __assign({}, obj);
    for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
        var k = keys_1[_a];
        delete result[k];
    }
    return result;
}
exports.omit = omit;
//# sourceMappingURL=omit.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/pick.js":
/*!**********************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/pick.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Performs `Pick<>` on an `object` during run-time
 *
 * @param obj - The object to pick key-value pairs from
 * @param keys - The keys to pick
 */
function pick(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var result = {};
    for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
        var k = keys_1[_a];
        if (!Object.prototype.hasOwnProperty.call(obj, k)) {
            continue;
        }
        result[k] = obj[k];
    }
    return result;
}
exports.pick = pick;
//# sourceMappingURL=pick.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/set-function-name.js":
/*!***********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/set-function-name.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
    Modifies `f` directly.
*/
function setFunctionName(f, name) {
    if (typeof name != "string") {
        name = "";
    }
    f.__name = name;
    return f;
}
exports.setFunctionName = setFunctionName;
//# sourceMappingURL=set-function-name.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/strict-equal.js":
/*!******************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/strict-equal.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var is_bigint_1 = __webpack_require__(/*! ./is-bigint */ "./node_modules/type-mapping/dist/type-util/is-bigint.js");
var try_get_bigint_factory_function_1 = __webpack_require__(/*! ./try-get-bigint-factory-function */ "./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js");
function strictEqualNative(a, b) {
    return (a === b);
}
function strictEqualPolyfill(a, b) {
    if (a === b) {
        return true;
    }
    if (is_bigint_1.isBigInt(a) && is_bigint_1.isBigInt(b)) {
        return a.toString() === b.toString();
    }
    return false;
}
/**
    This library supports `bigint`.
    However, not all browsers support `bigint`.

    Some developers may polyfill it with a `BigInt` class.

    ```ts
    //With polyfill, this may be false
    BigInt(2) === BigInt(2)
    ```

    ```ts
    //We want a special case for `BigInt`
    //This must be true
    strictEqual(BigInt(2), BigInt(2))
    ```
*/
function strictEqual(a, b) {
    if (try_get_bigint_factory_function_1.isBigIntNativelySupported()) {
        return strictEqualNative(a, b);
    }
    else {
        return strictEqualPolyfill(a, b);
    }
}
exports.strictEqual = strictEqual;
//# sourceMappingURL=strict-equal.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/to-type-str.js":
/*!*****************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/to-type-str.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var is_bigint_1 = __webpack_require__(/*! ./is-bigint */ "./node_modules/type-mapping/dist/type-util/is-bigint.js");
var is_primitive_1 = __webpack_require__(/*! ./is-primitive */ "./node_modules/type-mapping/dist/type-util/is-primitive.js");
/**
    Intended to work better than `String(mixed)`.
*/
function toLiteralStr(mixed) {
    //We do not mind === here.
    if (mixed === null) {
        return "null";
        //We do not mind === here.
    }
    else if (mixed === undefined) {
        return "undefined";
    }
    else if (is_bigint_1.isBigInt(typeof mixed)) {
        return mixed.toString() + "n";
    }
    else if (typeof mixed == "string") {
        return JSON.stringify(mixed);
    }
    else {
        return String(mixed);
    }
}
exports.toLiteralStr = toLiteralStr;
function toLiteralUnionStr(arr) {
    return arr
        .map(toLiteralStr)
        .join("|");
}
exports.toLiteralUnionStr = toLiteralUnionStr;
function getCtorName(ctor) {
    if (!(ctor instanceof Object)) {
        return "[Not Ctor]";
    }
    var name = ctor.name;
    if (typeof name == "string") {
        return name;
    }
    return "[Unknown Name]";
}
exports.getCtorName = getCtorName;
/**
    Intended to work better than `typeof mixed`.
*/
function toTypeStr(mixed) {
    //We do not mind === here.
    if (mixed === null) {
        return "null";
    }
    //We do not mind === here.
    if (mixed === undefined) {
        return "undefined";
    }
    var str = (typeof mixed);
    if (str !== "object") {
        return str;
    }
    if (is_bigint_1.isBigInt(mixed)) {
        return "bigint";
    }
    var prototype = Object.getPrototypeOf(mixed);
    if (prototype == undefined) {
        return "[Unknown Type]";
    }
    var constructor = prototype.constructor;
    if (constructor == undefined) {
        return "[Unknown Prototype]";
    }
    return getCtorName(constructor);
}
exports.toTypeStr = toTypeStr;
function toLiteralOrTypeStr(mixed) {
    if (is_primitive_1.isLiteral(mixed)) {
        return toLiteralStr(mixed);
    }
    else {
        return toTypeStr(mixed);
    }
}
exports.toLiteralOrTypeStr = toLiteralOrTypeStr;
function toLiteralOrTypeUnionStr(arr) {
    return arr
        .map(toLiteralOrTypeStr)
        .join("|");
}
exports.toLiteralOrTypeUnionStr = toLiteralOrTypeUnionStr;
//# sourceMappingURL=to-type-str.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/try-deep-merge.js":
/*!********************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/try-deep-merge.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var to_type_str_1 = __webpack_require__(/*! ./to-type-str */ "./node_modules/type-mapping/dist/type-util/to-type-str.js");
var strict_equal_1 = __webpack_require__(/*! ./strict-equal */ "./node_modules/type-mapping/dist/type-util/strict-equal.js");
var is_primitive_1 = __webpack_require__(/*! ./is-primitive */ "./node_modules/type-mapping/dist/type-util/is-primitive.js");
var ArrayBufferUtil = __webpack_require__(/*! ../array-buffer-util */ "./node_modules/type-mapping/dist/array-buffer-util/index.js");
var buffer_ctor_1 = __webpack_require__(/*! ./buffer-ctor */ "./node_modules/type-mapping/dist/type-util/buffer-ctor.js");
function tryDeepMergeImpl(path, a, b) {
    if (strict_equal_1.strictEqual(a, b)) {
        return {
            success: true,
            value: a,
        };
    }
    if (is_primitive_1.isPrimitive(a) || is_primitive_1.isPrimitive(b)) {
        return {
            success: false,
            path: path,
            aValue: a,
            bValue: b,
            message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal",
            expected: to_type_str_1.toTypeStr(a),
            actualValue: b,
        };
    }
    //We should have object types now.
    if ((typeof a == "function") || (typeof b == "function")) {
        return {
            success: false,
            path: path,
            aValue: a,
            bValue: b,
            message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal",
            expected: to_type_str_1.toTypeStr(a),
            actualValue: b,
        };
    }
    if ((a instanceof Date) || (b instanceof Date)) {
        if (!(a instanceof Date)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Date",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Date)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Date with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (a.getTime() === b.getTime()) {
            return {
                success: true,
                value: a,
            };
        }
        else {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge dates; they must have the same value",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
    }
    if (buffer_ctor_1.isInstanceOfBuffer(a) || buffer_ctor_1.isInstanceOfBuffer(b)) {
        if (!buffer_ctor_1.isInstanceOfBuffer(a)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Buffer",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!buffer_ctor_1.isInstanceOfBuffer(b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Buffer with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!ArrayBufferUtil.equals(a, b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Buffer; they are not equal",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        return {
            success: true,
            value: a,
        };
    }
    if ((a instanceof Uint8Array) || (b instanceof Uint8Array)) {
        if (!(a instanceof Uint8Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Uint8Array",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Uint8Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Uint8Array with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!ArrayBufferUtil.equals(a, b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Uint8Array; they are not equal",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        return {
            success: true,
            value: a,
        };
    }
    if ((a instanceof Array) || (b instanceof Array)) {
        if (!(a instanceof Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with array",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge array with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (a.length != b.length) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge arrays of different lengths",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        var newArray = [];
        for (var i = 0; i < a.length; ++i) {
            var elementResult = tryDeepMergeImpl(path.concat([i.toString()]), a[i], b[i]);
            if (elementResult.success) {
                newArray.push(elementResult.value);
            }
            else {
                return elementResult;
            }
        }
        return {
            success: true,
            value: newArray
        };
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    var mergedKeys = {};
    var newObj = {};
    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var key = aKeys_1[_i];
        //We can skip a.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `b.hasOwnProperty()` directly
        //because if `b = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(b, key)) {
            var valueResult = tryDeepMergeImpl(path.concat([key]), a[key], b[key]);
            if (valueResult.success) {
                newObj[key] = valueResult.value;
            }
            else {
                return valueResult;
            }
        }
        else {
            newObj[key] = a[key];
        }
    }
    for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var key = bKeys_1[_a];
        //We can skip b.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `a.hasOwnProperty()` directly
        //because if `a = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(a, key)) {
            var valueResult = tryDeepMergeImpl(path.concat([key]), a[key], b[key]);
            if (valueResult.success) {
                newObj[key] = valueResult.value;
            }
            else {
                return valueResult;
            }
        }
        else {
            newObj[key] = b[key];
        }
    }
    return {
        success: true,
        value: newObj,
    };
}
function tryDeepMerge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length == 0) {
        throw new Error("Cannot deep merge zero arguments");
    }
    var result = args[0];
    for (var i = 1; i < args.length; ++i) {
        var implResult = tryDeepMergeImpl([], result, args[i]);
        if (implResult.success) {
            result = implResult.value;
        }
        else {
            return __assign({}, implResult, { aRoot: result, bRoot: args[i] });
        }
    }
    return {
        success: true,
        value: result,
    };
}
exports.tryDeepMerge = tryDeepMerge;
//# sourceMappingURL=try-deep-merge.js.map

/***/ }),

/***/ "./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/type-mapping/dist/type-util/try-get-bigint-factory-function.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createPossiblyInstanceOfBigInt(x) {
    if (x == undefined) {
        return function () { return false; };
    }
    try {
        var ctor_1 = Object.getPrototypeOf(x).constructor;
        if (typeof ctor_1 != "function") {
            return function () { return false; };
        }
        //Make sure `instanceof` checks don't throw
        ({} instanceof ctor_1);
        return function (x) {
            return (x instanceof ctor_1);
        };
    }
    catch (_err) {
        return function () { return false; };
    }
}
function tryFindBigIntFactoryFunction() {
    try {
        var unsafeFactory_1 = BigInt;
        if (typeof unsafeFactory_1 != "function") {
            return undefined;
        }
        try {
            var bigInt = unsafeFactory_1(0);
            var possiblyInstanceOfBigInt = createPossiblyInstanceOfBigInt(bigInt);
            var wrapper = (function (x) {
                return unsafeFactory_1(x);
            });
            wrapper.possiblyInstanceOfBigInt = possiblyInstanceOfBigInt;
            wrapper.bigIntNative = (typeof bigInt == "bigint");
            return wrapper;
        }
        catch (_err) {
        }
        try {
            var possiblyInstanceOfBigInt = createPossiblyInstanceOfBigInt(new unsafeFactory_1(0));
            var wrapper = (function (x) {
                return new unsafeFactory_1(x);
            });
            wrapper.possiblyInstanceOfBigInt = possiblyInstanceOfBigInt;
            //Had to use `new`; not supported
            wrapper.bigIntNative = false;
            return wrapper;
        }
        catch (_err) {
        }
        return undefined;
    }
    catch (_err) {
        //No BigInt, no polyfill
        return undefined;
    }
}
var cachedBigIntFactoryFunction = "uninitialized";
function tryGetBigIntFactoryFunction() {
    if (cachedBigIntFactoryFunction == "uninitialized") {
        cachedBigIntFactoryFunction = tryFindBigIntFactoryFunction();
    }
    return cachedBigIntFactoryFunction;
}
exports.tryGetBigIntFactoryFunction = tryGetBigIntFactoryFunction;
function getBigIntFactoryFunctionOrError() {
    var result = tryGetBigIntFactoryFunction();
    if (result == undefined) {
        throw new Error("No native or polyfilled bigint implementation found; set the `BigInt` variable on the `globalThis`/`window`/`global` scope to a polyfilled implementation");
    }
    return result;
}
exports.getBigIntFactoryFunctionOrError = getBigIntFactoryFunctionOrError;
function isBigIntNativelySupported() {
    var factory = tryGetBigIntFactoryFunction();
    if (factory == undefined) {
        return false;
    }
    return factory.bigIntNative;
}
exports.isBigIntNativelySupported = isBigIntNativelySupported;
//# sourceMappingURL=try-get-bigint-factory-function.js.map

/***/ }),

/***/ "./node_modules/type-mapping/fluent.js":
/*!*********************************************!*\
  !*** ./node_modules/type-mapping/fluent.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./dist/fluent-lib */ "./node_modules/type-mapping/dist/fluent-lib/index.js"));

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

}]);
//# sourceMappingURL=vendors.bundle.js.map